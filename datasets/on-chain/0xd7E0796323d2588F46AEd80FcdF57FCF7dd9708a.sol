{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "paris",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@lazy-sol/access-control-upgradeable/contracts/InitializableAccessControlCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4; // custom errors (0.8.4)\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @title Initializable Role-based Access Control Core (I-RBAC-C)\n *\n * @notice Access control smart contract provides an API to check\n *      if a specific operation is permitted globally and/or\n *      if a particular user has a permission to execute it.\n *\n * @notice This contract is inherited by other contracts requiring the role-based access control (RBAC)\n *      protection for the restricted access functions\n *\n * @notice It deals with two main entities: features and roles.\n *\n * @notice Features are designed to be used to enable/disable public functions\n *      of the smart contract (used by a wide audience).\n * @notice User roles are designed to control the access to restricted functions\n *      of the smart contract (used by a limited set of maintainers).\n *\n * @notice Terms \"role\", \"permissions\" and \"set of permissions\" have equal meaning\n *      in the documentation text and may be used interchangeably.\n * @notice Terms \"permission\", \"single permission\" implies only one permission bit set.\n *\n * @notice Access manager is a special role which allows to grant/revoke other roles.\n *      Access managers can only grant/revoke permissions which they have themselves.\n *      As an example, access manager with no other roles set can only grant/revoke its own\n *      access manager permission and nothing else.\n *\n * @notice Access manager permission should be treated carefully, as a super admin permission:\n *      Access manager with even no other permission can interfere with another account by\n *      granting own access manager permission to it and effectively creating more powerful\n *      permission set than its own.\n *\n * @dev Both current and OpenZeppelin AccessControl implementations feature a similar API\n *      to check/know \"who is allowed to do this thing\".\n * @dev Zeppelin implementation is more flexible:\n *      - it allows setting unlimited number of roles, while current is limited to 256 different roles\n *      - it allows setting an admin for each role, while current allows having only one global admin\n * @dev Current implementation is more lightweight:\n *      - it uses only 1 bit per role, while Zeppelin uses 256 bits\n *      - it allows setting up to 256 roles at once, in a single transaction, while Zeppelin allows\n *        setting only one role in a single transaction\n *\n * @dev This smart contract is designed to be inherited by other\n *      smart contracts which require access control management capabilities.\n *\n * @dev Access manager permission has a bit 255 set.\n *      This bit must not be used by inheriting contracts for any other permissions/features.\n *\n * @dev This is an initializable version of the RBAC, based on Zeppelin implementation,\n *      it can be used for EIP-1167 minimal proxies, for ERC1967 proxies, etc.\n *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#Clones\n *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\n *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\n *      see https://forum.openzeppelin.com/t/uups-proxies-tutorial-solidity-javascript/7786\n *      see https://eips.ethereum.org/EIPS/eip-1167\n *\n * @dev The 'core' version of the RBAC contract hides three rarely used external functions from the public ABI,\n *      making them internal and thus reducing the overall compiled implementation size.\n *      isFeatureEnabled() public -> _isFeatureEnabled() internal\n *      isSenderInRole() public -> _isSenderInRole() internal\n *      isOperatorInRole() public -> _isOperatorInRole() internal\n *\n * @custom:since 1.1.0\n *\n * @author Basil Gorin\n */\nabstract contract InitializableAccessControlCore is Initializable {\n\t/**\n\t * @dev Privileged addresses with defined roles/permissions\n\t * @dev In the context of ERC20/ERC721 tokens these can be permissions to\n\t *      allow minting or burning tokens, transferring on behalf and so on\n\t *\n\t * @dev Maps user address to the permissions bitmask (role), where each bit\n\t *      represents a permission\n\t * @dev Bitmask 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n\t *      represents all possible permissions\n\t * @dev 'This' address mapping represents global features of the smart contract\n\t *\n\t * @dev We keep the mapping private to prevent direct writes to it from the inheriting\n\t *      contracts, `getRole()` and `updateRole()` functions should be used instead\n\t */\n\tmapping(address => uint256) private userRoles;\n\n\t/**\n\t * @dev Empty reserved space in storage. The size of the __gap array is calculated so that\n\t *      the amount of storage used by a contract always adds up to the 50.\n\t *      See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n\t */\n\tuint256[49] private __gap;\n\n\t/**\n\t * @notice Access manager is responsible for assigning the roles to users,\n\t *      enabling/disabling global features of the smart contract\n\t * @notice Access manager can add, remove and update user roles,\n\t *      remove and update global features\n\t *\n\t * @dev Role ROLE_ACCESS_MANAGER allows modifying user roles and global features\n\t * @dev Role ROLE_ACCESS_MANAGER has single bit at position 255 enabled\n\t */\n\tuint256 public constant ROLE_ACCESS_MANAGER = 0x8000000000000000000000000000000000000000000000000000000000000000;\n\n\t/**\n\t * @notice Upgrade manager is responsible for smart contract upgrades,\n\t *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\n\t *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\n\t *\n\t * @dev Role ROLE_UPGRADE_MANAGER allows passing the _authorizeUpgrade() check\n\t * @dev Role ROLE_UPGRADE_MANAGER has single bit at position 254 enabled\n\t */\n\tuint256 public constant ROLE_UPGRADE_MANAGER = 0x4000000000000000000000000000000000000000000000000000000000000000;\n\n\t/**\n\t * @dev Bitmask representing all the possible permissions (super admin role)\n\t * @dev Has all the bits are enabled (2^256 - 1 value)\n\t */\n\tuint256 internal constant FULL_PRIVILEGES_MASK = type(uint256).max; // before 0.8.0: uint256(-1) overflows to 0xFFFF...\n\n\t/**\n\t * @notice Thrown when a function is executed by an account that does not have\n\t *      the required access permission(s) (role)\n\t *\n\t * @dev This error is used to enforce role-based access control (RBAC) restrictions\n\t */\n\terror AccessDenied();\n\n\t/**\n\t * @dev Fired in updateRole() and updateFeatures()\n\t *\n\t * @param operator address which was granted/revoked permissions\n\t * @param requested permissions requested\n\t * @param assigned permissions effectively set\n\t */\n\tevent RoleUpdated(address indexed operator, uint256 requested, uint256 assigned);\n\n\t/**\n\t * @notice Function modifier making a function defined as public behave as restricted\n\t *      (so that only a pre-configured set of accounts can execute it)\n\t *\n\t * @param role the role transaction executor is required to have;\n\t *      the function throws an \"access denied\" exception if this condition is not met\n\t */\n\tmodifier restrictedTo(uint256 role) {\n\t\t// verify the access permission\n\t\t_requireSenderInRole(role);\n\n\t\t// execute the rest of the function\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Creates/deploys the RBAC implementation to be used in a proxy\n\t *\n\t * @dev Note:\n\t *      the implementation is already initialized and\n\t *      `_postConstruct` is not executable on the implementation\n\t *      `_postConstruct` is still available in the context of a proxy\n\t *      and should be executed on the proxy deployment (in the same tx)\n\t */\n\tconstructor() initializer {}\n\n\t/**\n\t * @dev Contract initializer, sets the contract owner to have full privileges\n\t *\n\t * @dev Can be executed only once, reverts when executed second time\n\t *\n\t * @dev IMPORTANT:\n\t *      this function SHOULD be executed during proxy deployment (in the same transaction)\n\t *\n\t * @param _owner smart contract owner having full privileges, can be zero\n\t * @param _features initial features mask of the contract, can be zero\n\t */\n\tfunction _postConstruct(address _owner, uint256 _features) internal virtual onlyInitializing {\n\t\t// grant owner full privileges\n\t\t__setRole(_owner, FULL_PRIVILEGES_MASK, FULL_PRIVILEGES_MASK);\n\t\t// update initial features bitmask\n\t\t__setRole(address(this), _features, _features);\n\t}\n\n\t/**\n\t * @dev Highest version that has been initialized.\n\t *      Non-zero value means contract was already initialized.\n\t * @dev see {Initializable}, {reinitializer}.\n\t *\n\t * @return highest version that has been initialized\n\t */\n\tfunction getInitializedVersion() public view returns(uint64) {\n\t\t// delegate to `_getInitializedVersion`\n\t\treturn _getInitializedVersion();\n\t}\n\n\t/**\n\t * @notice Retrieves globally set of features enabled\n\t *\n\t * @dev Effectively reads userRoles role for the contract itself\n\t *\n\t * @return 256-bit bitmask of the features enabled\n\t */\n\tfunction features() public view returns (uint256) {\n\t\t// features are stored in 'this' address mapping of `userRoles`\n\t\treturn getRole(address(this));\n\t}\n\n\t/**\n\t * @notice Updates set of the globally enabled features (`features`),\n\t *      taking into account sender's permissions\n\t *\n\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n\t * @dev Function is left for backward compatibility with older versions\n\t *\n\t * @param _mask bitmask representing a set of features to enable/disable\n\t */\n\tfunction updateFeatures(uint256 _mask) public {\n\t\t// delegate call to `updateRole`\n\t\tupdateRole(address(this), _mask);\n\t}\n\n\t/**\n\t * @notice Reads the permissions (role) for a given user from the `userRoles` mapping\n\t *      (privileged addresses with defined roles/permissions)\n\t * @notice In the context of ERC20/ERC721 tokens these can be permissions to\n\t *      allow minting or burning tokens, transferring on behalf and so on\n\t *\n\t * @dev Having a simple getter instead of making the mapping public\n\t *      allows enforcing the encapsulation of the mapping and protects from\n\t *      writing to it directly in the inheriting smart contracts\n\t *\n\t * @param operator address of a user to read permissions for,\n\t *      or self address to read global features of the smart contract\n\t */\n\tfunction getRole(address operator) public view returns(uint256) {\n\t\t// read the value from `userRoles` and return\n\t\treturn userRoles[operator];\n\t}\n\n\t/**\n\t * @notice Updates set of permissions (role) for a given user,\n\t *      taking into account sender's permissions.\n\t *\n\t * @dev Setting role to zero is equivalent to removing an all permissions\n\t * @dev Setting role to `FULL_PRIVILEGES_MASK` is equivalent to\n\t *      copying senders' permissions (role) to the user\n\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n\t *\n\t * @param operator address of a user to alter permissions for,\n\t *       or self address to alter global features of the smart contract\n\t * @param role bitmask representing a set of permissions to\n\t *      enable/disable for a user specified\n\t */\n\tfunction updateRole(address operator, uint256 role) public {\n\t\t// caller must have a permission to update user roles\n\t\t_requireSenderInRole(ROLE_ACCESS_MANAGER);\n\n\t\t// evaluate the role and reassign it\n\t\t__setRole(operator, role, _evaluateBy(msg.sender, getRole(operator), role));\n\t}\n\n\t/**\n\t * @notice Determines the permission bitmask an operator can set on the\n\t *      target permission set\n\t * @notice Used to calculate the permission bitmask to be set when requested\n\t *     in `updateRole` and `updateFeatures` functions\n\t *\n\t * @dev Calculated based on:\n\t *      1) operator's own permission set read from userRoles[operator]\n\t *      2) target permission set - what is already set on the target\n\t *      3) desired permission set - what do we want set target to\n\t *\n\t * @dev Corner cases:\n\t *      1) Operator is super admin and its permission set is `FULL_PRIVILEGES_MASK`:\n\t *        `desired` bitset is returned regardless of the `target` permission set value\n\t *        (what operator sets is what they get)\n\t *      2) Operator with no permissions (zero bitset):\n\t *        `target` bitset is returned regardless of the `desired` value\n\t *        (operator has no authority and cannot modify anything)\n\t *\n\t * @dev Example:\n\t *      Consider an operator with the permissions bitmask     00001111\n\t *      is about to modify the target permission set          01010101\n\t *      Operator wants to set that permission set to          00110011\n\t *      Based on their role, an operator has the permissions\n\t *      to update only lowest 4 bits on the target, meaning that\n\t *      high 4 bits of the target set in this example is left\n\t *      unchanged and low 4 bits get changed as desired:      01010011\n\t *\n\t * @param operator address of the contract operator which is about to set the permissions\n\t * @param target input set of permissions to operator is going to modify\n\t * @param desired desired set of permissions operator would like to set\n\t * @return resulting set of permissions given operator will set\n\t */\n\tfunction _evaluateBy(address operator, uint256 target, uint256 desired) internal view returns (uint256) {\n\t\t// read operator's permissions\n\t\tuint256 p = getRole(operator);\n\n\t\t// taking into account operator's permissions,\n\t\t// 1) enable the permissions desired on the `target`\n\t\ttarget |= p & desired;\n\t\t// 2) disable the permissions desired on the `target`\n\t\ttarget &= FULL_PRIVILEGES_MASK ^ (p & (FULL_PRIVILEGES_MASK ^ desired));\n\n\t\t// return calculated result\n\t\treturn target;\n\t}\n\n\t/**\n\t * @notice Ensures that the transaction sender has the required access permission(s) (role)\n\t *\n\t * @dev Reverts with an `AccessDenied` error if the sender does not have the required role\n\t *\n\t * @param required the set of permissions (role) that the transaction sender is required to have\n\t */\n\tfunction _requireSenderInRole(uint256 required) internal view {\n\t\t// check if the transaction has the required permission(s),\n\t\t// reverting with the \"access denied\" error if not\n\t\t_requireAccessCondition(_isSenderInRole(required));\n\t}\n\n\t/**\n\t * @notice Ensures that a specific condition is met\n\t *\n\t * @dev Reverts with an `AccessDenied` error if the condition is not met\n\t *\n\t * @param condition the condition that needs to be true for the function to proceed\n\t */\n\tfunction _requireAccessCondition(bool condition) internal pure {\n\t\t// check if the condition holds\n\t\tif(!condition) {\n\t\t\t// revert with the \"access denied\" error if not\n\t\t\trevert AccessDenied();\n\t\t}\n\t}\n\n\t/**\n\t * @notice Checks if requested set of features is enabled globally on the contract\n\t *\n\t * @param required set of features to check against\n\t * @return true if all the features requested are enabled, false otherwise\n\t */\n\tfunction _isFeatureEnabled(uint256 required) internal view returns (bool) {\n\t\t// delegate call to `__hasRole`, passing `features` property\n\t\treturn __hasRole(features(), required);\n\t}\n\n\t/**\n\t * @notice Checks if transaction sender `msg.sender` has all the permissions required\n\t *\n\t * @param required set of permissions (role) to check against\n\t * @return true if all the permissions requested are enabled, false otherwise\n\t */\n\tfunction _isSenderInRole(uint256 required) internal view returns (bool) {\n\t\t// delegate call to `isOperatorInRole`, passing transaction sender\n\t\treturn _isOperatorInRole(msg.sender, required);\n\t}\n\n\t/**\n\t * @notice Checks if operator has all the permissions (role) required\n\t *\n\t * @param operator address of the user to check role for\n\t * @param required set of permissions (role) to check\n\t * @return true if all the permissions requested are enabled, false otherwise\n\t */\n\tfunction _isOperatorInRole(address operator, uint256 required) internal view returns (bool) {\n\t\t// delegate call to `__hasRole`, passing operator's permissions (role)\n\t\treturn __hasRole(getRole(operator), required);\n\t}\n\n\t/**\n\t * @dev Sets the `assignedRole` role to the operator, logs both `requestedRole` and `actualRole`\n\t *\n\t * @dev Unsafe:\n\t *      provides direct write access to `userRoles` mapping without any security checks,\n\t *      doesn't verify the executor (msg.sender) permissions,\n\t *      must be kept private at all times\n\t *\n\t * @param operator address of a user to alter permissions for,\n\t *       or self address to alter global features of the smart contract\n\t * @param requestedRole bitmask representing a set of permissions requested\n\t *      to be enabled/disabled for a user specified, used only to be logged into event\n\t * @param assignedRole bitmask representing a set of permissions to\n\t *      enable/disable for a user specified, used to update the mapping and to be logged into event\n\t */\n\tfunction __setRole(address operator, uint256 requestedRole, uint256 assignedRole) private {\n\t\t// assign the role to the operator\n\t\tuserRoles[operator] = assignedRole;\n\n\t\t// fire an event\n\t\temit RoleUpdated(operator, requestedRole, assignedRole);\n\t}\n\n\t/**\n\t * @dev Checks if role `actual` contains all the permissions required `required`\n\t *\n\t * @param actual existent role\n\t * @param required required role\n\t * @return true if actual has required role (all permissions), false otherwise\n\t */\n\tfunction __hasRole(uint256 actual, uint256 required) private pure returns (bool) {\n\t\t// check the bitmask for the role required and return the result\n\t\treturn actual & required == required;\n\t}\n}\n"
    },
    "@lazy-sol/access-control-upgradeable/contracts/UpgradeableAccessControlCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"./InitializableAccessControlCore.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/**\n * @title Upgradeable Role-based Access Control Core (U-RBAC-C) // ERC1967Proxy\n *\n * @notice Access control smart contract provides an API to check\n *      if a specific operation is permitted globally and/or\n *      if a particular user has a permission to execute it.\n *\n * @notice This contract is inherited by other contracts requiring the role-based access control (RBAC)\n *      protection for the restricted access functions\n *\n * @notice It deals with two main entities: features and roles.\n *\n * @notice Features are designed to be used to enable/disable public functions\n *      of the smart contract (used by a wide audience).\n * @notice User roles are designed to control the access to restricted functions\n *      of the smart contract (used by a limited set of maintainers).\n *\n * @notice Terms \"role\", \"permissions\" and \"set of permissions\" have equal meaning\n *      in the documentation text and may be used interchangeably.\n * @notice Terms \"permission\", \"single permission\" implies only one permission bit set.\n *\n * @notice Access manager is a special role which allows to grant/revoke other roles.\n *      Access managers can only grant/revoke permissions which they have themselves.\n *      As an example, access manager with no other roles set can only grant/revoke its own\n *      access manager permission and nothing else.\n *\n * @notice Access manager permission should be treated carefully, as a super admin permission:\n *      Access manager with even no other permission can interfere with another account by\n *      granting own access manager permission to it and effectively creating more powerful\n *      permission set than its own.\n *\n * @dev Both current and OpenZeppelin AccessControl implementations feature a similar API\n *      to check/know \"who is allowed to do this thing\".\n * @dev Zeppelin implementation is more flexible:\n *      - it allows setting unlimited number of roles, while current is limited to 256 different roles\n *      - it allows setting an admin for each role, while current allows having only one global admin\n * @dev Current implementation is more lightweight:\n *      - it uses only 1 bit per role, while Zeppelin uses 256 bits\n *      - it allows setting up to 256 roles at once, in a single transaction, while Zeppelin allows\n *        setting only one role in a single transaction\n *\n * @dev This smart contract is designed to be inherited by other\n *      smart contracts which require access control management capabilities.\n *\n * @dev Access manager permission has a bit 255 set.\n *      This bit must not be used by inheriting contracts for any other permissions/features.\n *\n * @dev This is an upgradeable version of the RBAC, based on Zeppelin implementation for ERC1967,\n *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\n *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\n *      see https://forum.openzeppelin.com/t/uups-proxies-tutorial-solidity-javascript/7786\n *\n * @dev The 'core' version of the RBAC contract hides three rarely used external functions from the public ABI,\n *      making them internal and thus reducing the overall compiled implementation size.\n *      isFeatureEnabled() public -> _isFeatureEnabled() internal\n *      isSenderInRole() public -> _isSenderInRole() internal\n *      isOperatorInRole() public -> _isOperatorInRole() internal\n *\n * @custom:since 1.1.0\n *\n * @author Basil Gorin\n */\nabstract contract UpgradeableAccessControlCore is InitializableAccessControlCore, UUPSUpgradeable {\n\t/**\n\t * @notice Returns an address of the implementation smart contract,\n\t *      see ERC1967Upgrade._getImplementation()\n\t *\n\t * @return the current implementation address\n\t */\n\tfunction getImplementation() public view virtual returns (address) {\n\t\t// delegate to `ERC1967Upgrade._getImplementation()`\n\t\treturn _getImplementation();\n\t}\n\n\t/**\n\t * @inheritdoc UUPSUpgradeable\n\t */\n\tfunction _authorizeUpgrade(address) internal virtual override {\n\t\t// caller must have a permission to upgrade the contract\n\t\t_requireSenderInRole(ROLE_UPGRADE_MANAGER);\n\t}\n}\n"
    },
    "@lazy-sol/advanced-erc20/contracts/interfaces/ERC1363Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./ERC20Spec.sol\";\nimport \"./ERC165Spec.sol\";\n\n/**\n * @title ERC1363 Interface\n *\n * @dev Interface defining a ERC1363 Payable Token contract.\n *      Implementing contracts MUST implement the ERC1363 interface as well as the ERC20 and ERC165 interfaces.\n */\ninterface ERC1363 is ERC20, ERC165  {\n\t/*\n\t * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n\t * 0xb0202a11 ===\n\t *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n\t *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n\t *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n\t *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n\t *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n\t *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n\t */\n\n\t/**\n\t * @notice Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver\n\t * @param to address The address which you want to transfer to\n\t * @param value uint256 The amount of tokens to be transferred\n\t * @return true unless throwing\n\t */\n\tfunction transferAndCall(address to, uint256 value) external returns (bool);\n\n\t/**\n\t * @notice Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver\n\t * @param to address The address which you want to transfer to\n\t * @param value uint256 The amount of tokens to be transferred\n\t * @param data bytes Additional data with no specified format, sent in call to `to`\n\t * @return true unless throwing\n\t */\n\tfunction transferAndCall(address to, uint256 value, bytes memory data) external returns (bool);\n\n\t/**\n\t * @notice Transfer tokens from one address to another and then call `onTransferReceived` on receiver\n\t * @param from address The address which you want to send tokens from\n\t * @param to address The address which you want to transfer to\n\t * @param value uint256 The amount of tokens to be transferred\n\t * @return true unless throwing\n\t */\n\tfunction transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n\t/**\n\t * @notice Transfer tokens from one address to another and then call `onTransferReceived` on receiver\n\t * @param from address The address which you want to send tokens from\n\t * @param to address The address which you want to transfer to\n\t * @param value uint256 The amount of tokens to be transferred\n\t * @param data bytes Additional data with no specified format, sent in call to `to`\n\t * @return true unless throwing\n\t */\n\tfunction transferFromAndCall(address from, address to, uint256 value, bytes memory data) external returns (bool);\n\n\t/**\n\t * @notice Approve the passed address to spend the specified amount of tokens on behalf of msg.sender\n\t * and then call `onApprovalReceived` on spender.\n\t * @param spender address The address which will spend the funds\n\t * @param value uint256 The amount of tokens to be spent\n\t */\n\tfunction approveAndCall(address spender, uint256 value) external returns (bool);\n\n\t/**\n\t * @notice Approve the passed address to spend the specified amount of tokens on behalf of msg.sender\n\t * and then call `onApprovalReceived` on spender.\n\t * @param spender address The address which will spend the funds\n\t * @param value uint256 The amount of tokens to be spent\n\t * @param data bytes Additional data with no specified format, sent in call to `spender`\n\t */\n\tfunction approveAndCall(address spender, uint256 value, bytes memory data) external returns (bool);\n}\n\n/**\n * @title ERC1363Receiver Interface\n *\n * @dev Interface for any contract that wants to support `transferAndCall` or `transferFromAndCall`\n *      from ERC1363 token contracts.\n */\ninterface ERC1363Receiver {\n\t/*\n\t * Note: the ERC-165 identifier for this interface is 0x88a7ca5c.\n\t * 0x88a7ca5c === bytes4(keccak256(\"onTransferReceived(address,address,uint256,bytes)\"))\n\t */\n\n\t/**\n\t * @notice Handle the receipt of ERC1363 tokens\n\t *\n\t * @dev Any ERC1363 smart contract calls this function on the recipient\n\t *      after a `transfer` or a `transferFrom`. This function MAY throw to revert and reject the\n\t *      transfer. Return of other than the magic value MUST result in the\n\t *      transaction being reverted.\n\t *      Note: the token contract address is always the message sender.\n\t *\n\t * @param operator address The address which called `transferAndCall` or `transferFromAndCall` function\n\t * @param from address The address which are token transferred from\n\t * @param value uint256 The amount of tokens transferred\n\t * @param data bytes Additional data with no specified format\n\t * @return `bytes4(keccak256(\"onTransferReceived(address,address,uint256,bytes)\"))`\n\t *      unless throwing\n\t */\n\tfunction onTransferReceived(address operator, address from, uint256 value, bytes memory data) external returns (bytes4);\n}\n\n/**\n * @title ERC1363Spender Interface\n *\n * @dev Interface for any contract that wants to support `approveAndCall`\n *      from ERC1363 token contracts.\n */\ninterface ERC1363Spender {\n\t/*\n\t * Note: the ERC-165 identifier for this interface is 0x7b04a2d0.\n\t * 0x7b04a2d0 === bytes4(keccak256(\"onApprovalReceived(address,uint256,bytes)\"))\n\t */\n\n\t/**\n\t * @notice Handle the approval of ERC1363 tokens\n\t *\n\t * @dev Any ERC1363 smart contract calls this function on the recipient\n\t *      after an `approve`. This function MAY throw to revert and reject the\n\t *      approval. Return of other than the magic value MUST result in the\n\t *      transaction being reverted.\n\t *      Note: the token contract address is always the message sender.\n\t *\n\t * @param owner address The address which called `approveAndCall` function\n\t * @param value uint256 The amount of tokens to be spent\n\t * @param data bytes Additional data with no specified format\n\t * @return `bytes4(keccak256(\"onApprovalReceived(address,uint256,bytes)\"))`\n\t *      unless throwing\n\t */\n\tfunction onApprovalReceived(address owner, uint256 value, bytes memory data) external returns (bytes4);\n}\n\n/**\n * @title Mintable ERC1363 Extension\n *\n * @notice Adds mint functions to the ERC1363 interface, these functions\n *      follow the same idea and logic as ERC1363 transferAndCall functions,\n *      allowing to notify the recipient ERC1363Receiver contract about the tokens received\n */\ninterface MintableERC1363 is ERC1363 {\n\t/**\n\t * @notice Mint tokens to the receiver and then call `onTransferReceived` on the receiver\n\t * @param to address The address which you want to mint to\n\t * @param value uint256 The amount of tokens to be minted\n\t * @return true unless throwing\n\t */\n\tfunction mintAndCall(address to, uint256 value) external returns (bool);\n\n\t/**\n\t * @notice Mint tokens to the receiver and then call `onTransferReceived` on the receiver\n\t * @param to address The address which you want to mint to\n\t * @param value uint256 The amount of tokens to be minted\n\t * @param data bytes Additional data with no specified format, sent in call to `to`\n\t * @return true unless throwing\n\t */\n\tfunction mintAndCall(address to, uint256 value, bytes memory data) external returns (bool);\n}\n"
    },
    "@lazy-sol/advanced-erc20/contracts/interfaces/ERC165Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title ERC-165 Standard Interface Detection\n *\n * @dev Interface of the ERC165 standard, as defined in the\n *       https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * @dev Implementers can declare support of contract interfaces,\n *      which can then be queried by others.\n *\n * @author Christian Reitwießner, Nick Johnson, Fabian Vogelsteller, Jordi Baylina, Konrad Feldmeier, William Entriken\n */\ninterface ERC165 {\n\t/**\n\t * @notice Query if a contract implements an interface\n\t *\n\t * @dev Interface identification is specified in ERC-165.\n\t *      This function uses less than 30,000 gas.\n\t *\n\t * @param interfaceID The interface identifier, as specified in ERC-165\n\t * @return `true` if the contract implements `interfaceID` and\n\t *      `interfaceID` is not 0xffffffff, `false` otherwise\n\t */\n\tfunction supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "@lazy-sol/advanced-erc20/contracts/interfaces/ERC20Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title EIP-20: ERC-20 Token Standard\n *\n * @notice The ERC-20 (Ethereum Request for Comments 20), proposed by Fabian Vogelsteller in November 2015,\n *      is a Token Standard that implements an API for tokens within Smart Contracts.\n *\n * @notice It provides functionalities like to transfer tokens from one account to another,\n *      to get the current token balance of an account and also the total supply of the token available on the network.\n *      Besides these it also has some other functionalities like to approve that an amount of\n *      token from an account can be spent by a third party account.\n *\n * @notice If a Smart Contract implements the following methods and events it can be called an ERC-20 Token\n *      Contract and, once deployed, it will be responsible to keep track of the created tokens on Ethereum.\n *\n * @notice See https://ethereum.org/en/developers/docs/standards/tokens/erc-20/\n * @notice See https://eips.ethereum.org/EIPS/eip-20\n */\ninterface ERC20 {\n\t/**\n\t * @dev Fired in transfer(), transferFrom() to indicate that token transfer happened\n\t *\n\t * @param from an address tokens were consumed from\n\t * @param to an address tokens were sent to\n\t * @param value number of tokens transferred\n\t */\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\n\t/**\n\t * @dev Fired in approve() to indicate an approval event happened\n\t *\n\t * @param owner an address which granted a permission to transfer\n\t *      tokens on its behalf\n\t * @param spender an address which received a permission to transfer\n\t *      tokens on behalf of the owner `owner`\n\t * @param value amount of tokens granted to transfer on behalf\n\t */\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n\n\t/**\n\t * @return name of the token (ex.: USD Coin)\n\t */\n\t// OPTIONAL - This method can be used to improve usability,\n\t// but interfaces and other contracts MUST NOT expect these values to be present.\n\t// function name() external view returns (string memory);\n\n\t/**\n\t * @return symbol of the token (ex.: USDC)\n\t */\n\t// OPTIONAL - This method can be used to improve usability,\n\t// but interfaces and other contracts MUST NOT expect these values to be present.\n\t// function symbol() external view returns (string memory);\n\n\t/**\n\t * @dev Returns the number of decimals used to get its user representation.\n\t *      For example, if `decimals` equals `2`, a balance of `505` tokens should\n\t *      be displayed to a user as `5,05` (`505 / 10 ** 2`).\n\t *\n\t * @dev Tokens usually opt for a value of 18, imitating the relationship between\n\t *      Ether and Wei. This is the value {ERC20} uses, unless this function is\n\t *      overridden;\n\t *\n\t * @dev NOTE: This information is only used for _display_ purposes: it in\n\t *      no way affects any of the arithmetic of the contract, including\n\t *      {IERC20-balanceOf} and {IERC20-transfer}.\n\t *\n\t * @return token decimals\n\t */\n\t// OPTIONAL - This method can be used to improve usability,\n\t// but interfaces and other contracts MUST NOT expect these values to be present.\n\t// function decimals() external view returns (uint8);\n\n\t/**\n\t * @return the amount of tokens in existence\n\t */\n\tfunction totalSupply() external view returns (uint256);\n\n\t/**\n\t * @notice Gets the balance of a particular address\n\t *\n\t * @param owner the address to query the the balance for\n\t * @return balance an amount of tokens owned by the address specified\n\t */\n\tfunction balanceOf(address owner) external view returns (uint256 balance);\n\n\t/**\n\t * @notice Transfers some tokens to an external address or a smart contract\n\t *\n\t * @dev Called by token owner (an address which has a\n\t *      positive token balance tracked by this smart contract)\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `to` address:\n\t *          * zero address or\n\t *          * self address or\n\t *          * smart contract which doesn't support ERC20\n\t *\n\t * @param to an address to transfer tokens to,\n\t *      must be either an external address or a smart contract,\n\t *      compliant with the ERC20 standard\n\t * @param value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction transfer(address to, uint256 value) external returns (bool success);\n\n\t/**\n\t * @notice Transfers some tokens on behalf of address `from' (token owner)\n\t *      to some other address `to`\n\t *\n\t * @dev Called by token owner on his own or approved address,\n\t *      an address approved earlier by token owner to\n\t *      transfer some amount of tokens on its behalf\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `to` address:\n\t *          * zero address or\n\t *          * same as `from` address (self transfer)\n\t *          * smart contract which doesn't support ERC20\n\t *\n\t * @param from token owner which approved caller (transaction sender)\n\t *      to transfer `value` of tokens on its behalf\n\t * @param to an address to transfer tokens to,\n\t *      must be either an external address or a smart contract,\n\t *      compliant with the ERC20 standard\n\t * @param value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction transferFrom(address from, address to, uint256 value) external returns (bool success);\n\n\t/**\n\t * @notice Approves address called `spender` to transfer some amount\n\t *      of tokens on behalf of the owner (transaction sender)\n\t *\n\t * @dev Transaction sender must not necessarily own any tokens to grant the permission\n\t *\n\t * @param spender an address approved by the caller (token owner)\n\t *      to spend some tokens on its behalf\n\t * @param value an amount of tokens spender `spender` is allowed to\n\t *      transfer on behalf of the token owner\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction approve(address spender, uint256 value) external returns (bool success);\n\n\t/**\n\t * @notice Returns the amount which `spender` is still allowed to withdraw from `owner`.\n\t *\n\t * @dev A function to check an amount of tokens owner approved\n\t *      to transfer on its behalf by some other address called \"spender\"\n\t *\n\t * @param owner an address which approves transferring some tokens on its behalf\n\t * @param spender an address approved to transfer some tokens on behalf\n\t * @return remaining an amount of tokens approved address `spender` can transfer on behalf\n\t *      of token owner `owner`\n\t */\n\tfunction allowance(address owner, address spender) external view returns (uint256 remaining);\n}\n\n/**\n * @title Mintable/burnable ERC20 Extension\n *\n * @notice Adds mint/burn functions to the ERC20 interface;\n *      these functions are usually present in ERC20 implementations;\n *      they become a must for the bridged tokens since the bridge usually\n *      needs to have a way to mint tokens deposited from L1 to L2\n *      and to burn tokens to be withdrawn from L2 to L1\n */\ninterface MintableBurnableERC20 is ERC20 {\n\t/**\n\t * @dev Mints (creates) some tokens to address specified\n\t * @dev The value specified is treated as is without taking\n\t *      into account what `decimals` value is\n\t *\n\t * @param to an address to mint tokens to\n\t * @param value an amount of tokens to mint (create)\n\t * @return success true on success, false otherwise\n\t */\n\tfunction mint(address to, uint256 value) external returns (bool success);\n\n\t/**\n\t * @dev Burns (destroys) some tokens from the address specified\n\t *\n\t * @dev The value specified is treated as is without taking\n\t *      into account what `decimals` value is\n\t *\n\t * @param from an address to burn some tokens from\n\t * @param value an amount of tokens to burn (destroy)\n\t * @return success true on success, false otherwise\n\t */\n\tfunction burn(address from, uint256 value) external returns (bool success);\n}\n"
    },
    "@lazy-sol/advanced-erc20/contracts/lib/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n *\n * @dev Copy of the Zeppelin's library:\n *      https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b0cf6fbb7a70f31527f36579ad644e1cf12fdf4e/contracts/utils/cryptography/ECDSA.sol\n */\nlibrary ECDSA {\n\t/**\n\t * @dev Overload of {ECDSA-recover} that receives the `v`,\n\t * `r` and `s` signature fields separately.\n\t */\n\tfunction recover(\n\t\tbytes32 hash,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) internal pure returns (address) {\n\t\t// EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n\t\t// unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n\t\t// the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n\t\t// signatures from current libraries generate a unique signature with an s-value in the lower half order.\n\t\t//\n\t\t// If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n\t\t// with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n\t\t// vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n\t\t// these malleable signatures as well.\n\t\trequire(\n\t\t\tuint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\n\t\t\t\"invalid signature 's' value\"\n\t\t);\n\t\trequire(v == 27 || v == 28, \"invalid signature 'v' value\");\n\n\t\t// If the signature is valid (and not malleable), return the signer address\n\t\taddress signer = ecrecover(hash, v, r, s);\n\t\trequire(signer != address(0), \"invalid signature\");\n\n\t\treturn signer;\n\t}\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC1967Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.8.3._\n */\ninterface IERC1967Upgradeable {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822ProxiableUpgradeable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../interfaces/IERC1967Upgradeable.sol\";\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\nimport \"../utils/Initializable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n */\nabstract contract ERC1967UpgradeUpgradeable is Initializable, IERC1967Upgradeable {\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../ERC1967/ERC1967UpgradeUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n        _;\n    }\n\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "contracts/lib/MathLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title Math Library\n *\n * @notice On-demand math utilities used by at least two contracts in the project\n *\n * @author Lizard Labs Core Contributors\n */\nlibrary MathLib {\n\t/**\n\t * @dev Checks if number `n` has bit `i` set\n\t */\n\tfunction isBitSet(uint256 n, uint8 i) internal pure returns(bool) {\n\t\t// extract the required bit and check if it is not zero\n\t\treturn n & (1 << i) != 0;\n\t}\n}\n"
    },
    "contracts/lib/SafeERC20Lib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title SafeERC20\n *\n * @dev Inspired by OZ SafeERC20 implementation (v5.0.0), this contract doesn't require the ERC20\n *      token to follow any of the ERC20 interfaces (OZ IERC20, or others) at compile time.\n *\n * @dev Wrappers around ERC20 operations that throw on failure (when the token contract returns false).\n *      Tokens that return no value (and instead revert or throw on failure) are also supported,\n *      non-reverting calls are assumed to be successful.\n *\n * @dev To use this library you can add a `using SafeERC20 for address;` statement to your contract,\n *      which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Lib {\n\tusing Address for address;\n\n\t/**\n\t * @dev An operation with an ERC20 token failed.\n\t */\n\terror SafeERC20FailedOperation(address token);\n\n\t/**\n\t * @dev Transfers `value` amount of `token` from the calling contract to `to`.\n\t *      If `token` returns no value, non-reverting calls are assumed to be successful.\n\t */\n\tfunction safeTransfer(address token, address to, uint256 value) internal {\n\t\t_callOptionalReturn(token, abi.encodeWithSignature(\"transfer(address,uint256)\", to, value));\n\t}\n\n\t/**\n\t * @dev Transfers `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the calling contract.\n\t *      If `token` returns no value, non-reverting calls are assumed to be successful.\n\t */\n\tfunction safeTransferFrom(address token, address from, address to, uint256 value) internal {\n\t\t_callOptionalReturn(token, abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", from, to, value));\n\t}\n\n\t/**\n\t * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n\t *      on the return value: the return value is optional (but if data is returned, it must not be false).\n\t *\n\t * @param token The token address targeted by the call.\n\t * @param data The call data (encoded using abi.encode or one of its variants).\n\t */\n\tfunction _callOptionalReturn(address token, bytes memory data) private {\n\t\t// We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n\t\t// we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n\t\t// the target address contains contract code and also asserts for success in the low-level call.\n\n\t\tbytes memory returndata = token.functionCall(data);\n\t\tif (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n\t\t\trevert SafeERC20FailedOperation(token);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n\t *      on the return value: the return value is optional (but if data is returned, it must not be false).\n\t *\n\t * @dev This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n\t *\n\t * @param token The token targeted by the call.\n\t * @param data The call data (encoded using abi.encode or one of its variants).\n\t */\n\tfunction _callOptionalReturnBool(address token, bytes memory data) private returns (bool) {\n\t\t// We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n\t\t// we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n\t\t// and not revert is the subcall reverts.\n\n\t\t(bool success, bytes memory returndata) = token.call(data);\n\t\treturn success && (returndata.length == 0 || abi.decode(returndata, (bool))) && token.code.length > 0;\n\t}\n}\n"
    },
    "contracts/lib/SafeMathLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title Safe Math Library\n *\n * @notice Starting from Solidity 0.8 most of the arithmetic operations became safe by default.\n *      Integer type casting operation remains unsafe and can silently trim the integers.\n *      This library provides an overflow safe integer type casting functions.\n *\n * @author Lizard Labs Core Contributors\n */\nlibrary SafeMathLib {\n\t/// @dev Safely converts unsigned integer value to uint96, throwing on overflow\n\tfunction toUint96(uint256 value) internal pure returns(uint96) {\n\t\t// check for overflow\n\t\trequire(value <= type(uint96).max, \"uint96 79.2B overflow\");\n\t\t// return the result\n\t\treturn uint96(value);\n\t}\n}\n"
    },
    "contracts/lib/TimeDepositLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./MathLib.sol\";\nimport \"../protocol/staking/TimeWeightedStakingV1.sol\";\n\n/**\n * @title Time Deposit Library\n *\n * @dev Moves some deposit related calculation functions out of the TimeWeightedStakingV1 contract\n *\n * @author Lizard Labs Core Contributors\n */\nlibrary TimeDepositLib {\n\t/**\n\t * @dev Creates TimeDeposit data structure from deposit amount and duration based on the\n\t *      deposit settings and current time supplied\n\t *\n\t * @param settings deposit settings to use for calculation\n\t * @param amount deposit amount\n\t * @param duration deposit lock-up period\n\t * @param t current time `t` used for calculation\n\t *\n\t * @return deposit constructed TimeDeposit data structure\n\t */\n\tfunction newDeposit(\n\t\tTimeWeightedStakingV1.DepositSettings memory settings,\n\t\tuint96 amount,\n\t\tuint32 duration,\n\t\tuint32 t\n\t) internal pure returns(TimeWeightedStakingV1.TimeDeposit memory deposit) {\n\t\t// create a new deposit instance in memory and return it as the result\n\t\treturn TimeWeightedStakingV1.TimeDeposit({\n\t\t\t// this can uint32 overflow if duration is too long, or if current time is close to year 2106,\n\t\t\t// reverting the tx and effectively blocking new deposit creation, which is OK\n\t\t\tmaturesOn: t + duration,\n\t\t\tamount: amount,\n\t\t\t// weighted duration calculation can also cause the uint32 overflow and tx revert, which is OK\n\t\t\tweightedDuration: weightedDuration(settings, duration)\n\t\t});\n\t}\n\n\t/**\n\t * @dev Derives the weight of the deposit from the deposit amount, and weighted duration:\n\t *                deposit weight = deposit amount * weighted duration\n\t *\n\t * @dev The results are guaranteed to fit into a signed integer int128 type,\n\t *      the function throws if any of the results doesn't fit\n\t *\n\t * @param deposit the deposit\n\t *\n\t * @return deposit weight = deposit amount * weighted duration\n\t */\n\tfunction weight(TimeWeightedStakingV1.TimeDeposit memory deposit) internal pure returns(int128) {\n\t\t// calculate the base weight without applying any restrictions\n\t\tuint160 depositWeight = uint128(deposit.amount) * deposit.weightedDuration;\n\n\t\t// verify the calculated weight safely fits into signed integer int128\n\t\trequire(depositWeight <= uint128(type(int128).max), \"int128 overflow\");\n\n\t\t// return the calculated result\n\t\treturn int128(uint128(depositWeight));\n\t}\n\n\t/**\n\t * @dev Calculates the deposit weight based on the deposit settings configuration and deposit duration\n\t *\n\t * @param settings deposit settings to use for calculation\n\t * @param duration deposit lock-up period\n\t *\n\t * @return weighted duration = deposit duration * time weight multiplier\n\t */\n\tfunction weightedDuration(TimeWeightedStakingV1.DepositSettings memory settings, uint32 duration) internal pure returns(uint32) {\n\t\t// put the settings into the stack\n\t\t(uint32 minDur, uint32 maxDur, uint8 minMul, uint8 maxMul) = (\n\t\t\tsettings.minDepositDuration,\n\t\t\tsettings.maxDepositDuration,\n\t\t\tsettings.minDurationMultiplier,\n\t\t\tsettings.maxDurationMultiplier\n\t\t);\n\n\t\t// double check max duration x multiplier doesn't overflow\n\t\trequire(maxDur <= type(uint32).max / maxMul, \"max duration x multiplier overflow\");\n\n\t\t// if duration is bigger than the maximum allowed\n\t\tif(duration >= maxDur) {\n\t\t\t// fallback to maximum multiplier\n\t\t\treturn duration * maxMul;\n\t\t}\n\t\t// if duration is equal to the minimum allowed\n\t\tif(duration == minDur) {\n\t\t\t// fallback to minimum multiplier (might be zero)\n\t\t\treturn duration * minMul;\n\t\t}\n\t\t// if duration is lower than the minimum allowed\n\t\tif(duration < minDur) {\n\t\t\t// fallback to no-lock multiplier (zero)\n\t\t\treturn 0;\n\t\t}\n\n\t\t// otherwise calculate according to the linear multiplier formula\n\t\t// note: uint32 conversion is safe as long as maxDur * maxMul fits into uint32\n\t\treturn uint32(duration * minMul + uint64(duration) * (maxMul - minMul) * (duration - minDur) / (maxDur - minDur));\n\t}\n}\n"
    },
    "contracts/protocol/es/EmissionSchedule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title Emission Schedule\n *\n * @notice Emission schedule defines the rate at which new tokens are released into circulation over time.\n *      It's a function that outlines the number of tokens released per unit of time,\n *      such as during a month or year. \n *\n * @notice Emission schedule defines the emission volume of the new tokens released over time.\n *      It's a function that outlines the number of tokens released so far, by the given time.\n *      See emissionVolume(t) function\n *\n * @notice Emission rate is the derivative of the emission volume with respect to time,\n *      and emission volume is an integral of the emission rate over time.\n *      See emissionRate(t, dt) function\n * \n * @notice Emission schedule is defined on the time interval [start time, start time + duration],\n *      when token emission happens; also called an `emission period`.\n *      See emissionPeriod() function\n *\n * @notice Emission schedule defines initial (often zero) and final emission volumes.\n *      See initialEmissionVolume() and totalEmissionVolume() functions\n *\n * @notice The source of the new tokens released into circulation can be anything:\n *      tokens may get created (minted), transferred from the treasury wallet, etc.\n *      The source of the tokens is implementation dependent.\n *\n * @dev This interface aims to be generic and allow various types of implementations with\n *      various shapes of the emission curves;\n *      still the interface is specific enough for the clients app to integrate with.\n *\n * @dev Implementations MUST guarantee the following invariants ALWAYS hold TRUE:\n *      emissionVolume(t = start time) = initialEmissionVolume()\n *      emissionVolume(t < start time) = 0\n *      emissionVolume(t = start time + duration) = totalEmissionVolume()\n *      emissionVolume(t > start time + duration) = totalEmissionVolume()\n *      emissionVolume(t) - emissionVolume(t - dt) = emissionRate(t, dt)\n *      emissionVolume(t1) - emissionVolume(t0) = emissionVolumeDelta(t0, t1)\n *      emissionVolumeDelta(t1, t2) = 0, if t1 = t2\n *      alreadyReleasedAmount() <= emissionVolume(t = now)\n *      toBeReleasedAmount() = totalEmissionVolume() - alreadyReleasedAmount()\n *      canReleaseNowAmount() = emissionVolume(t = now) - alreadyReleasedAmount()\n *\n * @dev Implementation may not support any `dt` value in emissionRate(t, dt),\n *      but it must support at least dt = 1\n *\n * @author Lizard Labs Core Contributors\n */\ninterface EmissionSchedule {\n\t/**\n\t * @dev Fired in release(), releaseCapped(), releaseAll() functions, as well as\n\t *      in releaseAndCall(), releaseAndCallCapped(), releaseAllAndCall() functions\n\t *\n\t * @param target an account where tokens were released to, or ERC1363Receiver smart contract\n\t *       where tokens were sent to and the `onTransferReceived` callback function was triggered on\n\t * @param amount amount of the tokens released\n\t * @param withCallback true if `target` was treated as the ERC1363Receiver smart contract and\n\t *      `onTransferReceived` callback was executed on it; false otherwise\n\t * @param callbackPayload ERC1363 payload passed to the target contract's `onTransferReceived` callback\n\t */\n\tevent Released(address indexed target, uint256 amount, bool withCallback, bytes callbackPayload);\n\n\t/**\n\t * @notice Emission token is an address of the token this schedule releases into\n\t *      circulation, or zero address if schedule releases native currency like ETH\n\t *\n\t * @return Emission token address or zero address\n\t */\n\tfunction emissionToken() external view returns(address);\n\n\t/**\n\t * @notice Emission volume as a function of time `t` (unix timestamp)\n\t *\n\t * @param t current time or just the time of interest, unix timestamp\n\t * @return emission volume, number of tokens which could be released so far (by time `t`)\n\t */\n\tfunction emissionVolume(uint256 t) external view returns(uint256);\n\n\t/**\n\t * @notice Emission volume on the [t0, t1) time interval\n\t *\n\t * @param t0 lower time interval bound, inclusive, unix timestamp\n\t * @param t1 upper time interval bound, exclusive, unix timestamp\n\t * @return emission volume on the [t0, t1) time interval\n\t */\n\tfunction emissionVolumeDelta(uint256 t0, uint256 t1) external view returns(uint256);\n\n\t/**\n\t * @notice Emission rate as a function of time `t` (unix timestamp) and time change `dt` (seconds)\n\t *\n\t * @param t current time or just the time of interest, unix timestamp\n\t * @param dt time change, seconds, can't be zero (default value: 1)\n\t * @return emission rate, which is an emission volume on the [t - dt, t) time interval\n\t */\n\tfunction emissionRate(uint256 t, uint256 dt) external view returns(uint256);\n\n\t/**\n\t * @notice Emission period is the time interval when emission happens, it is defined\n\t *      by the start time, and duration\n\t *\n\t * @notice Implementations MUST use zero duration value for empty schedules, not releasing any tokens;\n\t *      implementations SHOULD return (0, 0) (start, duration) for empty schedules\n\t *\n\t * @return start emission start time, unix timestamp\n\t * @return duration emission duration, seconds\n\t */\n\tfunction emissionPeriod() external view returns(uint256 start, uint256 duration);\n\n\t/**\n\t * @notice Initial emission volume, amount of tokens which can be released immediately\n\t *      when the schedule starts\n\t *\n\t * @return initial emission volume, emissionVolume(0)\n\t */\n\tfunction initialEmissionVolume() external view returns(uint256);\n\n\t/**\n\t * @notice Total / final emission volume, amount of tokens which will be released eventually;\n\t *      amount of tokens which can be released after the schedule ends\n\t *\n\t * @return total (final) emission volume, emissionVolume(start time + duration)\n\t */\n\tfunction totalEmissionVolume() external view returns(uint256);\n\n\t/**\n\t * @notice Amount of tokens already released\n\t *\n\t * @notice Note: this can be lower than the value returned by `emissionVolume(now)`\n\t *      as not all the tokens which could be released, may be released\n\t *\n\t * @return amount of tokens already released\n\t */\n\tfunction alreadyReleasedAmount() external view returns(uint256);\n\n\t/**\n\t * @notice Amount of tokens that can be (will be) released in the future\n\t *\n\t * @return amount of tokens yet to be released\n\t */\n\tfunction toBeReleasedAmount() external view returns(uint256);\n\n\t/**\n\t * @notice Amount of tokes that can be released right now\n\t *\n\t * @dev Implementation MUST guarantee that this is the amount which:\n\t *      - can be safely passed to release(to, amount) function and it won't throw\n\t *      - is released and returned by the releaseCapped(to, cap) when releasing with no cap, or\n\t *            with the higher cap than the canReleaseNowAmount()\n\t *      - is released and returned by the releaseAll(to)\n\t *\n\t * @return amount of tokens that can be released right now\n\t */\n\tfunction canReleaseNowAmount() external view returns(uint256);\n\n\t/**\n\t * @notice Releases specified amount of tokens to the specified destination address `to`,\n\t *      throwing if the amount is either zero or exceeds canReleaseNowAmount()\n\t *\n\t * @dev Implementation MUST throw if the specified amount exceeds canReleaseNowAmount()\n\t *\n\t * @param to an address to release tokens to\n\t * @param amount the amount of tokens to release\n\t */\n\tfunction release(address to, uint256 amount) external;\n\n\t/**\n\t * @notice Releases tokens available for releasing, but no more than the specified cap\n\t *\n\t * @param to an address to release (send) tokens to\n\t * @param cap maximum amount of tokens to release (amount cap); zero means no cap\n\t * @return releasedAmount the actual released amount, not exceeding neither `cap`, nor canReleaseNowAmount()\n\t */\n\tfunction releaseCapped(address to, uint256 cap) external returns(uint256 releasedAmount);\n\n\t/**\n\t * @notice Releases all the tokens available for releasing\n\t *\n\t * @param to an address to release (send) tokens to\n\t * @return releasedAmount the actual released amount, not exceeding canReleaseNowAmount()\n\t */\n\tfunction releaseAll(address to) external returns(uint256 releasedAmount);\n\n\t/**\n\t * @notice Releases specified amount of tokens to the specified ERC1361Receiver contract,\n\t *      throwing if the amount specified is either zero or exceeds canReleaseNowAmount()\n\t *\n\t * @notice Executes the ERC1361 `onTransferReceived` callback function on the target contract\n\t *\n\t * @dev Implementation MUST throw if the amount specified exceeds canReleaseNowAmount()\n\t *\n\t * @param target ERC1363Receiver smart contract to send released tokens to,\n\t *       and trigger the `onTransferReceived` callback function on\n\t * @param amount the amount of tokens to release\n\t * @param data ERC1363 payload to be passed to the target contract's `onTransferReceived` callback\n\t */\n\tfunction releaseAndCall(address target, uint256 amount, bytes calldata data) external;\n\n\t/**\n\t * @notice Releases tokens available for releasing, but no more than the cap specified\n\t *\n\t * @notice Executes the ERC1361 `onTransferReceived` callback function on the target contract\n\t *\n\t * @param target ERC1363Receiver smart contract to send released tokens to,\n\t *       and trigger the `onTransferReceived` callback function on\n\t * @param cap maximum amount of tokens to release (amount cap); zero means no cap\n\t * @param data ERC1363 payload to be passed to the target contract's `onTransferReceived` callback\n\t * @return releasedAmount the actual released amount, not exceeding neither `cap`, nor canReleaseNowAmount()\n\t */\n\tfunction releaseAndCallCapped(address target, uint256 cap, bytes calldata data) external returns(uint256 releasedAmount);\n\n\t/**\n\t * @notice Releases all the tokens available for releasing\n\t *\n\t * @notice Executes the ERC1361 callback `onTransferReceived` on the target contract\n\t *\n\t * @param target ERC1363Receiver smart contract to send released tokens to,\n\t *       and trigger the `onTransferReceived` callback function on\n\t * @param data ERC1363 payload to be passed to the target contract's `onTransferReceived` callback\n\t * @return releasedAmount the actual released amount, not exceeding canReleaseNowAmount()\n\t */\n\tfunction releaseAllAndCall(address target, bytes calldata data) external returns(uint256 releasedAmount);\n}\n"
    },
    "contracts/protocol/multicall/Multicall.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title Multicall\n *\n * @notice Simplified version of the OZ Multicall contract\n *\n * @dev The use case of the Multicall is to be inherited by the contacts\n *      wishing to allow their clients to execute several functions in a batch\n *\n * @dev Executes in the self-context (storage) via `delegatecall`\n *\n * @author OpenZeppelin\n * @author Lizard Labs Core Contributors\n */\nabstract contract Multicall {\n\t/**\n\t * @dev Multicall support: a function to batch together multiple calls in a single external call.\n\t * @dev Receives and executes a batch of function calls on this contract.\n\t *\n\t * @param data an array of ABI-encoded function calls\n\t * @return results an array of ABI-encoded results of the function calls\n\t */\n\tfunction multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {\n\t\t// the implementation is copied from OZ Multicall contract;\n\t\t// Context-related stuff is dropped as it's not supported by this contract\n\t\tresults = new bytes[](data.length);\n\t\tfor (uint256 i = 0; i < data.length; i++) {\n\t\t\tresults[i] = Address.functionDelegateCall(address(this), data[i]);\n\t\t}\n\t\treturn results;\n\t}\n}\n"
    },
    "contracts/protocol/staking/SlashedStakingV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./TimeWeightedStakingV1.sol\";\n\n/**\n * @title Slashed Staking\n *\n * @notice Fixed-Term Time Weighted Staking extension supporting the reward capping/slashing mechanism\n *\n * @notice Additional Features:\n *      - Reward capping/slashing feature (optional): when enabled\n *            - contract requires the engagement manager approval (signed message) to claim the reward\n *            - reward, calculated on-chain, can be adjusted (decreased only) by the engagement manager\n *            - engagement manager uses the data on staker's off-chain activity to adjust the reward\n *\n * @dev Reward cap/slash message constructed by engagement manager for the staker can be one of 4 types:\n *      1) \"no cap, no slash\" – staker did full activity, they can claim whatever was calculated on-chain, in full;\n *         engagement manager provides an approval to claim whatever is available on-chain\n *      2) \"capped, no slash\" – staker didn't do any activity recently (i.e. in the current epoch),\n *         or the most recent data on their activity is not yet available, staker still can catch up;\n *         engagement manager caps the claimable reward to not allow claiming the reward for the most recent period\n *         of no activity (i.e. removes the reward from the current epoch), but doesn't yet slash the staker\n *      3) \"no cap, slashed\" – staker did an activity recently, but there is unrecoverable activity gap(s) in the past\n *         (for example in one or several epochs which already ended);\n *         engagement manager slashes the claimable reward, the slash amount is then taken out from the staker's\n *         account and sent by the Staking contract to the treasury\n *      4) \"capped, slashed\" – this is combination of (2) and (3) – staker didn't do any activity recently,\n *         and they also have some unrecoverable activity gap(s) in the past;\n *         they may had done some activity in the past (non-zero cap), or may not (zero cap);\n *         engagement manager caps and slashes the claimable reward\n *      Engagement manager can execute the claiming function on behalf of the staker and push the reward to them.\n *\n * @author Lizard Labs Core Contributors\n */\ncontract SlashedStakingV1 is TimeWeightedStakingV1 {\n\t/**\n\t * @dev Reward slash request formed and signed by the engagement manager\n\t */\n\tstruct RewardSlashRequest {\n\t\t/// @dev deposit token address\n\t\taddress depositToken;\n\t\t/// @dev reward token address\n\t\taddress rewardToken;\n\t\t/// @dev staker's account to claim the reward from\n\t\taddress account;\n\t\t/// @dev request valid from date, exclusive, unix timestamp\n\t\tuint32 validAfter;\n\t\t/// @dev request valid until date, exclusive, unix timestamp\n\t\tuint32 validBefore;\n\t\t/// @dev Cumulative reward amount calculated off-chain, caps/overrides UserAccount.accumulatedReward\n\t\tuint96 cumulativeReward;\n\t\t/// @dev An amount to take out from the calculated reward and send to `slashTo`\n\t\tuint96 slashAmount;\n\t\t/// @dev An address to send the slashed amount of the reward to\n\t\taddress slashTo;\n\t}\n\n\t/**\n\t * @notice Enables the reward capping/slashing feature, effectively switching the\n\t *      reward claiming mechanism from decentralized to centralized\n\t *\n\t * @dev When feature `FEATURE_SLASHING_ENABLED` is enabled, all the claiming functions\n\t *      claimReward(), claimRewardTo(), and claimRewardWithAuth() require the cap/slash\n\t *      data provided and signed by the `ROLE_ENGAGEMENT_MANAGER`\n\t */\n\tuint32 public constant FEATURE_SLASHING_ENABLED = 0x0000_0100;\n\n\t/**\n\t * @notice Engagement manager is responsible for supplying stakers' off-chain\n\t *      engagement related data to the smart contract to enable the staking reward\n\t *      slashing mechanism when staker's engagement level is low\n\t * @dev Engagement manager signature is required to claim the reward via all the available\n\t *      claim functions claimReward(), claimRewardTo(), and claimRewardWithAuth()\n\t */\n\tuint32 public constant ROLE_ENGAGEMENT_MANAGER = 0x0100_0000;\n\n\t/**\n\t * @notice EIP-712 delegation struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"RewardSlashRequest(address depositToken,address rewardToken,address account,uint32 validAfter,uint32 validBefore,uint96 cumulativeReward,uint96 slashAmount,address slashTo)\")\n\tbytes32 public constant REWARD_SLASH_REQUEST_TYPEHASH = 0x4c19ab73ad5a900f67dcaf434841f1fb22993a106d1a3c457c11786d47529caf;\n\n\t/**\n\t * @dev Fired in claimSlashedReward(), and claimSlashedRewardWithAuth()\n\t *\n\t * @param treasury receiver of the slashed reward tokens\n\t * @param depositToken address of the the deposited token (now withdrawn)\n\t * @param rewardToken address of the reward token\n\t * @param accountAddress staker's address\n\t * @param amount amount of the reward slashed (of the `rewardToken` token)\n\t */\n\tevent RewardSlashed(\n\t\taddress treasury,\n\t\taddress indexed depositToken,\n\t\taddress indexed rewardToken,\n\t\taddress indexed accountAddress,\n\t\tuint96 amount\n\t);\n\n\t/**\n\t * @inheritdoc EIP712Support\n\t */\n\tfunction DOMAIN_NAME() public pure override returns(string memory) {\n\t\t// simply return the contract name constant\n\t\treturn \"SlashedStakingV1\";\n\t}\n\n\t/**\n\t * @inheritdoc TimeWeightedStakingV1\n\t *\n\t * @dev Requires FEATURE_SLASHING_ENABLED to be disabled\n\t */\n\tfunction claimReward(address depositToken, address rewardToken) public override {\n\t\t// verify the reward slashing is not active\n\t\trequire(!_isFeatureEnabled(FEATURE_SLASHING_ENABLED), \"reward slashing enabled\");\n\n\t\t// delegate to `super.claimReward`\n\t\tsuper.claimReward(depositToken, rewardToken);\n\t}\n\n\t/**\n\t * @inheritdoc TimeWeightedStakingV1\n\t *\n\t * @dev Requires FEATURE_SLASHING_ENABLED to be disabled\n\t */\n\tfunction claimRewardTo(address to, address depositToken, address rewardToken) public override {\n\t\t// verify the reward slashing is not active\n\t\trequire(!_isFeatureEnabled(FEATURE_SLASHING_ENABLED), \"reward slashing enabled\");\n\n\t\t// delegate to `super.claimRewardTo`\n\t\tsuper.claimRewardTo(to, depositToken, rewardToken);\n\t}\n\n\t/**\n\t * @inheritdoc TimeWeightedStakingV1\n\t *\n\t * @dev Requires FEATURE_SLASHING_ENABLED to be disabled\n\t */\n\tfunction claimRewardWithAuth(RewardClaimRequest calldata req, Signature calldata sig) public override {\n\t\t// verify the reward slashing is not active\n\t\trequire(!_isFeatureEnabled(FEATURE_SLASHING_ENABLED), \"reward slashing enabled\");\n\n\t\t// delegate to `super.claimRewardWithAuth`\n\t\tsuper.claimRewardWithAuth(req, sig);\n\t}\n\n\t/**\n\t * @notice Claims pending reward if any and sends it to the specified address `to`,\n\t *      throwing if there is no reward available\n\t *\n\t * @notice Enables the reward capping/slashing mechanism, requires the reward claiming request\n\t *      signed by the engagement manager (reusable)\n\t *\n\t * @param to an address to send claimed reward to\n\t * @param req reward slashing request signed by the engagement manager\n\t * @param sig ECDSA signature for the slashing request\n\t */\n\tfunction claimSlashedReward(\n\t\taddress to,\n\t\tRewardSlashRequest calldata req,\n\t\tSignature calldata sig\n\t) public {\n\t\t// verify reward claiming is active\n\t\trequire(_isFeatureEnabled(FEATURE_REWARD_CLAIMING_ENABLED), \"reward claiming disabled\");\n\n\t\t// verify the tx sender and account specified match\n\t\t_requireAccessCondition(msg.sender == req.account);\n\n\t\t// delegate to `__claimSlashed`\n\t\t__claimSlashed(to, req, sig);\n\t}\n\n\t/**\n\t * @notice Claims the reward on behalf of `req.account`  and sends it to\n\t *      the specified address `req.to`, throwing if there is no reward available\n\t *\n\t * @notice Requires the staker `req.account` to sign the claiming request relayed to this function.\n\t *      Requires the engagement manager to sign the slashing request relayed to this function\n\t *\n\t * @dev Requires valid EIP712 staker's signature:\n\t *     - `validAfter` to be a timestamp in the past\n\t *     - `validBefore` to be a timestamp in the future\n\t *     - `v`, `r` and `s` to be a valid `secp256k1` signature by the `account`\n\t *        over the EIP712-formatted function arguments.\n\t *     - the signature to use `account` current nonce (see `getNonce()`).\n\t *\n\t * @dev Requires valid EIP712 engagement manager's signature:\n\t *     - `validAfter` to be a timestamp in the past\n\t *     - `validBefore` to be a timestamp in the future\n\t *     - `v`, `r` and `s` to be a valid `secp256k1` signature by the `account`\n\t *        over the EIP712-formatted function arguments.\n\t *\n\t * @param req1 reward claiming request, signed by the staker `req.account`\n\t * @param sig1 ECDSA signature for the reward claiming request\n\t * @param req2 reward slashing request, signed by the engagement manager\n\t * @param sig2 ECDSA signature for the reward slashing request\n\t */\n\tfunction claimSlashedRewardWithAuth(\n\t\tRewardClaimRequest calldata req1,\n\t\tSignature calldata sig1,\n\t\tRewardSlashRequest calldata req2,\n\t\tSignature calldata sig2\n\t) public {\n\t\t// verify reward claiming with auth is enabled\n\t\trequire(_isFeatureEnabled(FEATURE_EIP712_CLAIMING_ENABLED), \"EIP712 claiming disabled\");\n\n\t\t// ensure the signed requests match each other\n\t\trequire(\n\t\t\treq1.depositToken == req2.depositToken && req1.rewardToken == req2.rewardToken && req1.account == req2.account,\n\t\t\t\"bad request\"\n\t\t);\n\n\t\t// verify the request\n\t\t_requireAccessCondition(__deriveSigner(req1, sig1) == req1.account);\n\t\trequire(now32() > req1.validAfter, \"signature not yet valid\");\n\t\trequire(now32() < req1.validBefore, \"signature expired\");\n\n\t\t// execute the claim and verify the nonce according to how it is stored on signer's account\n\t\trequire(__claimSlashed(req1.to, req2, sig2) == req1.nonce, \"invalid nonce\");\n\t}\n\n\t/**\n\t * @dev Releases the `req.rewardToken` token from the staker's account `req.account` to the address `to`\n\t *      using the emission schedule configured for the (req.depositToken, req.rewardToken) token pair\n\t *\n\t * @dev Unsafe. Doesn't verify the access permissions. Must be kept private at all times.\n\t *\n\t * @param to an address to send released tokens to\n\t * @param req reward slashing request signed by the engagement manager\n\t * @return account's nonce (used in this claim transaction)\n\t */\n\tfunction __claimSlashed(\n\t\taddress to,\n\t\tRewardSlashRequest calldata req,\n\t\tSignature calldata sig\n\t) private returns(uint256) {\n\t\t// verify the reward slashing is not active\n\t\trequire(_isFeatureEnabled(FEATURE_SLASHING_ENABLED), \"reward slashing disabled\");\n\n\t\t// verify the request (signer, validity dates, etc.)\n\t\t_requireAccessCondition(_isOperatorInRole(__deriveSigner(req, sig), ROLE_ENGAGEMENT_MANAGER));\n\t\trequire(now32() > req.validAfter, \"signature not yet valid\");\n\t\trequire(now32() < req.validBefore, \"signature expired\");\n\n\t\t// delegate to `__claim`\n\t\treturn __claim(to, req);\n\t}\n\n\t/**\n\t * @dev Releases the `rewardToken` token from the staker's account `account` to the address `to`\n\t *      using the emission schedule configured for the (depositToken, rewardToken) token pair\n\t *\n\t * @dev Unsafe. Doesn't verify the access permissions. Must be kept private at all times.\n\t *\n\t * @param to an address to send released tokens to\n\t * @param r reward slashing request signed by the engagement manager\n\t * @return account's nonce (used in this claim transaction)\n\t */\n\tfunction __claim(address to, RewardSlashRequest calldata r) private returns(uint256) {\n\t\t// verify the inputs are valid\n\t\trequire(\n\t\t\tr.cumulativeReward > 0\n\t\t\t&& (r.slashAmount == 0 || r.slashAmount <= r.cumulativeReward && r.slashTo != address(0)),\n\t\t\t\"bad request\"\n\t\t);\n\n\t\t// update staking contract state: fast forward the time to now, calculate the reward available for claiming\n\t\t(uint96 toClaim, uint256 nonce) = __updateStateOnClaim(r.depositToken, r.rewardToken, r.account, r.cumulativeReward);\n\n\t\t// verify there is something to claim\n\t\trequire(toClaim > 0, \"nothing to claim\");\n\n\t\t// cache the emissions schedule on stack\n\t\tEmissionSchedule schedule = getEmissionSchedule(r.depositToken, r.rewardToken);\n\n\t\t// if slashing is requested\n\t\tif(r.slashAmount > 0) {\n\t\t\t// verify there is enough claimable amount to slash\n\t\t\trequire(r.slashAmount <= toClaim, \"not enough claimable amount to slash\");\n\n\t\t\t// execute the slashing by releasing slash rewards\n\t\t\tschedule.release(r.slashTo, r.slashAmount);\n\n\t\t\t// emit an event\n\t\t\temit RewardSlashed(r.slashTo, r.depositToken, r.rewardToken, r.account, r.slashAmount);\n\t\t}\n\n\t\t// if something left to release\n\t\tif(toClaim > r.slashAmount) {\n\t\t\t// then release the required reward\n\t\t\tschedule.release(to, toClaim - r.slashAmount);\n\n\t\t\t// emit an event\n\t\t\temit RewardClaimed(to, r.depositToken, r.rewardToken, r.account, toClaim - r.slashAmount);\n\t\t}\n\n\t\t// return the nonce, it may be used for EIP712 verification\n\t\treturn nonce;\n\t}\n\n\t/**\n\t * @dev Auxiliary function to verify structured EIP712 message signature and derive its signer\n\t *\n\t * @dev Recovers the non-zero signer address from the signed message throwing on failure\n\t *\n\t * @param req reward slashing request, signed by the engagement manager\n\t * @param sig ECDSA signature of the request\n\t * @return recovered non-zero signer address, unless throwing\n\t */\n\tfunction __deriveSigner(RewardSlashRequest calldata req, Signature calldata sig) internal view returns(address) {\n\t\t// build the EIP-712 hashStruct of the message\n\t\tbytes32 hashStruct = keccak256(abi.encode(\n\t\t\tREWARD_SLASH_REQUEST_TYPEHASH,\n\t\t\treq.depositToken,\n\t\t\treq.rewardToken,\n\t\t\treq.account,\n\t\t\treq.validAfter,\n\t\t\treq.validBefore,\n\t\t\treq.cumulativeReward,\n\t\t\treq.slashAmount,\n\t\t\treq.slashTo\n\t\t));\n\n\t\t// derive the signer of the EIP712 message\n\t\treturn __deriveSigner(hashStruct, sig);\n\t}\n}\n"
    },
    "contracts/protocol/staking/TimeWeightedStakingV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@lazy-sol/access-control-upgradeable/contracts/UpgradeableAccessControlCore.sol\";\nimport \"@lazy-sol/advanced-erc20/contracts/interfaces/ERC1363Spec.sol\";\n\nimport \"../../lib/SafeERC20Lib.sol\";\nimport \"../../lib/SafeMathLib.sol\";\nimport \"../../lib/MathLib.sol\";\nimport \"../../lib/TimeDepositLib.sol\";\nimport \"../../utils/EIP712Support.sol\";\nimport \"../es/EmissionSchedule.sol\";\nimport \"../multicall/Multicall.sol\";\n\n/**\n * @title Fixed-Term Time Weighted Staking\n *\n * @notice Fixed lock-up period staking, based on Synthetix reward pool calculation mechanics;\n *      In-depth analysis of Synthetix approach: https://youtu.be/iNZWMj4USUM\n *\n * @notice Token staking is the process of the token holders locking up the deposit token to participate in the\n *      operation and security of the protocol. In return for their contribution, participants earn rewards in the\n *      form of the reward token, which is often the same as the deposit token.\n *\n * @notice Core Features, Terms and Definitions\n *      - Reward pool mechanism:\n *         - the rewards are collected into the reward pool(s) and then\n *         - distributed among the participants based on their contributions\n *      - Fixed lock-up period:\n *         - participant locks their tokens for the predetermined period agreed upon, called the\n *            lock-up period, also known as lock-up duration, staking duration, or deposit duration\n *         - the tokens locked for the predetermined period are called the deposit\n *         - locking the tokens is called staking, depositing, or creating a deposit\n *         - the date when the lock-up period expires is called the deposit maturity date\n *         - the deposit which reached its maturity date is called the matured deposit\n *         - unlocking the tokens after the lock-up period is finished is called unstaking, or deposit withdrawal\n *      - Stake weight mechanism: deposit reward share is determined by the deposit weight / total weight ratio\n *         - total weight is a sum of the all deposits' weights\n *         - deposit weight = deposit amount * weighted duration, where\n *         - weighted duration = duration weight multiplier * lock-up period\n *         - the duration weight multiplier is derived from the lock-up period\n *      - Reward sources:\n *         - emission: reward is minted real-time according to the predefined declining schedule\n *         - revenue: portion of the revenue gets available to the contract from time to time\n *\n * @dev Synthetix approach to reward calculation\n *\n *      To calculate staker's `u` reward `r` between timestamps `k` and `n` we need to calculate:\n *      r(u,k,n) = {sum from k to n - 1 of Ri*Si/Ti}, where\n *         Si - amount staked by staker `u` at timestamp `i`\n *         Ti - total amount staked (by all stakers, sum of all stakes) at timestamp `i`\n *         Ri - reward rate (reward amount per staked token) at timestamp `i`\n *\n *      If we agree to calculate the reward each time staker `u` interacts with the contract\n *      (deposits, withdraws, claims reward, etc.), Si becomes constant between timestamps `k` and `n`:\n *      r(u,k,n) = S * {sum from k to n - 1 of Ri/Ti}, where\n *         S - constant amount staked by staker `u` between timestamps `k` and `n`\n *\n *      Since Solidity is extremely bad in arbitrary data sets traversal, the sum above can't be\n *      efficiently calculated without some additional tricks. The sum is split into two components:\n *      r(u,k,n) = S * ({sum from 0 to n - 1 of Ri/Ti} - {sum from 0 to k - 1 of Ri/Ti}), where\n *         the left sum, also called `rewardPerTokenStored`, is updated every time any staker (including `u`)\n *         interacts with the contract, and when additional reward is added to the contract\n *         the right sum, also called `userRewardPerTokenPaid`, is updated every time the the staker `u`\n *         interacts with the contract (deposits, withdraws, claims reward, etc.)\n *      This way the reward for staker 'u' is recalculated on every contract interaction,\n *      the `userRewardPerTokenPaid`, `rewardPerTokenStored` sums, and amount `S` are updated\n *\n * @dev Fixed lock-up period staking allows to introduce the time weighting, when stakes with\n *      longer lock-ups receive more reward than stakes of the same amount with shorter lock-ups.\n *      All the formulas and variables remain, however variables meaning slightly changes:\n *         S - constant weight staked by staker `u` between timestamps `k` and `n`\n *         Ti - total weight staked (by all stakers, sum of all stakes) at timestamp `i`\n *         Ri - reward rate (reward amount per weight) at timestamp `i`\n *      Weight is derived from the stake amount by multiplying by stake duration and optional multiplier\n *      the left {sum from 0 to n - 1 of Ri*Si/Ti} becomes `rewardPerWeightStored`\n *      the right {sum from 0 to k - 1 of Ri*Si/Ti} becomes `userRewardPerWeightPaid`\n *\n * @dev Staking contract operates on (deposit, reward) token pairs, meaning it is not bound to\n *      only one such pair, but rather can simultaneously process many.\n *      Deposit and reward tokens can be (and usually are) the same token.\n *\n * @dev Non-functional requirements:\n *      Min/max deposit/total amount: [1,     2^96]\n *      Min/max weighted duration:    [1,     2^32]\n *      Min/max deposit/total weight: [1,     2^128]\n *      Min/max reward rate:          [1,     2^96]\n *      Min/max reward per weight:    [2^-128,2^96],\n *                      stored as:    [1,     2^224]\n *\n * @author Lizard Labs Core Contributors\n */\ncontract TimeWeightedStakingV1 is UpgradeableAccessControlCore, EIP712Support, Multicall, ERC1363Receiver {\n\t/// @dev Using SafeERC20Lib for \"safe\" ERC20 transfers (non-standard ERC20 support)\n\tusing SafeERC20Lib for address;\n\n\t/// @dev Using SafeMathLib for safe type conversions\n\tusing SafeMathLib for uint256;\n\n\t/// @dev Using MathLib to work with bitmasks (bitflags)\n\tusing MathLib for uint8;\n\tusing MathLib for uint32;\n\n\t/// @dev Using TimeDepositLib to work with the deposit weights\n\tusing TimeDepositLib for TimeDeposit;\n\tusing TimeDepositLib for DepositSettings;\n\n\t/**\n\t * @dev Reward claim request, formed and signed by the staker, is used in\n\t *      claimRewardWithAuth() EIP712 variant of the claimRewardTo() function\n\t * @dev The request contains all the same fields non-EIP712 claimRewardTo() function\n\t *      expects, plus EIP712 specific request valid after/before dates and nonce\n\t */\n\tstruct RewardClaimRequest {\n\t\t/// @dev an address to send claimed reward to\n\t\taddress to;\n\t\t/// @dev address of the deposit token\n\t\taddress depositToken;\n\t\t/// @dev address of the reward token\n\t\taddress rewardToken;\n\t\t/// @dev staker's account to claim the reward from\n\t\taddress account;\n\t\t/// @dev request valid from date, exclusive, unix timestamp\n\t\tuint32 validAfter;\n\t\t/// @dev request valid until date, exclusive, unix timestamp\n\t\tuint32 validBefore;\n\t\t/// @dev request nonce, starts from zero and increases sequentially\n\t\tuint32 nonce;\n\t}\n\n\t/**\n\t * @dev Time deposit represents some amount of the stake token locked up in a staking\n\t *      contract for a predefined period of time\n\t * @dev The deposit matures on `createdOn + duration` time and deposited tokens unlock\n\t *      in a full amount\n\t *\n\t * @dev 160 bits data structure (1 storage slot)\n\t */\n\tstruct TimeDeposit {\n\t\t/**\n\t\t * @dev Deposit maturity date, unix timestamp\n\t\t *      immutable; max theoretical value is 4,294,967,295, or February 7, 2106 6:28:15 AM\n\t\t * @dev After deposit matures (when current time reaches the maturity date), it can be withdrawn\n\t\t */\n\t\tuint32 maturesOn;\n\t\t/**\n\t\t * @dev Amount of the tokens deposited/locked, wei\n\t\t *      immutable; max theoretical value is ~79.2*10^27 wei, or ~79.2B tokens\n\t\t *\n\t\t * @dev Maximum supported value ~39.6B (signed int96 maximum value)\n\t\t */\n\t\tuint96 amount;\n\t\t/**\n\t\t * @dev Weighted duration is the deposit duration multiplied by the time weight multiplier;\n\t\t *      immutable; max theoretical value 4,294,967,295 sec\n\t\t * @dev We store weighted duration instead of the deposit weight to save 96 bits of storage space;\n\t\t *      deposit weight = deposit amount * weighted duration\n\t\t *\n\t\t * @dev Maximum supported weight value ~1.7*10^38 wei*sec (signed int128 maximum value)\n\t\t */\n\t\tuint32 weightedDuration;\n\t}\n\n\t/**\n\t * @dev User account represents a staker with one or multiple deposits and\n\t *      stores cumulative deposit data helping to avoid per-deposit reward calculation\n\t * @dev User account stores the reward calculation state, the left sum of\n\t *      r(u,k,n) = S * ({sum from 0 to n - 1 of Ri/Ti} - {sum from 0 to k - 1 of Ri/Ti}),\n\t *      also called `userRewardPerWeightPaid`\n\t *\n\t * @dev 256 + 256 + 224 bits data structure (3 storage slots)\n\t */\n\tstruct UserAccount {\n\t\t/**\n\t\t * @dev Total weight `S` of the currently staked (and locked-up) tokens;\n\t\t *      sum of the weights of all the deposits associated with the account\n\t\t * @dev Weight effectively replaces amount in the time weighted staking\n\t\t */\n\t\tuint128 weight;\n\t\t/**\n\t\t * @dev Temporary bonus weight S¹ is a part of the total weight `S`;\n\t\t *      sum of the temporary bonus weights of all the deposits\n\t\t * @dev Temporary bonus weight is assigned to accounts who staked early;\n\t\t *      it is removed at some point from all the accounts and deposits\n\t\t */\n\t\t// uint128 bonusWeight;\n\t\t/**\n\t\t * @dev Also known as `userRewardPerWeightPaid`, {sum from 0 to k - 1 of Ri/Ti}\n\t\t */\n\t\tuint224 rewardPerWeightPaid;\n\t\t/**\n\t\t * @dev Bonus weight expiration date, unix timestamp\n\t\t *\n\t\t * @dev After bonus weight expires (when current time reaches the expiration date),\n\t\t *      the bonus weight can be (and should be) removed (set to zero)\n\t\t */\n\t\t//  uint32 bonusWeightExpirationTime;\n\t\t/**\n\t\t * @dev Total calculated reward, including already claimed and not yet claimed\n\t\t * @dev Accumulated reward stores the result of the reward recalculation,\n\t\t *      which happens every time staker interacts with the contract\n\t\t */\n\t\tuint96 accumulatedReward;\n\t\t/**\n\t\t * @dev Total claimed reward, sum of all past claims made by the staker;\n\t\t *      reward which has already been paid to the staker, meaning\n\t\t *      the reward token was transferred to the staker's address/wallet\n\t\t * @dev Accumulated reward can be claimed by staker;\n\t\t *      when claimed the claimed reward counter gets updated\n\t\t */\n\t\tuint96 claimedReward;\n\t\t/**\n\t\t * @dev Next valid nonce for EIP-712 claimRewardWithAuthorization meta function;\n\t\t *      every time the reward is claimed, the nonce is increased by one\n\t\t */\n\t\tuint32 nonce;\n\t}\n\n\t/**\n\t * @dev Reward calculation state keeps track of the right sum of\n\t *      r(u,k,n) = S * ({sum from 0 to n - 1 of Ri/Ti} - {sum from 0 to k - 1 of Ri/Ti}),\n\t *      also called `rewardPerWeightStored`, current time `n` and total weight `Tn`\n\t *\n\t * @dev 256 + 128 bits data structure (2 storage slots)\n\t */\n\tstruct RewardCalculationState {\n\t\t/**\n\t\t * @dev Timestamp `n`, the last time `rewardPerWeightStored` {sum from 0 to n - 1 of Ri/Ti}\n\t\t *      was updated\n\t\t */\n\t\tuint32 lastUpdateTime;\n\t\t/**\n\t\t * @dev `rewardPerWeightStored` {sum from 0 to n - 1 of Ri/Ti} at timestamp `n`\n\t\t */\n\t\tuint224 rewardPerWeightStored;\n\t\t/**\n\t\t * @dev Total weight staked `Tn` at timestamp `n`\n\t\t */\n\t\tuint128 totalWeightStaked;\n\t}\n\n\t/**\n\t * @dev Deposit settings define the rules related to deposit creation, withdrawal,\n\t *      and reward calculation\n\t *\n\t * @dev 80 bits data structure (1 storage slots)\n\t */\n\tstruct DepositSettings {\n\t\t/**\n\t\t * @dev Minimum deposit duration (lock-up period), seconds\n\t\t *      default value: 13 weeks (3 months)\n\t\t */\n\t\tuint32 minDepositDuration;\n\t\t/**\n\t\t * @dev Maximum deposit duration (lock-up period), seconds\n\t\t *      default value: 104 weeks (2 years)\n\t\t */\n\t\tuint32 maxDepositDuration;\n\t\t/**\n\t\t * @dev Minimum duration weight multiplier: multiplier applied to the deposits with the minimum duration\n\t\t *      default value: 1 (x1)\n\t\t */\n\t\tuint8 minDurationMultiplier;\n\t\t/**\n\t\t * @dev Maximum duration weight multiplier: multiplier applied to the deposits with the maximum duration\n\t\t *      default value: 3 (x3)\n\t\t * @dev Duration weight multiplier for the deposits with the duration in between minimum and maximum\n\t\t *      durations linearly increases from the minimum to the maximum duration multiplier\n\t\t */\n\t\tuint8 maxDurationMultiplier;\n\t\t/**\n\t * @dev Emission schedules are used to generate yield, mint reward tokens;\n\t *      the exact reward token release mechanism is implementation dependent\n\t\t */\n\t\tEmissionSchedule rewardEmissionSchedule;\n\t}\n\n\t/**\n\t * @dev User accounts store cumulative deposit info used to calculate the reward\n\t * @dev Users' (stakers') accounts mapping\n\t *      maps keccak256(deposit token, reward token, staker address) => staker's account\n\t */\n\tmapping(bytes32 => UserAccount) private accounts;\n\n\t/**\n\t * @dev User deposits array is used only for deposit withdrawal,\n\t *      as each deposit defines its maturity date\n\t * @dev Users' (stakers') deposits mapping\n\t *      maps keccak256(deposit token, reward token, staker address) => staker's deposits array\n\t */\n\tmapping(bytes32 => TimeDeposit[]) private deposits;\n\n\t/**\n\t * @dev Reward calculation state stores the data related to reward calculation\n\t *\n\t * @dev Mapping of reward calculation states\n\t *      maps keccak256(deposit token, reward token) => reward calculation state\n\t */\n\tmapping(bytes32 => RewardCalculationState) private rewardCalculationStates;\n\n\t/**\n\t * @dev Deposit settings define the rules related to deposit creation, withdrawal,\n\t *      and reward calculation\n\t *\n\t * @dev Mapping of the deposit settings\n\t *      maps keccak256(deposit token, reward token) => deposit settings\n\t */\n\tmapping(bytes32 => DepositSettings) private depositSettings;\n\n\t/**\n\t * @dev Empty reserved space in storage. The size of the __gap array is calculated so that\n\t *      the amount of storage used by a contract always adds up to the 50.\n\t *      See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n\t */\n\tuint256[46] private __gap;\n\n\t/**\n\t * @notice Enables the deposits functionality, allows to stake\n\t *\n\t * @dev Feature FEATURE_DEPOSITS_ENABLED is required for the deposit(),\n\t *      depositTo(), and ERC-1363 deposit functions to succeed\n\t */\n\tuint32 public constant FEATURE_DEPOSITS_ENABLED = 0x0000_0001;\n\n\t/**\n\t * @notice Enables the deposit withdrawal functionality, allows to unstake\n\t *\n\t * @dev Feature FEATURE_WITHDRAWALS_ENABLED is required for the withdraw()\n\t *      and withdrawTo() functions to succeed\n\t */\n\tuint32 public constant FEATURE_WITHDRAWALS_ENABLED = 0x0000_0002;\n\n\t/**\n\t * @notice Enables the reward claiming functionality, allows to claim the reward\n\t *\n\t * @dev Feature FEATURE_REWARD_CLAIMING_ENABLED is required for the claimReward()\n\t *      and claimRewardTo() functions to succeed\n\t */\n\tuint32 public constant FEATURE_REWARD_CLAIMING_ENABLED = 0x0000_0004;\n\n\t/**\n\t * @notice Enables the EIP712-signed meta reward claiming functionality\n\t *\n\t * @dev Feature FEATURE_EIP712_CLAIMING_ENABLED is required for the\n\t *      claimRewardWithAuth() function to succeed\n\t */\n\tuint32 public constant FEATURE_EIP712_CLAIMING_ENABLED = 0x0000_0008;\n\n\t/**\n\t * @notice Deposit settings manager is responsible for deposit settings setup\n\t *\n\t * @dev Role ROLE_DEPOSIT_SETTINGS_MANAGER allows\n\t *      updating global deposit settings via updateDepositSettings(), and\n\t *      deleting these settings via deleteDepositSettings()\n\t */\n\tuint32 public constant ROLE_DEPOSIT_SETTINGS_MANAGER = 0x0002_0000;\n\n\t/**\n\t * @notice EIP-712 delegation struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"RewardClaimRequest(address to,address depositToken,address rewardToken,address account,uint32 validAfter,uint32 validBefore,uint32 nonce)\")\n\tbytes32 public constant REWARD_CLAIM_REQUEST_TYPEHASH = 0x1153c03c400ea66b2322724e2a59b678a30561439d99fbd76456d87b02ed6653;\n\n\t/**\n\t * @dev Fired internally when global reward calculation state is updated for the (deposit, reward) token pair:\n\t *      deposit(), depositTo(), ERC-1363 deposit, ERC-1363 depositTo\n\t *      withdraw(), withdrawTo()\n\t *      claimReward(), claimRewardTo()\n\t *\n\t * @param depositToken address of the the deposit token\n\t * @param rewardToken address of the reward token\n\t * @param state new reward calculation state\n\t */\n\tevent StateUpdated(address indexed depositToken, address indexed rewardToken, RewardCalculationState state);\n\n\t/**\n\t * @dev Fired internally when global reward calculation state is updated for the (deposit, reward) token pair:\n\t *      deposit(), depositTo(), ERC-1363 deposit, ERC-1363 depositTo\n\t *      withdraw(), withdrawTo()\n\t *      claimReward(), claimRewardTo()\n\t *\n\t * @param depositToken address of the the deposit token\n\t * @param rewardToken address of the reward token\n\t * @param accountAddress staker's address\n\t * @param account staker's account state after update\n\t */\n\tevent AccountStateUpdated(\n\t\taddress indexed depositToken,\n\t\taddress indexed rewardToken,\n\t\taddress indexed accountAddress,\n\t\tUserAccount account\n\t);\n\n\t/**\n\t * @dev Fired in deposit(), depositTo(), ERC-1363 deposit, ERC-1363 depositTo\n\t *\n\t * @param depositSupplier sender of the deposit tokens, usually transaction sender\n\t * @param depositToken address of the the token deposited\n\t * @param rewardToken address of the reward token\n\t * @param depositOwner owner of the deposit created, future receiver of the deposit tokens\n\t * @param depositId ID of the deposit created for the staker for the (deposit, reward) token pair\n\t * @param deposit deposit details (deposited amount, deposit maturity date, deposit weight)\n\t */\n\tevent DepositCreated(\n\t\taddress depositSupplier,\n\t\taddress indexed depositToken,\n\t\taddress indexed rewardToken,\n\t\taddress indexed depositOwner,\n\t\tuint256 depositId,\n\t\tTimeDeposit deposit\n\t);\n\n\t/**\n\t * @dev Fired in withdraw(), and withdrawTo()\n\t *\n\t * @param beneficiary receiver of the deposit tokens, usually transaction sender\n\t * @param depositToken address of the the deposited token (now withdrawn)\n\t * @param rewardToken address of the reward token\n\t * @param depositOwner owner of the deposit withdrawn, always the transaction sender\n\t * @param depositId ID of the deposit withdrawn (and removed from the storage)\n\t * @param deposit deposit details before the deletion from the storage\n\t */\n\tevent DepositWithdrawn(\n\t\taddress beneficiary,\n\t\taddress indexed depositToken,\n\t\taddress indexed rewardToken,\n\t\taddress indexed depositOwner,\n\t\tuint256 depositId,\n\t\tTimeDeposit deposit\n\t);\n\n\t/**\n\t * @dev Fired in claimReward(), claimRewardTo(), and claimRewardWithAuth()\n\t *\n\t * @param beneficiary receiver of the reward tokens, usually transaction sender\n\t * @param depositToken address of the the deposited token (now withdrawn)\n\t * @param rewardToken address of the reward token\n\t * @param accountAddress staker's address, always the transaction sender or EIP712 signer\n\t * @param amount amount of the paid out reward (of the `rewardToken` token)\n\t */\n\tevent RewardClaimed(\n\t\taddress beneficiary,\n\t\taddress indexed depositToken,\n\t\taddress indexed rewardToken,\n\t\taddress indexed accountAddress,\n\t\tuint96 amount\n\t);\n\n\t/**\n\t * @dev Fired in updateDepositSettings()\n\t *\n\t * @param depositToken address of the the deposit token\n\t * @param rewardToken address of the reward token\n\t * @param settings new deposit settings set for the (deposit, reward) token pair\n\t */\n\tevent DepositSettingsUpdated(\n\t\taddress indexed depositToken,\n\t\taddress indexed rewardToken,\n\t\tDepositSettings settings\n\t);\n\n\t/**\n\t * @dev Fired in deleteDepositSettings()\n\t *\n\t * @param depositToken address of the the deposit token\n\t * @param rewardToken address of the reward token\n\t */\n\tevent DepositSettingsDeleted(address indexed depositToken, address indexed rewardToken);\n\n\t/**\n\t * @inheritdoc EIP712Support\n\t */\n\tfunction DOMAIN_NAME() public pure virtual override returns(string memory) {\n\t\t// simply return the contract name constant\n\t\treturn \"TimeWeightedStakingV1\";\n\t}\n\n\t/**\n\t * @dev \"Constructor replacement\" for a smart contract with a delayed initialization (post-deployment initialization)\n\t *      Creates the \"DepositSettings\", which can be read back later with getDepositSettings() function\n\t *\n\t * @dev Initializes the RBAC module setting the tx sender as an admin\n\t *\n\t * @param tokenAddress ERC-1363 token address, acting as both deposit and reward token\n\t * @param emissionScheduleAddress address of the emission schedule used to release the reward\n\t */\n\tfunction postConstruct(address tokenAddress, address emissionScheduleAddress) public initializer {\n\t\t// initialize contract storage: initialize default deposit settings\n\t\t__updateDepositSettings(\n\t\t\ttokenAddress,\n\t\t\ttokenAddress,\n\t\t\tDepositSettings({\n\t\t\t\tminDepositDuration:    13 weeks, // 3 months\n\t\t\t\tmaxDepositDuration:    104 weeks, // 2 years (24 months)\n\t\t\t\tminDurationMultiplier: 1, // x1\n\t\t\t\tmaxDurationMultiplier: 3, // x3\n\t\t\t\trewardEmissionSchedule: EmissionSchedule(emissionScheduleAddress)\n\t\t\t})\n\t\t);\n\n\t\t// initialize the RBAC module\n\t\t_postConstruct(msg.sender, 0);\n\t}\n\n\t/**\n\t * @dev Gets the global reward calculation state for the given token pair\n\t *\n\t * @param depositToken address of the deposit token\n\t * @param rewardToken address of the reward token\n\t * @return global reward calculation state for the given token pair\n\t */\n\tfunction getState(address depositToken, address rewardToken) public view returns(RewardCalculationState memory) {\n\t\t// calculate the mapping key, read from storage and return\n\t\treturn rewardCalculationStates[__key(depositToken, rewardToken)];\n\t}\n\n\t/**\n\t * @dev Reward calculation state update function. Executed on the deposit creation operation.\n\t *\n\t * @dev Updates global staking reward calculation state (RewardCalculationState) in storage:\n\t *      `lastUpdateTime` timestamp `n`\n\t *      `totalWeightStaked` total weight staked `Tn` at timestamp `n`\n\t *      `rewardPerWeightStored` {sum from 0 to n - 1 of Ri/Ti} at timestamp `n`\n\t * @dev Updates staker's account reward calculation state (UserAccount) in memory:\n\t *      `accumulatedReward` staker accumulated reward between timestamps `k` and `n`\n\t *      `rewardPerWeightPaid` {sum from 0 to k - 1 of Ri/Ti} at timestamp `k = n`\n\t *      `weight` staker's account weight\n\t *\n\t * @param depositToken address of the deposit token\n\t * @param rewardToken address of the reward token\n\t * @param accountAddress staker's account address\n\t * @param userDeposit new deposit created\n\t */\n\tfunction __updateStateOnDeposit(\n\t\taddress depositToken,\n\t\taddress rewardToken,\n\t\taddress accountAddress,\n\t\tTimeDeposit memory userDeposit\n\t) private {\n\t\t// to efficiently update the user's account, read it first into the memory\n\t\tUserAccount memory account = getUserAccount(depositToken, rewardToken, accountAddress);\n\n\t\t// update global state (storage), update the account (memory)\n\t\t__updateState(depositToken, rewardToken, userDeposit.weight(), account);\n\n\t\t// save the the user's account back into the storage\n\t\t__saveUserAccount(depositToken, rewardToken, accountAddress, account);\n\t}\n\n\t/**\n\t * @dev Reward calculation state update function. Executed on the deposit withdrawal operation.\n\t *\n\t * @dev Updates global staking reward calculation state (RewardCalculationState) in storage:\n\t *      `lastUpdateTime` timestamp `n`\n\t *      `totalWeightStaked` total weight staked `Tn` at timestamp `n`\n\t *      `rewardPerWeightStored` {sum from 0 to n - 1 of Ri/Ti} at timestamp `n`\n\t * @dev Updates staker's account reward calculation state (UserAccount) in memory:\n\t *      `accumulatedReward` staker accumulated reward between timestamps `k` and `n`\n\t *      `rewardPerWeightPaid` {sum from 0 to k - 1 of Ri/Ti} at timestamp `k = n`\n\t *      `weight` staker's account weight\n\t *\n\t * @param depositToken address of the deposit token\n\t * @param rewardToken address of the reward token\n\t * @param accountAddress staker's account address\n\t * @param userDeposit the deposit withdrawn\n\t */\n\tfunction __updateStateOnWithdraw(\n\t\taddress depositToken,\n\t\taddress rewardToken,\n\t\taddress accountAddress,\n\t\tTimeDeposit memory userDeposit\n\t) private {\n\t\t// to efficiently update the user's account, read it first into the memory\n\t\tUserAccount memory account = getUserAccount(depositToken, rewardToken, accountAddress);\n\n\t\t// update global state (storage), update the account (memory)\n\t\t__updateState(depositToken, rewardToken, -userDeposit.weight(), account);\n\n\t\t// save the the user's account back into the storage\n\t\t__saveUserAccount(depositToken, rewardToken, accountAddress, account);\n\t}\n\n\t/**\n\t * @dev Reward calculation state update function. Executed on the  reward claim operation.\n\t *\n\t * @dev Updates global staking reward calculation state (RewardCalculationState) in storage:\n\t *      `lastUpdateTime` timestamp `n`\n\t *      `rewardPerWeightStored` {sum from 0 to n - 1 of Ri/Ti} at timestamp `n`\n\t * @dev Updates staker's account reward calculation state (UserAccount) in memory:\n\t *      `accumulatedReward` staker accumulated reward between timestamps `k` and `n`\n\t *      `rewardPerWeightPaid` {sum from 0 to k - 1 of Ri/Ti} at timestamp `k = n`\n\t *      `nonce` staker's account nonce\n\t *      `claimedReward` staker's account claimed reward counter\n\t *\n\t * @param depositToken address of the deposit token\n\t * @param rewardToken address of the reward token\n\t * @param accountAddress staker's account address\n\t * @param cumulativeClaimAmountCap how many tokens to claim from the account, optional (unset value is max uint96)\n\t *      the `claimedReward` on the account will be updated to `min(accumulatedReward, cumulativeClaimAmountCap)`\n\t *\n\t * @return toClaim how many tokens were claimed from the account (and have to be sent out by the caller),\n\t *      this represents the change of the claimedReward on the account due to the update\n\t * @return nonce account's nonce before the update; nonce increases by one during the update\n\t */\n\tfunction __updateStateOnClaim(\n\t\taddress depositToken,\n\t\taddress rewardToken,\n\t\taddress accountAddress,\n\t\tuint96 cumulativeClaimAmountCap\n\t) internal returns(uint96 toClaim, uint256 nonce) {\n\t\t// to efficiently update the user's account, read it first into the memory\n\t\tUserAccount memory account = getUserAccount(depositToken, rewardToken, accountAddress);\n\n\t\t// update global state (storage), update the account (memory)\n\t\t__updateState(depositToken, rewardToken, 0, account);\n\n\t\t// if the requested cumulative amount is less than already claimed, there is nothing to do\n\t\t// only if the amount is bigger than already claimed we update the account\n\t\tif(cumulativeClaimAmountCap > account.claimedReward) {\n\t\t\t// if the requested cumulative amount exceeds whatever is calculated by the contract\n\t\t\tif(cumulativeClaimAmountCap > account.accumulatedReward) {\n\t\t\t\t// we trim the request to the maximum value possible\n\t\t\t\tcumulativeClaimAmountCap = account.accumulatedReward;\n\t\t\t}\n\t\t\t// calculate how much of the reward is possible to claim\n\t\t\ttoClaim = cumulativeClaimAmountCap - account.claimedReward;\n\t\t\t// update the claimed reward\n\t\t\taccount.claimedReward = cumulativeClaimAmountCap;\n\t\t}\n\t\t// the nonce should be updated in any case\n\t\t// save the nonce to be returned and increment it right after\n\t\tnonce = account.nonce++;\n\n\t\t// save the the user's account back into the storage\n\t\t__saveUserAccount(depositToken, rewardToken, accountAddress, account);\n\n\t\t// explicitly return the results\n\t\treturn (toClaim, nonce);\n\t}\n\n\t/**\n\t * @dev Reward calculation state update function. Executed on ALL operations.\n\t *\n\t * @dev Updates global staking reward calculation state (RewardCalculationState) in storage:\n\t *      `lastUpdateTime` timestamp `n`\n\t *      `totalWeightStaked` total weight staked `Tn` at timestamp `n`\n\t *      `rewardPerWeightStored` {sum from 0 to n - 1 of Ri/Ti} at timestamp `n`\n\t * @dev Updates staker's account reward calculation state (UserAccount) in memory:\n\t *      `accumulatedReward` staker accumulated reward between timestamps `k` and `n`\n\t *      `rewardPerWeightPaid` {sum from 0 to k - 1 of Ri/Ti} at timestamp `k = n`\n\t *      `weight` staker's account weight\n\t *\n\t * @param depositToken address of the deposit token\n\t * @param rewardToken address of the reward token\n\t * @param weightDelta how user's account and global weight changed, optional (unset value is zero)\n\t *      positive: weight increased; negative: weight decreased\n\t * @param account staker's account to be updated in the memory\n\t */\n\tfunction __updateState(address depositToken, address rewardToken, int128 weightDelta, UserAccount memory account) private {\n\t\t{ // <<-- save 5 bytes\n\t\t// update global state\n\t\tuint224 rewardPerWeightStored = __updateState(depositToken, rewardToken, weightDelta);\n\n\t\t// update the account\n\t\t// update `accumulatedReward` staker accumulated reward between timestamps `k` and `n`\n\t\taccount.accumulatedReward += __mul(account.weight, rewardPerWeightStored - account.rewardPerWeightPaid);\n\t\t// and the `userRewardPerWeightPaid` {sum from 0 to k - 1 of Ri/Ti} at timestamp `k = n`\n\t\taccount.rewardPerWeightPaid = rewardPerWeightStored;\n\t\t}\n\t\t// update the total weight of the account\n\t\taccount.weight = uint128(int128(account.weight) + weightDelta);\n\t}\n\n\t/**\n\t * @dev Reward calculation state update function. Executed on ALL operations.\n\t *\n\t * @dev Updates global staking reward calculation state (RewardCalculationState) in storage:\n\t *      `lastUpdateTime` timestamp `n`\n\t *      `totalWeightStaked` total weight staked `Tn` at timestamp `n`\n\t *      `rewardPerWeightStored` {sum from 0 to n - 1 of Ri/Ti} at timestamp `n`\n\t *\n\t * @param depositToken address of the deposit token\n\t * @param rewardToken address of the reward token\n\t * @param weightDelta how user's account and global weight changed, optional (unset value is zero)\n\t *      positive: weight increased; negative: weight decreased\n\t *\n\t * @return `rewardPerWeightStored` {sum from 0 to n - 1 of Ri/Ti} at timestamp `n` - after the update\n\t */\n\tfunction __updateState(address depositToken, address rewardToken, int128 weightDelta) private returns(uint224) {\n\t\t// calculate and cache the reward calculation state mapping key\n\t\tbytes32 key = __key(depositToken, rewardToken);\n\n\t\t// to efficiently update the reward calculation state, read it first into the memory\n\t\tRewardCalculationState memory rcs = rewardCalculationStates[key];\n\n\t\t// save 15 bytes by putting current time on stack \n\t\tuint32 currentTime = now32();\n\n\t\t// if staking contract is empty (no active deposits), no accounts receive the reward;\n\t\t// the `rewardPerWeightStored` {sum from 0 to n - 1 of Ri/Ti} freezes\n\t\t// and doesn't grow until at least one deposit is made;\n\t\t// otherwise, if staking contract is not empty (there is at least one active deposit)\n\t\tif(rcs.totalWeightStaked > 0 && rcs.lastUpdateTime < currentTime) {\n\t\t\t// get the reward amount for the time passed since last update\n\t\t\t// getting the amount may fail if the DepositSettings are deleted or\n\t\t\t// if the EmissionSchedule gets deleted or modified\n\t\t\t// using try-catch approach to get the amount safely and fallback to zero on error\n\t\t\ttry __getEmissionSchedule(key).emissionVolumeDelta(rcs.lastUpdateTime, currentTime) returns (uint256 amount) {\n\t\t\t\t// the call succeeded, based on the amount for the time passed since last update\n\t\t\t\t// update the `rewardPerWeightStored` {sum from 0 to n - 1 of Ri/Ti} at timestamp `n`\n\t\t\t\trcs.rewardPerWeightStored += __div(amount.toUint96(), rcs.totalWeightStaked);\n\t\t\t\t// NOTE: moving the L718 `rcs.lastUpdateTime = currentTime;` current timestamp `n` update here results in\n\t\t\t\t//       no lost rewards due to stakers' inactivity when `totalWeightStaked` is zero\n\t\t\t} catch {/* the call failed, do nothing, amount is zero, no update is required */}\n\t\t}\n\t\t// update the current timestamp `n`\n\t\trcs.lastUpdateTime = currentTime;\n\t\t// update the global weight\n\t\t// this can int128 overflow only on new deposit creation, effectively blocking the creation, which is OK\n\t\trcs.totalWeightStaked = uint128(int128(rcs.totalWeightStaked) + weightDelta);\n\n\t\t// save the reward calculation state back into storage\n\t\trewardCalculationStates[key] = rcs;\n\n\t\t// emit an event\n\t\temit StateUpdated(depositToken, rewardToken, rcs);\n\n\t\t// return the result\n\t\treturn rcs.rewardPerWeightStored;\n\t}\n\n\t/**\n\t * @notice Deposits `amount` of `depositToken` and locks them up for the `duration` of seconds.\n\t *      Deposit tokens are transferred into the contract, therefore the transfer for the\n\t *      amount specified must be approved beforehand.\n\t *\n\t * @dev Note: instead of approve + deposit one can do ERC-1363 deposit in a single transaction\n\t *\n\t * @dev Throws if (deposit, reward) token pair is not registered within the contract\n\t *      (is unknown to the contract, doesn't have associated DepositSettings with EmissionSchedule\n\t *\n\t * @dev Throws if the `amount` input param exceeds signed integer int96 maximum value\n\t *\n\t * @param depositToken address of the deposited token\n\t * @param rewardToken address of the reward token\n\t * @param amount amount of tokens to transfer, lock, and deposit;\n\t *      mustn't exceed the signed integer int96 maximum value\n\t * @param duration deposit lock-up period in seconds\n\t *\n\t * @return depositId ID of the newly created deposit\n\t */\n\tfunction deposit(\n\t\taddress depositToken,\n\t\taddress rewardToken,\n\t\tuint96 amount,\n\t\tuint32 duration\n\t) public returns(uint256 depositId) {\n\t\t// transfer staking token in\n\t\t// note: deflationary tokens are not supported!\n\t\tdepositToken.safeTransferFrom(msg.sender, address(this), amount);\n\n\t\t// return the deposit ID explicitly\n\t\treturn __createDeposit(msg.sender, depositToken, rewardToken, msg.sender, amount, duration);\n\t}\n\n\t/**\n\t * @notice Deposits `amount` of `depositToken` to the staker's account `userAddress`, who will\n\t *      be the owner of the created deposit, and locks them up for the `duration` of seconds.\n\t *      Deposit tokens are transferred into the contract, therefore the transfer for the\n\t *      amount specified must be approved beforehand.\n\t *\n\t * @dev Note: instead of approve + deposit one can do ERC-1363 deposit in a single transaction\n\t *\n\t * @dev Throws if (deposit, reward) token pair is not registered within the contract\n\t *      (is unknown to the contract, doesn't have associated DepositSettings with EmissionSchedule\n\t *\n\t * @dev Throws if the `amount` input param exceeds signed integer int96 maximum value\n\t *\n\t * @param depositToken address of the deposited token\n\t * @param rewardToken address of the reward token\n\t * @param depositOwner address of the user who will be the owner of this deposit\n\t * @param amount amount of tokens to transfer, lock, and deposit;\n\t *      mustn't exceed the signed integer int96 maximum value\n\t * @param duration deposit lock-up period in seconds\n\t *\n\t * @return depositId ID of the newly created deposit\n\t */\n\tfunction depositTo(\n\t\taddress depositToken,\n\t\taddress rewardToken,\n\t\taddress depositOwner,\n\t\tuint96 amount,\n\t\tuint32 duration\n\t) public returns(uint256 depositId) {\n\t\t// transfer staking token in\n\t\t// note: deflationary tokens are not supported!\n\t\tdepositToken.safeTransferFrom(msg.sender, address(this), amount);\n\n\t\t// return the deposit ID explicitly\n\t\treturn __createDeposit(msg.sender, depositToken, rewardToken, depositOwner, amount, duration);\n\t}\n\n\t/**\n\t * @dev Creates a deposit record for `amount` of `depositToken`, locked for the `duration` of seconds.\n\t *      Unsafe. Doesn't transfer the tokens. Must be kept private at all times.\n\t *\n\t * @dev Throws if (deposit, reward) token pair is not registered within the contract\n\t *      (is unknown to the contract, doesn't have associated DepositSettings with EmissionSchedule\n\t *\n\t * @dev Throws if the `amount` input param exceeds signed integer int96 maximum value\n\t *\n\t * @param depositSupplier an address who sent the deposit tokens for the deposit\n\t * @param depositToken address of the deposited token\n\t * @param rewardToken address of the reward token\n\t * @param depositOwner address of the owner of this deposit (a.k.a staker)\n\t * @param amount amount of tokens to transfer, lock, and deposit;\n\t *      mustn't exceed the signed integer int96 maximum value\n\t * @param duration deposit lock-up period in seconds\n\t *\n\t * @return depositId ID of the newly created deposit\n\t */\n\tfunction __createDeposit(\n\t\taddress depositSupplier,\n\t\taddress depositToken,\n\t\taddress rewardToken,\n\t\taddress depositOwner,\n\t\tuint96 amount,\n\t\tuint32 duration\n\t) private returns(uint256 depositId) {\n\t\t// verify depositing is active\n\t\trequire(_isFeatureEnabled(FEATURE_DEPOSITS_ENABLED), \"deposits disabled\");\n\n\t\t// load the deposit settings into the memory\n\t\tDepositSettings memory settings = getDepositSettings(depositToken, rewardToken);\n\n\t\t// verify the inputs\n\t\trequire(depositOwner != address(0), \"zero address\");\n\t\trequire(amount > 0, \"zero amount\");\n\t\trequire(duration >= settings.minDepositDuration, \"duration too short\");\n\t\trequire(duration <= settings.maxDepositDuration || settings.maxDepositDuration == 0, \"duration too long\");\n\n\t\t// create the deposit data structure in memory\n\t\tTimeDeposit memory userDeposit = settings.newDeposit(amount, duration, now32());\n\n\t\t// save the link to the user's deposits\n\t\tTimeDeposit[] storage userDeposits = __deposits(depositToken, rewardToken, depositOwner);\n\n\t\t// index of the newly created deposit serves as deposit ID\n\t\tdepositId = userDeposits.length;\n\n\t\t// save the deposit into the storage\n\t\tuserDeposits.push(userDeposit);\n\n\t\t// update staking contract state: fast forward the time to now\n\t\t__updateStateOnDeposit(depositToken, rewardToken, depositOwner, userDeposit);\n\n\t\t// emit an event\n\t\temit DepositCreated(depositSupplier, depositToken, rewardToken, depositOwner, depositId, userDeposit);\n\n\t\t// return the deposit ID explicitly\n\t\treturn depositId;\n\t}\n\n\t/**\n\t * @notice Withdraws the deposit with ID `depositId` stored for the (deposit, reward) token pair\n\t *      (`depositToken`, `rewardToken`)\n\t *\n\t * @dev The deposit is deleted from the contact storage after successful withdrawal\n\t *\n\t * @param depositToken address of the deposited token\n\t * @param rewardToken address of the reward token\n\t * @param depositId ID of the deposit to withdraw\n\t */\n\tfunction withdraw(address depositToken, address rewardToken, uint256 depositId) public {\n\t\t// delegate to `withdrawTo`\n\t\twithdrawTo(msg.sender, depositToken, rewardToken, depositId);\n\t}\n\n\t/**\n\t * @notice Withdraws the deposit with ID `depositId` stored for the (deposit, reward) token pair\n\t *      (`depositToken`, `rewardToken`) and sends the tokens to the account `to`\n\t *\n\t * @dev The deposit is deleted from the contact storage after successful withdrawal\n\t *\n\t * @param to account address to send withdrawn tokens to\n\t * @param depositToken address of the deposited token\n\t * @param rewardToken address of the reward token\n\t * @param depositId ID of the deposit to withdraw\n\t */\n\tfunction withdrawTo(address to, address depositToken, address rewardToken, uint256 depositId) public {\n\t\t// verify withdrawals are active\n\t\trequire(_isFeatureEnabled(FEATURE_WITHDRAWALS_ENABLED), \"withdrawals disabled\");\n\n\t\t// save the link to the user's deposits\n\t\tTimeDeposit[] storage userDeposits = __deposits(depositToken, rewardToken, msg.sender);\n\n\t\t// make sure depositId is valid and throw clear error if not\n\t\trequire(depositId < userDeposits.length, \"doesn't exist\");\n\t\t// read the deposit into memory\n\t\tTimeDeposit memory userDeposit = userDeposits[depositId];\n\n\t\t// make sure deposit has matured\n\t\trequire(userDeposit.maturesOn <= now32(), \"deposit locked\");\n\t\t// make sure deposit is not already withdrawn\n\t\trequire(userDeposit.amount > 0, \"already withdrawn\");\n\n\t\t// update staking contract state: fast forward the time to now\n\t\t__updateStateOnWithdraw(depositToken, rewardToken, msg.sender, userDeposit);\n\n\t\t// delete the deposit\n\t\tdelete userDeposits[depositId];\n\n\t\t// transfer staking token out\n\t\t// note: deflationary tokens are not supported!\n\t\tdepositToken.safeTransfer(to, userDeposit.amount);\n\n\t\t// emit an event\n\t\temit DepositWithdrawn(to, depositToken, rewardToken, msg.sender, depositId, userDeposit);\n\t}\n\n\t/**\n\t * @notice ERC-1363 alternative for functions:\n\t *      deposit(): allows a single transaction deposit instead of two (approve + deposit) transactions\n\t *      depositTo(): allows a single transaction deposit instead of two (approve + depositTo) transactions\n\t *\n\t * @dev Use `data = abi.encodePacked(bytes4(keccak256(\"deposit(address,uint32)\")), rewardToken, duration)`\n\t *      to execute the deposit(depositToken, rewardToken, amount, duration) function.\n\t *\n\t *      The deposit(depositToken, rewardToken, amount, duration) params are derived in the following way:\n\t *      depositToken is an ERC-1363 contract which triggered the callback, this is the contract\n\t *         one would utilize to do the ERC-1363 `transferAndCall` or `transferFromAndCall` transfer\n\t *      rewardToken is decoded from the data field, passed by the ERC-1363 implementation as is from the client tx\n\t *      amount is the transfer 'value' reported by the ERC-1363 contract\n\t *      duration is decoded from the data field, passed by the ERC-1363 implementation as is from the client tx\n\t *      `msg.sender` (deposit owner and supplier) is the token spender `from`\n\t *\n\t * @dev Use `data = abi.encodePacked(bytes4(keccak256(\"depositTo(address,address,uint32)\")), rewardToken, depositOwner, duration)`\n\t *      to execute the depositTo(depositToken, rewardToken, depositOwner, amount, duration) function.\n\t *\n\t *      The depositTo(depositToken, rewardToken, depositOwner, amount, duration) params are derived in the following way:\n\t *      depositToken is an ERC-1363 contract which triggered the callback, this is the contract\n\t *         one would utilize to do the ERC-1363 `transferAndCall` or `transferFromAndCall` transfer\n\t *      rewardToken is decoded from the data field, passed by the ERC-1363 implementation as is from the client tx\n\t *      depositOwner is decoded from the data field, passed by the ERC-1363 implementation as is from the client tx\n\t *      amount is the transfer 'value' reported by the ERC-1363 contract\n\t *      duration is decoded from the data field, passed by the ERC-1363 implementation as is from the client tx\n\t *      `msg.sender` (deposit supplier) is the token spender `from`\n\t *\n\t * @dev Throws if the `value` supplied exceeds signed integer int96 maximum value\n\t *\n\t * @inheritdoc ERC1363Receiver\n\t */\n\tfunction onTransferReceived(address, address from, uint256 value, bytes memory data) public virtual returns (bytes4) {\n\t\t// verify the input data format compatibility\n\t\t// data length for deposit() function is 28 bytes = 4 bytes + 20 bytes + 4 bytes\n\t\t// data length for depositTo() function is 48 bytes = 4 bytes + 20 bytes + 20 bytes + 4 bytes\n\t\trequire(data.length == 28 || data.length == 48, \"invalid data length\");\n\n\t\t// decode the function selector from the data field first\n\t\tbytes4 selector; // function selector (4 bytes)\n\t\tassembly(\"memory-safe\") {\n\t\t\t// array offset 0 contains array length data.length\n\t\t\t// bytes array data starts at offset 0x20\n\t\t\t// when reading a bytes4 type, Solidity takes the first 4 bytes of the 32-byte word and ignores the rest\n\t\t\tselector := mload(add(data, 32)) // mload reads from 32 to 64\n\t\t}\n\n\t\t// the data which cannot be derived from the function inputs:\n\t\taddress rewardToken; // the address (20 bytes)\n\t\taddress depositOwner = from; // for deposit() this is `from`\n\t\tuint32 duration; // uint32 (4 bytes)\n\n\t\t// decode ERC-1363 access to deposit() function\n\t\tif(selector == bytes4(keccak256(\"deposit(address,uint32)\"))) {\n\t\t\t// decoding the abi.encodePacked(bytes4(keccak256(\"deposit(address,uint32)\")), rewardToken, duration)\n\t\t\t// bytes example: 0xdd1d708b8464135c8f25da09e49bc8782676a84730c318bc00000002\n\t\t\t// data structure: | bytes4|      address of the reward token      | uint32|\n\t\t\t// offset (bytes): |32 - 36|36                 -                 56|56 - 60|\n\t\t\tassembly(\"memory-safe\") {\n\t\t\t\t// array offset 0 contains array length data.length\n\t\t\t\t// bytes array data starts at offset 0x20\n\t\t\t\t// for an address, Solidity takes the last 20 bytes of the 32-byte word\n\t\t\t\trewardToken := mload(add(data, 24)) // mload reads from 24 to 56\n\t\t\t\t// when reading a uint32 type, Solidity takes the last 4 bytes of the 32-byte word\n\t\t\t\tduration := mload(add(data, 28)) // mload reads from 28 to 60\n\t\t\t}\n\t\t}\n\t\t// decode ERC-1363 access to deposit() function\n\t\telse if(selector == bytes4(keccak256(\"depositTo(address,address,uint32)\"))) {\n\t\t\t// decoding the abi.encodePacked(bytes4(keccak256(\"depositTo(address,address,uint32)\")), rewardToken, depositOwner, duration)\n\t\t\t// bytes example: 0xdd1d708b8464135c8f25da09e49bc8782676a84730c318bcf39fd6e51aad88f6f4ce6ab8827279cfffb9226600000002\n\t\t\t// data structure: | bytes4|      address of the reward token      |     address of the deposit owner      | uint32|\n\t\t\t// offset (bytes): |32 - 36|36                 -                 56|56                 -                 76|76 - 80|\n\t\t\tassembly(\"memory-safe\") {\n\t\t\t\t// array offset 0 contains array length data.length\n\t\t\t\t// bytes array data starts at offset 0x20\n\t\t\t\t// for an address, Solidity takes the last 20 bytes of the 32-byte word\n\t\t\t\trewardToken := mload(add(data, 24)) // mload reads from 24 to 56\n\t\t\t\t// for an address, Solidity takes the last 20 bytes of the 32-byte word\n\t\t\t\tdepositOwner := mload(add(data, 44)) // mload reads from 44 to 76\n\t\t\t\t// when reading a uint32 type, Solidity takes the last 4 bytes of the 32-byte word\n\t\t\t\tduration := mload(add(data, 48)) // mload reads from 48 to 80\n\t\t\t}\n\t\t}\n\t\t// no other ERC-1363 functions are supported\n\t\telse {\n\t\t\t// throw an exception\n\t\t\trevert(\"unknown function\");\n\t\t}\n\n\t\t// msg.sender here is the token smart contract itself, that is `depositToken`\n\t\t// `from`, the address which spends the tokens, is the token supplier `depositSupplier`\n\t\t// the relayer who executed the transaction (named `operator`) is not of a particular interest\n\t\t// usually this will be the same address as `from` (token supplier)\n\t\t// create the deposit using the inputs derived, delegate to `__createDeposit`,\n\t\t// which validates all the inputs internally and throws on any error\n\t\t__createDeposit(from, msg.sender, rewardToken, depositOwner, value.toUint96(), duration);\n\n\t\t// reaching this point always indicates the operation was successful\n\t\treturn bytes4(keccak256(\"onTransferReceived(address,address,uint256,bytes)\"));\n\t}\n\n\t/**\n\t * @notice Loads user account (a.k.a. staker's account) from the storage\n\t *\n\t * @param depositToken address of the deposit token\n\t * @param rewardToken address of the reward token\n\t * @param accountAddress staker's account address\n\t * @return staker's account loaded from the storage into the memory\n\t */\n\tfunction getUserAccount(\n\t\taddress depositToken,\n\t\taddress rewardToken,\n\t\taddress accountAddress\n\t) public view returns(UserAccount memory) {\n\t\t// calculate account mapping key, and return the link to account in the storage\n\t\treturn accounts[__key(depositToken, rewardToken, accountAddress)];\n\t}\n\n\t/**\n\t * @dev Saves user account (a.k.a. staker's account) back into the storage\n\t *\n\t * @param depositToken address of the deposit token\n\t * @param rewardToken address of the reward token\n\t * @param accountAddress staker's account address\n\t * @param account staker's account to be saved from the memory into the storage\n\t */\n\tfunction __saveUserAccount(\n\t\taddress depositToken,\n\t\taddress rewardToken,\n\t\taddress accountAddress,\n\t\tUserAccount memory account\n\t) private {\n\t\t// save the the user's account into the storage\n\t\taccounts[__key(depositToken, rewardToken, accountAddress)] = account;\n\t\t// emit an event\n\t\temit AccountStateUpdated(depositToken, rewardToken, accountAddress, account);\n\t}\n\n\t/**\n\t * @notice Loads staker's deposits array from the storage\n\t *\n\t * @dev The gas cost of the operation grows linearly with the number deposits in the array,\n\t *      thus the function MUST NOT be used in any mutative functions\n\t *\n\t * @param depositToken address of the deposit token\n\t * @param rewardToken address of the reward token\n\t * @param accountAddress staker's account (a.k.a deposit owner) address\n\t * @return an array of deposits for the given account\n\t */\n\tfunction getDepositsArray(\n\t\taddress depositToken,\n\t\taddress rewardToken,\n\t\taddress accountAddress\n\t) public view returns(TimeDeposit[] memory) {\n\t\t// get the link to the deposits array, read its length, and return\n\t\treturn __deposits(depositToken, rewardToken, accountAddress);\n\t}\n\n\t/**\n\t * @notice Gets the total number of deposits (locked, matured, withdrawn)\n\t *\n\t * @dev Use this function to determine maximum possible value to pass as\n\t *      `depositId` to the getTheDeposit() function\n\t *\n\t * @param depositToken address of the deposit token\n\t * @param rewardToken address of the reward token\n\t * @param accountAddress staker's account (a.k.a deposit owner) address\n\t * @return length of the deposits array fo the given staker\n\t */\n\tfunction getDepositsLength(\n\t\taddress depositToken,\n\t\taddress rewardToken,\n\t\taddress accountAddress\n\t) public view returns(uint256) {\n\t\t// get the link to the deposits array, read its length, and return\n\t\treturn __deposits(depositToken, rewardToken, accountAddress).length;\n\t}\n\n\t/**\n\t * @notice Loads staker's deposit from the storage\n\t *\n\t * @param depositToken address of the deposit token\n\t * @param rewardToken address of the reward token\n\t * @param depositOwner staker's account (a.k.a deposit owner) address\n\t * @param depositId ID of the deposit to load from the storage\n\t * @return staker's deposit for the given token pair and deposit ID\n\t */\n\tfunction getDeposit(\n\t\taddress depositToken,\n\t\taddress rewardToken,\n\t\taddress depositOwner,\n\t\tuint256 depositId\n\t) public view returns(TimeDeposit memory) {\n\t\t// save the link to the user's account\n\t\tTimeDeposit[] storage userDeposits = __deposits(depositToken, rewardToken, depositOwner);\n\n\t\t// make sure depositId is valid and throw clear error if not\n\t\trequire(depositId < userDeposits.length, \"doesn't exist\");\n\n\t\t// read from storage and return\n\t\treturn userDeposits[depositId];\n\t}\n\n\t/**\n\t * @notice Loads staker's deposits array from the storage and sums up the deposit amounts\n\t *\n\t * @dev The gas cost of the operation grows linearly with the number deposits in the array,\n\t *      thus the function MUST NOT be used in any mutative functions\n\t *\n\t * @param depositToken address of the deposit token\n\t * @param rewardToken address of the reward token\n\t * @param accountAddress staker's account (a.k.a deposit owner) address\n\t * @return total amount staked, the sum of the deposit amounts\n\t */\n\tfunction sumDepositAmounts(\n\t\taddress depositToken,\n\t\taddress rewardToken,\n\t\taddress accountAddress\n\t) public view returns(uint96) {\n\t\t// load the deposits array from storage into memory\n\t\tTimeDeposit[] memory depositsArray = getDepositsArray(depositToken, rewardToken, accountAddress);\n\t\t// variable to accumulate the result of the sum\n\t\tuint96 sumAccumulator = 0;\n\t\t// iterate the array\n\t\tfor(uint256 i = 0; i < depositsArray.length; i++) {\n\t\t\t// accumulate the deposit amounts\n\t\t\tsumAccumulator += depositsArray[i].amount;\n\t\t}\n\t\t// return the result\n\t\treturn sumAccumulator;\n\t}\n\n\t/**\n\t * @dev Helper function to get the link to the TimeDeposit[] array of the given user\n\t *\n\t * @dev Calculates the `deposits` mapping key and returns the link to the staker's deposits array\n\t *\n\t * @param depositToken address of the deposit token\n\t * @param rewardToken address of the reward token\n\t * @param accountAddress staker's account address\n\t * @return link to the staker's deposits array\n\t */\n\tfunction __deposits(\n\t\taddress depositToken,\n\t\taddress rewardToken,\n\t\taddress accountAddress\n\t) private view returns(TimeDeposit[] storage) {\n\t\t// calculate deposits mapping key, and return the link to deposits array in the storage\n\t\treturn deposits[__key(depositToken, rewardToken, accountAddress)];\n\t}\n\n\t/**\n\t * @notice Estimates the reward amount that a deposit of the specified amount and duration would generate\n\t *      during the next year if staked now, assuming other stakers remain inactive\n\t * \n\t * @param depositToken deposit token address\n\t * @param rewardToken reward token address\n\t * @param depositAmount estimated deposit amount\n\t * @param depositDuration estimated deposit duration\n\t * @return rewardAmount estimated reward amount for the given deposit parameters\n\t */\n\tfunction estimateFutureReward(\n\t\taddress depositToken,\n\t\taddress rewardToken,\n\t\tuint96 depositAmount,\n\t\tuint32 depositDuration\n\t) public view returns(uint96 rewardAmount) {\n\t\t// if deposit amount or deposit duration is zero\n\t\tif(depositAmount == 0 || depositDuration == 0) {\n\t\t\t// no need to calculate anything, reward is zero\n\t\t\treturn 0;\n\t\t}\n\n\t\t// load the deposit settings into the memory\n\t\tDepositSettings memory settings = getDepositSettings(depositToken, rewardToken);\n\n\t\t// current time `t` affects the emission volume\n\t\tuint32 t = now32();\n\n\t\t// create the deposit data structure in memory\n\t\tTimeDeposit memory userDeposit = settings.newDeposit(depositAmount, depositDuration, t);\n\n\t\t// calculate the expected deposit weight `w`\n\t\tint128 depositWeight = userDeposit.weight();\n\n\t\t// if deposit weight `w` is zero\n\t\tif(depositWeight == 0) {\n\t\t\t// no need for further calculation, reward is zero\n\t\t\treturn 0;\n\t\t}\n\n\t\t// read the current total deposited weight `W` to calculate the deposit share `s` in the pool:\n\t\t//                                 `s = w / (w + W)`\n\t\tuint128 totalWeight = getState(depositToken, rewardToken).totalWeightStaked;\n\n\t\t// get the cumulative reward token emission `e` during the deposit duration period\n\t\tuint256 emission = getEmissionSchedule(depositToken, rewardToken).emissionVolumeDelta(t, t + 365 days);\n\n\t\t// apply the share `s` to the cumulative emission amount `e` to get the reward estimate `r`:\n\t\t//                            `r = e * s = e * w / (w + W)`\n\t\treturn (emission * uint128(depositWeight) / (uint128(depositWeight) + totalWeight)).toUint96();\n\t}\n\n\t/**\n\t * @notice Pending reward is a reward available for claiming now, this is a difference\n\t *      of the total calculated reward and total claimed reward\n\t *\n\t * @param depositToken address of the deposit token\n\t * @param rewardToken address of the reward token\n\t * @param accountAddress staker's account address\n\t * @return pendingReward reward available for claiming now\n\t */\n\tfunction getPendingReward(\n\t\taddress depositToken,\n\t\taddress rewardToken,\n\t\taddress accountAddress\n\t) external view returns(uint96) {\n\t\t// calculate and cache the mapping key\n\t\tbytes32 key = __key(depositToken, rewardToken);\n\n\t\t// to efficiently access the reward calculation state, read it first into the memory\n\t\tRewardCalculationState memory rcs = rewardCalculationStates[key];\n\n\t\t// to efficiently read the fields on the user's account, load account into the memory\n\t\tUserAccount memory account = getUserAccount(depositToken, rewardToken, accountAddress);\n\n\t\t// if staking contract is not empty (there is at least one active deposit)\n\t\tif(rcs.totalWeightStaked > 0 && rcs.lastUpdateTime < now32()) {\n\t\t\t// get the reward amount for the time passed since last update\n\t\t\tuint256 amount = __getEmissionSchedule(key).emissionVolumeDelta(rcs.lastUpdateTime, now32());\n\t\t\t// calculate the `rewardPerWeightStored` {sum from 0 to n - 1 of Ri/Ti} at timestamp `n`\n\t\t\trcs.rewardPerWeightStored += __div(amount.toUint96(), rcs.totalWeightStaked);\n\t\t}\n\n\t\t// update `accumulatedReward` staker accumulated reward between timestamps `k` and `n`\n\t\taccount.accumulatedReward += __mul(account.weight, rcs.rewardPerWeightStored - account.rewardPerWeightPaid);\n\n\t\t// calculate pending reward as the difference between accumulated and claimed/paid\n\t\treturn account.accumulatedReward - account.claimedReward;\n\t}\n\n\t/**\n\t * @notice Claims pending reward if any; throws if there is no reward available\n\t *\n\t * @param depositToken address of the deposit token\n\t * @param rewardToken address of the reward token\n\t */\n\tfunction claimReward(address depositToken, address rewardToken) public virtual {\n\t\t// delegate to `claimRewardTo`\n\t\tclaimRewardTo(msg.sender, depositToken, rewardToken);\n\t}\n\n\t/**\n\t * @notice Claims pending reward if any and sends it to the specified address `to`,\n\t *      throwing if there is no reward available\n\t *\n\t * @param to an address to send claimed reward to\n\t * @param depositToken address of the deposit token\n\t * @param rewardToken address of the reward token\n\t */\n\tfunction claimRewardTo(address to, address depositToken, address rewardToken) public virtual {\n\t\t// verify reward claiming is active\n\t\trequire(_isFeatureEnabled(FEATURE_REWARD_CLAIMING_ENABLED), \"reward claiming disabled\");\n\n\t\t// delegate to `__claim`\n\t\t__claim(to, depositToken, rewardToken, msg.sender);\n\t}\n\n\t/**\n\t * @notice Claims the reward on behalf of `req.account`  and sends it to\n\t *      the specified address `req.to`, throwing if there is no reward available\n\t *\n\t * @notice Requires the staker `req.account` to sign the request structure relayed to this function\n\t *\n\t * @dev Requires valid EIP712 staker's signature:\n\t *     - `validAfter` to be a timestamp in the past\n\t *     - `validBefore` to be a timestamp in the future\n\t *     - `v`, `r` and `s` to be a valid `secp256k1` signature by the `account`\n\t *        over the EIP712-formatted function arguments.\n\t *     - the signature to use `account` current nonce (see `getNonce()`).\n\t *\n\t * @param req reward claiming request, signed by the staker `req.account`\n\t * @param sig ECDSA signature for the reward claiming request\n\t */\n\tfunction claimRewardWithAuth(RewardClaimRequest calldata req, Signature calldata sig) public virtual {\n\t\t// verify reward claiming with auth is enabled\n\t\trequire(_isFeatureEnabled(FEATURE_EIP712_CLAIMING_ENABLED), \"EIP712 claiming disabled\");\n\n\t\t// verify the request\n\t\t_requireAccessCondition(__deriveSigner(req, sig) == req.account);\n\t\trequire(now32() > req.validAfter, \"signature not yet valid\");\n\t\trequire(now32() < req.validBefore, \"signature expired\");\n\n\t\t// execute the claim and verify the nonce according to how it is stored on signer's account\n\t\trequire(__claim(req.to, req.depositToken, req.rewardToken, req.account) == req.nonce, \"invalid nonce\");\n\t}\n\n\t/**\n\t * @dev Releases the `rewardToken` token from the staker's account `account` to the address `to`\n\t *      using the emission schedule configured for the (depositToken, rewardToken) token pair\n\t *\n\t * @dev Unsafe. Doesn't verify the access permissions. Must be kept private at all times.\n\t *\n\t * @param to an address to send released tokens to\n\t * @param depositToken address of the deposit token\n\t * @param rewardToken address of the reward token\n\t * @param account staker's account address to claim the reward from\n\t * @return account's nonce (can be used for EIP712 signature verification)\n\t */\n\tfunction __claim(address to, address depositToken, address rewardToken, address account) private returns(uint256) {\n\t\t// update staking contract state: fast forward the time to now, calculate the reward available for claiming\n\t\t(uint96 toClaim, uint256 nonce) = __updateStateOnClaim(depositToken, rewardToken, account, type(uint96).max);\n\n\t\t// verify there is something to claim\n\t\trequire(toClaim > 0, \"nothing to claim\");\n\n\t\t// then release the required reward\n\t\tgetEmissionSchedule(depositToken, rewardToken).release(to, toClaim);\n\n\t\t// emit an event\n\t\temit RewardClaimed(to, depositToken, rewardToken, account, toClaim);\n\n\t\t// return the nonce, it may be used for EIP712 verification\n\t\treturn nonce;\n\t}\n\n\t/**\n\t * @dev Auxiliary function to verify structured EIP712 message signature and derive its signer\n\t *\n\t * @dev Recovers the non-zero signer address from the signed message throwing on failure\n\t *\n\t * @param req reward claim request, signed by the staker\n\t * @param sig ECDSA signature of the request\n\t * @return recovered non-zero signer address, unless throwing\n\t */\n\tfunction __deriveSigner(RewardClaimRequest calldata req, Signature calldata sig) internal view returns(address) {\n\t\t// build the EIP-712 hashStruct of the message\n\t\tbytes32 hashStruct = keccak256(abi.encode(\n\t\t\tREWARD_CLAIM_REQUEST_TYPEHASH,\n\t\t\treq.to,\n\t\t\treq.depositToken,\n\t\t\treq.rewardToken,\n\t\t\treq.account,\n\t\t\treq.validAfter,\n\t\t\treq.validBefore,\n\t\t\treq.nonce\n\t\t));\n\n\t\t// derive the signer of the EIP712 message\n\t\treturn __deriveSigner(hashStruct, sig);\n\t}\n\n\t/**\n\t * @dev Implementation of the core reward calculation formula\n\t *      r(u,k,n) = S * ({sum from 0 to n - 1 of Ri/Ti} - {sum from 0 to k - 1 of Ri/Ti})\n\t *\n\t * @dev Multiplies  reward per weight => reward amount\n\t *\n\t * @param weight `S` of some staker `u`\n\t * @param rewardPerWeight {sum from 0 to n - 1 of Ri/Ti} - {sum from 0 to k - 1 of Ri/Ti}\n\t * @return rewardAmount r(u,k,n)\n\t */\n\tfunction __mul(uint128 weight, uint224 rewardPerWeight) private pure returns(uint96 rewardAmount) {\n\t\t// apply `r(u,k,n) = S * ({sum from 0 to n - 1 of Ri/Ti} - {sum from 0 to k - 1 of Ri/Ti})`\n\t\t// max weight is 2^128, but when the weight is max the rewardPerWeight is min (1)\n\t\t// max rewardPerWeight is 2^224, but when rewardPerWeight is max, thw weight is min (1)\n\t\t// hence max `weight * rewardPerWeight` is 2^224, or 2^96 after 128 bits shift right\n\t\treturn (uint256(weight) * rewardPerWeight >> 128).toUint96();\n\t}\n\n\t/**\n\t * @dev Implementation of the right part of the core reward calculation formula\n\t *      r(u,k,n) = S * ({sum from 0 to n - 1 of Ri/Ti} - {sum from 0 to k - 1 of Ri/Ti})\n\t *\n\t * @dev Divides reward amount by weight, calculating the reward per weight;\n\t *      The result is multiplier by the 1e38 constant, also used in the `__mul()` function\n\t *\n\t * @param rewardAmount amount of the reward available for distribution `Ri`\n\t * @param weight total weight of all the staked tokens `Ti`\n\t * @return rewardPerWeight `Ri/Ti` how much of the reward is there per one unit of weight;\n\t *      this value is only used to be fed into `__mul()` function\n\t */\n\tfunction __div(uint96 rewardAmount, uint128 weight) private pure returns(uint224 rewardPerWeight) {\n\t\t// min rewardAmount is 1, max weight is 2^128, hence 128 bits shift left\n\t\t// max rewardAmount is 2^96, min weight is 1, hence max rewardPerWeight is 2^224\n\t\treturn (uint224(rewardAmount) << 128) / weight;\n\t}\n\n\t/// @dev Shortcut to `keccak256(abi.encodePacked(depositToken, rewardToken))` mapping key\n\tfunction __key(address depositToken, address rewardToken) private pure returns(bytes32) {\n\t\treturn keccak256(abi.encodePacked(depositToken, rewardToken));\n\t}\n\n\t/// @dev Shortcut to `keccak256(abi.encodePacked(depositToken, rewardToken, accountAddress))` mapping key\n\tfunction __key(address depositToken, address rewardToken, address accountAddress) private pure returns(bytes32) {\n\t\treturn keccak256(abi.encodePacked(depositToken, rewardToken, accountAddress));\n\t}\n\n\t/**\n\t * @dev Deposit settings getter for the (deposit, reward) token pair.\n\t *\n\t * @dev Deposit settings define how the deposit weights are calculated, what deposit durations (lock-up periods)\n\t *      are allowed, and what emission schedule is used to release the reward token.\n\t *\n\t * @dev Throws if deposit settings are not set for the (deposit, reward) token pair.\n\t *\n\t * @param depositToken address of the deposit token\n\t * @param rewardToken address of the reward token\n\t * @return deposit settings as a DepositSettings data structure\n\t */\n\tfunction getDepositSettings(address depositToken, address rewardToken) public view returns(DepositSettings memory) {\n\t\t// read from the storage\n\t\tDepositSettings memory settings = depositSettings[__key(depositToken, rewardToken)];\n\n\t\t// verify the settings read indeed exist and we're not just reading an empty storage\n\t\trequire(address(settings.rewardEmissionSchedule) != address(0), \"unknown token pair\");\n\n\t\t// return the result\n\t\treturn settings;\n\t}\n\n\t/**\n\t * @dev Reward emission schedule getter for the (deposit, reward) token pair.\n\t *\n\t * @dev Throws if emission schedule is not set for the (deposit, reward) token pair.\n\t *\n\t * @param depositToken address of the deposit token\n\t * @param rewardToken address of the reward token\n\t * @return reward emission schedule used to release the reward token\n\t */\n\tfunction getEmissionSchedule(address depositToken, address rewardToken) public view returns(EmissionSchedule) {\n\t\t// load the emission schedule from storage\n\t\tEmissionSchedule rewardEmissionSchedule = __getEmissionSchedule(__key(depositToken, rewardToken));\n\n\t\t// verify the emission schedule read indeed exists and we're not just reading an empty storage\n\t\trequire(address(rewardEmissionSchedule) != address(0), \"unknown token pair\");\n\n\t\t// return the result\n\t\treturn rewardEmissionSchedule;\n\t}\n\n\t/**\n\t * @dev Loads emission schedule from the storage for the (deposit, reward) token pair, returning\n\t *      zero if emission schedule is not set for the (deposit, reward) token pair.\n\t *\n\t * @param key `__key(depositToken, rewardToken)`\n\t * @return emission schedule instance, or zero\n\t */\n\tfunction __getEmissionSchedule(bytes32 key) private view returns(EmissionSchedule) {\n\t\t// load from the storage and return as is\n\t\treturn depositSettings[key].rewardEmissionSchedule;\n\t}\n\n\t/**\n\t * @notice Restricted access function to delete the deposit settings and reward emission schedule for\n\t *      the (deposit, reward) token pair, previously created with `updateDepositSettings()` or during deployment\n\t *\n\t * @dev Deleting the deposit settings for the (deposit, reward) pair doesn't update the already\n\t *      created deposits which used these settings\n\t *\n\t * ╔═══════════════════════════════════════════════════════════════════════════════════════════════╗\n\t * ║                                            WARNING                                            ║\n\t * ╠═══════════════════════════════════════════════════════════════════════════════════════════════╣\n\t * ║  Deleting the reward emission schedule breaks the reward calculation for existing deposits.   ║\n\t * ║  After deleting, the reward gets lost on each user interaction (deposit, withdraw, claim).    ║\n\t * ╚═══════════════════════════════════════════════════════════════════════════════════════════════╝\n\t *\n\t * @param depositToken address of the deposit token\n\t * @param rewardToken address of the reward token\n\t */\n\tfunction deleteDepositSettings(address depositToken, address rewardToken) public {\n\t\t// verify the access permission\n\t\t_requireSenderInRole(ROLE_DEPOSIT_SETTINGS_MANAGER);\n\n\t\t// delete deposit settings with reward emission schedule\n\t\tdelete depositSettings[__key(depositToken, rewardToken)];\n\n\t\t// emit an event\n\t\temit DepositSettingsDeleted(depositToken, rewardToken);\n\t}\n\n\t/**\n\t * @notice Restricted access function to update the deposit settings for the (deposit, reward) token pair,\n\t *      which are used to create the deposits and calculate the staking reward\n\t *\n\t * @dev Updating the deposit settings for the (deposit, reward) pair doesn't affect the settings of\n\t *      the already created deposits which used these settings,\n\t *      BUT updates of the reward emission schedule affects the reward calculation logic and reward\n\t *      emission, and may potentially break it.\n\t *\n\t * ╔═══════════════════════════════════════════════════════════════════════════════════════════════╗\n\t * ║                                          WARNING(s)                                           ║\n\t * ╠═══════════════════════════════════════════════════════════════════════════════════════════════╣\n\t * ║  Do not add tokens whose smart contract code you didn't audit and which you don't trust.      ║\n\t * ║  Malicious ERC20 smart contract code can affect the deposit/withdraw functions                ║\n\t * ║  and reward calculations.                                                                     ║\n\t * ╠═══════════════════════════════════════════════════════════════════════════════════════════════╣\n\t * ║  Updating the reward emission schedule affects the reward calculation logic                   ║\n\t * ║  and reward emission, and MAY potentially break both. Use with care!                          ║\n\t * ╚═══════════════════════════════════════════════════════════════════════════════════════════════╝\n\t *\n\t * @param depositToken address of the deposit token\n\t * @param rewardToken address of the reward token\n\t * @param settings new deposit settings to set for the (deposit, reward) token pair\n\t */\n\tfunction updateDepositSettings(\n\t\taddress depositToken,\n\t\taddress rewardToken,\n\t\tDepositSettings calldata settings\n\t) public {\n\t\t// verify the access permission\n\t\t_requireSenderInRole(ROLE_DEPOSIT_SETTINGS_MANAGER);\n\n\t\t// delegate to unsafe `__updateDepositSettings`\n\t\t__updateDepositSettings(depositToken, rewardToken, settings);\n\t}\n\n\t/**\n\t * @dev Updates deposit settings for the (deposit, reward) token pair.\n\t *      Unsafe. Doesn't verify the access permissions. Must be kept private at all times.\n\t *\n\t * @param depositToken address of the deposit token\n\t * @param rewardToken address of the reward token\n\t * @param settings new deposit settings to set for the (deposit, reward) token pair\n\t */\n\tfunction __updateDepositSettings(\n\t\taddress depositToken,\n\t\taddress rewardToken,\n\t\tDepositSettings memory settings\n\t) private {\n\t\t// verify the inputs are set\n\t\trequire(\n\t\t\tdepositToken != address(0) && rewardToken != address(0) && address(settings.rewardEmissionSchedule) != address(0),\n\t\t\t\"zero address\"\n\t\t);\n\n\t\t// verify deposit settings are correct\n\t\trequire(settings.minDepositDuration <= settings.maxDepositDuration, \"min > max duration\");\n\t\trequire(settings.minDurationMultiplier <= settings.maxDurationMultiplier, \"min > max multiplier\");\n\t\trequire(\n\t\t\tuint64(settings.maxDepositDuration) * settings.maxDurationMultiplier <= type(uint32).max,\n\t\t\t\"max duration x multiplier overflow\"\n\t\t);\n\n\t\t// verify the emission token consistency\n\t\trequire(settings.rewardEmissionSchedule.emissionToken() == rewardToken, \"unexpected emission token\");\n\n\t\t// calculate and cache the mapping key\n\t\tbytes32 key = __key(depositToken, rewardToken);\n\n\t\t// update deposit settings\n\t\tdepositSettings[key] = settings;\n\n\t\t// emit an event\n\t\temit DepositSettingsUpdated(depositToken, rewardToken, settings);\n\t}\n\n\t/**\n\t * @dev Testing time-dependent functionality may be difficult;\n\t *      we override time in the helper test smart contract (mock)\n\t *\n\t * @return `block.timestamp` in mainnet, custom values in testnets (if overridden)\n\t */\n\tfunction now32() public view virtual returns(uint32) {\n\t\t// return current block timestamp\n\t\treturn uint32(block.timestamp);\n\t}\n}\n"
    },
    "contracts/utils/EIP712Support.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@lazy-sol/advanced-erc20/contracts/lib/ECDSA.sol\";\n\n/**\n * @title EIP-712 Support\n *\n * @notice Enables very basic EIP-712 support, helps improving code reuse\n *\n * @author Lizard Labs Core Contributors\n */\nabstract contract EIP712Support {\n\t/// @dev ECDSA signature\n\tstruct Signature {\n\t\t/// @dev v the recovery byte of the signature\n\t\tuint8 v;\n\t\t/// @dev r half of the ECDSA signature pair\n\t\tbytes32 r;\n\t\t/// @dev half of the ECDSA signature pair\n\t\tbytes32 s;\n\t}\n\n\t/**\n\t * @notice EIP-712 contract's domain typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t *\n\t * @dev Note: we do not include version into the domain typehash/separator,\n\t *      it is implied version is concatenated to the name field, like \"TokenRewardDistributorV1\"\n\t */\n\t// keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\")\n\tbytes32 public constant DOMAIN_TYPEHASH = 0x8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a866;\n\n\t/**\n\t * @notice EIP-712 contract domain name and version concatenated, ex.: MyContractV2\n\t *      see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\n\t *      note: we specify contract version in its name\n\t */\n\tfunction DOMAIN_NAME() public pure virtual returns(string memory);\n\n\t/**\n\t * @notice EIP-712 contract domain separator,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\n\t *      note: we specify contract version in its name\n\t */\n\tfunction DOMAIN_SEPARATOR() public view returns(bytes32) {\n\t\t// build the EIP-712 contract domain separator, see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\n\t\t// note: we specify contract version in its name\n\t\treturn keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(DOMAIN_NAME())), block.chainid, address(this)));\n\t}\n\n\t/**\n\t * @dev Auxiliary function to verify structured EIP712 message signature and derive its signer\n\t *\n\t * @dev Recovers the non-zero signer address from the signed message throwing on failure\n\t *\n\t * @param hashStruct EIP-712 hashStruct of the message\n\t * @param sig ECDSA signature of the message\n\t * @return recovered non-zero signer address, unless throwing\n\t */\n\tfunction __deriveSigner(bytes32 hashStruct, Signature calldata sig) internal view returns(address) {\n\t\t// calculate the EIP-712 digest \"\\x19\\x01\" ‖ domainSeparator ‖ hashStruct(message)\n\t\tbytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR(), hashStruct));\n\n\t\t// recover the address which signed the message with v, r, s\n\t\taddress signer = ECDSA.recover(digest, sig.v, sig.r, sig.s);\n\n\t\t// return the signer address derived from the signature\n\t\treturn signer;\n\t}\n}\n"
    }
  }
}}