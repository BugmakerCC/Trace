{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "london",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 10
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/access/access_control/AccessControlStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { EnumerableSet } from '../../data/EnumerableSet.sol';\n\nlibrary AccessControlStorage {\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    struct Layout {\n        mapping(bytes32 => RoleData) roles;\n    }\n\n    bytes32 internal constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.AccessControl');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/access/access_control/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IAccessControlInternal } from './IAccessControlInternal.sol';\n\n/**\n * @title AccessControl interface\n */\ninterface IAccessControl is IAccessControlInternal {\n    /*\n     * @notice query whether role is assigned to account\n     * @param role role to query\n     * @param account account to query\n     * @return whether role is assigned to account\n     */\n    function hasRole(\n        bytes32 role,\n        address account\n    ) external view returns (bool);\n\n    /*\n     * @notice query admin role for given role\n     * @param role role to query\n     * @return admin role\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /*\n     * @notice assign role to given account\n     * @param role role to assign\n     * @param account recipient of role assignment\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /*\n     * @notice unassign role from given account\n     * @param role role to unassign\n     * @parm account\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @notice relinquish role\n     * @param role role to relinquish\n     */\n    function renounceRole(bytes32 role) external;\n\n    /**\n     * @notice Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(\n        bytes32 role,\n        uint256 index\n    ) external view returns (address);\n\n    /**\n     * @notice Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@solidstate/contracts/access/access_control/IAccessControlInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Partial AccessControl interface needed by internal functions\n */\ninterface IAccessControlInternal {\n    event RoleAdminChanged(\n        bytes32 indexed role,\n        bytes32 indexed previousAdminRole,\n        bytes32 indexed newAdminRole\n    );\n\n    event RoleGranted(\n        bytes32 indexed role,\n        address indexed account,\n        address indexed sender\n    );\n\n    event RoleRevoked(\n        bytes32 indexed role,\n        address indexed account,\n        address indexed sender\n    );\n}\n"
    },
    "@solidstate/contracts/data/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Set implementation with enumeration functions\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nlibrary EnumerableSet {\n    error EnumerableSet__IndexOutOfBounds();\n\n    struct Set {\n        bytes32[] _values;\n        // 1-indexed to allow 0 to signify nonexistence\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    function at(\n        Bytes32Set storage set,\n        uint256 index\n    ) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    function at(\n        AddressSet storage set,\n        uint256 index\n    ) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    function at(\n        UintSet storage set,\n        uint256 index\n    ) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    function contains(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    function contains(\n        AddressSet storage set,\n        address value\n    ) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function contains(\n        UintSet storage set,\n        uint256 value\n    ) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    function indexOf(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, value);\n    }\n\n    function indexOf(\n        AddressSet storage set,\n        address value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function indexOf(\n        UintSet storage set,\n        uint256 value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, bytes32(value));\n    }\n\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function add(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    function add(\n        AddressSet storage set,\n        address value\n    ) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    function remove(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    function remove(\n        AddressSet storage set,\n        address value\n    ) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function remove(\n        UintSet storage set,\n        uint256 value\n    ) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    function toArray(\n        Bytes32Set storage set\n    ) internal view returns (bytes32[] memory) {\n        return set._inner._values;\n    }\n\n    function toArray(\n        AddressSet storage set\n    ) internal view returns (address[] memory) {\n        bytes32[] storage values = set._inner._values;\n        address[] storage array;\n\n        assembly {\n            array.slot := values.slot\n        }\n\n        return array;\n    }\n\n    function toArray(\n        UintSet storage set\n    ) internal view returns (uint256[] memory) {\n        bytes32[] storage values = set._inner._values;\n        uint256[] storage array;\n\n        assembly {\n            array.slot := values.slot\n        }\n\n        return array;\n    }\n\n    function _at(\n        Set storage set,\n        uint256 index\n    ) private view returns (bytes32) {\n        if (index >= set._values.length)\n            revert EnumerableSet__IndexOutOfBounds();\n        return set._values[index];\n    }\n\n    function _contains(\n        Set storage set,\n        bytes32 value\n    ) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    function _indexOf(\n        Set storage set,\n        bytes32 value\n    ) private view returns (uint256) {\n        unchecked {\n            return set._indexes[value] - 1;\n        }\n    }\n\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    function _add(\n        Set storage set,\n        bytes32 value\n    ) private returns (bool status) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            set._indexes[value] = set._values.length;\n            status = true;\n        }\n    }\n\n    function _remove(\n        Set storage set,\n        bytes32 value\n    ) private returns (bool status) {\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            unchecked {\n                bytes32 last = set._values[set._values.length - 1];\n\n                // move last value to now-vacant index\n\n                set._values[valueIndex - 1] = last;\n                set._indexes[last] = valueIndex;\n            }\n            // clear last index\n\n            set._values.pop();\n            delete set._indexes[value];\n\n            status = true;\n        }\n    }\n}\n"
    },
    "contracts/common/admin/interfaces/ICrossPaymentModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { IPaymentModule } from \"./IPaymentModule.sol\";\n\ninterface ICrossPaymentModule {\n    struct CrossPaymentSignatureInput {\n        address payer;\n        uint256 sourceChainId;\n        uint256 paymentIndex;\n        bytes signature;\n    }\n\n    struct ProcessCrossPaymentOutput {\n        bytes32 platformId;\n        uint32[] services;\n        uint32[] serviceAmounts;\n        address spender;\n        uint256 destinationChainId;\n        address payer;\n        uint256 sourceChainId;\n        uint256 paymentIndex;\n    }\n\n    function updateCrossPaymentSignerAddress(address newSignerAddress) external;\n    function processCrossPayment(\n        IPaymentModule.ProcessPaymentInput memory paymentInput,\n        address spender,\n        uint256 destinationChainId\n    ) external payable returns (uint256);\n    function processCrossPaymentForDelegator(\n        IPaymentModule.ProcessPaymentInput memory paymentInput,\n        address delegator,\n        uint256 destinationChainId,\n        uint256 gasFee,\n        bytes memory signature\n    ) external payable returns (uint256);\n    function processCrossPaymentBuyTokenForDelegator(\n        IPaymentModule.ProcessPaymentInput memory paymentInput,\n        address delegator,\n        uint256 gasFee,\n        bytes memory signature\n    ) external payable returns (uint256);\n    function spendCrossPaymentSignature(address spender, ProcessCrossPaymentOutput memory output, bytes memory signature) external;\n    function getCrossPaymentSignerAddress() external view returns (address);\n    function getCrossPaymentOutputByIndex(uint256 paymentIndex) external view returns (ProcessCrossPaymentOutput memory);\n    function prefixedMessage(bytes32 hash) external pure returns (bytes32);\n    function getHashedMessage(ProcessCrossPaymentOutput memory output) external pure returns (bytes32);\n    function recoverSigner(bytes32 message, bytes memory signature) external pure returns (address);\n    function checkSignature(ProcessCrossPaymentOutput memory output, bytes memory signature) external view;\n    function getDelegatorHashedMessage(address delegator, uint256 destinationChainId, uint256 gasFee) external pure returns (bytes32);\n    function checkDelegatorSignature(address delegator, uint256 destinationChainId, uint256 gasFee, bytes memory signature) external pure;\n    function getDelegatorBuyTokenHashedMessage(\n        address delegator,\n        address destinationAddress,\n        uint32 destinationChainId,\n        uint256 gasFee\n    ) external pure returns (bytes32);\n    function checkDelegatorBuyTokenSignature(\n        address delegator,\n        address destinationAddress,\n        uint32 destinationChainId,\n        uint256 gasFee,\n        bytes memory signature\n    ) external pure;\n    function getChainID() external view returns (uint256);\n\n    /** EVENTS */\n    event CrossPaymentProcessed(uint256 indexed previousBlock, uint256 indexed paymentIndex);\n    event CrossPaymentSignatureSpent(uint256 indexed previousBlock, uint256 indexed sourceChainId, uint256 indexed paymentIndex);\n    event CrossPaymentSignerAddressUpdated(address indexed oldSigner, address indexed newSigner);\n    event CrossPaymentProcessedBuyToken(\n        uint256 indexed paymentIndex,\n        address delegator,\n        uint256 indexed destinationChainId,\n        address indexed destinationAddress\n    );\n\n    /** ERRORS */\n    error ProcessCrossPaymentError(string errorMessage);\n    error CheckSignatureError(string errorMessage);\n    error ProcessCrossPaymentSignatureError(string errorMessage);\n}\n"
    },
    "contracts/common/admin/interfaces/IPaymentModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\ninterface IPaymentModule {\n    enum PaymentMethod {\n        NATIVE,\n        USD,\n        ALTCOIN\n    }\n\n    enum PaymentType {\n        NATIVE,\n        GIFT,\n        CROSSCHAIN\n    }\n\n    struct AcceptedToken {\n        string name;\n        PaymentMethod tokenType;\n        address token;\n        address router;\n        bool isV2Router;\n        uint256 slippageTolerance;\n    }\n\n    struct ProcessPaymentInput {\n        bytes32 platformId;\n        uint32[] services;\n        uint32[] serviceAmounts;\n        address referrer;\n        address user;\n        address tokenAddress;\n    }\n\n    struct ProcessPaymentOutput {\n        ProcessPaymentInput processPaymentInput;\n        uint256 usdPrice;\n        uint256 paymentAmount;\n        uint256 burnedAmount;\n        uint256 treasuryShare;\n        uint256 referrerShare;\n    }\n\n    struct ProcessCrossPaymentOutput {\n        bytes32 platformId;\n        uint32[] services;\n        uint32[] serviceAmounts;\n        address payer;\n        address spender;\n        uint256 sourceChainId;\n        uint256 destinationChainId;\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function PAYMENT_PROCESSOR_ROLE() external pure returns (bytes32);\n    function adminWithdraw(address tokenAddress, uint256 amount, address treasury) external;\n    function setUsdToken(address newUsdToken) external;\n    function setRouterAddress(address newRouter, bool _isV2Router) external;\n    function addAcceptedToken(AcceptedToken memory acceptedToken) external;\n    function removeAcceptedToken(address tokenAddress) external;\n    function updateAcceptedToken(AcceptedToken memory acceptedToken) external;\n    function setV3PoolFeeForTokenNative(address token, uint24 poolFee) external;\n    function getUsdToken() external view returns (address);\n    function processPayment(ProcessPaymentInput memory params) external payable returns (uint256);\n    function getPaymentByIndex(uint256 paymentIndex) external view returns (ProcessPaymentOutput memory);\n    function getQuoteTokenPrice(address token0, address token1) external view returns (uint256 price);\n    function getV3PoolFeeForTokenWithNative(address token) external view returns (uint24);\n    function isV2Router() external view returns (bool);\n    function getRouterAddress() external view returns (address);\n    function getAcceptedTokenByAddress(address tokenAddress) external view returns (AcceptedToken memory);\n    function getAcceptedTokens() external view returns (address[] memory);\n\n    /** EVENTS */\n    event TokenBurned(uint256 indexed tokenBurnedLastBlock, address indexed tokenAddress, uint256 amount);\n    event PaymentProcessed(uint256 indexed previousBlock, uint256 indexed paymentIndex);\n    event TreasuryAddressUpdated(address indexed oldTreasury, address indexed newTreasury);\n\n    /** ERRORS */\n    error ProcessPaymentError(string errorMessage);\n}\n"
    },
    "contracts/common/diamonds/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n    enum FacetCutAction {\n        Add,\n        Replace,\n        Remove\n    }\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external;\n}\n"
    },
    "contracts/common/diamonds/interfaces/IDiamondCutWithApproval.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { IDiamondCut } from \"./IDiamondCut.sol\";\n\ninterface IDiamondCutWithApproval is IDiamondCut {\n    function contractOwner() external view returns (address);\n\n    function setContractOwner(address _newContractOwner) external;\n}\n"
    },
    "contracts/common/diamonds/interfaces/IDiamondProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondProxy {\n    function implementation() external view returns (address);\n\n    function setImplementation(address _implementation) external;\n}\n"
    },
    "contracts/launchpad/facets/LaunchPadFactoryAdminFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { AccessControlStorage } from \"@solidstate/contracts/access/access_control/AccessControlStorage.sol\";\nimport { IAccessControl } from \"@solidstate/contracts/access/access_control/IAccessControl.sol\";\nimport { IERC20, IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ILaunchPadCommon } from \"../interfaces/ILaunchPadCommon.sol\";\nimport { ILaunchPadFactoryAdmin } from \"../interfaces/ILaunchPadFactoryAdmin.sol\";\nimport { ILaunchPadProject } from \"../interfaces/ILaunchPadProject.sol\";\nimport { ILaunchPadProjectAdmin } from \"../interfaces/ILaunchPadProjectAdmin.sol\";\nimport { LibLaunchPadFactoryStorage } from \"../libraries/LibLaunchPadFactoryStorage.sol\";\nimport { LibLaunchPadProjectStorage } from \"../libraries/LibLaunchPadProjectStorage.sol\";\nimport { IDiamondCutWithApproval, IDiamondCut } from \"../../common/diamonds/interfaces/IDiamondCutWithApproval.sol\";\nimport { ITokenLauncherFactory } from \"../../token-launcher/interfaces/ITokenLauncherFactory.sol\";\nimport { ITokenLauncherLiquidityPoolFactory } from \"../../token-launcher/interfaces/ITokenLauncherLiquidityPoolFactory.sol\";\nimport { ITokenFiErc20 } from \"../../token-launcher/interfaces/ITokenFiErc20.sol\";\nimport { IDiamondProxy } from \"../../common/diamonds/interfaces/IDiamondProxy.sol\";\n\ncontract LaunchPadFactoryAdminFacet is ILaunchPadFactoryAdmin {\n    using SafeERC20 for IERC20;\n\n    function removeLaunchpad(address launchpad) external override onlyAdmin {\n        LibLaunchPadFactoryStorage.DiamondStorage storage ds = LibLaunchPadFactoryStorage.diamondStorage();\n        require(ds.isLaunchPad[launchpad], \"LaunchPadFactory: LaunchPad does not exist\");\n        address owner = ds.launchPadOwner[launchpad];\n        // remove launchpad from owner\n        for (uint256 i = 0; i < ds.launchPadsByOwner[owner].length; i++) {\n            if (ds.launchPadsByOwner[owner][i] == launchpad) {\n                ds.launchPadsByOwner[owner][i] = ds.launchPadsByOwner[owner][ds.launchPadsByOwner[owner].length - 1];\n                ds.launchPadsByOwner[owner].pop();\n                break;\n            }\n        }\n        address[] memory investors = ILaunchPadProject(launchpad).getAllInvestors();\n        // remove launchpad from investors\n        for (uint256 i = 0; i < investors.length; i++) {\n            for (uint256 j = 0; j < ds.launchPadsByInvestor[investors[i]].length; j++) {\n                if (ds.launchPadsByInvestor[investors[i]][j] == launchpad) {\n                    ds.launchPadsByInvestor[investors[i]][j] = ds.launchPadsByInvestor[investors[i]][ds.launchPadsByInvestor[investors[i]].length - 1];\n                    ds.launchPadsByInvestor[investors[i]].pop();\n                    break;\n                }\n            }\n        }\n        // remove launchpad\n        for (uint256 i = 0; i < ds.launchPads.length; i++) {\n            if (ds.launchPads[i] == launchpad) {\n                ds.launchPads[i] = ds.launchPads[ds.launchPads.length - 1];\n                ds.launchPads.pop();\n                break;\n            }\n        }\n        ds.launchPadOwner[launchpad] = address(0);\n        ds.isLaunchPad[launchpad] = false;\n        emit LibLaunchPadFactoryStorage.LaunchpadRemoved(launchpad, owner);\n    }\n\n    function upgradeLaunchPadProjectFacets(\n        address launchPad,\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) external onlyAdmin {\n        IDiamondCut(launchPad).diamondCut(_diamondCut, _init, _calldata);\n    }\n\n    function transferLaunchpadDiamondOwnership(address launchPad, address newOwner) external override onlyAdmin {\n        require(newOwner != address(0), \"LaunchPadFactory: New owner cannot be 0\");\n        IDiamondCutWithApproval(launchPad).setContractOwner(newOwner);\n    }\n\n    function updateMaxTokenCreationDeadline(uint256 newMaxTokenCreationDeadline) external override onlyAdmin {\n        LibLaunchPadFactoryStorage.DiamondStorage storage ds = LibLaunchPadFactoryStorage.diamondStorage();\n        uint256 oldMaxTokenCreationDeadline = ds.maxTokenCreationDeadline;\n        ds.maxTokenCreationDeadline = newMaxTokenCreationDeadline;\n        emit LibLaunchPadFactoryStorage.MaxTokenCreationDeadlineUpdated(oldMaxTokenCreationDeadline, newMaxTokenCreationDeadline);\n    }\n\n    function updateSignerAddress(address newSignerAddress) external override onlyAdmin {\n        LibLaunchPadFactoryStorage.DiamondStorage storage ds = LibLaunchPadFactoryStorage.diamondStorage();\n        address oldSignerAddress = ds.signerAddress;\n        ds.signerAddress = newSignerAddress;\n        emit LibLaunchPadFactoryStorage.SignerAddressUpdated(oldSignerAddress, newSignerAddress);\n    }\n\n    function updateLaunchpadImplementation(address newLaunchpadImplementation) external override onlyAdmin {\n        LibLaunchPadFactoryStorage.DiamondStorage storage ds = LibLaunchPadFactoryStorage.diamondStorage();\n        ds.launchPadImplementation = newLaunchpadImplementation;\n    }\n\n    function setLaunchpadImplementation(address launchPad) external override {\n        require(\n            IAccessControl(address(this)).hasRole(AccessControlStorage.DEFAULT_ADMIN_ROLE, msg.sender) ||\n                IAccessControl(launchPad).hasRole(LibLaunchPadProjectStorage.LAUNCHPAD_OWNER_ROLE, msg.sender),\n            \"LaunchPadFactory: Only admin or project owner can call this function\"\n        );\n\n        LibLaunchPadFactoryStorage.DiamondStorage storage ds = LibLaunchPadFactoryStorage.diamondStorage();\n\n        address _implementation = IDiamondProxy(launchPad).implementation();\n        require(_implementation != ds.launchPadImplementation, \"LaunchPadFactory: Implementation is already set\");\n\n        IDiamondProxy(launchPad).setImplementation(ds.launchPadImplementation);\n    }\n\n    function createTokenAfterICO(address launchPad) external payable override onlyLaunchPadOwner(launchPad) {\n        require(\n            ILaunchPadProject(launchPad).getLaunchPadInfo().tokenAddress == address(0),\n            \"LaunchPadFactory:createTokenAfterICO: Token address is already set\"\n        );\n\n        LibLaunchPadFactoryStorage.DiamondStorage storage ds = LibLaunchPadFactoryStorage.diamondStorage();\n        require(ds.launchPadOwner[launchPad] != address(0), \"LaunchPadFactory:createTokenAfterICO: LaunchPad does not exist\");\n\n        CreateErc20Input memory createErc20Input = ds.tokenInfoByLaunchPadAddress[launchPad];\n\n        // create a TokenFiErc20 token by using TokenLauncherFactory\n        // payment would be ignored because launchpad factory has a discount NFT\n        address tokenAddress = ITokenLauncherFactory(address(this)).createErc20{ value: msg.value }(\n            ITokenLauncherFactory.CreateErc20Input({\n                tokenInfo: ITokenFiErc20.TokenInfo({\n                    name: createErc20Input.name,\n                    symbol: createErc20Input.symbol,\n                    logo: createErc20Input.logo,\n                    decimals: createErc20Input.decimals,\n                    initialSupply: ILaunchPadProject(launchPad).totalTokensSold() + createErc20Input.treasuryReserved,\n                    maxSupply: createErc20Input.maxSupply,\n                    treasury: address(this),\n                    owner: address(this),\n                    fees: ITokenFiErc20.Fees({\n                        transferFee: ITokenFiErc20.FeeDetails({ percentage: 0, onlyOnSwaps: false }),\n                        burn: ITokenFiErc20.FeeDetails({ percentage: 0, onlyOnSwaps: false }),\n                        reflection: ITokenFiErc20.FeeDetails({ percentage: 0, onlyOnSwaps: false }),\n                        buyback: ITokenFiErc20.FeeDetails({ percentage: 0, onlyOnSwaps: false })\n                    }),\n                    buybackDetails: ITokenFiErc20.BuybackDetails({\n                        pairToken: address(0),\n                        router: address(0),\n                        liquidityBasisPoints: 0,\n                        priceImpactBasisPoints: 0\n                    })\n                }),\n                referrer: address(0),\n                paymentToken: address(0)\n            })\n        );\n\n        ILaunchPadProjectAdmin(launchPad).setTokenAddress(tokenAddress);\n        ITokenFiErc20(tokenAddress).addExemptAddress(launchPad);\n        ITokenFiErc20(tokenAddress).updateTreasury(createErc20Input.owner);\n        IAccessControl(tokenAddress).grantRole(AccessControlStorage.DEFAULT_ADMIN_ROLE, createErc20Input.owner);\n        IAccessControl(tokenAddress).renounceRole(AccessControlStorage.DEFAULT_ADMIN_ROLE);\n\n        // Transfer the totalTokensSold() amount to the launchpad\n        IERC20(tokenAddress).safeTransfer(launchPad, ILaunchPadProject(launchPad).totalTokensSold());\n        // Transfer the treasury amount to the treasury\n        if (createErc20Input.treasuryReserved > 0) {\n            IERC20(tokenAddress).safeTransfer(createErc20Input.owner, createErc20Input.treasuryReserved);\n        }\n    }\n\n    function setExistingTokenAfterICO(address launchPad, address tokenAddress, uint256 amount) external override onlyLaunchPadOwner(launchPad) {\n        LibLaunchPadFactoryStorage.DiamondStorage storage ds = LibLaunchPadFactoryStorage.diamondStorage();\n        require(ds.launchPadOwner[launchPad] != address(0), \"LaunchPadFactory:setExistingTokenAfterICO: LaunchPad does not exist\");\n        require(\n            ILaunchPadProject(launchPad).getLaunchPadInfo().tokenAddress == address(0),\n            \"LaunchPadFactory:setExistingTokenAfterICO: Token address is already set\"\n        );\n\n        ILaunchPadProjectAdmin(launchPad).setTokenAddress(tokenAddress);\n\n        // Transfer tokens from the user to this\n        uint256 initialBalance = IERC20(tokenAddress).balanceOf(launchPad);\n        IERC20(tokenAddress).safeTransferFrom(msg.sender, launchPad, amount);\n        uint256 receivedTokens = IERC20(tokenAddress).balanceOf(launchPad) - initialBalance;\n        require(\n            receivedTokens >= ILaunchPadProject(launchPad).totalTokensSold(),\n            \"LaunchPadFactory:setExistingTokenAfterICO: Token has tax, please exempt launchpad address\"\n        );\n    }\n\n    function setExistingTokenAfterTransfer(address launchPad, address tokenAddress) external override onlyLaunchPadOwner(launchPad) {\n        LibLaunchPadFactoryStorage.DiamondStorage storage ds = LibLaunchPadFactoryStorage.diamondStorage();\n        require(ds.launchPadOwner[launchPad] != address(0), \"LaunchPadFactory:setExistingTokenAfterTransfer: LaunchPad does not exist\");\n        require(\n            ILaunchPadProject(launchPad).getLaunchPadInfo().tokenAddress == address(0),\n            \"LaunchPadFactory:setExistingTokenAfterTransfer: Token address is already set\"\n        );\n        ILaunchPadProjectAdmin(launchPad).setTokenAddress(tokenAddress);\n\n        // Check if the launchpad has received at least the total tokens sold\n        uint256 currentBalance = IERC20(tokenAddress).balanceOf(launchPad);\n        require(\n            currentBalance >= ILaunchPadProject(launchPad).totalTokensSold(),\n            \"LaunchPadFactory:setExistingTokenAfterTransfer: Launchpad has not received tokens yet\"\n        );\n    }\n\n    function createLaunchpadV2LiquidityPool(address launchPad) external payable override onlyLaunchPadOwner(launchPad) {\n        LibLaunchPadFactoryStorage.DiamondStorage storage ds = LibLaunchPadFactoryStorage.diamondStorage();\n        require(ds.launchPadOwner[launchPad] != address(0), \"LaunchPadFactory:createLaunchpadV2LiquidityPool: LaunchPad does not exist\");\n\n        ILaunchPadCommon.LaunchPadInfo memory launchPadInfo = ILaunchPadProject(launchPad).getLaunchPadInfo();\n        require(block.timestamp > launchPadInfo.startTimestamp + launchPadInfo.duration, \"Sale is still ongoing\");\n        require(\n            ILaunchPadProject(launchPad).getLaunchPadInfo().tokenAddress != address(0),\n            \"LaunchPadFactory:createLaunchpadV2LiquidityPool: Token address is 0 - token does not exist\"\n        );\n        require(launchPadInfo.idoInfo.enabled == true, \"LaunchPad:createLaunchpadV2LiquidityPool: IDO is not enabled\");\n\n        uint256 tokenDecimals = IERC20Metadata(launchPadInfo.tokenAddress).decimals();\n        ITokenLauncherLiquidityPoolFactory.CreateV2LpTlInput memory createV2Input = ITokenLauncherLiquidityPoolFactory.CreateV2LpTlInput({\n            createV2LpInput: ITokenLauncherLiquidityPoolFactory.CreateV2LpInput({\n                owner: launchPadInfo.owner,\n                treasury: launchPadInfo.owner,\n                liquidityPoolDetails: ITokenLauncherLiquidityPoolFactory.LiquidityPoolDetails({\n                    sourceToken: launchPadInfo.tokenAddress,\n                    pairedToken: launchPadInfo.idoInfo.pairToken,\n                    amountSourceToken: launchPadInfo.idoInfo.amountToList,\n                    amountPairedToken: (launchPadInfo.idoInfo.price * launchPadInfo.idoInfo.amountToList) / (10 ** tokenDecimals),\n                    routerAddress: launchPadInfo.idoInfo.dexRouter\n                }),\n                lockLPDetails: ITokenLauncherLiquidityPoolFactory.LockLPDetails({\n                    lockLPTokenPercentage: 0,\n                    unlockTimestamp: 0,\n                    beneficiary: launchPadInfo.owner,\n                    isVesting: false\n                })\n            }),\n            buybackDetails: ITokenFiErc20.BuybackDetails({\n                pairToken: launchPadInfo.idoInfo.pairToken,\n                router: launchPadInfo.idoInfo.dexRouter,\n                liquidityBasisPoints: 0,\n                priceImpactBasisPoints: 0\n            })\n        });\n\n        ITokenLauncherLiquidityPoolFactory(address(this)).createTokenLauncherV2LiquidityPool{ value: msg.value }(createV2Input);\n    }\n\n    function updateLaunchPadOwner(address launchPadAddress, address newOwner) external override onlyLaunchPadOwner(launchPadAddress) {\n        LibLaunchPadFactoryStorage.DiamondStorage storage ds = LibLaunchPadFactoryStorage.diamondStorage();\n\n        address owner = ds.launchPadOwner[launchPadAddress];\n        require(owner != newOwner, \"LaunchPadStore: Same owner\");\n        require(newOwner != address(0), \"LaunchPadStore: New owner cannot be 0\");\n        address[] storage launchPads = ds.launchPadsByOwner[owner];\n\n        bool _launchPadExists = false;\n        for (uint256 i = 0; i < ds.launchPadsByOwner[owner].length; i++) {\n            if (ds.launchPadsByOwner[owner][i] == launchPadAddress) {\n                ds.launchPadsByOwner[owner][i] = ds.launchPadsByOwner[owner][launchPads.length - 1];\n                ds.launchPadsByOwner[owner].pop();\n                _launchPadExists = true;\n                break;\n            }\n        }\n        require(_launchPadExists == true, \"LaunchPadStore: LaunchPad does not exist\");\n\n        ds.launchPadsByOwner[newOwner].push(launchPadAddress);\n        ds.launchPadOwner[launchPadAddress] = newOwner;\n        emit LibLaunchPadFactoryStorage.LaunchPadOwnerUpdated(ds.currentBlockLaunchPadOwnerUpdated, owner, newOwner);\n        ds.currentBlockLaunchPadOwnerUpdated = block.number;\n    }\n\n    function updateLaunchPadMaxDurationIncrement(uint256 newMaxDurationIncrement) external override onlyAdmin {\n        LibLaunchPadFactoryStorage.DiamondStorage storage ds = LibLaunchPadFactoryStorage.diamondStorage();\n        ds.maxDurationIncrement = newMaxDurationIncrement;\n    }\n\n    modifier onlyAdmin() {\n        require(\n            IAccessControl(address(this)).hasRole(AccessControlStorage.DEFAULT_ADMIN_ROLE, msg.sender),\n            \"LaunchPadFactory: Only admin can call this function\"\n        );\n        _;\n    }\n\n    modifier onlyLaunchPadOwner(address launchPad) {\n        require(\n            IAccessControl(launchPad).hasRole(LibLaunchPadProjectStorage.LAUNCHPAD_OWNER_ROLE, msg.sender),\n            \"LaunchPadFactory: Only project owner can call this function\"\n        );\n        _;\n    }\n}\n"
    },
    "contracts/launchpad/interfaces/ILaunchPadCommon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\ninterface ILaunchPadCommon {\n    enum LaunchPadType {\n        FlokiPadCreatedBefore,\n        FlokiPadCreatedAfter\n    }\n\n    struct IdoInfo {\n        bool enabled;\n        address dexRouter;\n        address pairToken;\n        uint256 price;\n        uint256 amountToList;\n    }\n\n    struct RefundInfo {\n        uint256 penaltyFeePercent;\n        uint256 expireDuration;\n    }\n\n    struct FundTarget {\n        uint256 softCap;\n        uint256 hardCap;\n    }\n\n    struct ReleaseSchedule {\n        uint256 timestamp;\n        uint256 percent;\n    }\n\n    struct ReleaseScheduleV2 {\n        uint256 timestamp;\n        uint256 percent;\n        bool isVesting;\n    }\n\n    struct CreateErc20Input {\n        string name;\n        string symbol;\n        string logo;\n        uint8 decimals;\n        uint256 maxSupply;\n        address owner;\n        uint256 treasuryReserved;\n    }\n\n    struct LaunchPadInfo {\n        address owner;\n        address tokenAddress;\n        address paymentTokenAddress;\n        uint256 price;\n        FundTarget fundTarget;\n        uint256 maxInvestPerWallet;\n        uint256 startTimestamp;\n        uint256 duration;\n        uint256 tokenCreationDeadline;\n        RefundInfo refundInfo;\n        IdoInfo idoInfo;\n    }\n\n    struct CreateLaunchPadInput {\n        LaunchPadType launchPadType;\n        LaunchPadInfo launchPadInfo;\n        ReleaseScheduleV2[] releaseSchedule;\n        CreateErc20Input createErc20Input;\n        address referrer;\n        bool isSuperchargerEnabled;\n        uint256 feePercentage;\n        address paymentTokenAddress;\n    }\n}\n"
    },
    "contracts/launchpad/interfaces/ILaunchPadFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ILaunchPadCommon } from \"./ILaunchPadCommon.sol\";\nimport { ICrossPaymentModule } from \"../../common/admin/interfaces/ICrossPaymentModule.sol\";\n\ninterface ILaunchPadFactory {\n    struct StoreLaunchPadInput {\n        ILaunchPadCommon.LaunchPadType launchPadType;\n        address launchPadAddress;\n        address owner;\n        address referrer;\n    }\n\n    function addInvestorToLaunchPad(address investor) external;\n    function createLaunchPad(ILaunchPadCommon.CreateLaunchPadInput memory input) external payable;\n    function createLaunchPadWithPaymentSignature(\n        ILaunchPadCommon.CreateLaunchPadInput memory storeInput,\n        ICrossPaymentModule.CrossPaymentSignatureInput memory crossPaymentSignatureInput\n    ) external;\n}\n"
    },
    "contracts/launchpad/interfaces/ILaunchPadFactoryAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ILaunchPadCommon } from \"./ILaunchPadCommon.sol\";\nimport { IDiamondCut } from \"../../common/diamonds/interfaces/IDiamondCut.sol\";\n\ninterface ILaunchPadFactoryAdmin is ILaunchPadCommon {\n    function removeLaunchpad(address launchpad) external;\n\n    function upgradeLaunchPadProjectFacets(address launchPad, IDiamondCut.FacetCut[] memory _diamondCut, address _init, bytes memory _calldata) external;\n\n    function updateMaxTokenCreationDeadline(uint256 newMaxTokenCreationDeadline) external;\n\n    function updateSignerAddress(address newSignerAddress) external;\n\n    function updateLaunchpadImplementation(address newLaunchpadImplementation) external;\n\n    function setLaunchpadImplementation(address launchPad) external;\n\n    function createTokenAfterICO(address launchPadAddress) external payable;\n\n    function setExistingTokenAfterICO(address launchPad, address tokenAddress, uint256 amount) external;\n\n    function setExistingTokenAfterTransfer(address launchPad, address tokenAddress) external;\n\n    function createLaunchpadV2LiquidityPool(address launchPadAddress) external payable;\n\n    function updateLaunchPadOwner(address tokenAddress, address newOwner) external;\n\n    function updateLaunchPadMaxDurationIncrement(uint256 newMaxDurationIncrement) external;\n\n    function transferLaunchpadDiamondOwnership(address launchPad, address newOwner) external;\n}\n"
    },
    "contracts/launchpad/interfaces/ILaunchPadProject.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ILaunchPadCommon } from \"./ILaunchPadCommon.sol\";\n\ninterface ILaunchPadProject {\n    struct PurchasedInfo {\n        uint256 purchasedTokenAmount;\n        uint256 claimedTokenAmount;\n        uint256 paidTokenAmount;\n    }\n\n    struct BuyTokenInput {\n        uint256 tokenAmount;\n        uint256 tier;\n        uint256 nonce;\n        uint256 deadline;\n        bytes signature;\n    }\n\n    struct ClaimTokenWithSuperchargerInput {\n        uint256 timestamp;\n        uint256 deadline;\n        bytes signature;\n    }\n\n    struct RefundWithSuperchargerInput {\n        uint256 timestamp;\n        uint256 deadline;\n        bytes signature;\n    }\n\n    function buyTokens(uint256 tokenAmount) external payable;\n\n    function buyTokensWithSupercharger(BuyTokenInput memory input) external payable;\n\n    function reserveTokens(address user, uint256 tokenAmount, uint256 sourceChainId, uint256 paymentIndex, bytes memory signature) external;\n\n    function processRefund(address user, uint256 tokenAmount, bytes memory signature) external;\n\n    function processRefundOnTokenCreationExpired(address user, uint256 tokenAmount, bytes memory signature) external;\n\n    function processRefundOnSoftCapFailure(address user, bytes memory signature) external;\n\n    function checkSignature(address wallet, uint256 tier, uint256 nonce, uint256 deadline, bytes memory signature) external view;\n\n    function checkSignatureForCrossPayment(address wallet, uint256 amount, uint256 sourceChainId, uint256 paymentIndex, bytes memory signature) external view;\n\n    function checkSignatureForRefund(address wallet, uint256 amount, bytes memory signature) external view;\n\n    function claimTokens() external;\n\n    function claimTokensWithSupercharger(ILaunchPadProject.ClaimTokenWithSuperchargerInput memory input) external;\n\n    function getAllInvestors() external view returns (address[] memory);\n\n    function getCurrentTier() external view returns (uint256);\n\n    function getFeeShare() external view returns (uint256);\n\n    function getHardCapPerTier(uint256 tier) external view returns (uint256);\n\n    function getInvestorAddressByIndex(uint256 index) external view returns (address);\n\n    function getInvestorsLength() external view returns (uint256);\n\n    function getLaunchPadAddress() external view returns (address);\n\n    function getLaunchPadInfo() external view returns (ILaunchPadCommon.LaunchPadInfo memory);\n\n    function getMaxInvestPerWalletPerTier(uint256 tier) external view returns (uint256);\n\n    function getNextNonce(address user) external view returns (uint256);\n\n    function getProjectOwnerRole() external view returns (bytes32);\n\n    function getPurchasedInfoByUser(address user) external view returns (PurchasedInfo memory);\n\n    function getReleasedTokensPercentage() external view returns (uint256);\n\n    function getReleaseSchedule() external view returns (ILaunchPadCommon.ReleaseScheduleV2[] memory);\n\n    function getTokensAvailableToBeClaimed(address user) external view returns (uint256);\n\n    function getTokenCreationDeadline() external view returns (uint256);\n\n    function getTotalRaised() external view returns (uint256);\n\n    function getInvestorsRefundedCount() external view returns (uint256);\n\n    function getMaxInvestorsToRefund() external view returns (uint256);\n\n    function getRemainingInvestorsToRefund() external view returns (uint256);\n\n    function setMaxInvestorsToRefund(uint256 maxInvestorsUpdate) external;\n\n    function isSuperchargerEnabled() external view returns (bool);\n\n    function recoverSigner(bytes32 message, bytes memory signature) external view returns (address);\n\n    function refund(uint256 tokenAmount) external;\n\n    function refundOnSoftCapFailure() external;\n\n    function refundOnTokenCreationExpired(uint256 tokenAmount) external;\n\n    function refundAllInvestors() external;\n\n    function refundOnUnstakedDuringSales(ILaunchPadProject.RefundWithSuperchargerInput memory input) external;\n\n    function tokenDecimals() external view returns (uint256);\n\n    function totalTokensClaimed() external view returns (uint256);\n\n    function totalTokensSold() external view returns (uint256);\n}\n"
    },
    "contracts/launchpad/interfaces/ILaunchPadProjectAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ILaunchPadCommon } from \"./ILaunchPadCommon.sol\";\n\ninterface ILaunchPadProjectAdmin {\n    function setSupercharger(bool isSuperchargerEnabled) external;\n\n    function updateStartTimestamp(uint256 newStartTimestamp) external;\n\n    function extendDuration(uint256 durationIncrease) external;\n\n    function updateReleaseSchedule(ILaunchPadCommon.ReleaseScheduleV2[] memory releaseSchedule) external;\n\n    function setTokenAddress(address tokenAddress) external;\n\n    function withdrawFees() external;\n\n    function withdrawTokens(address tokenAddress) external;\n\n    function withdrawTokensToRecipient(address tokenAddress, address recipient) external;\n\n    /** EVENTS */\n\n    event SuperchargerUpdated(bool isSuperchargerEnabled);\n    event StartTimestampUpdated(uint256 newStartTimestamp);\n    event DurationExtended(uint256 durationIncrease);\n    event ReleaseScheduleUpdated(ILaunchPadCommon.ReleaseScheduleV2[] releaseSchedule);\n    event TokenAddressUpdated(address tokenAddress);\n    event FeesWithdrawn(uint256 feeAmount);\n    event TokensWithdrawn(address tokenAddress);\n    event TokensWithdrawnToRecipient(address tokenAddress, address recipient);\n\n    /** ERRORS */\n    error UPDATE_RELEASE_SCHEDULE_ERROR(string errorMessage);\n    error UPDATE_START_TIMESTAMP_ERROR(string errorMessage);\n    error EXTEND_DURATION_ERROR(string errorMessage);\n}\n"
    },
    "contracts/launchpad/libraries/LibLaunchPadFactoryStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ILaunchPadCommon } from \"../interfaces/ILaunchPadCommon.sol\";\nimport { ILaunchPadFactory } from \"../interfaces/ILaunchPadFactory.sol\";\nimport { ILaunchPadProject } from \"../interfaces/ILaunchPadProject.sol\";\nimport { ILaunchPadProjectAdmin } from \"../interfaces/ILaunchPadProjectAdmin.sol\";\n\nlibrary LibLaunchPadFactoryStorage {\n    bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(\"tokenfi.launchpad.factory.diamond.storage\");\n\n    struct DiamondStorage {\n        address[] launchPads;\n        mapping(address => address[]) launchPadsByOwner;\n        mapping(address => address[]) launchPadsByInvestor;\n        mapping(address => address) launchPadOwner;\n        mapping(address => bool) isLaunchPad;\n        mapping(address => ILaunchPadCommon.CreateErc20Input) tokenInfoByLaunchPadAddress;\n        uint256 currentBlockLaunchPadCreated;\n        uint256 currentBlockLaunchPadOwnerUpdated;\n        address _tokenLauncherERC20; // deprecated (available on Diamond itself)\n        address _tokenLauncherStore; // deprecated (available on Diamond itself)\n        address _tokenLauncherBuybackHandler; // deprecated (available on Diamond itself)\n        address launchPadProjectFacet;\n        address accessControlFacet;\n        address pausableFacet;\n        address loupeFacet;\n        address proxyFacet;\n        address launchPadProjectDiamondInit;\n        address _tokenfiToken; // deprecated (available on LaunchPadPaymentStorage)\n        address _usdToken; // deprecated (available on LaunchPadPaymentStorage)\n        address _router; // deprecated (available on LaunchPadPaymentStorage)\n        address _treasury; // deprecated (available on LaunchPadPaymentStorage)\n        address signerAddress;\n        uint256 maxTokenCreationDeadline;\n        uint256[] _superChargerMultiplierByTier; // deprecated (cause of wrong updates by v1)\n        uint256[] _superChargerHeadstartByTier; // deprecated (cause of wrong updates by v1)\n        uint256[] _superChargerTokensPercByTier; // deprecated (cause of wrong updates by v1)\n        uint256 maxDurationIncrement;\n        address launchPadProjectAdminFacet;\n        address launchPadImplementation;\n        uint256[] superChargerMultiplierByTier;\n        uint256[] superChargerHeadstartByTier;\n        uint256[] superChargerTokensPercByTier;\n        address diamondCutWithApprovalFacet;\n    }\n\n    event LaunchPadCreated(uint256 indexed previousBlock, ILaunchPadFactory.StoreLaunchPadInput launchPad);\n    event LaunchPadOwnerUpdated(uint256 indexed previousBlock, address owner, address newOwner);\n    event MaxTokenCreationDeadlineUpdated(uint256 indexed previousMaxTokenCreationDeadline, uint256 newMaxTokenCreationDeadline);\n    event LaunchpadRemoved(address indexed launchPadAddress, address indexed owner);\n    event SignerAddressUpdated(address indexed previousSignerAddress, address indexed newSignerAddress);\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    function getLaunchPadProjectSelectors() internal pure returns (bytes4[] memory) {\n        bytes4[] memory functionSelectors = new bytes4[](38);\n        functionSelectors[0] = ILaunchPadProject.buyTokens.selector;\n        functionSelectors[1] = ILaunchPadProject.buyTokensWithSupercharger.selector;\n        functionSelectors[2] = ILaunchPadProject.checkSignature.selector;\n        functionSelectors[3] = ILaunchPadProject.claimTokens.selector;\n        functionSelectors[4] = ILaunchPadProject.getAllInvestors.selector;\n        functionSelectors[5] = ILaunchPadProject.getCurrentTier.selector;\n        functionSelectors[6] = ILaunchPadProject.getFeeShare.selector;\n        functionSelectors[7] = ILaunchPadProject.getHardCapPerTier.selector;\n        functionSelectors[8] = ILaunchPadProject.getInvestorAddressByIndex.selector;\n        functionSelectors[9] = ILaunchPadProject.getInvestorsLength.selector;\n        functionSelectors[10] = ILaunchPadProject.getLaunchPadAddress.selector;\n        functionSelectors[11] = ILaunchPadProject.getLaunchPadInfo.selector;\n        functionSelectors[12] = ILaunchPadProject.getMaxInvestPerWalletPerTier.selector;\n        functionSelectors[13] = ILaunchPadProject.getNextNonce.selector;\n        functionSelectors[14] = ILaunchPadProject.getProjectOwnerRole.selector;\n        functionSelectors[15] = ILaunchPadProject.getPurchasedInfoByUser.selector;\n        functionSelectors[16] = ILaunchPadProject.getReleasedTokensPercentage.selector;\n        functionSelectors[17] = ILaunchPadProject.getReleaseSchedule.selector;\n        functionSelectors[18] = ILaunchPadProject.getTokensAvailableToBeClaimed.selector;\n        functionSelectors[19] = ILaunchPadProject.getTokenCreationDeadline.selector;\n        functionSelectors[20] = ILaunchPadProject.getTotalRaised.selector;\n        functionSelectors[21] = ILaunchPadProject.isSuperchargerEnabled.selector;\n        functionSelectors[22] = ILaunchPadProject.recoverSigner.selector;\n        functionSelectors[23] = ILaunchPadProject.refund.selector;\n        functionSelectors[24] = ILaunchPadProject.refundOnSoftCapFailure.selector;\n        functionSelectors[25] = ILaunchPadProject.refundOnTokenCreationExpired.selector;\n        functionSelectors[26] = ILaunchPadProject.tokenDecimals.selector;\n        functionSelectors[27] = ILaunchPadProject.totalTokensClaimed.selector;\n        functionSelectors[28] = ILaunchPadProject.totalTokensSold.selector;\n        functionSelectors[29] = ILaunchPadProject.reserveTokens.selector;\n        functionSelectors[30] = ILaunchPadProject.processRefund.selector;\n        functionSelectors[31] = ILaunchPadProject.processRefundOnTokenCreationExpired.selector;\n        functionSelectors[32] = ILaunchPadProject.processRefundOnSoftCapFailure.selector;\n        functionSelectors[33] = ILaunchPadProject.refundAllInvestors.selector;\n        functionSelectors[34] = ILaunchPadProject.getInvestorsRefundedCount.selector;\n        functionSelectors[35] = ILaunchPadProject.getMaxInvestorsToRefund.selector;\n        functionSelectors[36] = ILaunchPadProject.setMaxInvestorsToRefund.selector;\n        functionSelectors[37] = ILaunchPadProject.getRemainingInvestorsToRefund.selector;\n\n        return functionSelectors;\n    }\n\n    function getLaunchPadProjectAdminSelectors() internal pure returns (bytes4[] memory) {\n        bytes4[] memory functionSelectors = new bytes4[](9);\n        functionSelectors[0] = ILaunchPadProjectAdmin.setSupercharger.selector;\n        functionSelectors[1] = ILaunchPadProjectAdmin.setTokenAddress.selector;\n        functionSelectors[2] = ILaunchPadProjectAdmin.withdrawFees.selector;\n        functionSelectors[3] = ILaunchPadProjectAdmin.withdrawTokens.selector;\n        functionSelectors[4] = ILaunchPadProjectAdmin.withdrawTokensToRecipient.selector;\n        functionSelectors[5] = ILaunchPadProjectAdmin.updateStartTimestamp.selector;\n        functionSelectors[6] = ILaunchPadProjectAdmin.extendDuration.selector;\n        functionSelectors[7] = ILaunchPadProjectAdmin.updateReleaseSchedule.selector;\n\n        return functionSelectors;\n    }\n}\n"
    },
    "contracts/launchpad/libraries/LibLaunchPadProjectStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ILaunchPadCommon } from \"../interfaces/ILaunchPadProject.sol\";\nimport { ILaunchPadProject } from \"../interfaces/ILaunchPadProject.sol\";\n\n/// @notice storage for LaunchPads created by users\n\nlibrary LibLaunchPadProjectStorage {\n    bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(\"tokenfi.launchpad.project.diamond.storage\");\n    bytes32 internal constant LAUNCHPAD_OWNER_ROLE = keccak256(\"LAUNCHPAD_OWNER_ROLE\");\n    bytes32 internal constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    struct DiamondStorage {\n        ILaunchPadCommon.LaunchPadInfo launchPadInfo;\n        address launchPadFactory;\n        uint256 totalTokensSold;\n        uint256 totalTokensClaimed;\n        uint256 feePercentage; // in basis points 1e4\n        bool feeShareCollected;\n        bool isSuperchargerEnabled;\n        ILaunchPadCommon.ReleaseSchedule[] releaseSchedule;\n        ILaunchPadCommon.ReleaseScheduleV2[] releaseScheduleV2;\n        mapping(address => ILaunchPadProject.PurchasedInfo) purchasedInfoByUser;\n        address[] investors;\n        mapping(address => uint256[]) buyTokenNonces;\n        uint256 maxInvestorsToRefund;\n        uint256 investorsRefundedCount;\n        mapping(uint256 => mapping(uint256 => bool)) signatureUsedByIndexByChainId;\n        mapping(address => bool) hasProvedNoUnstakes;\n    }\n\n    event TokensPurchased(address indexed buyer, uint256 amount);\n    event TokensRefunded(address indexed buyer, uint256 amount);\n    event TokensRefundInitiated(address indexed buyer, address paymentTokenAddress, uint256 refundableAmount, uint256 amount);\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            ds.slot := position\n        }\n    }\n}\n"
    },
    "contracts/token-launcher/interfaces/ITokenFiErc1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ICrossPaymentModule } from \"../../common/admin/interfaces/ICrossPaymentModule.sol\";\n\ninterface ITokenFiErc1155 {\n    struct TokenInfo {\n        string name;\n        string symbol;\n        string collectionLogo;\n        string baseURI;\n        bool isPublicMintEnabled;\n        bool isAdminMintEnabled;\n        address owner;\n    }\n\n    struct CreateTokenInput {\n        uint256 tokenId;\n        uint256 maxSupply;\n        uint256 publicMintUsdPrice;\n        uint8 decimals;\n        string uri;\n    }\n\n    function adminMint(address account, uint256 id, uint256 amount) external;\n    function setTokenInfo(TokenInfo memory _newTokenInfo) external;\n    function createToken(CreateTokenInput memory input) external;\n    function setTokenPublicMintPrice(uint256 _tokenId, uint256 _price) external;\n    function setTokenUri(uint256 _tokenId, string memory _uri) external;\n    function mint(address account, uint256 id, uint256 amount, address paymentToken, address referrer) external payable;\n    function mintWithPaymentSignature(\n        address account,\n        uint256 id,\n        uint256 amount,\n        ICrossPaymentModule.CrossPaymentSignatureInput memory crossPaymentSignatureInput\n    ) external;\n    function tokenInfo() external view returns (TokenInfo memory);\n    function maxSupply(uint256 tokenId) external view returns (uint256);\n    function decimals(uint256 tokenId) external view returns (uint256);\n    function paymentServiceIndexByTokenId(uint256 tokenId) external view returns (uint256);\n    function exists(uint256 id) external view returns (bool);\n    function getExistingTokenIds() external view returns (uint256[] memory);\n    function paymentModule() external view returns (address);\n\n    event TokenInfoUpdated(TokenInfo indexed oldTokenInfo, TokenInfo indexed newTokenInfo);\n    event MintPaymentProccessed(address indexed user, uint256 indexed paymentId);\n}\n"
    },
    "contracts/token-launcher/interfaces/ITokenFiErc20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\ninterface ITokenFiErc20 {\n    struct FeeDetails {\n        uint256 percentage;\n        bool onlyOnSwaps;\n    }\n\n    struct Fees {\n        FeeDetails transferFee;\n        FeeDetails burn;\n        FeeDetails reflection;\n        FeeDetails buyback;\n    }\n\n    struct BuybackDetails {\n        address pairToken;\n        address router;\n        uint256 liquidityBasisPoints;\n        uint256 priceImpactBasisPoints;\n    }\n\n    struct TokenInfo {\n        string name;\n        string symbol;\n        string logo;\n        uint8 decimals;\n        uint256 initialSupply;\n        uint256 maxSupply;\n        address treasury;\n        address owner;\n        Fees fees;\n        BuybackDetails buybackDetails;\n    }\n\n    struct TotalReflection {\n        uint256 tTotal;\n        uint256 rTotal;\n        uint256 tFeeTotal;\n    }\n\n    struct ReflectionInfo {\n        TotalReflection totalReflection;\n        mapping(address => uint256) rOwned;\n        mapping(address => uint256) tOwned;\n        mapping(address => bool) isExcludedFromReflectionRewards;\n        address[] excluded;\n    }\n\n    /** ONLY ROLES */\n    function mint(address to, uint256 amount) external;\n    function updateTokenLauncher(address _newTokenLauncher) external;\n    function updateTreasury(address _newTreasury) external;\n    function setName(string memory name) external;\n    function setSymbol(string memory symbol) external;\n    function setDecimals(uint8 decimals) external;\n    function updateFees(Fees memory _fees) external;\n    function setBuybackDetails(BuybackDetails memory _buybackDetails) external;\n    function setBuybackHandler(address _newBuybackHandler) external;\n    function addExchangePool(address pool) external;\n    function removeExchangePool(address pool) external;\n    function addExemptAddress(address account) external;\n    function removeExemptAddress(address account) external;\n\n    /** VIEW */\n    function fees() external view returns (Fees memory);\n    function tokenInfo() external view returns (TokenInfo memory);\n    function buybackHandler() external view returns (address);\n    function isExchangePool(address pool) external view returns (bool);\n    function isExemptedFromTax(address account) external view returns (bool);\n    function isReflectionToken() external view returns (bool);\n\n    /** REFLECTION Implemetation */\n    function reflect(uint256 tAmount) external;\n    function excludeAccount(address account) external;\n    function includeAccount(address account) external;\n    function isExcludedFromReflectionRewards(address account) external view returns (bool);\n    function totalReflection() external view returns (TotalReflection memory);\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) external view returns (uint256);\n    function tokenFromReflection(uint256 rAmount) external view returns (uint256);\n    function totalFees() external view returns (uint256);\n\n    event ExemptedAdded(address indexed account);\n    event ExemptedRemoved(address indexed account);\n    event ExchangePoolAdded(address indexed pool);\n    event ExchangePoolRemoved(address indexed pool);\n    event TokenLauncherUpdated(address indexed oldTokenLauncher, address indexed newTokenLauncher);\n    event TransferTax(address indexed account, address indexed receiver, uint256 amount, string indexed taxType);\n    event BuybackHandlerUpdated(address indexed oldBuybackHandler, address indexed newBuybackHandler);\n    event BuybackDetailsUpdated(address indexed router, address indexed pairToken, uint256 liquidityBasisPoints, uint256 priceImpactBasisPoints);\n    event TreasuryUpdated(address indexed oldTreasury, address indexed newTreasury);\n}\n"
    },
    "contracts/token-launcher/interfaces/ITokenFiErc721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ICrossPaymentModule } from \"../../common/admin/interfaces/ICrossPaymentModule.sol\";\n\ninterface ITokenFiErc721 {\n    enum PaymentServices {\n        TOKEN_MINT\n    }\n\n    struct TokenInfo {\n        string name;\n        string symbol;\n        string collectionLogo;\n        string baseURI;\n        uint256 maxSupply;\n        bool isPublicMintEnabled;\n        bool isAdminMintEnabled;\n        address owner;\n    }\n\n    function adminMint(address _to) external;\n    function adminMintBatch(address _to, uint256 _amount) external;\n    function setTokenInfo(TokenInfo memory _newTokenInfo) external;\n    function setTokenUri(uint256 tokenId, string memory uri) external;\n    function mint(address _to, address paymentToken, address referrer) external payable;\n    function mintWithPaymentSignature(address _to, ICrossPaymentModule.CrossPaymentSignatureInput memory crossPaymentSignatureInput) external;\n    function mintBatch(address _to, uint256 _amount, address paymentToken, address referrer) external payable;\n    function mintBatchWithPaymentSignature(\n        address _to,\n        uint256 _amount,\n        ICrossPaymentModule.CrossPaymentSignatureInput memory crossPaymentSignatureInput\n    ) external;\n    function tokenInfo() external view returns (TokenInfo memory);\n    function paymentModule() external view returns (address);\n\n    event TokenInfoUpdated(TokenInfo indexed oldTokenInfo, TokenInfo indexed newTokenInfo);\n    event MintPaymentProccessed(address indexed user, uint256 indexed paymentId);\n}\n"
    },
    "contracts/token-launcher/interfaces/ITokenLauncherCommon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\ninterface ITokenLauncherCommon {\n    enum TokenType {\n        ERC20,\n        ERC721,\n        ERC1155\n    }\n}\n"
    },
    "contracts/token-launcher/interfaces/ITokenLauncherFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ITokenLauncherCommon } from \"./ITokenLauncherCommon.sol\";\nimport { ITokenFiErc20 } from \"./ITokenFiErc20.sol\";\nimport { ITokenFiErc721 } from \"./ITokenFiErc721.sol\";\nimport { ITokenFiErc1155 } from \"./ITokenFiErc1155.sol\";\nimport { ICrossPaymentModule } from \"../../common/admin/interfaces/ICrossPaymentModule.sol\";\n\ninterface ITokenLauncherFactory is ITokenLauncherCommon {\n    struct CreateErc20Input {\n        ITokenFiErc20.TokenInfo tokenInfo;\n        address referrer;\n        address paymentToken;\n    }\n\n    struct PublicErc721MintPaymentInfo {\n        uint256 usdPrice;\n        address treasury;\n        uint256 burnBasisPoints;\n        uint256 referrerBasisPoints;\n    }\n\n    struct CreateErc721Input {\n        ITokenFiErc721.TokenInfo tokenInfo;\n        PublicErc721MintPaymentInfo publicMintPaymentInfo;\n        address referrer;\n        address paymentToken;\n    }\n\n    struct PublicErc1155MintPaymentInfo {\n        address treasury;\n        uint256 burnBasisPoints;\n        uint256 referrerBasisPoints;\n    }\n\n    struct CreateErc1155Input {\n        ITokenFiErc1155.TokenInfo tokenInfo;\n        PublicErc1155MintPaymentInfo publicMintPaymentInfo;\n        ITokenFiErc1155.CreateTokenInput[] initialTokens;\n        address referrer;\n        address paymentToken;\n    }\n\n    struct StoreTokenInput {\n        address tokenAddress;\n        address owner;\n        address referrer;\n        uint256 paymentIndex;\n        TokenType tokenType;\n    }\n\n    function createErc20(CreateErc20Input memory input) external payable returns (address tokenAddress);\n    function createErc20WithPaymentSignature(\n        CreateErc20Input memory input,\n        ICrossPaymentModule.CrossPaymentSignatureInput memory crossPaymentSignatureInput\n    ) external returns (address tokenAddress);\n    function createErc721(CreateErc721Input memory input) external payable returns (address tokenAddress);\n    function createErc721WithPaymentSignature(\n        CreateErc721Input memory input,\n        ICrossPaymentModule.CrossPaymentSignatureInput memory crossPaymentSignatureInput\n    ) external returns (address tokenAddress);\n    function createErc1155(CreateErc1155Input memory input) external payable returns (address tokenAddress);\n    function createErc1155WithPaymentSignature(\n        CreateErc1155Input memory input,\n        ICrossPaymentModule.CrossPaymentSignatureInput memory crossPaymentSignatureInput\n    ) external returns (address tokenAddress);\n\n    /** EVNETS */\n    event TokenCreated(uint256 indexed currentBlockTokenCreated, StoreTokenInput input);\n}\n"
    },
    "contracts/token-launcher/interfaces/ITokenLauncherLiquidityPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ITokenFiErc20 } from \"./ITokenFiErc20.sol\";\n\ninterface ITokenLauncherLiquidityPoolFactory {\n    struct LiquidityPoolDetails {\n        address sourceToken;\n        address pairedToken;\n        uint256 amountSourceToken;\n        uint256 amountPairedToken;\n        address routerAddress;\n    }\n\n    struct LockLPDetails {\n        uint256 lockLPTokenPercentage;\n        uint256 unlockTimestamp;\n        address beneficiary;\n        bool isVesting;\n    }\n\n    struct CreateV2LpInput {\n        address owner;\n        address treasury;\n        LiquidityPoolDetails liquidityPoolDetails;\n        LockLPDetails lockLPDetails;\n    }\n\n    struct CreateV2LpTlInput {\n        CreateV2LpInput createV2LpInput;\n        ITokenFiErc20.BuybackDetails buybackDetails;\n    }\n\n    struct CreateV2Output {\n        address liquidityPoolToken;\n        uint256 liquidity;\n    }\n\n    struct RegisterLiquidityPoolInput {\n        address tokenAddress;\n        address liquidityPoolToken;\n    }\n\n    function createTokenLauncherV2LiquidityPool(ITokenLauncherLiquidityPoolFactory.CreateV2LpTlInput memory input) external payable;\n    function createV2LiquidityPool(CreateV2LpInput memory input) external payable;\n    function registerLiquidityPool(RegisterLiquidityPoolInput memory input) external;\n    function getLiquidityPoolTokensByToken(address token) external view returns (address[] memory);\n\n    event TokenLiquidityCreated(address indexed owner, LiquidityPoolDetails liquidityPoolDetails);\n    event VaultFactoryUpdated(address indexed oldVaultFactory, address indexed newVaultFactory);\n    event LiquidityPoolRegistered(uint256 indexed previousBlock, address indexed lpToken, address indexed sourceToken);\n}\n"
    }
  }
}}