{"Address.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.7.5;\n\n\n// TODO(zx): replace with OZ implementation.\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    // function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n    //     require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n    //     return _functionCallWithValue(target, data, value, errorMessage);\n    // }\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n\n  /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.3._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.3._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n\n    function addressToString(address _address) internal pure returns(string memory) {\n        bytes32 _bytes = bytes32(uint256(_address));\n        bytes memory HEX = \"0123456789abcdef\";\n        bytes memory _addr = new bytes(42);\n\n        _addr[0] = \u00270\u0027;\n        _addr[1] = \u0027x\u0027;\n\n        for(uint256 i = 0; i \u003c 20; i++) {\n            _addr[2+i*2] = HEX[uint8(_bytes[i + 12] \u003e\u003e 4)];\n            _addr[3+i*2] = HEX[uint8(_bytes[i + 12] \u0026 0x0f)];\n        }\n\n        return string(_addr);\n\n    }\n}"},"bonding.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.7.5;\n\nimport \"./SafeMath.sol\";\nimport \"./FixedPoint.sol\";\nimport \"./Address.sol\";\nimport \"./SafeERC20.sol\";\n\nimport \"./IERC20Metadata.sol\";\nimport \"./IERC20.sol\";\nimport \"./IBondingCalculator.sol\";\nimport \"./IUniswapV2ERC20.sol\";\nimport \"./IUniswapV2Pair.sol\";\n\ncontract MuppetsBondingCalculator is IBondingCalculator {\n    using FixedPoint for *;\n    using SafeMath for uint256;\n\n    IERC20 internal immutable FU;\n\n    constructor(address _FU) {\n        require(_FU != address(0), \"Zero address: FU\");\n        FU = IERC20(_FU);\n    }\n\n    function getKValue(address _pair) public view returns (uint256 k_) {\n        uint256 token0 = IERC20Metadata(IUniswapV2Pair(_pair).token0()).decimals();\n        uint256 token1 = IERC20Metadata(IUniswapV2Pair(_pair).token1()).decimals();\n        uint256 decimals = token0.add(token1).sub(IERC20Metadata(_pair).decimals());\n\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(_pair).getReserves();\n        k_ = reserve0.mul(reserve1).div(10**decimals);\n    }\n\n    function getTotalValue(address _pair) public view returns (uint256 _value) {\n        _value = getKValue(_pair).sqrrt().mul(2);\n    }\n\n    function valuation(address _pair, uint256 amount_) external view override returns (uint256 _value) {\n        uint256 totalValue = getTotalValue(_pair);\n        uint256 totalSupply = IUniswapV2Pair(_pair).totalSupply();\n\n        _value = totalValue.mul(FixedPoint.fraction(amount_, totalSupply).decode112with18()).div(1e18);\n    }\n\n    function markdown(address _pair) external view override returns (uint256) {\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(_pair).getReserves();\n\n        uint256 reserve;\n        if (IUniswapV2Pair(_pair).token0() == address(FU)) {\n            reserve = reserve1;\n        } else {\n            require(IUniswapV2Pair(_pair).token1() == address(FU), \"Invalid pair\");\n            reserve = reserve0;\n        }\n        return reserve.mul(2 * (10**IERC20Metadata(address(FU)).decimals())).div(getTotalValue(_pair));\n    }\n}\n"},"FixedPoint.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.7.5;\n\nimport \"./FullMath.sol\";\n\n\nlibrary Babylonian {\n\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        if (x == 0) return 0;\n\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx \u003e= 0x100000000000000000000000000000000) {\n            xx \u003e\u003e= 128;\n            r \u003c\u003c= 64;\n        }\n        if (xx \u003e= 0x10000000000000000) {\n            xx \u003e\u003e= 64;\n            r \u003c\u003c= 32;\n        }\n        if (xx \u003e= 0x100000000) {\n            xx \u003e\u003e= 32;\n            r \u003c\u003c= 16;\n        }\n        if (xx \u003e= 0x10000) {\n            xx \u003e\u003e= 16;\n            r \u003c\u003c= 8;\n        }\n        if (xx \u003e= 0x100) {\n            xx \u003e\u003e= 8;\n            r \u003c\u003c= 4;\n        }\n        if (xx \u003e= 0x10) {\n            xx \u003e\u003e= 4;\n            r \u003c\u003c= 2;\n        }\n        if (xx \u003e= 0x8) {\n            r \u003c\u003c= 1;\n        }\n        r = (r + x / r) \u003e\u003e 1;\n        r = (r + x / r) \u003e\u003e 1;\n        r = (r + x / r) \u003e\u003e 1;\n        r = (r + x / r) \u003e\u003e 1;\n        r = (r + x / r) \u003e\u003e 1;\n        r = (r + x / r) \u003e\u003e 1;\n        r = (r + x / r) \u003e\u003e 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return (r \u003c r1 ? r : r1);\n    }\n}\n\nlibrary BitMath {\n\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x \u003e 0, \u0027BitMath::mostSignificantBit: zero\u0027);\n\n        if (x \u003e= 0x100000000000000000000000000000000) {\n            x \u003e\u003e= 128;\n            r += 128;\n        }\n        if (x \u003e= 0x10000000000000000) {\n            x \u003e\u003e= 64;\n            r += 64;\n        }\n        if (x \u003e= 0x100000000) {\n            x \u003e\u003e= 32;\n            r += 32;\n        }\n        if (x \u003e= 0x10000) {\n            x \u003e\u003e= 16;\n            r += 16;\n        }\n        if (x \u003e= 0x100) {\n            x \u003e\u003e= 8;\n            r += 8;\n        }\n        if (x \u003e= 0x10) {\n            x \u003e\u003e= 4;\n            r += 4;\n        }\n        if (x \u003e= 0x4) {\n            x \u003e\u003e= 2;\n            r += 2;\n        }\n        if (x \u003e= 0x2) r += 1;\n    }\n}\n\n\nlibrary FixedPoint {\n\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    struct uq144x112 {\n        uint256 _x;\n    }\n\n    uint8 private constant RESOLUTION = 112;\n    uint256 private constant Q112 = 0x10000000000000000000000000000;\n    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000;\n    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\n\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\n        return uint112(self._x \u003e\u003e RESOLUTION);\n    }\n\n    function decode112with18(uq112x112 memory self) internal pure returns (uint) {\n\n        return uint(self._x) / 5192296858534827;\n    }\n\n    function fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\n        require(denominator \u003e 0, \u0027FixedPoint::fraction: division by zero\u0027);\n        if (numerator == 0) return FixedPoint.uq112x112(0);\n\n        if (numerator \u003c= uint144(-1)) {\n            uint256 result = (numerator \u003c\u003c RESOLUTION) / denominator;\n            require(result \u003c= uint224(-1), \u0027FixedPoint::fraction: overflow\u0027);\n            return uq112x112(uint224(result));\n        } else {\n            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\n            require(result \u003c= uint224(-1), \u0027FixedPoint::fraction: overflow\u0027);\n            return uq112x112(uint224(result));\n        }\n    }\n    \n    // square root of a UQ112x112\n    // lossy between 0/1 and 40 bits\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        if (self._x \u003c= uint144(-1)) {\n            return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) \u003c\u003c 112)));\n        }\n\n        uint8 safeShiftBits = 255 - BitMath.mostSignificantBit(self._x);\n        safeShiftBits -= safeShiftBits % 2;\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) \u003c\u003c safeShiftBits) \u003c\u003c ((112 - safeShiftBits) / 2)));\n    }\n}"},"FullMath.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.7.5;\n\nlibrary FullMath {\n    function fullMul(uint256 x, uint256 y) private pure returns (uint256 l, uint256 h) {\n        uint256 mm = mulmod(x, y, uint256(-1));\n        l = x * y;\n        h = mm - l;\n        if (mm \u003c l) h -= 1;\n    }\n\n    function fullDiv(\n        uint256 l,\n        uint256 h,\n        uint256 d\n    ) private pure returns (uint256) {\n        uint256 pow2 = d \u0026 -d;\n        d /= pow2;\n        l /= pow2;\n        l += h * ((-pow2) / pow2 + 1);\n        uint256 r = 1;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        return l * r;\n    }\n\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 d\n    ) internal pure returns (uint256) {\n        (uint256 l, uint256 h) = fullMul(x, y);\n\n        uint256 mm = mulmod(x, y, d);\n        if (mm \u003e l) h -= 1;\n        l -= mm;\n\n        if (h == 0) return l / d;\n\n        require(h \u003c d, \u0027FullMath: FULLDIV_OVERFLOW\u0027);\n        return fullDiv(l, h, d);\n    }\n}\n"},"IBondingCalculator.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0\npragma solidity \u003e=0.7.5;\n\ninterface IBondingCalculator {\n    function markdown( address _LP ) external view returns ( uint );\n\n    function valuation( address pair_, uint amount_ ) external view returns ( uint _value );\n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0\npragma solidity \u003e=0.7.5;\n\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender\u0027s allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller\u0027s\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"IERC20Metadata.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0\npragma solidity \u003e=0.7.5;\n\nimport \"./IERC20.sol\";\n\ninterface IERC20Metadata is IERC20 {\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}"},"IUniswapV2ERC20.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0\npragma solidity \u003e=0.7.5;\n\ninterface IUniswapV2ERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n}"},"IUniswapV2Pair.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0\npragma solidity \u003e=0.7.5;\n\nimport \"./IUniswapV2ERC20.sol\";\n\ninterface IUniswapV2Pair is IUniswapV2ERC20 {\n    function token0() external pure returns (address);\n    function token1() external pure returns (address);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function mint(address to) external returns (uint liquidity);\n    function sync() external;\n}"},"SafeERC20.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity \u003e=0.7.5;\n\nimport {IERC20} from \"./IERC20.sol\";\n\n/// @notice Safe IERC20 and ETH transfer library that safely handles missing return values.\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/TransferHelper.sol)\n/// Taken from Solmate\nlibrary SafeERC20 {\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, amount)\n        );\n\n        require(success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(IERC20.transfer.selector, to, amount)\n        );\n\n        require(success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(IERC20.approve.selector, to, amount)\n        );\n\n        require(success \u0026\u0026 (data.length == 0 || abi.decode(data, (bool))), \"APPROVE_FAILED\");\n    }\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        (bool success, ) = to.call{value: amount}(new bytes(0));\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n}"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.7.5;\n\n\n// TODO(zx): Replace all instances of SafeMath with OZ implementation\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    // Only used in the  BondingCalculator.sol\n    function sqrrt(uint256 a) internal pure returns (uint c) {\n        if (a \u003e 3) {\n            c = a;\n            uint b = add( div( a, 2), 1 );\n            while (b \u003c c) {\n                c = b;\n                b = div( add( div( a, b ), b), 2 );\n            }\n        } else if (a != 0) {\n            c = 1;\n        }\n    }\n\n}"}}