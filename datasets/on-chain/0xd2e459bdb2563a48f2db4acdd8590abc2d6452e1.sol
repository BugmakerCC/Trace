{{
  "language": "Solidity",
  "sources": {
    "src/utility/Reader.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.4;\n\nimport {Registry} from \"../Registry.sol\";\nimport {Coordinator, Subscription} from \"../Coordinator.sol\";\n\n/// @title Reader\n/// @notice Utility contract: implements multicall like batch reading functionality\n/// @dev Multicall src: https://github.com/mds1/multicall\n/// @dev Functions forgo validation assuming correct off-chain inputs are used\ncontract Reader {\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Coordinator\n    /// @dev `Coordinator` used over `EIP712Coordinator` since no EIP-712 functionality consumed\n    Coordinator private immutable COORDINATOR;\n\n    /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Initializes new Reader\n    /// @param registry registry contract\n    constructor(Registry registry) {\n        // Collect coordinator from registry\n        COORDINATOR = Coordinator(registry.COORDINATOR());\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Reads `Subscription`(s) from `Coordinator` in batch\n    /// @dev Does not validate that subscriptions between `startId` and `endId` exist\n    /// @dev Does not validate that `startId` is at least `0`\n    /// @dev Does not validate that `endId` is greater than `startId`\n    /// @param startId start subscription ID (inclusive)\n    /// @param endId end subscription ID (exclusive)\n    /// @return `Subscription`(s)\n    function readSubscriptionBatch(uint32 startId, uint32 endId) external view returns (Subscription[] memory) {\n        // Setup array to populate\n        uint32 length = endId - startId;\n        Subscription[] memory subscriptions = new Subscription[](length);\n\n        // Iterate and collect subscriptions\n        for (uint32 id = startId; id < endId; id++) {\n            // Collect 0-index array id\n            uint32 idx = id - startId;\n            // Collect and store subscription\n            subscriptions[idx] = COORDINATOR.getSubscription(id);\n        }\n\n        return subscriptions;\n    }\n\n    /// @notice Given `Subscription` ids and intervals, collects redundancy count of (subscription, interval)-pair\n    /// @dev By default, if a (subscription ID, interval)-pair does not exist, function will return `redundancyCount == 0`\n    /// @dev Does not validate `ids.length == intervals.length`\n    /// @param ids array of subscription IDs\n    /// @param intervals array of intervals to check where each ids[idx] corresponds to intervals[idx]\n    /// @return array of redundancy counts for (subscription ID, interval)-pairs\n    function readRedundancyCountBatch(uint32[] calldata ids, uint32[] calldata intervals)\n        external\n        view\n        returns (uint16[] memory)\n    {\n        // Setup array to populate\n        uint16[] memory redundancyCounts = new uint16[](ids.length);\n\n        // For each (subscription ID, interval)-pair\n        for (uint32 i = 0; i < ids.length; i++) {\n            // Compute `redundancyCount`-mapping key\n            bytes32 key = keccak256(abi.encode(ids[i], intervals[i]));\n            // Collect redundancy for (id, interval)\n            redundancyCounts[i] = COORDINATOR.redundancyCount(key);\n        }\n\n        return redundancyCounts;\n    }\n}\n"
    },
    "src/Registry.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.4;\n\n/// @title Registry\n/// @notice Allows registering Infernet contracts for inter-contract discovery\n/// @dev Requires deploy-time decleration of contract addresses\n/// @dev Immutable with no upgradeability; used only for discovery\ncontract Registry {\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Coordinator address\n    address public immutable COORDINATOR;\n\n    /// @notice Inbox address\n    address public immutable INBOX;\n\n    /// @notice Reader address\n    address public immutable READER;\n\n    /// @notice Fee registry address\n    address public immutable FEE;\n\n    /// @notice Wallet factory address\n    address public immutable WALLET_FACTORY;\n\n    /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Initializes new Registry\n    /// @dev Requires pre-computing expected deployed addresses\n    /// @param coordinator Coordinator address\n    /// @param inbox Inbox address\n    /// @param reader Reader address\n    /// @param fee Fee registry address\n    /// @param walletFactory Wallet factory address\n    constructor(address coordinator, address inbox, address reader, address fee, address walletFactory) {\n        COORDINATOR = coordinator;\n        INBOX = inbox;\n        READER = reader;\n        FEE = fee;\n        WALLET_FACTORY = walletFactory;\n    }\n}\n"
    },
    "src/Coordinator.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.4;\n\nimport {Inbox} from \"./Inbox.sol\";\nimport {Fee} from \"./payments/Fee.sol\";\nimport {Registry} from \"./Registry.sol\";\nimport {Wallet} from \"./payments/Wallet.sol\";\nimport {BaseConsumer} from \"./consumer/Base.sol\";\nimport {IVerifier} from \"./payments/IVerifier.sol\";\nimport {WalletFactory} from \"./payments/WalletFactory.sol\";\nimport {ReentrancyGuard} from \"solady/utils/ReentrancyGuard.sol\";\n\n/*//////////////////////////////////////////////////////////////\n                            PUBLIC STRUCTS\n//////////////////////////////////////////////////////////////*/\n\n/// @notice A subscription is the fundamental unit of Infernet\n/// @dev A subscription represents some request configuration for off-chain compute via containers on Infernet nodes\n/// @dev A subscription with `frequency == 1` is a one-time subscription (a callback)\n/// @dev A subscription with `frequency > 1` is a recurring subscription (many callbacks)\n/// @dev Tightly-packed struct:\n///      - [owner, activeAt, period, frequency]: [160, 32 32, 32] = 256\n///      - [redundancy, containerId, lazy, verifier]: [16, 32, 8, 160] = 216\n///      - [paymentAmount]: [256] = 256\n///      - [paymentToken]: [160] = 160\n///      - [wallet]: [160] = 160\nstruct Subscription {\n    /// @notice Subscription owner + recipient\n    /// @dev This is the address called to fulfill a subscription request and must inherit `BaseConsumer`\n    address owner;\n    /// @notice Timestamp when subscription is first active and an off-chain Infernet node can respond\n    /// @dev When `period == 0`, the subscription is immediately active\n    /// @dev When `period > 0`, subscription is active at `createdAt + period`\n    /// @dev Cancelled subscriptions update `activeAt` to `type(uint32).max` effectively restricting all future submissions\n    uint32 activeAt;\n    /// @notice Time, in seconds, between each subscription interval\n    /// @dev At worst, assuming subscription occurs once/year << uint32\n    uint32 period;\n    /// @notice Number of times a subscription is processed\n    /// @dev At worst, assuming 30 req/min * 60 min * 24 hours * 365 days * 10 years << uint32\n    uint32 frequency;\n    /// @notice Number of unique nodes that can fulfill a subscription at each `interval`\n    /// @dev uint16 allows for >255 nodes (uint8) but <65,535\n    uint16 redundancy;\n    /// @notice Container identifier used by off-chain Infernet nodes to determine which container is used to fulfill a subscription\n    /// @dev Represented as fixed size hash of stringified list of containers\n    /// @dev Can be used to specify a linear DAG of containers by seperating container names with a \",\" delimiter (\"A,B,C\")\n    /// @dev Better represented by a string[] type but constrained to hash(string) to keep struct and functions simple\n    bytes32 containerId;\n    /// @notice `true` if container compute responses lazily stored as an `InboxItem`(s) in `Inbox`, else `false`\n    /// @dev When `true`, container compute outputs are stored in `Inbox` and not delivered eagerly to a consumer\n    /// @dev When `false`, container compute outputs are not stored in `Inbox` and are delivered eagerly to a consumer\n    bool lazy;\n    /// @notice Optional verifier contract to restrict subscription payment on the basis of proof verification\n    /// @dev If `address(0)`, we assume that no proof contract is necessary, and disperse supplied payment immediately\n    /// @dev If verifier contract is supplied, it must implement the `IVerifier` interface\n    /// @dev Eager verifier contracts disperse payment immediately to relevant `Wallet`(s)\n    /// @dev Lazy verifier contracts disperse payment after a delay (max. 1-week) to relevant `Wallet`(s)\n    /// @dev Notice that consumer contracts can still independently implement their own 0-cost proof verification within their contracts\n    address payable verifier;\n    /// @notice Optional amount to pay in `paymentToken` each time a subscription is processed\n    /// @dev If `0`, subscription has no associated payment\n    /// @dev uint256 since we allow `paymentToken`(s) to have arbitrary ERC20 implementations (unknown `decimal`s)\n    /// @dev In theory, this could be a {dynamic pricing mechanism, reverse auction, etc.} but kept simple for now (abstractions can be built later)\n    uint256 paymentAmount;\n    /// @notice Optional payment token\n    /// @dev If `address(0)`, payment is in Ether (or no payment in conjunction with `paymentAmount == 0`)\n    /// @dev Else, `paymentToken` must be an ERC20-compatible token contract\n    address paymentToken;\n    /// @notice Optional `Wallet` to pay for compute payments; `owner` must be approved spender\n    /// @dev Defaults to `address(0)` when no payment specified\n    address payable wallet;\n}\n\n/// @notice A ProofRequest is a request made to a verifier contract to validate some proof bytes\n/// @dev Tightly-packed struct\n///      - [expiry, nodeWallet]: [32, 160] = 192\n///      - [consumerEscrowed]: [256] = 256\nstruct ProofRequest {\n    /// @notice Proof request expiration\n    /// @dev Set to block.timestamp (time of proof request initiation) + 1 week window\n    uint32 expiry;\n    /// @notice Address of node `Wallet` which has escrowed `paymentAmount` `paymentToken`\n    Wallet nodeWallet;\n    /// @notice Amount of `paymentToken` escrowed by the consumer as successful payment to `nodeWallet`\n    /// @dev Because verifiers can update their fees, we have to keep a reference to the exact escrowed amount rather than calculate on-demand\n    uint256 consumerEscrowed;\n}\n\n/// @title Coordinator\n/// @notice Coordination layer between consuming smart contracts and off-chain Infernet nodes\n/// @dev Implements `ReentrancyGuard` to prevent reentrancy in `deliverCompute`\n/// @dev Allows creating and deleting `Subscription`(s)\n/// @dev Allows any address (a `node`) to deliver susbcription outputs via off-chain container compute\ncontract Coordinator is ReentrancyGuard {\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Fee registry contract (used to collect protocol fee)\n    Fee private immutable FEE;\n\n    /// @notice Inbox contract (handles lazily storing subscription responses)\n    Inbox private immutable INBOX;\n\n    /// @notice Wallet factory contract (handles validity verification of `Wallet` contracts)\n    WalletFactory private immutable WALLET_FACTORY;\n\n    /*//////////////////////////////////////////////////////////////\n                                MUTABLE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Current highest subscription ID\n    /// @dev 1-indexed to allow using id as a mapping value (prevent 0-indexed default from being misused)\n    /// @dev uint32 size(4.2B) should be sufficiently large\n    uint32 public id = 1;\n\n    /// @notice hash(subscriptionId, interval, caller) => has caller responded for (sub, interval)?\n    mapping(bytes32 => bool) public nodeResponded;\n\n    /// @notice hash(subscriptionId, interval) => Number of responses for (sub, interval)?\n    /// @dev Limited to type(Subscription.redundancy) == uint16\n    /// @dev Technically, this is not required and we can save an SLOAD if we simply add a uint48 to the subscription\n    ///      struct that represents 32 bits of the interval -> 16 bits of redundancy count, reset each interval change\n    ///      But, this is a little over the optimization:readability line and would make Subscriptions harder to grok\n    mapping(bytes32 => uint16) public redundancyCount;\n\n    /// @notice hash(subscriptionId, interval, caller) => proof request\n    mapping(bytes32 => ProofRequest) public proofRequests;\n\n    /// @notice subscriptionID => Subscription\n    /// @dev 1-indexed, 0th-subscription is empty\n    /// @dev Visibility restricted to `internal` because we expose an explicit `getSubscription` view function that returns `Subscription` struct\n    mapping(uint32 => Subscription) internal subscriptions;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Emitted when a new subscription is created\n    /// @param id subscription ID\n    event SubscriptionCreated(uint32 indexed id);\n\n    /// @notice Emitted when a subscription is cancelled\n    /// @param id subscription ID\n    event SubscriptionCancelled(uint32 indexed id);\n\n    /// @notice Emitted when a subscription is fulfilled\n    /// @param id subscription ID\n    /// @param node address of fulfilling node\n    event SubscriptionFulfilled(uint32 indexed id, address indexed node);\n\n    /// @notice Emitted when a verifier returns with proof validity\n    /// @param id subscription ID\n    /// @param interval subscription interval\n    /// @param node address of fulfilling node\n    /// @param active True if proof verification period still active, else False\n    /// @param verifier address of verifier contract\n    /// @param valid True if proof valid else False\n    event ProofVerified(\n        uint32 indexed id, uint32 indexed interval, address indexed node, bool active, address verifier, bool valid\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Thrown by `deliverCompute()` if attempting to use an invalid `wallet` or one not created by `WalletFactory`\n    /// @dev 4-byte signature: `0x23455ba1`\n    error InvalidWallet();\n\n    /// @notice Thrown by `deliverCompute()` if attempting to deliver container compute response for non-current interval\n    /// @dev E.g submitting tx for `interval` < current (period elapsed) or `interval` > current (too early to submit)\n    /// @dev 4-byte signature: `0x4db310c3`\n    error IntervalMismatch();\n\n    /// @notice Thrown by `deliverCompute()` if `redundancy` has been met for current `interval`\n    /// @dev E.g submitting 4th output tx for a subscription with `redundancy == 3`\n    /// @dev 4-byte signature: `0x2f4ca85b`\n    error IntervalCompleted();\n\n    /// @notice Thrown by `finalizeProofVerification()` if called by a `msg.sender` that is unauthorized to finalize proof\n    /// @dev When a proof request is expired, this can be any address; until then, this is the designated `verifier` address\n    /// @dev 4-byte signature: `0xb9857aa1`\n    error UnauthorizedVerifier();\n\n    /// @notice Thrown by `deliverCompute()` if `node` has already responded this `interval`\n    /// @dev 4-byte signature: `0x88a21e4f`\n    error NodeRespondedAlready();\n\n    /// @notice Thrown by `deliverCompute()` if attempting to access a subscription that does not exist\n    /// @dev 4-byte signature: `0x1a00354f`\n    error SubscriptionNotFound();\n\n    /// @notice Thrown by `finalizeProofVerification()` if attempting to access a proof request that does not exist\n    /// @dev 4-byte signature: `0x1d68b37c`\n    error ProofRequestNotFound();\n\n    /// @notice Thrown by `cancelSubscription()` if attempting to modify a subscription not owned by caller\n    /// @dev 4-byte signature: `0xa7fba711`\n    error NotSubscriptionOwner();\n\n    /// @notice Thrown by `deliverCompute()` if attempting to deliver a completed subscription\n    /// @dev 4-byte signature: `0xae6704a7`\n    error SubscriptionCompleted();\n\n    /// @notice Thrown by `deliverCompute()` if attempting to deliver a subscription before `activeAt`\n    /// @dev 4-byte signature: `0xefb74efe`\n    error SubscriptionNotActive();\n\n    /// @notice Thrown by `deliverCompute` if attempting to pay a `IVerifier`-contract in a token it does not support receiving payments in\n    /// @dev 4-byte signature: `0xe2372799`\n    error UnsupportedVerifierToken();\n\n    /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Initializes new Coordinator\n    /// @param registry registry contract\n    constructor(Registry registry) {\n        // Collect fee contract from registry\n        FEE = Fee(registry.FEE());\n        // Collect inbox contract from registry\n        INBOX = Inbox(registry.INBOX());\n        // Collect wallet factory contract from registry\n        WALLET_FACTORY = WalletFactory(registry.WALLET_FACTORY());\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Given an input `amount`, returns the value of `fee` applied to it\n    /// @param amount to calculate fee on top of\n    /// @param fee to use in calculation\n    /// @return fee amount\n    function _calculateFee(uint256 amount, uint16 fee) internal pure returns (uint256) {\n        // (amount * fee) / 1e4 scaling factor\n        return amount * fee / 10_000;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Returns `Subscription` from `subscriptions` mapping, indexed by `subscriptionId`\n    /// @dev Useful utility view function because by default public mappings with struct values return destructured parameters\n    /// @param subscriptionId subscription ID to collect\n    function getSubscription(uint32 subscriptionId) external view returns (Subscription memory) {\n        return subscriptions[subscriptionId];\n    }\n\n    /// @notice Creates new subscription\n    /// @param containerId compute container identifier used by off-chain Infernet node\n    /// @param frequency max number of times to process subscription (i.e, `frequency == 1` is a one-time request)\n    /// @param period period, in seconds, at which to progress each responding `interval`\n    /// @param redundancy number of unique responding Infernet nodes\n    /// @param lazy whether to lazily store subscription responses\n    /// @param paymentToken If providing payment for compute, payment token address (address(0) for ETH, else ERC20 contract address)\n    /// @param paymentAmount If providing payment for compute, payment in `paymentToken` per compute request fulfillment\n    /// @param wallet If providing payment for compute, Infernet `Wallet` address; `msg.sender` must be approved spender\n    /// @param verifier optional verifier contract to restrict payment based on response proof verification\n    /// @return subscription ID\n    function createSubscription(\n        string memory containerId,\n        uint32 frequency,\n        uint32 period,\n        uint16 redundancy,\n        bool lazy,\n        address paymentToken,\n        uint256 paymentAmount,\n        address wallet,\n        address verifier\n    ) external returns (uint32) {\n        // Get subscription id and increment\n        // Unlikely this will ever overflow so we can toss in unchecked\n        uint32 subscriptionId;\n        unchecked {\n            subscriptionId = id++;\n        }\n\n        // Store new subscription\n        subscriptions[subscriptionId] = Subscription({\n            // If period is = 0 (one-time), active immediately\n            // Else, next active at first period mark\n            // Probably reasonable to keep the overflow protection here given adding 2 uint32's into a uint32\n            activeAt: uint32(block.timestamp) + period,\n            owner: msg.sender,\n            redundancy: redundancy,\n            frequency: frequency,\n            period: period,\n            containerId: keccak256(abi.encode(containerId)),\n            lazy: lazy,\n            verifier: payable(verifier),\n            paymentAmount: paymentAmount,\n            paymentToken: paymentToken,\n            wallet: payable(wallet)\n        });\n\n        // Emit new subscription\n        emit SubscriptionCreated(subscriptionId);\n\n        // Explicitly return subscriptionId\n        return subscriptionId;\n    }\n\n    /// @notice Cancel a subscription\n    /// @dev Must be called by `subscriptions[subscriptionId].owner`\n    /// @dev Cancels subscription by setting `Subscription` `activeAt` to maximum (technically, de-activating)\n    /// @param subscriptionId subscription ID to cancel\n    function cancelSubscription(uint32 subscriptionId) external {\n        // Throw if owner of subscription is not caller\n        if (subscriptions[subscriptionId].owner != msg.sender) {\n            revert NotSubscriptionOwner();\n        }\n\n        // Set `activeAt` to max type(uint32)\n        // While we could delete the subscription itself (and in previous versions of Infernet this was done),\n        // it is net cheaper on average to simply invalidate via `activeAt` instead, to allow use of `Subscription`\n        // parameters during verifier proof verification payout (since that path is to called with greater frequency)\n        subscriptions[subscriptionId].activeAt = type(uint32).max;\n\n        // Emit cancellation\n        // Event can be emitted more than once if cancelling already cancelled subscription\n        emit SubscriptionCancelled(subscriptionId);\n    }\n\n    /// @notice Calculates subscription `interval` based on `activeAt` and `period`\n    /// @param activeAt when does a subscription start accepting callback responses\n    /// @param period time, in seconds, between each subscription response `interval`\n    /// @return current subscription interval\n    function getSubscriptionInterval(uint32 activeAt, uint32 period) public view returns (uint32) {\n        // If period is 0, we're always at interval 1\n        if (period == 0) {\n            return 1;\n        }\n\n        // Else, interval = ((block.timestamp - activeAt) / period) + 1\n        // This is only called after validating block.timestamp >= activeAt so timestamp can't underflow\n        // We also short-circuit above if period is zero so no need for division by zero checks\n        unchecked {\n            return ((uint32(block.timestamp) - activeAt) / period) + 1;\n        }\n    }\n\n    /// @notice Allows any address (nodes) to deliver container compute responses for a subscription\n    /// @dev Re-entering generally does not work because each node can only call `deliverCompute` once per subscription\n    /// @dev But, you can call `deliverCompute` with a seperate `msg.sender` (in same delivery call) so we optimistically restrict with `nonReentrant`\n    /// @dev When `Subscription`(s) request lazy responses, stores container output in `Inbox`\n    /// @dev When `Subscription`(s) request eager responses, delivers container output directly via `BaseConsumer.rawReceiveCompute()`\n    /// @param subscriptionId subscription ID to deliver\n    /// @param deliveryInterval subscription `interval` to deliver\n    /// @param input optional off-chain input recorded by Infernet node (empty, hashed input, processed input, or both)\n    /// @param output optional off-chain container output (empty, hashed output, processed output, both, or fallback: all encodeable data)\n    /// @param proof optional container execution proof (or arbitrary metadata)\n    /// @param nodeWallet node wallet (used to receive payments, and put up escrow/slashing funds); msg.sender must be authorized spender of wallet\n    function deliverCompute(\n        uint32 subscriptionId,\n        uint32 deliveryInterval,\n        bytes calldata input,\n        bytes calldata output,\n        bytes calldata proof,\n        address nodeWallet\n    ) public nonReentrant {\n        // In infernet-sdk v0.1.0, loading a subscription into memory was handled\n        // piece-wise in assembly because a Subscription struct contained dynamic\n        // types (forcing an explict, unbounded SLOAD cost to copy dynamic length /\n        // word size bytes).\n\n        // In infernet-sdk v0.2.0, we removed dynamic types in Subscription structs\n        // allowing us to directly copy a subscription into memory. Notice: this is\n        // still not the most optimized approach, given we pay up-front to SLOAD 2\n        // slots, rather than loading 1 slot at a time (subsidizing costs in case\n        // of failure conditions). Still, the additional gas overhead (~500 gas in most\n        // failure cases) is better than poor developer UX and worse readability.\n\n        // Collect subscription\n        Subscription memory subscription = subscriptions[subscriptionId];\n\n        // Revert if subscription does not exist\n        if (subscription.owner == address(0)) {\n            revert SubscriptionNotFound();\n        }\n\n        // Revert if subscription is not yet active\n        if (uint32(block.timestamp) < subscription.activeAt) {\n            revert SubscriptionNotActive();\n        }\n\n        // Calculate subscription interval\n        uint32 interval = getSubscriptionInterval(subscription.activeAt, subscription.period);\n\n        // Revert if not processing current interval\n        if (interval != deliveryInterval) {\n            revert IntervalMismatch();\n        }\n\n        // Revert if interval > frequency\n        if (interval > subscription.frequency) {\n            revert SubscriptionCompleted();\n        }\n\n        // Revert if redundancy requirements for this interval have been met\n        bytes32 key = keccak256(abi.encode(subscriptionId, interval));\n        uint16 numRedundantDeliveries = redundancyCount[key];\n        if (numRedundantDeliveries == subscription.redundancy) {\n            revert IntervalCompleted();\n        }\n        // Highly unlikely to overflow given incrementing by 1/node\n        unchecked {\n            redundancyCount[key] = numRedundantDeliveries + 1;\n        }\n\n        // Revert if node has already responded this interval\n        key = keccak256(abi.encode(subscriptionId, interval, msg.sender));\n        if (nodeResponded[key]) {\n            revert NodeRespondedAlready();\n        }\n        nodeResponded[key] = true;\n\n        // Handle payments (non-zero payment per subscription fulfillment)\n        if (subscription.paymentAmount > 0) {\n            // Check if node wallet is valid and created by WalletFactory\n            // While this check in theory could be within the verification flow itself (when the node escrows funds),\n            // we keep it here to preserve the readability given following check and early input sanitization\n            if (!WALLET_FACTORY.isValidWallet(nodeWallet)) {\n                revert InvalidWallet();\n            }\n\n            // Check if subscription wallet is valid and created by WalletFactory\n            if (!WALLET_FACTORY.isValidWallet(subscription.wallet)) {\n                revert InvalidWallet();\n            }\n\n            // Setup consumer wallet\n            Wallet consumer = Wallet(subscription.wallet);\n\n            // Setup initial payment amount\n            uint256 tokenAvailable = subscription.paymentAmount;\n\n            // Collect protocol fee and recipient\n            uint16 protocolFee = FEE.FEE();\n            address protocolFeeRecipient = FEE.FEE_RECIPIENT();\n\n            // Calculate fee as function of subscription payment amount\n            // Imposed as 2 * FEE * AMOUNT (rather than (AMOUNT*FEE + (AMOUNT*0.95 * FEE))); uniform application on base amount\n            uint256 paidToProtocol = _calculateFee(subscription.paymentAmount, protocolFee * 2);\n\n            // Deduct from temporary amount available and pay protocol\n            tokenAvailable -= paidToProtocol;\n            consumer.cTransfer(subscription.owner, subscription.paymentToken, protocolFeeRecipient, paidToProtocol);\n\n            // If no verifier specified as precondition to payment fulfillment\n            if (subscription.verifier == address(0)) {\n                // Immediately process remaining payment from consumer to node\n                consumer.cTransfer(subscription.owner, subscription.paymentToken, nodeWallet, tokenAvailable);\n                // Else, verifier specified as precondition to payment fulfillment\n            } else {\n                // Setup verifier contract\n                IVerifier verifier = IVerifier(subscription.verifier);\n\n                // Check if verifier accepts `paymentToken`\n                if (!verifier.isSupportedToken(subscription.paymentToken)) {\n                    revert UnsupportedVerifierToken();\n                }\n\n                // Collect verifier fee\n                uint256 verifierFee = verifier.fee(subscription.paymentToken);\n\n                // Calculate protocol fee paid by verifier\n                tokenAvailable -= verifierFee;\n                paidToProtocol = _calculateFee(verifierFee, protocolFee);\n\n                // Pay protocol on behalf of verifier\n                consumer.cTransfer(subscription.owner, subscription.paymentToken, protocolFeeRecipient, paidToProtocol);\n\n                // Pay verifier (verifier fee - paid protocol fee)\n                consumer.cTransfer(\n                    subscription.owner, subscription.paymentToken, verifier.getWallet(), verifierFee - paidToProtocol\n                );\n\n                // Setup node wallet\n                Wallet node = Wallet(payable(nodeWallet));\n\n                // Escrow slashable amount from node\n                node.cLock(msg.sender, subscription.paymentToken, subscription.paymentAmount);\n\n                // Escrow remaining payable amount (to node) from consumer\n                consumer.cLock(subscription.owner, subscription.paymentToken, tokenAvailable);\n\n                // Store new proof request\n                proofRequests[key] = ProofRequest({\n                    expiry: uint32(block.timestamp) + 1 weeks,\n                    nodeWallet: node,\n                    consumerEscrowed: tokenAvailable\n                });\n\n                // Initiate verifier verification\n                verifier.requestProofVerification(subscriptionId, interval, msg.sender, proof);\n            }\n        }\n\n        // If delivering subscription lazily\n        if (subscription.lazy) {\n            // First, we must store the container outputs in `Inbox`\n            uint256 index = INBOX.writeViaCoordinator(\n                subscription.containerId, msg.sender, subscriptionId, interval, input, output, proof\n            );\n\n            // Next, we can deliver the subscription w/:\n            // 1. Nullifying container outputs (since we are storing outputs in the `Inbox`)\n            // 2. Providing a pointer to the `Inbox` entry via `containerId`, `index`\n            BaseConsumer(subscription.owner).rawReceiveCompute(\n                subscriptionId,\n                interval,\n                numRedundantDeliveries + 1,\n                msg.sender,\n                \"\",\n                \"\",\n                \"\",\n                subscription.containerId,\n                index\n            );\n        } else {\n            // Else, delivering subscription eagerly\n            // We must ensure `containerId`, `index` are nullified since eagerly delivering container outputs\n            BaseConsumer(subscription.owner).rawReceiveCompute(\n                subscriptionId, interval, numRedundantDeliveries + 1, msg.sender, input, output, proof, bytes32(0), 0\n            );\n        }\n\n        // Emit successful delivery\n        emit SubscriptionFulfilled(subscriptionId, msg.sender);\n    }\n\n    /// @notice Inbound counterpart to `IVerifier.requestProofVerification()` to process proof verification\n    /// @dev If called by `verifier`, accepts `valid` to process payout\n    /// @dev Else, can be called by anyone after 1 week timeout to side in favor of node by default\n    /// @param subscriptionId subscription ID for which proof verification was requested\n    /// @param interval interval of subscription for which proof verification was requested\n    /// @param node node in said interval for which proof verification was requested\n    /// @param valid `true` if proof was valid, else `false`\n    function finalizeProofVerification(uint32 subscriptionId, uint32 interval, address node, bool valid) external {\n        // Collect proof request\n        bytes32 key = keccak256(abi.encode(subscriptionId, interval, node));\n        ProofRequest memory request = proofRequests[key];\n\n        // Delete proof request (optimistically, proof processed)\n        delete proofRequests[key];\n\n        // If proof request does not exist, throw\n        if (request.expiry == 0) {\n            revert ProofRequestNotFound();\n        }\n\n        // Collect associated subscription\n        Subscription memory sub = subscriptions[subscriptionId];\n\n        // Unescrow wallets\n        request.nodeWallet.cUnlock(node, sub.paymentToken, sub.paymentAmount);\n        Wallet(sub.wallet).cUnlock(sub.owner, sub.paymentToken, request.consumerEscrowed);\n\n        // If proof verification period is still active\n        bool active = uint32(block.timestamp) < request.expiry;\n        if (active) {\n            // If caller is not verifier, revert\n            if (sub.verifier != msg.sender) {\n                revert UnauthorizedVerifier();\n            }\n\n            // If proof is valid\n            if (valid) {\n                // Process payment to node\n                Wallet(sub.wallet).cTransfer(\n                    sub.owner, sub.paymentToken, address(request.nodeWallet), request.consumerEscrowed\n                );\n                // Else, if proof is not valid\n            } else {\n                // Slash node\n                request.nodeWallet.cTransfer(node, sub.paymentToken, sub.wallet, sub.paymentAmount);\n            }\n            // Else, if proof verification period expired\n        } else {\n            // Process payment to node\n            Wallet(sub.wallet).cTransfer(\n                sub.owner, sub.paymentToken, address(request.nodeWallet), request.consumerEscrowed\n            );\n        }\n\n        // Emit successful proof verification\n        // Verifier here can be either sub.verifier or non-verifier msg.sender if after expiration\n        emit ProofVerified(subscriptionId, interval, node, active, msg.sender, valid);\n    }\n}\n"
    },
    "src/Inbox.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.4;\n\nimport {Registry} from \"./Registry.sol\";\nimport {Coordinated} from \"./utility/Coordinated.sol\";\n\n/*//////////////////////////////////////////////////////////////\n                            PUBLIC STRUCTS\n//////////////////////////////////////////////////////////////*/\n\n/// @notice An inbox item contains data about a compute response\n/// @dev An inbox item must have an associated immutable `timestamp` of when it was first recorded\n/// @dev An inbox item must have a `subscriptionId` and an `interval` if it is storing the response to a `Subscription`\n/// @dev An inbox item may optionally have an `input`, `output`, and `proof` (compute response parameters)\n/// @dev Tightly-packed struct:\n///     - [timestamp, subscriptionId, interval]: [32, 32, 32] = 96\n//      - [input, output, proof] = dynamic\nstruct InboxItem {\n    uint32 timestamp;\n    uint32 subscriptionId;\n    uint32 interval;\n    bytes input;\n    bytes output;\n    bytes proof;\n}\n\n/// @title Inbox\n/// @notice Optionally stores container compute responses\n/// @dev Inherits `Coordinated` to use `onlyCoordinator` modifier for coordinator-permissioned functions\n/// @dev Allows `Coordinator` to store compute responses for lazy consumption with associated `Subscription`(s)\n/// @dev Allows any address to store compute responses for lazy consumptions without associated `Subscription`(s)\ncontract Inbox is Coordinated {\n    /*//////////////////////////////////////////////////////////////\n                                MUTABLE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice containerId => delivering node address => array of delivered compute responses\n    /// @dev Notice that validation of an `InboxItem` corresponding to a `containerId` is left to a downstream consumer\n    /// @dev Even though we have a `read` function for `items`, we keep visbility `public` because it may be useful to collect `InboxItem[]` length\n    mapping(bytes32 => mapping(address => InboxItem[])) public items;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Emitted when a new InboxItem is added\n    /// @param containerId compute container ID\n    /// @param node delivering node address\n    /// @param index index of newly-added inbox item\n    event NewInboxItem(bytes32 indexed containerId, address indexed node, uint256 index);\n\n    /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Initializes new Inbox\n    /// @param registry registry contract\n    constructor(Registry registry) Coordinated(registry) {}\n\n    /*//////////////////////////////////////////////////////////////\n                           INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Allows pushing an `InboxItem` to `items`\n    /// @param containerId compute container ID\n    /// @param node delivering node address\n    /// @param subscriptionId optional associated subscription ID (`0` if none)\n    /// @param interval optional associated subscription interval (`0` if none)\n    /// @param input optional compute container input\n    /// @param output optional compute container output\n    /// @param proof optional compute container proof\n    /// @return index of newly-added inbox item\n    function _write(\n        bytes32 containerId,\n        address node,\n        uint32 subscriptionId,\n        uint32 interval,\n        bytes calldata input,\n        bytes calldata output,\n        bytes calldata proof\n    ) internal returns (uint256) {\n        // Push new inbox item to items store\n        items[containerId][node].push(\n            InboxItem({\n                timestamp: uint32(block.timestamp),\n                subscriptionId: subscriptionId,\n                interval: interval,\n                input: input,\n                output: output,\n                proof: proof\n            })\n        );\n\n        // Collect index of newly-added inbox item\n        uint256 index = items[containerId][node].length - 1;\n\n        // Emit newly-added inbox item\n        emit NewInboxItem(containerId, node, index);\n\n        // Explicitly return index\n        return index;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Allows any address to optimistically deliver compute responses\n    /// @dev Zeroes out `subscriptionId` and `interval` since compute response is not associated to a subscription request\n    /// @param containerId compute container ID\n    /// @param input optional compute container input\n    /// @param output optional compute container output\n    /// @param proof optional compute container proof\n    /// @return index of newly-added inbox item\n    function write(bytes32 containerId, bytes calldata input, bytes calldata output, bytes calldata proof)\n        external\n        returns (uint256)\n    {\n        return _write(containerId, msg.sender, 0, 0, input, output, proof);\n    }\n\n    /// @notice Allows `Coordinator` to store container compute response during `deliverCompute()` execution\n    /// @dev `node` address is explicitly passed because `tx.origin` may not be accurate\n    /// @dev `msg.sender` must be `address(COORDINATOR)` for authenticated write (storing subscriptionId, interval)\n    /// @param containerId compute container ID\n    /// @param node delivering node address\n    /// @param subscriptionId optional associated subscription ID (`0` if none)\n    /// @param interval optional associated subscription interval (`0` if none)\n    /// @param input optional compute container input\n    /// @param output optional compute container output\n    /// @param proof optional compute container proof\n    /// @return index of newly-added inbox item\n    function writeViaCoordinator(\n        bytes32 containerId,\n        address node,\n        uint32 subscriptionId,\n        uint32 interval,\n        bytes calldata input,\n        bytes calldata output,\n        bytes calldata proof\n    ) external onlyCoordinator returns (uint256) {\n        return _write(containerId, node, subscriptionId, interval, input, output, proof);\n    }\n\n    /// @notice Read a stored `InboxItem`\n    /// @dev By default, structs as values in public mappings return destructured parameters\n    /// @dev This function allows returning a coerced `InboxItem` type instead of destructured parameters\n    /// @param containerId compute container ID\n    /// @param node delivering node address\n    /// @param index item index\n    /// @return inbox item\n    function read(bytes32 containerId, address node, uint256 index) external view returns (InboxItem memory) {\n        return items[containerId][node][index];\n    }\n}\n"
    },
    "src/payments/Fee.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.4;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\n\n/// @title Fee\n/// @notice Protocol fee registry\n/// @dev Implements `Ownable` to represent `feeRecipient` as registry owner\ncontract Fee is Ownable {\n    /*//////////////////////////////////////////////////////////////\n                                MUTABLE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Fee amount, range: [0, 10000] with 2 decimal precision [0.00, 100.00]\n    /// @dev Updating fee past 100.00 is not disallowed and it is up to the updating caller to ensure bounds\n    /// @dev Exposes public getter to allow checking fee\n    uint16 public FEE;\n\n    /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Initializes new Fee\n    /// @param feeRecipient initial protocol fee recipient\n    /// @param fee initial protocol fee\n    constructor(address feeRecipient, uint16 fee) {\n        // Set owner as fee recipient\n        _initializeOwner(feeRecipient);\n        // Set fee\n        FEE = fee;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Allows `owner` (fee recipient) to update protocol `fee`\n    /// @param newFee protocol fee to update to\n    function updateFee(uint16 newFee) external onlyOwner {\n        FEE = newFee;\n    }\n\n    /// @notice Returns fee recipient (`owner`) address\n    /// @dev Acts simply as a proxy to the existing `owner()` fn to be more verbose\n    /// @return fee recipient address\n    function FEE_RECIPIENT() external view returns (address) {\n        return owner();\n    }\n}\n"
    },
    "src/payments/Wallet.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.4;\n\nimport {Registry} from \"../Registry.sol\";\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {Coordinated} from \"../utility/Coordinated.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\n/// @title Wallet\n/// @notice Payments wallet that allows: (1) managing ETH & ERC20 token balances, (2) allowing consumers to spend balance, (3) allowing coordinator to manage balance\n/// @dev Implements `Ownable` to setup an update-able `Wallet` `owner`\n/// @dev Implements `Coordinated` to restrict payment-handling functions to being called from coordinator\n/// @dev It is known that a frontrunning exploit exists (similar to the `approve` ERC20 vulnerability), where a consumer can request compute, and frontrun with a withdraw before the compute\n///      is delivered forcing unpaid compute execution (for results that can be copied and used). Solving for this vulnerability (for example, with Chainlink subscriptions' always-preserved balances) is\n///      is ignored, instead delegating to (1) reputation systems at the node-level for ease-of-use.\ncontract Wallet is Ownable, Coordinated {\n    /*//////////////////////////////////////////////////////////////\n                                MUTABLE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice token address => locked balance in escrow\n    /// @dev address(0) represents ETH\n    mapping(address => uint256) private lockedBalance;\n\n    /// @notice consumer => token address => spend limit\n    /// @dev Exposes public getter to enable checking allowance\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Emitted when `Wallet` owner processes a withdrawl\n    /// @param token token withdrawn\n    /// @param amount amount of `token` withdrawn\n    event Withdrawl(address token, uint256 amount);\n\n    /// @notice Emitted when `Wallet` owner approves a `spender` to use `amount` `token`\n    /// @param spender authorized spender of `amount` `token`\n    /// @param token token that can be spent\n    /// @param amount amount of `token` allocated\n    event Approval(address indexed spender, address token, uint256 amount);\n\n    /// @notice Emitted when `Coordinator` locks or unlocks some `amount` `token` in `Wallet` escrow\n    /// @param spender authorized spender of `amount` `token`\n    /// @param token token that can be escrowed\n    /// @param amount amount of `token` escrowed\n    /// @param locked True if locking in escrow, False if unlocking from escrow\n    event Escrow(address indexed spender, address token, uint256 amount, bool locked);\n\n    /// @notice Emitted when `Wallet` transfers some quantity of tokens\n    /// @param spender authorized spender of `amount` `token`\n    /// @param token token transferred\n    /// @param to receipient\n    /// @param amount amount of `token` transferred\n    event Transfer(address indexed spender, address token, address indexed to, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Thrown if attempting to transfer or lock tokens in quantity greater than possible\n    /// @dev Thrown by `withdraw()` if attempting to withdraw `amount > unlockedBalance`\n    /// @dev Thrown by `cLock()` if attempting to escrow `amount > unlockedBalance`\n    /// @dev Thrown by `cUnlock()` if attempting to unlock `amount > lockedBalance`\n    /// @dev 4-byte signature: `0x356680b7`\n    error InsufficientFunds();\n\n    /// @notice Thrown if attempting to transfer or lock tokens in quantity greater than allowed to a `spender`\n    /// @dev Thrown by `cTranasfer()` if attempting to transfer `amount` > allowed\n    /// @dev Thrown by `cLock()` if attempting to lcok `amount` > allowed\n    /// @dev 4-byte signature: `0x13be252b`\n    error InsufficientAllowance();\n\n    /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Initializes new Wallet\n    /// @param registry registry contract\n    /// @param initialOwner intial wallet owner\n    constructor(Registry registry, address initialOwner) Coordinated(registry) {\n        // Initialize owner\n        _initializeOwner(initialOwner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Returns balance of `token` that is not currently locked in escrow\n    /// @param token token address (ERC20 contract address or `address(0)` for ETH)\n    /// @return unlocked token balance\n    function _getUnlockedBalance(address token) internal view returns (uint256) {\n        // Get locked token balance\n        uint256 locked = lockedBalance[token];\n\n        // Get total token balance\n        uint256 balance;\n        if (token == address(0)) {\n            // If token is ETH, collect contract balance\n            balance = address(this).balance;\n        } else {\n            // Else, collect token balance from ERC20 contract\n            balance = SafeTransferLib.balanceOf(token, address(this));\n        }\n\n        // Return total token balance - locked token balance\n        return balance - locked;\n    }\n\n    /// @notice Transfers `amount` `token` from `address(this)` to `to`\n    /// @param token token to transfer (ERC20 contract address or `address(0)` for ETH)\n    /// @param to address to transfer to\n    /// @param amount amount of token to transfer\n    function _transferToken(address token, address to, uint256 amount) internal {\n        if (token == address(0)) {\n            // Transfer ETH\n            SafeTransferLib.forceSafeTransferETH(to, amount);\n        } else {\n            // Tranfer tokens\n            SafeTransferLib.safeTransfer(token, to, amount);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Allows `owner` to withdraw `amount` `token`(s)\n    /// @dev Can only withdraw tokens not locked in escrow\n    /// @param token token address\n    /// @param amount amount of tokens to withdraw from `Wallet`\n    function withdraw(address token, uint256 amount) external onlyOwner {\n        // Get unlocked token balance\n        uint256 unlockedBalance = _getUnlockedBalance(token);\n\n        // Throw if requested withdraw amount > unlocked token balance\n        if (amount > unlockedBalance) {\n            revert InsufficientFunds();\n        }\n\n        // Withdraw `amount` `token`(s) to `msg.sender` (`owner`)\n        _transferToken(token, msg.sender, amount);\n\n        // Emit withdrawl\n        emit Withdrawl(token, amount);\n    }\n\n    /// @notice Allows `owner` to approve `spender` as a consumer that can spend `amount` `token`(s) from `Wallet`\n    /// @dev We purposefully ignore the `approve` frontrunning vulnerability as it is rarely applied in practice\n    /// @param spender consumer address to approve\n    /// @param token token address to approve spend for\n    /// @param amount approval amount\n    function approve(address spender, address token, uint256 amount) external onlyOwner {\n        allowance[spender][token] = amount;\n        emit Approval(spender, token, amount);\n    }\n\n    /// @notice Allows coordinator to transfer `amount` `tokens` to `to` on behalf of `spender`\n    /// @param spender on-behalf of whom to transfer tokens\n    /// @param token token to transfer (ERC20 contract address or `address(0)` for ETH)\n    /// @param to address to transfer to\n    /// @param amount amount of token to transfer\n    function cTransfer(address spender, address token, address to, uint256 amount) external onlyCoordinator {\n        // Ensure allowance allows transferring `amount` `token`\n        if (allowance[spender][token] < amount) {\n            revert InsufficientAllowance();\n        }\n\n        // Decrement allowance\n        allowance[spender][token] -= amount;\n\n        // Transfer token\n        _transferToken(token, to, amount);\n\n        // Emit transfer\n        emit Transfer(spender, token, to, amount);\n    }\n\n    /// @notice Allows coordinator to lock `amount` `token`(s) in escrow on behalf of `spender`\n    /// @param spender on-behalf of whom tokens are locked\n    /// @param token token to lock\n    /// @param amount amount to lock\n    function cLock(address spender, address token, uint256 amount) external onlyCoordinator {\n        // Get unlocked token balance\n        uint256 unlockedBalance = _getUnlockedBalance(token);\n\n        // Throw if requested escrow amount is greater than available unlocked token amount\n        if (amount > unlockedBalance) {\n            revert InsufficientFunds();\n        }\n\n        // Ensure allowance allows locking `amount` `token`\n        if (allowance[spender][token] < amount) {\n            revert InsufficientAllowance();\n        }\n\n        // Decrement allowance\n        allowance[spender][token] -= amount;\n\n        // Increment escrow locked balance\n        lockedBalance[token] += amount;\n\n        // Emit escrow locking\n        emit Escrow(spender, token, amount, true);\n    }\n\n    /// @notice Allows coordinator to unlock `amount` `token`(s) from escrow on behalf of `spender`\n    /// @param spender on-behalf of whom tokens are unlocked\n    /// @param token token to unlock\n    /// @param amount amount to unlock\n    function cUnlock(address spender, address token, uint256 amount) external onlyCoordinator {\n        // Get locked token balance\n        uint256 locked = lockedBalance[token];\n\n        // Throw if requested unlock amount is greater than currently escrowed token amount\n        if (amount > locked) {\n            revert InsufficientFunds();\n        }\n\n        // Decrement locked balance\n        lockedBalance[token] -= amount;\n\n        // Increment spender allowance (now that funds are unlocked)\n        allowance[spender][token] += amount;\n\n        // Emit escrow unlocking\n        emit Escrow(spender, token, amount, false);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                FALLBACK\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Allow ETH deposits to `Wallet`\n    receive() external payable {}\n}\n"
    },
    "src/consumer/Base.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.4;\n\nimport {Inbox} from \"../Inbox.sol\";\nimport {Registry} from \"../Registry.sol\";\nimport {Coordinator} from \"../Coordinator.sol\";\n\n/// @title BaseConsumer\n/// @notice Handles receiving container compute responses from Infernet coordinator\n/// @notice Handles exposing container inputs to Infernet nodes via `getContainerInputs()`\n/// @notice Declares internal `INBOX` reference to allow downstream consumers to read from `Inbox`\n/// @dev Contains a single public entrypoint `rawReceiveCompute` callable only by the Infernet coordinator. Once\n///      msg.sender is verified, parameters are proxied to internal function `_receiveCompute`\n/// @dev Does not inherit `Coordinated` for `rawReceiveCompute` coordinator-permissioned check to keep error scope localized\nabstract contract BaseConsumer {\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Coordinator\n    /// @dev Internal visibility since COORDINATOR is consumed by inheriting contracts\n    Coordinator internal immutable COORDINATOR;\n\n    /// @notice Inbox\n    /// @dev Internal visibility since INBOX can be consumed by inheriting readers\n    Inbox internal immutable INBOX;\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Thrown if attempting to call `rawReceiveCompute` from a `msg.sender != address(COORDINATOR)`\n    /// @dev 4-byte signature: `0x9ec853e6`\n    error NotCoordinator();\n\n    /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Initialize new BaseConsumer\n    /// @param registry registry address\n    constructor(address registry) {\n        // Setup Coordinator (via address from canonical registry)\n        COORDINATOR = Coordinator(Registry(registry).COORDINATOR());\n        // Setup Inbox (via address from canonical registry)\n        INBOX = Inbox(Registry(registry).INBOX());\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           VIRTUAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Callback entrypoint to receive container compute responses from validated Coordinator source\n    /// @dev Called by `rawReceiveCompute` once validated that `msg.sender == address(COORDINATOR)`\n    /// @dev Same function parameters as `rawReceiveCompute`\n    /// @param subscriptionId id of subscription being responded to\n    /// @param interval subscription interval\n    /// @param redundancy after this call succeeds, how many nodes will have delivered a response for this interval\n    /// @param node address of responding Infernet node\n    /// @param input optional off-chain container input recorded by Infernet node (empty, hashed input, processed input, or both), empty for lazy subscriptions\n    /// @param output optional off-chain container output (empty, hashed output, processed output, both, or fallback: all encodeable data), empty for lazy subscriptions\n    /// @param proof optional off-chain container execution proof (or arbitrary metadata), empty for lazy subscriptions\n    /// @param containerId if lazy subscription, subscription compute container ID, else empty\n    /// @param index if lazy subscription, `Inbox` lazy store index, else empty\n    function _receiveCompute(\n        uint32 subscriptionId,\n        uint32 interval,\n        uint16 redundancy,\n        address node,\n        bytes calldata input,\n        bytes calldata output,\n        bytes calldata proof,\n        bytes32 containerId,\n        uint256 index\n    ) internal virtual {}\n\n    /// @notice View function to broadcast dynamic container inputs to off-chain Infernet nodes\n    /// @dev Developers can modify this function to return dynamic inputs\n    /// @param subscriptionId subscription ID to collect container inputs for\n    /// @param interval subscription interval to collect container inputs for\n    /// @param timestamp timestamp at which container inputs are collected\n    /// @param caller calling address\n    function getContainerInputs(uint32 subscriptionId, uint32 interval, uint32 timestamp, address caller)\n        external\n        view\n        virtual\n        returns (bytes memory)\n    {}\n\n    /*//////////////////////////////////////////////////////////////\n                               FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Callback entrypoint called by Infernet Coordinator to return container compute responses\n    /// @dev Callable only by `address(COORDINATOR)`, else throws `NotCoordinator()` error\n    /// @param subscriptionId id of subscription being responded to\n    /// @param interval subscription interval\n    /// @param redundancy after this call succeeds, how many nodes will have delivered a response for this interval\n    /// @param node address of responding Infernet node\n    /// @param input optional off-chain container input recorded by Infernet node (empty, hashed input, processed input, or both), empty for lazy subscriptions\n    /// @param output optional off-chain container output (empty, hashed output, processed output, both, or fallback: all encodeable data), empty for lazy subscriptions\n    /// @param proof optional off-chain container execution proof (or arbitrary metadata), empty for lazy subscriptions\n    /// @param containerId if lazy subscription, subscription compute container ID, else empty\n    /// @param index if lazy subscription, `Inbox` lazy store index, else empty\n    function rawReceiveCompute(\n        uint32 subscriptionId,\n        uint32 interval,\n        uint16 redundancy,\n        address node,\n        bytes calldata input,\n        bytes calldata output,\n        bytes calldata proof,\n        bytes32 containerId,\n        uint256 index\n    ) external {\n        // Ensure caller is coordinator\n        if (msg.sender != address(COORDINATOR)) {\n            revert NotCoordinator();\n        }\n\n        // Call internal receive function, since caller is validated\n        _receiveCompute(subscriptionId, interval, redundancy, node, input, output, proof, containerId, index);\n    }\n}\n"
    },
    "src/payments/IVerifier.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.4;\n\n/// @title IVerifier\n/// @notice Basic interface for verifier contracts to: (1) expose verification fees and `Wallet` address, (2) expose function to begin proof verification journey\ninterface IVerifier {\n    /// @notice Gets verifier contract's associated `Wallet` address\n    /// @dev Does not necessarily have to conform to the exact `Wallet` spec. since this address does not need to authorize the coordinator for spend\n    /// @return `Wallet` address to receive proof verification payment\n    function getWallet() external view returns (address);\n\n    /// @notice Checks if `token` is accepted payment method by verifier contract\n    /// @param token token address\n    /// @return `true` if `token` is supported, else `false`\n    function isSupportedToken(address token) external view returns (bool);\n\n    /// @notice Gets proving fee denominated in `token`\n    /// @dev Function `isSupportedToken` is called first\n    /// @param token token address\n    /// @return proving fee denominated in `token`\n    function fee(address token) external view returns (uint256);\n\n    /// @notice Request proof verification from verification contract\n    /// @dev Verifiers should restrict this function to being called only by `address(COORDINATOR)` to prevent DoS misuse\n    /// @dev Verifier contract has to call `verifyProof` on coordinator after a proof verification request\n    /// @dev By this point, verifier contract has been paid for proof verification\n    /// @param subscriptionId subscription ID\n    /// @param interval subscription response interval\n    /// @param node response submitting node\n    /// @param proof provided response proof bytes\n    function requestProofVerification(uint32 subscriptionId, uint32 interval, address node, bytes calldata proof)\n        external;\n\n    /// @notice Enforce ETH deposits to `IVerifier`-implementing contract\n    /// @dev A verifier may still choose to not support ETH by returning `false` for `isSupportedToken(address(0))`\n    receive() external payable;\n}\n"
    },
    "src/payments/WalletFactory.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.4;\n\nimport {Wallet} from \"./Wallet.sol\";\nimport {Registry} from \"../Registry.sol\";\n\n/// @title WalletFactory\n/// @notice Responsible for creating and tracking `Wallet`(s)\ncontract WalletFactory {\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Registry contract\n    /// @dev Consumed as parameter during `Wallet`-creation\n    Registry private immutable REGISTRY;\n\n    /*//////////////////////////////////////////////////////////////\n                                MUTABLE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice address => is wallet created by factory?\n    /// @dev View functionality exposed via `isValidWallet()`\n    mapping(address => bool) private wallets;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Emitted when a new `Wallet` is created\n    /// @param caller `createWallet` call initiator\n    /// @param owner owner of `Wallet`\n    /// @param wallet `Wallet` address\n    event WalletCreated(address indexed caller, address indexed owner, address wallet);\n\n    /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Initializes new WalletFactory\n    /// @param registry registry contract\n    constructor(Registry registry) {\n        // Store registry contract\n        REGISTRY = registry;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Creates new `Wallet` initially owned by `owner`\n    /// @param initialOwner initial owner\n    /// @return newly-created `Wallet` address\n    function createWallet(address initialOwner) external returns (address) {\n        // Create new wallet\n        Wallet wallet = new Wallet(REGISTRY, initialOwner);\n\n        // Track created wallet\n        wallets[address(wallet)] = true;\n\n        // Emit wallet creation\n        emit WalletCreated(msg.sender, initialOwner, address(wallet));\n\n        // Return created wallet address\n        return address(wallet);\n    }\n\n    /// @notice Checks if an address is a valid `Wallet` created by this `WalletFactory`\n    /// @param wallet address to check\n    /// @return `true` if `wallet` is a valid `Wallet`, else `false`\n    function isValidWallet(address wallet) external view returns (bool) {\n        return wallets[wallet];\n    }\n}\n"
    },
    "lib/solady/src/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Reentrancy guard mixin.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ReentrancyGuard.sol)\nabstract contract ReentrancyGuard {\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Unauthorized reentrant call.\n    error Reentrancy();\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                          STORAGE                           */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Equivalent to: `uint72(bytes9(keccak256(\"_REENTRANCY_GUARD_SLOT\")))`.\n    /// 9 bytes is large enough to avoid collisions with lower slots,\n    /// but not too large to result in excessive bytecode bloat.\n    uint256 private constant _REENTRANCY_GUARD_SLOT = 0x929eee149b4bd21268;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                      REENTRANCY GUARD                      */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Guards a function from reentrancy.\n    modifier nonReentrant() virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if eq(sload(_REENTRANCY_GUARD_SLOT), address()) {\n                mstore(0x00, 0xab143c06) // `Reentrancy()`.\n                revert(0x1c, 0x04)\n            }\n            sstore(_REENTRANCY_GUARD_SLOT, address())\n        }\n        _;\n        /// @solidity memory-safe-assembly\n        assembly {\n            sstore(_REENTRANCY_GUARD_SLOT, codesize())\n        }\n    }\n\n    /// @dev Guards a view function from read-only reentrancy.\n    modifier nonReadReentrant() virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if eq(sload(_REENTRANCY_GUARD_SLOT), address()) {\n                mstore(0x00, 0xab143c06) // `Reentrancy()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _;\n    }\n}\n"
    },
    "src/utility/Coordinated.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.4;\n\nimport {Registry} from \"../Registry.sol\";\n\n/// @title Coordinated\n/// @notice Exposes utility modifier `onlyCoordinator` for coordinator-permissioned functions\n/// @dev Best used when implementing contract needs just a msg.sender check (and not call access to coordinator itself)\nabstract contract Coordinated {\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Coordinator contract address\n    /// @dev Private to prevent conflicting with similar public variables in namespace\n    /// @dev Immutable to prevent address changes given registry deployment is immutable\n    address private immutable COORDINATOR;\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Thrown if coordinator-permissioned function is called from non-coordinator address\n    /// @dev 4-byte signature: `0x9ec853e6`\n    error NotCoordinator();\n\n    /*//////////////////////////////////////////////////////////////\n                               MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Allows calls from only the coordinator\n    modifier onlyCoordinator() {\n        if (msg.sender != COORDINATOR) {\n            revert NotCoordinator();\n        }\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Initializes new Coordinated\n    /// @param registry registry contract\n    constructor(Registry registry) {\n        // Collect coordinator address from registry\n        COORDINATOR = registry.COORDINATOR();\n    }\n}\n"
    },
    "lib/solady/src/auth/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\n///\n/// @dev Note:\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\n///\n/// While the ownable portion follows\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\nabstract contract Ownable {\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev The caller is not authorized to call the function.\n    error Unauthorized();\n\n    /// @dev The `newOwner` cannot be the zero address.\n    error NewOwnerIsZeroAddress();\n\n    /// @dev The `pendingOwner` does not have a valid handover request.\n    error NoHandoverRequest();\n\n    /// @dev Cannot double-initialize.\n    error AlreadyInitialized();\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                           EVENTS                           */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\n    /// despite it not being as lightweight as a single argument event.\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n\n    /// @dev An ownership handover to `pendingOwner` has been requested.\n    event OwnershipHandoverRequested(address indexed pendingOwner);\n\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\n\n    /// @dev `keccak256(bytes(\"OwnershipTransferred(address,address)\"))`.\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverRequested(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverCanceled(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                          STORAGE                           */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev The owner slot is given by:\n    /// `bytes32(~uint256(uint32(bytes4(keccak256(\"_OWNER_SLOT_NOT\")))))`.\n    /// It is intentionally chosen to be a high value\n    /// to avoid collision with lower slots.\n    /// The choice of manual storage layout is to enable compatibility\n    /// with both regular and upgradeable contracts.\n    bytes32 internal constant _OWNER_SLOT =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927;\n\n    /// The ownership handover slot of `newOwner` is given by:\n    /// ```\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\n    ///     let handoverSlot := keccak256(0x00, 0x20)\n    /// ```\n    /// It stores the expiry timestamp of the two-step ownership handover.\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                     INTERNAL FUNCTIONS                     */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Override to return true to make `_initializeOwner` prevent double-initialization.\n    function _guardInitializeOwner() internal pure virtual returns (bool guard) {}\n\n    /// @dev Initializes the owner directly without authorization guard.\n    /// This function must be called upon initialization,\n    /// regardless of whether the contract is upgradeable or not.\n    /// This is to enable generalization to both regular and upgradeable contracts,\n    /// and to save gas in case the initial owner is not the caller.\n    /// For performance reasons, this function will not check if there\n    /// is an existing owner.\n    function _initializeOwner(address newOwner) internal virtual {\n        if (_guardInitializeOwner()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                if sload(ownerSlot) {\n                    mstore(0x00, 0x0dc149f0) // `AlreadyInitialized()`.\n                    revert(0x1c, 0x04)\n                }\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Store the new value.\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Store the new value.\n                sstore(_OWNER_SLOT, newOwner)\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n            }\n        }\n    }\n\n    /// @dev Sets the owner directly without authorization guard.\n    function _setOwner(address newOwner) internal virtual {\n        if (_guardInitializeOwner()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n                // Store the new value.\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n                // Store the new value.\n                sstore(ownerSlot, newOwner)\n            }\n        }\n    }\n\n    /// @dev Throws if the sender is not the owner.\n    function _checkOwner() internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the caller is not the stored owner, revert.\n            if iszero(eq(caller(), sload(_OWNER_SLOT))) {\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\n    /// Override to return a different value if needed.\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\n        return 48 * 3600;\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(shl(96, newOwner)) {\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _setOwner(newOwner);\n    }\n\n    /// @dev Allows the owner to renounce their ownership.\n    function renounceOwnership() public payable virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /// @dev Request a two-step ownership handover to the caller.\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\n    function requestOwnershipHandover() public payable virtual {\n        unchecked {\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Compute and set the handover slot to `expires`.\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\n                mstore(0x00, caller())\n                sstore(keccak256(0x0c, 0x20), expires)\n                // Emit the {OwnershipHandoverRequested} event.\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\n            }\n        }\n    }\n\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\n    function cancelOwnershipHandover() public payable virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x20), 0)\n            // Emit the {OwnershipHandoverCanceled} event.\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\n        }\n    }\n\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            let handoverSlot := keccak256(0x0c, 0x20)\n            // If the handover does not exist, or has expired.\n            if gt(timestamp(), sload(handoverSlot)) {\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\n                revert(0x1c, 0x04)\n            }\n            // Set the handover slot to 0.\n            sstore(handoverSlot, 0)\n        }\n        _setOwner(pendingOwner);\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                   PUBLIC READ FUNCTIONS                    */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns the owner of the contract.\n    function owner() public view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_OWNER_SLOT)\n        }\n    }\n\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\n    function ownershipHandoverExpiresAt(address pendingOwner)\n        public\n        view\n        virtual\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the handover slot.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            // Load the handover slot.\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                         MODIFIERS                          */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Marks a function as only callable by the owner.\n    modifier onlyOwner() virtual {\n        _checkOwner();\n        _;\n    }\n}\n"
    },
    "lib/solady/src/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Permit2 operations from (https://github.com/Uniswap/permit2/blob/main/src/libraries/Permit2Lib.sol)\n///\n/// @dev Note:\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\n/// - For ERC20s, this implementation won't check that a token has code,\n///   responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev The ETH transfer has failed.\n    error ETHTransferFailed();\n\n    /// @dev The ERC20 `transferFrom` has failed.\n    error TransferFromFailed();\n\n    /// @dev The ERC20 `transfer` has failed.\n    error TransferFailed();\n\n    /// @dev The ERC20 `approve` has failed.\n    error ApproveFailed();\n\n    /// @dev The Permit2 operation has failed.\n    error Permit2Failed();\n\n    /// @dev The Permit2 amount must be less than `2**160 - 1`.\n    error Permit2AmountOverflow();\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                         CONSTANTS                          */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\n\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\n    /// storage reads and writes, but low enough to prevent griefing.\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\n\n    /// @dev The unique EIP-712 domain domain separator for the DAI token contract.\n    bytes32 internal constant DAI_DOMAIN_SEPARATOR =\n        0xdbb8cf42e1ecb028be3f3dbc922e1d878b963f411dc388ced501601c60f7c6f7;\n\n    /// @dev The address for the WETH9 contract on Ethereum mainnet.\n    address internal constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /// @dev The canonical Permit2 address.\n    /// [Github](https://github.com/Uniswap/permit2)\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\n    address internal constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                       ETH OPERATIONS                       */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\n    //\n    // The regular variants:\n    // - Forwards all remaining gas to the target.\n    // - Reverts if the target reverts.\n    // - Reverts if the current contract has insufficient balance.\n    //\n    // The force variants:\n    // - Forwards with an optional gas stipend\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\n    // - If the target reverts, or if the gas stipend is exhausted,\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\n    // - Reverts if the current contract has insufficient balance.\n    //\n    // The try variants:\n    // - Forwards with a mandatory gas stipend.\n    // - Instead of reverting, returns whether the transfer succeeded.\n\n    /// @dev Sends `amount` (in wei) ETH to `to`.\n    function safeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Sends all the ETH in the current contract to `to`.\n    function safeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer all the ETH and check if it succeeded or not.\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\n    function forceSafeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\n    function forceSafeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // forgefmt: disable-next-item\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\n        }\n    }\n\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                      ERC20 OPERATIONS                      */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for\n    /// the current contract to manage.\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    ///\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\n    function trySafeTransferFrom(address token, address from, address to, uint256 amount)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            success :=\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have their entire balance approved for the current contract to manage.\n    function safeTransferAllFrom(address token, address from, address to)\n        internal\n        returns (uint256 amount)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\n            // Perform the transfer, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransfer(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\n            mstore(0x20, address()) // Store the address of the current contract.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x14, to) // Store the `to` argument.\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// Reverts upon failure.\n    function safeApprove(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            // Perform the approval, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\n    /// Reverts upon failure.\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            // Perform the approval, retrying upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                mstore(0x34, 0) // Store 0 for the `amount`.\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\n                mstore(0x34, amount) // Store back the original `amount`.\n                // Retry the approval, reverting upon failure.\n                if iszero(\n                    and(\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                    )\n                ) {\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\n    /// Returns zero if the `token` does not exist.\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, account) // Store the `account` argument.\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            amount :=\n                mul( // The arguments of `mul` are evaluated from right to left.\n                    mload(0x20),\n                    and( // The arguments of `and` are evaluated from right to left.\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\n                    )\n                )\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// If the initial attempt fails, try to use Permit2 to transfer the token.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\n    function safeTransferFrom2(address token, address from, address to, uint256 amount) internal {\n        if (!trySafeTransferFrom(token, from, to, amount)) {\n            permit2TransferFrom(token, from, to, amount);\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to` via Permit2.\n    /// Reverts upon failure.\n    function permit2TransferFrom(address token, address from, address to, uint256 amount)\n        internal\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 0x74), shr(96, shl(96, token)))\n            mstore(add(m, 0x54), amount)\n            mstore(add(m, 0x34), to)\n            mstore(add(m, 0x20), shl(96, from))\n            // `transferFrom(address,address,uint160,address)`.\n            mstore(m, 0x36c78516000000000000000000000000)\n            let p := PERMIT2\n            let exists := eq(chainid(), 1)\n            if iszero(exists) { exists := iszero(iszero(extcodesize(p))) }\n            if iszero(and(call(gas(), p, 0, add(m, 0x10), 0x84, codesize(), 0x00), exists)) {\n                mstore(0x00, 0x7939f4248757f0fd) // `TransferFromFailed()` or `Permit2AmountOverflow()`.\n                revert(add(0x18, shl(2, iszero(iszero(shr(160, amount))))), 0x04)\n            }\n        }\n    }\n\n    /// @dev Permit a user to spend a given amount of\n    /// another user's tokens via native EIP-2612 permit if possible, falling\n    /// back to Permit2 if native permit fails or is not implemented on the token.\n    function permit2(\n        address token,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        bool success;\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} shl(96, xor(token, WETH9)) {} {\n                mstore(0x00, 0x3644e515) // `DOMAIN_SEPARATOR()`.\n                if iszero(\n                    and( // The arguments of `and` are evaluated from right to left.\n                        lt(iszero(mload(0x00)), eq(returndatasize(), 0x20)), // Returns 1 non-zero word.\n                        // Gas stipend to limit gas burn for tokens that don't refund gas when\n                        // an non-existing function is called. 5K should be enough for a SLOAD.\n                        staticcall(5000, token, 0x1c, 0x04, 0x00, 0x20)\n                    )\n                ) { break }\n                // After here, we can be sure that token is a contract.\n                let m := mload(0x40)\n                mstore(add(m, 0x34), spender)\n                mstore(add(m, 0x20), shl(96, owner))\n                mstore(add(m, 0x74), deadline)\n                if eq(mload(0x00), DAI_DOMAIN_SEPARATOR) {\n                    mstore(0x14, owner)\n                    mstore(0x00, 0x7ecebe00000000000000000000000000) // `nonces(address)`.\n                    mstore(add(m, 0x94), staticcall(gas(), token, 0x10, 0x24, add(m, 0x54), 0x20))\n                    mstore(m, 0x8fcbaf0c000000000000000000000000) // `IDAIPermit.permit`.\n                    // `nonces` is already at `add(m, 0x54)`.\n                    // `1` is already stored at `add(m, 0x94)`.\n                    mstore(add(m, 0xb4), and(0xff, v))\n                    mstore(add(m, 0xd4), r)\n                    mstore(add(m, 0xf4), s)\n                    success := call(gas(), token, 0, add(m, 0x10), 0x104, codesize(), 0x00)\n                    break\n                }\n                mstore(m, 0xd505accf000000000000000000000000) // `IERC20Permit.permit`.\n                mstore(add(m, 0x54), amount)\n                mstore(add(m, 0x94), and(0xff, v))\n                mstore(add(m, 0xb4), r)\n                mstore(add(m, 0xd4), s)\n                success := call(gas(), token, 0, add(m, 0x10), 0xe4, codesize(), 0x00)\n                break\n            }\n        }\n        if (!success) simplePermit2(token, owner, spender, amount, deadline, v, r, s);\n    }\n\n    /// @dev Simple permit on the Permit2 contract.\n    function simplePermit2(\n        address token,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, 0x927da105) // `allowance(address,address,address)`.\n            {\n                let addressMask := shr(96, not(0))\n                mstore(add(m, 0x20), and(addressMask, owner))\n                mstore(add(m, 0x40), and(addressMask, token))\n                mstore(add(m, 0x60), and(addressMask, spender))\n                mstore(add(m, 0xc0), and(addressMask, spender))\n            }\n            let p := mul(PERMIT2, iszero(shr(160, amount)))\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x5f), // Returns 3 words: `amount`, `expiration`, `nonce`.\n                    staticcall(gas(), p, add(m, 0x1c), 0x64, add(m, 0x60), 0x60)\n                )\n            ) {\n                mstore(0x00, 0x6b836e6b8757f0fd) // `Permit2Failed()` or `Permit2AmountOverflow()`.\n                revert(add(0x18, shl(2, iszero(p))), 0x04)\n            }\n            mstore(m, 0x2b67b570) // `Permit2.permit` (PermitSingle variant).\n            // `owner` is already `add(m, 0x20)`.\n            // `token` is already at `add(m, 0x40)`.\n            mstore(add(m, 0x60), amount)\n            mstore(add(m, 0x80), 0xffffffffffff) // `expiration = type(uint48).max`.\n            // `nonce` is already at `add(m, 0xa0)`.\n            // `spender` is already at `add(m, 0xc0)`.\n            mstore(add(m, 0xe0), deadline)\n            mstore(add(m, 0x100), 0x100) // `signature` offset.\n            mstore(add(m, 0x120), 0x41) // `signature` length.\n            mstore(add(m, 0x140), r)\n            mstore(add(m, 0x160), s)\n            mstore(add(m, 0x180), shl(248, v))\n            if iszero(call(gas(), p, 0, add(m, 0x1c), 0x184, codesize(), 0x00)) {\n                mstore(0x00, 0x6b836e6b) // `Permit2Failed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "solady/=lib/solady/src/",
      "forge-std/=lib/forge-std/src/",
      "weird-erc20/=lib/weird-erc20/src/",
      "ds-test/=lib/forge-std/lib/ds-test/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "evmVersion": "paris",
    "viaIR": true,
    "libraries": {}
  }
}}