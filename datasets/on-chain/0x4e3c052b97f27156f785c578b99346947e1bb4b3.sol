{{
  "language": "Solidity",
  "sources": {
    "lib/multisig/src/Constants.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\n/// @dev Constant variable for zero.\nuint256 constant ZERO = 0;\n/// @dev Constant variable for one.\nuint256 constant ONE = 1;\n/// @dev Requires a minimum number of guardians when creating a multisig wallet or updating the signer set.\nuint8 constant MINIMUM_GUARDIANS = 2;\n/// @dev EIP712 typehash for a transaction to execute by the wallet\nbytes32 constant TRANSACTION_TYPEHASH = keccak256(\"Transaction(uint256 nonce,address to,uint256 value,bytes data)\");\n/// @dev EIP712 typehash for a batch transaction to execute by the wallet\nbytes32 constant BATCH_TRANSACTION_TYPEHASH = keccak256(\"BatchTransaction(Transaction[] transactions)Transaction(uint256 nonce,address to,uint256 value,bytes data)\");\n/// @dev EIP712 typehash for a cross chain transaction to execute by the wallet\nbytes32 constant CROSS_CHAIN_TRANSACTION_TYPEHASH = keccak256(\"CrossChainTransaction(uint256 bucket,uint256 nonce,address to,uint256 value,bytes data)\");\n/// @dev EIP712 typehash for updating to a new signer set\nbytes32 constant SIGNER_SET_TYPEHASH = keccak256(\"SignerSet(uint32 currentSignerSetId,uint256 threshold,address[] signers,address[] guardians)\");\n\n/// @dev Function selector to handle onERC1155Received calls in fallback\nbytes4 constant SELECTOR_ON_ERC1155_RECEIVED = 0xf23a6e61;\n/// @dev Return value when handling onERC1155Received calls in fallback\nbytes constant RETURN_DATA_ON_ERC1155_RECEIVED = hex\"f23a6e6100000000000000000000000000000000000000000000000000000000\";\n/// @dev Function selector to handle onERC1155BatchReceived calls in fallback\nbytes4 constant SELECTOR_ON_ERC1155_BATCH_RECEIVED = 0xbc197c81;\n/// @dev Return value when handling onERC1155BatchReceived calls in fallback\nbytes constant RETURN_DATA_ON_ERC1155_BATCH_RECEIVED = hex\"bc197c8100000000000000000000000000000000000000000000000000000000\";\n/// @dev Function selector to handle onERC721Received calls in fallback\nbytes4 constant SELECTOR_ON_ERC721_RECEIVED = 0x150b7a02;\n/// @dev Return value when handling onERC721Received calls in fallback\nbytes constant RETURN_DATA_ON_ERC721_RECEIVED = hex\"150b7a0200000000000000000000000000000000000000000000000000000000\";"
    },
    "lib/multisig/src/DataTypes.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"@limitbreak/tm-core-lib/src/utils/structs/EnumerableSet.sol\";\n\n/// @dev Storage for a set of signers with threshold\nstruct SignerSet {\n    uint32 id;\n    uint32 threshold;\n    EnumerableSet.AddressSet signers;\n    EnumerableSet.AddressSet guardians;\n}\n\n/// @dev Struct for signer's signatures when executing transactions\nstruct SignatureECDSA {\n    uint256 v;\n    bytes32 r;\n    bytes32 s;\n}\n\n/// @dev Struct for batched transaction data\nstruct BatchedTransaction {\n    address to;\n    uint256 value;\n    bytes data;\n}\n\n/// @dev Struct for batched transaction data\nstruct CrossChainTransaction {\n    uint256 bucket;\n    address to;\n    uint256 value;\n    bytes data;\n}\n\n/// @dev Struct to store state and return value for fallback returns\nstruct FallbackReturn {\n    bool enabled;\n    bytes returnData;\n}"
    },
    "lib/multisig/src/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/EIP712.sol)\n\npragma solidity 0.8.24;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the `_domainSeparatorV4` function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * _Available since v3.4._\n *\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n */\nabstract contract EIP712 {\n    bytes32 private constant _CHAIN_TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n    bytes32 private constant _CHAINLESS_TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,address verifyingContract)\");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedChainDomainSeparator;\n    bytes32 private immutable _cachedChainlessDomainSeparator;\n    uint256 private immutable _cachedChainId;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedChainDomainSeparator = _buildChainDomainSeparator();\n        _cachedChainlessDomainSeparator = _buildChainlessDomainSeparator();\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _chainDomainSeparator() internal view returns (bytes32 domainSeparator) {\n        if (block.chainid == _cachedChainId) {\n            domainSeparator = _cachedChainDomainSeparator;\n        } else {\n            domainSeparator = _buildChainDomainSeparator();\n        }\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _chainlessDomainSeparator() internal view returns (bytes32 domainSeparator) {\n        domainSeparator = _cachedChainlessDomainSeparator;\n    }\n\n    function _buildChainDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(_CHAIN_TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    function _buildChainlessDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(_CHAINLESS_TYPE_HASH, _hashedName, _hashedVersion, address(this)));\n    }\n\n    function _hashChainTypedData(bytes32 structHash) internal view virtual returns (bytes32 hash) {\n        hash = _toTypedDataHash(_chainDomainSeparator(), structHash);\n    }\n\n    function _hashChainlessTypedData(bytes32 structHash) internal view virtual returns (bytes32 hash) {\n        hash = _toTypedDataHash(_chainlessDomainSeparator(), structHash);\n    }\n\n    function _toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n}"
    },
    "lib/multisig/src/Errors.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\n/// @dev Thrown when setting a fallback return data and the caller is not the wallet\nerror MultisigWallet__CallerMustBeWallet();\n/// @dev Thrown when executing a transaction and the call reverts\nerror MultisigWallet__CallReverted(bytes result);\n/// @dev Thrown when a call with no value is not handled by the fallback function\nerror MultisigWallet__FallbackNotHandled();\n/// @dev Thrown when executing a batch transaction or signer set update and array lengths do not match or are zero length\nerror MultisigWallet__InvalidArrayLengths();\n/// @dev Thrown when validating signatures and a signer is not in the current signer set or signatures are not ordered by signer ascending\nerror MultisigWallet__InvalidSignatures();\n/// @dev Thrown when updating a signer set and the number of guardians is less than `MINIMUM_GUARDIANS` or guardians are not ordered by their address ascending\nerror MultisigWallet__InvalidGuardianSet();\n/// @dev Thrown when updating a signer set and the number of signers is less than threshold or signers are not ordered by signer ascending\nerror MultisigWallet__InvalidSignerSet();\n/// @dev Thrown when a signature V value exceeds type(uint8).max\nerror MultisigWallet__InvalidV();\n/// @dev Thrown when validating signatures and the number of signatures submitted is less than the threshold\nerror MultisigWallet__NotEnoughSignatures();\n/// @dev Thrown when execute a cross chain transaction and the to address does not have deployed code\nerror MultisigWallet__ToHasNoCode();"
    },
    "lib/multisig/src/MultisigWallet.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\nimport \"./EIP712.sol\";\nimport \"./Constants.sol\";\nimport \"./DataTypes.sol\";\nimport \"./Errors.sol\";\nimport \"@limitbreak/tm-core-lib/src/utils/security/TstorishReentrancyGuard.sol\";\n\n/**\n * @title  MultisigWallet\n * @author Limit Break, Inc.\n * @notice The MultisigWallet contract is designed to allow authorized signers to\n *         execute transactions when the number of signatures meets or exceeds the \n *         wallet's threshold for execution.\n * \n * @dev    A MultisigWallet's signer set has three components:\n *         - Signers - List of addresses that may sign a transaction or signer set replacement\n *         - Guardians - List of addresses, one of which *MUST* sign a signer set replacement\n *         - Threshold - The minimum number of signers required to execute a transaction\n * \n * @dev    Signer set replacement is implemented through EIP-712 signatures that \n *         *DO NOT* use the `chainId` in the domain separator. This is to allow a \n *         signer set chain on one chain to be applied across all chains that the \n *         wallet is deployed to and for a \"new chain\" to \"catch up\" to the current\n *         signer set without having to re-sign the changes with the initial signers.\n */\ncontract MultisigWallet is EIP712, TstorishReentrancyGuard {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @dev Current signer set data\n    SignerSet private signerSet;\n    /// @dev Current wallet nonce, transactions must be signed with the current nonce to execute\n    uint256 public currentNonce;\n    /// @dev Mapping of cross chain nonce buckets to their current nonce\n    mapping (uint256 => uint256) public crossChainNonceBuckets;\n    /// @dev Mapping of selectors to return values for adding support of token protocols that use basic transfer checks on addresses with code\n    mapping (bytes4 => FallbackReturn) public fallbackReturns;\n\n    /// @dev Emitted when a batch transaction is executed\n    event BatchTransactionExecuted(bytes32 indexed batchTxHash, bytes[] results);\n    /// @dev Emitted when a fallback return is updated\n    event FallbackReturnUpdated(bytes4 indexed selector, bool enabled, bytes returnData);\n    /// @dev Emitted when the signer set is replaced\n    event SignerSetReplaced(uint32 newSignerSetId, uint32 newThreshold, address[] newSignerAddresses, address[] newGuardianAddresses);\n    /// @dev Emitted when a transaction is executed\n    event TransactionExecuted(bytes32 indexed txHash, bytes result);\n\n\n    /**\n     * @dev Construct the multisig wallet with the supplied list of initial signers and signature threshold.\n     * \n     * @dev Throws when the number of signers is less than the threshold.\n     * @dev Throws when the signers are not supplied in ascending order.\n     * \n     * @param threshold                 Number of signatures required to execute a transaction.\n     * @param signers                   List of initial signers.\n     * @param guardians                 List of initial guardians.\n     * @param fallbackReturnSelectors   Array of function selectors to return a value for in the fallback.\n     * @param fallbackReturnData        Array of data to return for each function signature in the fallback.\n     */\n    constructor(\n        uint256 threshold,\n        address[] memory signers,\n        address[] memory guardians,\n        bytes4[] memory fallbackReturnSelectors,\n        bytes[] memory fallbackReturnData\n    ) TstorishReentrancyGuard() EIP712(\"MultisigWallet\", \"1\") {\n        _setSignerSet(signers, threshold);\n        _setGuardianSet(guardians);\n\n        uint256 fallbackReturnSelectorsLength = fallbackReturnSelectors.length;\n        if (fallbackReturnSelectorsLength != fallbackReturnData.length) {\n            revert MultisigWallet__InvalidArrayLengths();\n        }\n\n        for (uint256 i; i < fallbackReturnSelectorsLength; ++i) {\n            bytes4 fallbackReturnSelector = fallbackReturnSelectors[i];\n            bytes memory fallbackReturn = fallbackReturnData[i];\n            fallbackReturns[fallbackReturnSelector] = FallbackReturn({\n                enabled: true,\n                returnData: fallbackReturn\n            });\n            emit FallbackReturnUpdated(fallbackReturnSelector, true, fallbackReturn);\n        }\n\n        fallbackReturns[SELECTOR_ON_ERC1155_RECEIVED] = FallbackReturn({\n            enabled: true,\n            returnData: RETURN_DATA_ON_ERC1155_RECEIVED\n        });\n        emit FallbackReturnUpdated(SELECTOR_ON_ERC1155_RECEIVED, true, RETURN_DATA_ON_ERC1155_RECEIVED);\n        fallbackReturns[SELECTOR_ON_ERC1155_BATCH_RECEIVED] = FallbackReturn({\n            enabled: true,\n            returnData: RETURN_DATA_ON_ERC1155_BATCH_RECEIVED\n        });\n        emit FallbackReturnUpdated(SELECTOR_ON_ERC1155_BATCH_RECEIVED, true, RETURN_DATA_ON_ERC1155_BATCH_RECEIVED);\n        fallbackReturns[SELECTOR_ON_ERC721_RECEIVED] = FallbackReturn({\n            enabled: true,\n            returnData: RETURN_DATA_ON_ERC721_RECEIVED\n        });\n        emit FallbackReturnUpdated(SELECTOR_ON_ERC721_RECEIVED, true, RETURN_DATA_ON_ERC721_RECEIVED);\n    }\n\n    /**\n     * @notice Executes a transaction from the multisig wallet when properly signed.\n     * \n     * @dev    Throws when there are not enough signatures supplied for the current threshold.\n     * @dev    Throws when the recovered address for a signature is not in the current signer set.\n     * @dev    Throws when signatures are supplied where the signer order is not ascending.\n     * @dev    Throws when the call from the multisig to the `to` address reverts.\n     * \n     * @dev    <h4>Postconditions:</h4>\n     * @dev    1. This contract's native token balance has increased by `msg.value`.\n     * @dev    2. `currentNonce` is incremented by one.\n     * @dev    3. This contract's native token balance is decreased by `value`.\n     * @dev    4. A call is made to `to` with a message value of `value` and calldata of `data`.\n     * @dev    5. A `TransactionExecuted` event has been emitted.  The EIP712 transaction hash and call return data is logged in the event.\n     * \n     * @param to          Address to call.\n     * @param value       Value to send to the `to` address.\n     * @param data        Calldata to send to the `to` address.\n     * @param signatures  Array of signature values from the multisig signers.\n     */\n    function executeTransaction(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        SignatureECDSA[] calldata signatures\n    ) external payable nonReentrant {\n        unchecked {\n            bytes32 txHash = _getTransactionHash(\n                currentNonce++,\n                to,\n                value,\n                data\n            );\n            _checkSignatures(txHash, signatures);\n\n            (bool success, bytes memory result) = to.call{value: value}(data);\n            if (success) {\n                emit TransactionExecuted(txHash, result);\n            } else {\n                revert MultisigWallet__CallReverted(result);\n            }\n        }\n    }\n\n    /**\n     * @notice Executes a batch of transactions from the multisig wallet when properly signed.\n     * \n     * @dev    Throws when the batch array lengths are zero or do not match.\n     * @dev    Throws when there are not enough signatures supplied for the current threshold.\n     * @dev    Throws when the recovered address for a signature is not in the current signer set.\n     * @dev    Throws when signatures are supplied where the signer order is not ascending.\n     * @dev    Throws when the call from the multisig to the `to` address reverts.\n     * \n     * @dev    <h4>Postconditions:</h4>\n     * @dev    1. This contract's native token balance has increased by `msg.value`.\n     * @dev    2. `currentNonce` is incremented by the number of transactions in the batch.\n     * @dev    3. This contract's native token balance is decreased by the sum of values in `transactions`.\n     * @dev    4. Calls are made to each address in `transactions` with the corresponding `data` and `value`.\n     * @dev    5. A `BatchTransactionExecuted` event has been emitted.  The EIP712 transaction hash and call return data is logged in the event.\n     * \n     * @param transactions  Array of transactions to execute.\n     * @param signatures    Array of signature values from the multisig signers.\n     */\n    function executeBatchTransaction(\n        BatchedTransaction[] calldata transactions,\n        SignatureECDSA[] calldata signatures\n    ) external payable nonReentrant {\n        if (transactions.length == 0) {\n            revert MultisigWallet__InvalidArrayLengths();\n        }\n\n        unchecked {\n            uint256 cachedNonce = currentNonce;\n            bytes32[] memory txHashes = new bytes32[](transactions.length);\n            bytes[] memory txResults = new bytes[](transactions.length);\n\n            address to;\n            uint256 value;\n            bytes calldata data;\n            BatchedTransaction calldata transaction;\n            for (uint256 i; i < transactions.length; ++i) {\n                transaction = transactions[i];\n                to = transaction.to;\n                value = transaction.value;\n                data = transaction.data;\n\n                bytes32 txHash = _getTransactionHashForBatch(\n                    cachedNonce++,\n                    to,\n                    value,\n                    data\n                );\n                txHashes[i] = txHash;\n\n                (bool success, bytes memory result) = to.call{value: value}(data);\n                if (success) {\n                    txResults[i] = result;\n                } else {\n                    revert MultisigWallet__CallReverted(result);\n                }\n            }\n\n            currentNonce = cachedNonce;\n            bytes32 batchTxHash = _getBatchTransactionHashFromTxHashes(txHashes);\n\n            _checkSignatures(batchTxHash, signatures);\n            emit BatchTransactionExecuted(batchTxHash, txResults);\n        }\n    }\n\n    /**\n     * @notice Executes a transaction from the multisig wallet when properly signed.\n     * \n     * @dev    Cross chain transactions are signed with a domain separator that does not include\n     *         the chainId so that they may be replayed across all chains the multisig wallet is\n     *         deployed to.\n     * \n     * @dev    Throws when the cross chain nonce has already been consumed.\n     * @dev    Throws when there are not enough signatures supplied for the current threshold.\n     * @dev    Throws when the recovered address for a signature is not in the current signer set.\n     * @dev    Throws when signatures are supplied where the signer order is not ascending.\n     * @dev    Throws when a call from the multisig reverts.\n     * \n     * @dev    <h4>Postconditions:</h4>\n     * @dev    1. This contract's native token balance has increased by `msg.value`.\n     * @dev    2. Each nonce in `transactions` is consumed in the `consumedCrossChainNonces` mapping.\n     * @dev    3. This contract's native token balance is decreased by the sum of values in `transactions`.\n     * @dev    4. Calls are made to each address in `transactions` with the corresponding `data` and `value`.\n     * @dev    5. A `TransactionExecuted` event has been emitted for each transaction.\n     *            The EIP712 transaction hash and call return data is logged in the event.\n     * \n     * @param transactions  Array of cross chain transactions to execute.     \n     * @param signatures    Array of signature values from the multisig signers.\n     */\n    function executeCrossChainTransactions(\n        CrossChainTransaction[] calldata transactions,\n        SignatureECDSA[][] calldata signatures\n    ) external payable nonReentrant {\n        if (transactions.length == 0 || transactions.length != signatures.length) {\n            revert MultisigWallet__InvalidArrayLengths();\n        }\n\n        unchecked {\n            CrossChainTransaction calldata transaction;\n            SignatureECDSA[] calldata txSignatures;\n            uint256 bucket;\n            address to;\n            uint256 value;\n            bytes calldata data;\n\n            for (uint256 i; i < transactions.length; ++i) {\n                transaction = transactions[i];\n                txSignatures = signatures[i];\n                bucket = transaction.bucket;\n                to = transaction.to;\n                value = transaction.value;\n                data = transaction.data;\n\n                if (to.code.length == 0) {\n                    revert MultisigWallet__ToHasNoCode();\n                }\n\n                bytes32 txHash = _getCrossChainTransactionHash(\n                    bucket,\n                    crossChainNonceBuckets[bucket]++,\n                    to,\n                    value,\n                    data\n                );\n                _checkSignatures(txHash, txSignatures);\n\n                (bool success, bytes memory result) = to.call{value: value}(data);\n                if (success) {\n                    emit TransactionExecuted(txHash, result);\n                } else {\n                    revert MultisigWallet__CallReverted(result);\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Updates the signer set with a new list of signers.\n     * \n     * @dev    Throws when there are not enough signatures supplied for the current threshold.\n     * @dev    Throws when the recovered address for a signature is not in the current signer set.\n     * @dev    Throws when signatures are supplied where the signer order is not ascending.\n     * @dev    Throws when the number of new signers is less than the new threshold.\n     * @dev    Throws when the new signers are not supplied in ascending order.\n     * @dev    Throws when the recovered address for the guardian signature is not in the current guardian set.\n     * \n     * @dev    <h4>Postconditions:</h4>\n     * @dev    1. The new signers, guardians and threshold are stored.\n     * @dev    2. A `SignerSetReplaced` event has been emitted.\n     * \n     * @param threshold          Number of signers required to execute a transaction.\n     * @param signers            Array of signer addresses allowed to sign a transaction.\n     * @param guardians          Array of guardian addresses allowed to sign the next signer set update.\n     * @param signatures         Array of signature values from the multisig signers.\n     * @param guardianSignature  Signature from a guardian authorizing this signer set change.\n     */\n    function setSignerSet(\n        uint256 threshold,\n        address[] calldata signers,\n        address[] calldata guardians,\n        SignatureECDSA[] calldata signatures,\n        SignatureECDSA calldata guardianSignature\n    ) external {\n        uint32 currentSignerSetId = signerSet.id;\n        bytes32 signerSetHash = _getSignerSetHash(currentSignerSetId, threshold, signers, guardians);\n        _checkSignatures(signerSetHash, signatures);\n        _checkGuardianSignature(signerSetHash, guardianSignature);\n        _setSignerSet(signers, threshold);\n        _setGuardianSet(guardians);\n        unchecked {\n            signerSet.id = ++currentSignerSetId;\n        }\n        emit SignerSetReplaced(currentSignerSetId, uint32(threshold), signers, guardians);\n    }\n\n    /**\n     * @notice Executes a batch of signer set updates.\n     * \n     * @dev    Primary use case for this function is to bring a multisig wallet up to the current\n     * @dev    signing set from a primary chain when the wallet is deployed on a new chain.\n     * \n     * @dev    Throws when the batch array lengths are zero or do not match.\n     * @dev    Throws when there are not enough signatures supplied for the current threshold.\n     * @dev    Throws when the recovered address for a signature is not in the current signer set.\n     * @dev    Throws when signatures are supplied where the signer order is not ascending.\n     * @dev    Throws when the number of new signers is less than the new threshold.\n     * @dev    Throws when the new signers are not supplied in ascending order.\n     * @dev    Throws when the recovered address for the guardian signature is not in the current guardian set.\n     * \n     * @dev    <h4>Postconditions:</h4>\n     * @dev    1. The new signers, guardians and threshold are stored.\n     * @dev    2. A `SignerSetReplaced` event has been emitted.\n     * \n     * @param batchThreshold          Array of number of signers required to execute a transaction.\n     * @param batchSigners            Array of signer addresses allowed to sign a transaction.\n     * @param batchGuardians          Array of guardian addresses allowed to sign the next signer set update.\n     * @param batchSignatures         Array of signature values from the multisig signers.\n     * @param batchGuardianSignature  Array of signatures from a guardian authorizing this signer set change.\n     */\n    function batchSetSignerSet(\n        uint256[] calldata batchThreshold,\n        address[][] calldata batchSigners,\n        address[][] calldata batchGuardians,\n        SignatureECDSA[][] calldata batchSignatures,\n        SignatureECDSA[] calldata batchGuardianSignature\n    ) external {\n        if (\n            batchThreshold.length == 0 ||\n            batchThreshold.length != batchSigners.length ||\n            batchSigners.length != batchGuardians.length ||\n            batchGuardians.length != batchSignatures.length ||\n            batchSignatures.length != batchGuardianSignature.length\n        ) {\n            revert MultisigWallet__InvalidArrayLengths();\n        }\n\n        unchecked {\n            uint32 currentSignerSetId = signerSet.id;\n            for (uint256 i; i < batchThreshold.length; ++i) {\n                bytes32 signerSetHash = _getSignerSetHash(currentSignerSetId, batchThreshold[i], batchSigners[i], batchGuardians[i]);\n                _checkSignatures(signerSetHash, batchSignatures[i]);\n                _checkGuardianSignature(signerSetHash, batchGuardianSignature[i]);\n                _setSignerSet(batchSigners[i], batchThreshold[i]);\n                _setGuardianSet(batchGuardians[i]);\n                ++currentSignerSetId;\n            }\n            signerSet.id = currentSignerSetId;\n\n            uint256 lastIndex = batchThreshold.length - 1;\n            emit SignerSetReplaced(\n                currentSignerSetId,\n                uint32(batchThreshold[lastIndex]),\n                batchSigners[lastIndex],\n                batchGuardians[lastIndex]\n            );\n        }\n    }\n\n    /**\n     * @notice Sets a generic return value in bytes for a given function selector that is handled by the fallback.\n     * \n     * @dev    This function must be called through `executeTransaction` or `executeBatchTransaction`.\n     * \n     * @param selector    Function selector to supply return data for.\n     * @param enabled     True if the fallback should handle the function, false otherwise.\n     * @param returnData  Bytes of return data to return when the fallback handles a call for the selector.\n     */\n    function setFallbackReturnData(bytes4 selector, bool enabled, bytes calldata returnData) external {\n        if (msg.sender != address(this)) {\n            revert MultisigWallet__CallerMustBeWallet();\n        }\n\n        fallbackReturns[selector] = FallbackReturn({\n            enabled: enabled,\n            returnData: returnData\n        });\n\n        emit FallbackReturnUpdated(selector, enabled, returnData);\n    }\n\n    /**\n     * @notice Computes the EIP712 hash value that must be signed for a transaction by the multisig signers to execute.\n     * \n     * @dev    Uses a supplied nonce value so that transactions may be queued for signing and execution.\n     * \n     * @param nonce  The value the nonce should be when the transaction is executed.\n     * @param to     Address to call.\n     * @param value  Value to send to the `to` address.\n     * @param data   Calldata to send to the `to` address.\n     * \n     * @return hash  The computed EIP712 hash to be signed.\n     */\n    function getTransactionHash(\n        uint256 nonce,\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external view returns (bytes32 hash) {\n        hash = _getTransactionHash(nonce, to, value, data);\n    }\n\n    /**\n     * @notice Computes the EIP712 hash value that must be signed for a transaction by the multisig signers to execute.\n     * \n     * @dev    Uses the current nonce value for determining the transaction hash. \n     * \n     * @param to     Address to call.\n     * @param value  Value to send to the `to` address.\n     * @param data   Calldata to send to the `to` address.\n     * \n     * @return hash  The computed EIP712 hash to be signed.\n     */\n    function getTransactionHashWithCurrentNonce(\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external view returns (bytes32 hash) {\n        hash = _getTransactionHash(currentNonce, to, value, data);\n    }\n\n    /**\n     * @notice Computes the EIP712 hash value that must be signed for a transaction by the multisig signers to execute.\n     * \n     * @dev    Uses a supplied nonce value so that transactions may be queued for signing and execution.\n     * \n     * @param nonce       The value the nonce should be when the transaction is executed.\n     * @param transactions  Array of transactions to execute.\n     * \n     * @return hash  The computed EIP712 hash to be signed.\n     */\n    function getBatchTransactionHash(\n        uint256 nonce,\n        BatchedTransaction[] calldata transactions\n    ) external view returns (bytes32 hash) {\n        hash = _getBatchTransactionHash(nonce, transactions);\n    }\n\n    /**\n     * @notice Computes the EIP712 hash value that must be signed for a transaction by the multisig signers to execute.\n     * \n     * @dev    Uses the current nonce value for determining the transaction hash. \n     * \n     * @param transactions  Array of transactions to execute.\n     * \n     * @return hash  The computed EIP712 hash to be signed.\n     */\n    function getBatchTransactionHashWithCurrentNonce(\n        BatchedTransaction[] calldata transactions\n    ) external view returns (bytes32 hash) {\n        hash = _getBatchTransactionHash(currentNonce, transactions);\n    }\n\n    /**\n     * @notice Computes the EIP712 hash value that must be signed for a cross chain transaction by the multisig signers to execute.\n     * \n     * @param nonce       The value the nonce should be when the transaction is executed.\n     * @param transaction  The cross chain transaction to get the EIP712 hash for.\n     * \n     * @return hash  The computed EIP712 hash to be signed.\n     */\n    function getCrossChainTransactionHash(\n        uint256 nonce,\n        CrossChainTransaction calldata transaction\n    ) external view returns (bytes32 hash) {\n        hash = _getCrossChainTransactionHash(\n            transaction.bucket,\n            nonce,\n            transaction.to,\n            transaction.value,\n            transaction.data\n        );\n    }\n\n    /**\n     * @notice Computes the EIP712 hash value that must be signed for a cross chain transaction by the multisig signers to execute.\n     * \n     * @param transaction  The cross chain transaction to get the EIP712 hash for.\n     * \n     * @return hash  The computed EIP712 hash to be signed.\n     */\n    function getCrossChainTransactionHashWithCurrentNonce(\n        CrossChainTransaction calldata transaction\n    ) external view returns (bytes32 hash) {\n        hash = _getCrossChainTransactionHash(\n            transaction.bucket,\n            crossChainNonceBuckets[transaction.bucket],\n            transaction.to,\n            transaction.value,\n            transaction.data\n        );\n    }\n\n    /**\n     * @notice Computes the EIP712 hash value that must be signed to update the signer set.\n     * \n     * @param threshold   Number of signers required to execute a transaction.\n     * @param signers     Array of signer addresses allowed to sign a transaction.\n     * @param guardians   Array of guardian addresses allowed to sign the next signer set update.\n     * \n     * @return hash       The computed EIP712 hash to be signed.\n     */\n    function getSignerSetHash(\n        uint256 threshold,\n        address[] calldata signers,\n        address[] calldata guardians\n    ) external view returns (bytes32 hash) {\n        hash = _getSignerSetHash(signerSet.id, threshold, signers, guardians);\n    }\n\n    /**\n     * @notice Checks the signatures for a EIP712 hash to ensure signatures are valid to execute a transaction.\n     * \n     * @dev    Throws when there are not enough signatures supplied for the current threshold.\n     * @dev    Throws when the recovered address for a signature is not in the current signer set.\n     * @dev    Throws when signatures are supplied where the signer order is not ascending.\n     * \n     * @param hash        Hash value of the message that was signed by the signers.\n     * @param signatures  Array of signature values from the multisig signers.\n     * \n     * @return True if signatures are valid for the current signer set and threshold, throws otherwise.\n     */\n    function checkSignaturesForExecuteTransaction(\n        bytes32 hash,\n        SignatureECDSA[] calldata signatures\n    ) external view returns (bool) {\n        _checkSignatures(hash, signatures);\n\n        return true;\n    }\n\n    /**\n     * @notice Checks the signatures for a EIP712 hash to ensure signatures are valid to update the signer set.\n     * \n     * @dev    Throws when there are not enough signatures supplied for the current threshold.\n     * @dev    Throws when the recovered address for a signature is not in the current signer set.\n     * @dev    Throws when signatures are supplied where the signer order is not ascending.\n     * @dev    Throws when the recovered guardian address for the guardian signature is not in the current guardian set.\n     * \n     * @param hash        Hash value of the message that was signed by the signers.\n     * @param signatures  Array of signature values from the multisig signers.\n     * \n     * @return True if signatures are valid for the current signer set, threshold and guardians, throws otherwise.\n     */\n    function checkSignaturesForSetSignerSet(\n        bytes32 hash,\n        SignatureECDSA[] calldata signatures,\n        SignatureECDSA calldata guardianSignature\n    ) external view returns (bool) {\n        _checkSignatures(hash, signatures);\n        _checkGuardianSignature(hash, guardianSignature);\n\n        return true;\n    }\n\n    /**\n     * @notice Returns the current signer set id.\n     * \n     * @return currentSignerSetId The id of the current signer set.\n     */\n    function getCurrentSignerSetId() external view returns (uint32 currentSignerSetId) {\n        currentSignerSetId = signerSet.id;\n    }\n\n    /**\n     * @notice Returns the threshold for the current signer set.\n     * \n     * @return threshold The number of valid signatures required to execute a transaction.\n     */\n    function getThreshold() external view returns (uint256 threshold) {\n        threshold = signerSet.threshold;\n    }\n\n    /**\n     * @notice Returns if an address is a valid signer in the current signer set.\n     * \n     * @return addressIsSigner True if the signer is in the current signer set, false otherwise.\n     */\n    function isSigner(address signer) external view returns (bool addressIsSigner) {\n        addressIsSigner = signerSet.signers.contains(signer);\n    }\n\n    /**\n     * @notice Returns an address array of all addresses in the current signer set.\n     * \n     * @return signers  Array of signers in the current signer set.\n     */\n    function getSigners() external view returns (address[] memory signers) {\n        signers = signerSet.signers.values();\n    }\n\n    /**\n     * @notice Returns an address array of all addresses in the current guardian set.\n     * \n     * @return guardians  Array of guardians in the current signer set.\n     */\n    function getGuardians() external view returns (address[] memory guardians) {\n        guardians = signerSet.guardians.values();\n    }\n\n    /**\n     * @notice Returns the chain specific domain separator hash for signing transactions to execute.\n     * \n     * @return chainDomainSeparatorHash  The hash of the chain specific domain separator.\n     */\n    function chainDomainSeparator() external view returns (bytes32 chainDomainSeparatorHash) {\n        chainDomainSeparatorHash = _chainDomainSeparator();\n    }\n\n    /**\n     * @notice Returns the domain separator without chainId hash for signing transactions to update signer sets.\n     * \n     * @return chainlessDomainSeparatorHash  The hash of the domain separator without chainId.\n     */\n    function chainlessDomainSeparator() external view returns (bytes32 chainlessDomainSeparatorHash) {\n        chainlessDomainSeparatorHash = _chainlessDomainSeparator();\n    }\n\n    /**\n     * @dev Internal function to store a new set of signers and threshold. Called during contract construction\n     * @dev and when `setSignerSet` is executed by the current signers.\n     * \n     * @param signers    Array of signer addresses allowed to sign a transaction.\n     * @param threshold  Number of signers required to execute a transaction.\n     */\n    function _setSignerSet(address[] memory signers, uint256 threshold) internal {\n        if (threshold == 0 || signers.length < threshold || threshold > type(uint32).max) {\n            revert MultisigWallet__InvalidSignerSet();\n        }\n\n        EnumerableSet.AddressSet storage signerSetSigners = signerSet.signers;\n        uint256 currentSignerSetLength = signerSetSigners.length();\n        if (currentSignerSetLength > 0) {\n            unchecked {\n                uint256 index = currentSignerSetLength - 1;\n                while (true) {\n                    signerSetSigners.remove(signerSetSigners.at(index));\n                    if (index == 0) break;\n                    --index;\n                }\n            }\n        }\n\n        address previousSigner;\n        for (uint256 i; i < signers.length; i++) {\n            address signer = signers[i];\n            if (signer <= previousSigner) {\n                revert MultisigWallet__InvalidSignerSet();\n            }\n            signerSetSigners.add(signer);\n            previousSigner = signer;\n        }\n        signerSet.threshold = uint32(threshold);\n    }\n\n    /**\n     * @dev Internal function to store a new set of guardians. Called during contract construction\n     * @dev and when `setSignerSet` is executed by the current signers.\n     * \n     * @param guardians  Array of guardian addresses allowed to authorize a signer set change.\n     */\n    function _setGuardianSet(address[] memory guardians) internal {\n        if (guardians.length < MINIMUM_GUARDIANS) {\n            revert MultisigWallet__InvalidGuardianSet();\n        }\n\n        EnumerableSet.AddressSet storage signerSetGuardians = signerSet.guardians;\n        uint256 currentGuardianSetLength = signerSetGuardians.length();\n        if (currentGuardianSetLength > 0) {\n            unchecked {\n                uint256 index = currentGuardianSetLength - 1;\n                while (true) {\n                    signerSetGuardians.remove(signerSetGuardians.at(index));\n                    if (index == 0) break;\n                    --index;\n                }\n            }\n        }\n\n        address previousGuardian;\n        for (uint256 i; i < guardians.length; i++) {\n            address guardian = guardians[i];\n            if (guardian <= previousGuardian) {\n                revert MultisigWallet__InvalidGuardianSet();\n            }\n            signerSetGuardians.add(guardian);\n            previousGuardian = guardian;\n        }\n    }\n\n    /**\n     * @dev Internal function to compute the EIP712 signature hash to be signed for a transaction.\n     * \n     * @param nonce  The value the nonce should be when the transaction is executed.\n     * @param to     Address to call.\n     * @param value  Value to send to the `to` address.\n     * @param data   Calldata to send to the `to` address.\n     * \n     * @return hash  The computed EIP712 hash to be signed.\n     */\n    function _getTransactionHash(\n        uint256 nonce,\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) internal view returns (bytes32 hash) {\n        hash = _hashChainTypedData(\n            keccak256(\n                abi.encode(\n                    TRANSACTION_TYPEHASH,\n                    nonce,\n                    to,\n                    value,\n                    keccak256(data)\n                )\n            )\n        );\n    }\n\n    /**\n     * @dev Internal function to compute the EIP712 signature hash to be signed for a cross chain transaction.\n     * \n     * @param bucket The bucket the nonce is in.\n     * @param nonce  The nonce value of the cross chain transaction.\n     * @param to     Address to call.\n     * @param value  Value to send to the `to` address.\n     * @param data   Calldata to send to the `to` address.\n     * \n     * @return hash  The computed EIP712 hash to be signed.\n     */\n    function _getCrossChainTransactionHash(\n        uint256 bucket,\n        uint256 nonce,\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) internal view returns (bytes32 hash) {\n        hash = _hashChainlessTypedData(\n            keccak256(\n                abi.encode(\n                    CROSS_CHAIN_TRANSACTION_TYPEHASH,\n                    bucket,\n                    nonce,\n                    to,\n                    value,\n                    keccak256(data)\n                )\n            )\n        );\n    }\n\n    /**\n     * @dev Internal function to compute the hash of a transaction that is included in a batch.\n     * \n     * @param nonce  The value the nonce should be when the transaction is executed.\n     * @param to     Address to call.\n     * @param value  Value to send to the `to` address.\n     * @param data   Calldata to send to the `to` address.\n     * \n     * @return hash  The computed EIP712 hash to be signed.\n     */\n    function _getTransactionHashForBatch(\n        uint256 nonce,\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) internal pure returns (bytes32 hash) {\n        hash = keccak256(\n            abi.encode(\n                TRANSACTION_TYPEHASH,\n                nonce,\n                to,\n                value,\n                keccak256(data)\n            )\n        );\n    }\n\n    /**\n     * @dev Internal function to compute the EIP712 signature hash to be signed for a batch transaction.\n     * \n     * @param txHashes  Array of transaction hashes for each transaction in the batch.\n     * \n     * @return hash  The computed EIP712 hash to be signed.\n     */\n    function _getBatchTransactionHashFromTxHashes(\n        bytes32[] memory txHashes\n    ) internal view returns (bytes32 hash) {\n        hash = _hashChainTypedData(\n            keccak256(\n                abi.encode(\n                    BATCH_TRANSACTION_TYPEHASH,\n                    _getBytes32ArrayHashed(txHashes)\n                )\n            )\n        );\n    }\n\n    /**\n     * @dev Internal function to compute the EIP712 signature hash to be signed for a batch transaction.\n     * \n     * @param nonce       The value the nonce should be when the transaction is executed.\n     * @param transactions  Array of transactions to execute.\n     * \n     * @return hash  The computed EIP712 hash to be signed.\n     */\n    function _getBatchTransactionHash(\n        uint256 nonce,\n        BatchedTransaction[] calldata transactions\n    ) internal view returns (bytes32 hash) {\n        unchecked {\n            uint256 cachedNonce = nonce;\n            bytes32[] memory txHashes = new bytes32[](transactions.length);\n            BatchedTransaction calldata transaction;\n            for (uint256 i; i < transactions.length; ++i) {\n                transaction = transactions[i];\n                bytes32 txHash = _getTransactionHashForBatch(\n                    cachedNonce++,\n                    transaction.to,\n                    transaction.value,\n                    transaction.data\n                );\n                txHashes[i] = txHash;\n            }\n\n            hash = _getBatchTransactionHashFromTxHashes(txHashes);\n        }\n    }\n\n    /**\n     * @dev Internal function to compute the EIP712 signature hash to be signed for a signer set update.\n     * \n     * @param signerSetId  The current signer set id \n     * @param threshold    Number of signers required to execute a transaction.\n     * @param signers      Array of signer addresses allowed to sign a transaction.\n     * @param guardians    Array of guardian addresses allowed to authorize a signer set change.\n     * \n     * @return hash       The computed EIP712 hash to be signed.\n     */\n    function _getSignerSetHash(\n        uint32 signerSetId,\n        uint256 threshold,\n        address[] calldata signers,\n        address[] calldata guardians\n    ) internal view returns (bytes32 hash) {\n        hash = _hashChainlessTypedData(\n            keccak256(\n                abi.encode(\n                    SIGNER_SET_TYPEHASH,\n                    signerSetId,\n                    threshold,\n                    _getAddressBytesHashed(signers),\n                    _getAddressBytesHashed(guardians)\n                )\n            )\n        );\n    }\n\n    /**\n     * @dev Internal function to hash an array of addresses for EIP712 signatures.\n     * \n     * @param addresses  Array of addresses to hash.\n     * \n     * @return addressesHash  Hash of the address values.\n     */\n    function _getAddressBytesHashed(address[] calldata addresses) internal pure returns (bytes32 addressesHash) {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            let len := mul(addresses.length, 0x20)\n            mstore(0x40, add(ptr, len))\n            calldatacopy(ptr, addresses.offset, add(addresses.offset, len))\n            addressesHash := keccak256(ptr, len)\n        }\n    }\n\n    /**\n     * @dev Internal function to hash an array of bytes32 values for EIP712 signatures.\n     * \n     * @param hashes  Array of bytes32 hashes to hash.\n     * \n     * @return hashesHash  Hash of the bytes32 values.\n     */\n    function _getBytes32ArrayHashed(bytes32[] memory hashes) internal pure returns (bytes32 hashesHash) {\n        assembly (\"memory-safe\") {\n            let ptr := add(hashes, 0x20)\n            let len := mul(mload(hashes), 0x20)\n            hashesHash := keccak256(ptr, len)\n        }\n    }\n\n    /**\n     * @dev Internal function to check that the provided signatures are signed by the signers in\n     * @dev the signer set and meet the signer set threshold for executing a transaction.\n     * \n     * @dev Throws when the number of signatures is less than the signer set threshold.\n     * @dev Throws when a signatures v value is greater than type(uint8).max.\n     * @dev Throws when a signer is not in the signer set.\n     * \n     * @param hash        Hash value of the message that was signed by the signers.\n     * @param signatures  Array of signature values from the multisig signers.\n     */\n    function _checkSignatures(bytes32 hash, SignatureECDSA[] calldata signatures) internal view {\n        uint256 requiredSignatures = signerSet.threshold;\n\n        if (requiredSignatures > signatures.length) {\n            revert MultisigWallet__NotEnoughSignatures();\n        }\n\n        EnumerableSet.AddressSet storage signers = signerSet.signers;\n        SignatureECDSA calldata signature;\n        address previousSigner;\n        for (uint256 i; i < requiredSignatures; ++i) {\n            signature = signatures[i];\n            if (signature.v > type(uint8).max) {\n                revert MultisigWallet__InvalidV();\n            }\n\n            address signer = ecrecover(hash, uint8(signature.v), signature.r, signature.s);\n            if (signer <= previousSigner || !signers.contains(signer)) {\n                revert MultisigWallet__InvalidSignatures();\n            }\n            previousSigner = signer;\n        }\n    }\n\n    /**\n     * @dev Internal function to check that the provided signature is signed by a guardian in\n     * @dev the current signer set.\n     * \n     * @dev Throws when the signature v value is greater than type(uint8).max.\n     * @dev Throws when the signer is not in the guardian set.\n     * \n     * @param hash       Hash value of the message that was signed by the signers.\n     * @param signature  Signature value from a guardian.\n     */\n    function _checkGuardianSignature(bytes32 hash, SignatureECDSA calldata signature) internal view {\n        if (signature.v > type(uint8).max) {\n            revert MultisigWallet__InvalidV();\n        }\n\n        address signer = ecrecover(hash, uint8(signature.v), signature.r, signature.s);\n        if (!signerSet.guardians.contains(signer)) {\n            revert MultisigWallet__InvalidSignatures();\n        }\n    }\n\n    /// @dev Receive function allows native funds to be deposited\n    receive() external payable { }\n\n    /// @dev Fallback function allows native funds to be deposited with calldata\n    fallback() external payable {\n        if (msg.data.length > 3) {\n            FallbackReturn storage fallbackReturn = fallbackReturns[msg.sig];\n            if (fallbackReturn.enabled) {\n                bytes memory returnData = fallbackReturn.returnData;\n                assembly (\"memory-safe\") {\n                    return(add(returnData, 0x20), mload(returnData))\n                }\n            }\n        }\n        if (msg.value == 0) {\n            revert MultisigWallet__FallbackNotHandled();\n        }\n    }\n}"
    },
    "lib/tm-core-lib/src/utils/misc/StorageTstorish.sol": {
      "content": "pragma solidity ^0.8.24;\n\nlibrary StorageTstorish {   \n    // keccak256(abi.encode(uint256(keccak256(\"storage.Tstorish\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant DATA_STORAGE_SLOT = \n        0xdacd49f6a6c42b45a5c3d195b83b324104542d9147bb8064a39c6a8d23ba9b00;\n\n    struct Data {\n        // Indicates if TSTORE support has been activated during or post-deployment.\n        bool tstoreSupport;\n    }\n\n    function data() internal pure returns (Data storage ptr) {\n        bytes32 slot = DATA_STORAGE_SLOT;\n        assembly {\n            ptr.slot := slot\n        }\n    }\n}"
    },
    "lib/tm-core-lib/src/utils/misc/Tstorish.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"./StorageTstorish.sol\";\n\n/**\n * @title  Tstorish\n * @notice Based on https://github.com/ProjectOpenSea/tstorish/commit/a81ed74453ed7b9fe7e96a9906bc4def19b73e33\n */\nabstract contract Tstorish {\n\n    /*\n     * ------------------------------------------------------------------------+\n     * Opcode      | Mnemonic         | Stack              | Memory            |\n     * ------------------------------------------------------------------------|\n     * 60 0x02     | PUSH1 0x02       | 0x02               |                   |\n     * 60 0x1e     | PUSH1 0x1e       | 0x1e 0x02          |                   |\n     * 61 0x3d5c   | PUSH2 0x3d5c     | 0x3d5c 0x1e 0x02   |                   |\n     * 3d          | RETURNDATASIZE   | 0 0x3d5c 0x1e 0x02 |                   |\n     *                                                                         |\n     * :: store deployed bytecode in memory: (3d) RETURNDATASIZE (5c) TLOAD :: |\n     * 52          | MSTORE           | 0x1e 0x02          | [0..0x20): 0x3d5c |\n     * f3          | RETURN           |                    | [0..0x20): 0x3d5c |\n     * ------------------------------------------------------------------------+\n     */\n    uint256 constant _TLOAD_TEST_PAYLOAD = 0x6002_601e_613d5c_3d_52_f3;\n    uint256 constant _TLOAD_TEST_PAYLOAD_LENGTH = 0x0a;\n    uint256 constant _TLOAD_TEST_PAYLOAD_OFFSET = 0x16;\n\n    // Declare an immutable variable to store the tstore test contract address.\n    address private immutable _tloadTestContract;\n\n    // Declare an immutable variable to store the initial TSTORE support status.\n    bool internal immutable _tstoreInitialSupport;\n\n    // Declare an immutable function type variable for the _setTstorish function\n    // based on chain support for tstore at time of deployment.\n    function(uint256,uint256) internal immutable _setTstorish;\n\n    // Declare an immutable function type variable for the _getTstorish function\n    // based on chain support for tstore at time of deployment.\n    function(uint256) view returns (uint256) internal immutable _getTstorish;\n\n    // Declare an immutable function type variable for the _clearTstorish function\n    // based on chain support for tstore at time of deployment.\n    function(uint256) internal immutable _clearTstorish;\n\n    // Declare a few custom revert error types.\n    error TStoreAlreadyActivated();\n    error TStoreNotSupported();\n    error TloadTestContractDeploymentFailed();\n    error OnlyDirectCalls();\n\n    /**\n     * @dev Determine TSTORE availability during deployment. This involves\n     *      attempting to deploy a contract that utilizes TLOAD as part of the\n     *      contract construction bytecode, and configuring initial support for\n     *      using TSTORE in place of SSTORE based on the result.\n     */\n    constructor() {\n        // Deploy the contract testing TLOAD support and store the address.\n        address tloadTestContract = _prepareTloadTest();\n\n        // Ensure the deployment was successful.\n        if (tloadTestContract == address(0)) {\n            revert TloadTestContractDeploymentFailed();\n        }\n\n        // Determine if TSTORE is supported.\n        _tstoreInitialSupport = StorageTstorish.data().tstoreSupport = _testTload(tloadTestContract);\n\n        if (_tstoreInitialSupport) {\n            // If TSTORE is supported, set functions to their versions that use\n            // tstore/tload directly without support checks.\n            _setTstorish = _setTstore;\n            _getTstorish = _getTstore;\n            _clearTstorish = _clearTstore;\n        } else {\n            // If TSTORE is not supported, set functions to their versions that \n            // fallback to sstore/sload until tstoreSupport is true.\n            _setTstorish = _setTstorishWithSstoreFallback;\n            _getTstorish = _getTstorishWithSloadFallback;\n            _clearTstorish = _clearTstorishWithSstoreFallback;\n        }\n\n        // Set the address of the deployed TLOAD test contract as an immutable.\n        _tloadTestContract = tloadTestContract;\n    }\n\n    /**\n     * @dev Called internally when tstore is activated by an external call to \n     *      `__activateTstore`. Developers must override this function and handle\n     *      relevant transfers of data from regular storage to transient storage *OR*\n     *      revert the transaction if it is in a state that should not support the activation\n     *      of tstore.\n     */\n    function _onTstoreSupportActivated() internal virtual;\n\n    /**\n     * @dev External function to activate TSTORE usage. Does not need to be\n     *      called if TSTORE is supported from deployment, and only needs to be\n     *      called once. Reverts if TSTORE has already been activated or if the\n     *      opcode is not available. Note that this must be called directly from\n     *      an externally-owned account to avoid potential reentrancy issues.\n     */\n    function __activateTstore() external {\n        // Determine if TSTORE can potentially be activated.\n        if (_tstoreInitialSupport || StorageTstorish.data().tstoreSupport) {\n            revert TStoreAlreadyActivated();\n        }\n\n        // Determine if TSTORE can be activated and revert if not.\n        if (!_testTload(_tloadTestContract)) {\n            revert TStoreNotSupported();\n        }\n\n        // Mark TSTORE as activated.\n        StorageTstorish.data().tstoreSupport = true;\n\n        _onTstoreSupportActivated();\n    }\n\n    /**\n     * @dev Private function to set a TSTORISH value. Assigned to _setTstorish \n     *      internal function variable at construction if chain has tstore support.\n     *\n     * @param storageSlot The slot to write the TSTORISH value to.\n     * @param value       The value to write to the given storage slot.\n     */\n    function _setTstore(uint256 storageSlot, uint256 value) internal {\n        assembly {\n            tstore(storageSlot, value)\n        }\n    }\n\n    /**\n     * @dev Private function to set a TSTORISH value with sstore fallback. \n     *      Assigned to _setTstorish internal function variable at construction\n     *      if chain does not have tstore support.\n     *\n     * @param storageSlot The slot to write the TSTORISH value to.\n     * @param value       The value to write to the given storage slot.\n     */\n    function _setTstorishWithSstoreFallback(uint256 storageSlot, uint256 value) internal {\n        if (StorageTstorish.data().tstoreSupport) {\n            assembly {\n                tstore(storageSlot, value)\n            }\n        } else {\n            assembly {\n                sstore(storageSlot, value)\n            }\n        }\n    }\n\n    /**\n     * @dev Private function to read a TSTORISH value. Assigned to _getTstorish\n     *      internal function variable at construction if chain has tstore support.\n     *\n     * @param storageSlot The slot to read the TSTORISH value from.\n     *\n     * @return value The TSTORISH value at the given storage slot.\n     */\n    function _getTstore(\n        uint256 storageSlot\n    ) internal view returns (uint256 value) {\n        assembly {\n            value := tload(storageSlot)\n        }\n    }\n\n    /**\n     * @dev Private function to read a TSTORISH value with sload fallback. \n     *      Assigned to _getTstorish internal function variable at construction\n     *      if chain does not have tstore support.\n     *\n     * @param storageSlot The slot to read the TSTORISH value from.\n     *\n     * @return value The TSTORISH value at the given storage slot.\n     */\n    function _getTstorishWithSloadFallback(\n        uint256 storageSlot\n    ) internal view returns (uint256 value) {\n        if (StorageTstorish.data().tstoreSupport) {\n            assembly {\n                value := tload(storageSlot)\n            }\n        } else {\n            assembly {\n                value := sload(storageSlot)\n            }\n        }\n    }\n\n    /**\n     * @dev Private function to clear a TSTORISH value. Assigned to _clearTstorish internal \n     *      function variable at construction if chain has tstore support.\n     *\n     * @param storageSlot The slot to clear the TSTORISH value for.\n     */\n    function _clearTstore(uint256 storageSlot) internal {\n        assembly {\n            tstore(storageSlot, 0)\n        }\n    }\n\n    /**\n     * @dev Private function to clear a TSTORISH value with sstore fallback. \n     *      Assigned to _clearTstorish internal function variable at construction\n     *      if chain does not have tstore support.\n     *\n     * @param storageSlot The slot to clear the TSTORISH value for.\n     */\n    function _clearTstorishWithSstoreFallback(uint256 storageSlot) internal {\n        if (StorageTstorish.data().tstoreSupport) {\n            assembly {\n                tstore(storageSlot, 0)\n            }\n        } else {\n            assembly {\n                sstore(storageSlot, 0)\n            }\n        }\n    }\n\n    /**\n     * @dev Private function to copy a value from storage to transient storage at the same slot.\n     *      Useful when tstore is activated on a chain that didn't initially support it.\n     */\n    function _copyFromStorageToTransient(uint256 storageSlot) internal {\n        if (StorageTstorish.data().tstoreSupport) {\n            assembly {\n                tstore(storageSlot, sload(storageSlot))\n            }\n        } else {\n            revert TStoreNotSupported();\n        }\n    }\n\n    /**\n     * @dev Private function to deploy a test contract that utilizes TLOAD as\n     *      part of its fallback logic.\n     */\n    function _prepareTloadTest() private returns (address contractAddress) {\n        // Utilize assembly to deploy a contract testing TLOAD support.\n        assembly {\n            // Write the contract deployment code payload to scratch space.\n            mstore(0, _TLOAD_TEST_PAYLOAD)\n\n            // Deploy the contract.\n            contractAddress := create(\n                0,\n                _TLOAD_TEST_PAYLOAD_OFFSET,\n                _TLOAD_TEST_PAYLOAD_LENGTH\n            )\n        }\n    }\n\n    /**\n     * @dev Private view function to determine if TSTORE/TLOAD are supported by\n     *      the current EVM implementation by attempting to call the test\n     *      contract, which utilizes TLOAD as part of its fallback logic.\n     */\n    function _testTload(\n        address tloadTestContract\n    ) private view returns (bool ok) {\n        // Call the test contract, which will perform a TLOAD test. If the call\n        // does not revert, then TLOAD/TSTORE is supported. Do not forward all\n        // available gas, as all forwarded gas will be consumed on revert.\n        (ok, ) = tloadTestContract.staticcall{ gas: gasleft() / 10 }(\"\");\n    }\n}"
    },
    "lib/tm-core-lib/src/utils/security/TstorishReentrancyGuard.sol": {
      "content": "pragma solidity ^0.8.24;\n\nimport \"../misc/Tstorish.sol\";\n\n/**\n * @dev Variant of {ReentrancyGuard} that uses transient storage.\n *\n * NOTE: This variant only works on networks where EIP-1153 is available.\n */\nabstract contract TstorishReentrancyGuard is Tstorish {\n\n    // keccak256(abi.encode(uint256(keccak256(\"storage.TstorishReentrancyGuard\")) - 1)) & ~bytes32(uint256(0xff))\n    uint256 private constant REENTRANCY_GUARD_STORAGE = \n        0xeff9701f8ef712cda0f707f0a4f48720f142bf7e1bce9d4747c32b4eeb890500;\n\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() Tstorish() {\n        if (!_tstoreInitialSupport) {\n            _setTstorish(REENTRANCY_GUARD_STORAGE, NOT_ENTERED);\n        }\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_getTstorish(REENTRANCY_GUARD_STORAGE) == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _setTstorish(REENTRANCY_GUARD_STORAGE, ENTERED);\n    }\n\n    function _nonReentrantAfter() private {\n        _setTstorish(REENTRANCY_GUARD_STORAGE, NOT_ENTERED);\n    }\n\n    function _onTstoreSupportActivated() internal virtual override {\n        _copyFromStorageToTransient(REENTRANCY_GUARD_STORAGE);\n    }\n}"
    },
    "lib/tm-core-lib/src/utils/structs/EnumerableSet.sol": {
      "content": "pragma solidity ^0.8.4;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}"
    }
  },
  "settings": {
    "remappings": [
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/",
      "@limitbreak/creator-token-transfer-validator/=lib/creator-token-transfer-validator/",
      "@limitbreak/tm-cloner/=lib/tm-cloner/",
      "@limitbreak/tm-core-lib/=lib/tm-core-lib/",
      "@limitbreak/tm-extension-registry/=lib/tm-extension-registry/",
      "@limitbreak/tm-role-server/=lib/tm-role-server/",
      "@limitbreak/tm-template-factory/=lib/tm-template-factory/",
      "@limitbreak/tm-web2-gateway/=lib/tm-web2-gateway/",
      "@limitbreak/wrapped-native/=lib/wrapped-native/",
      "@limitbreak/permit-c/=lib/payment-processor-v2/lib/PermitC/src/",
      "@limitbreak/trusted-forwarder/=lib/payment-processor-v2/lib/TrustedForwarder/src/",
      "@opensea/tstorish/=lib/creator-token-standards/lib/tstorish/src/",
      "@openzeppelin/=lib/payment-processor-v2/lib/openzeppelin-contracts/",
      "@rari-capital/solmate/=lib/payment-processor-v2/lib/solmate/",
      "ERC721A/=lib/creator-token-standards/lib/ERC721A/contracts/",
      "PermitC/=lib/payment-processor-v2/lib/PermitC/",
      "TrustedForwarder/=lib/TrustedForwarder/",
      "creator-token-standards/=lib/creator-token-standards/",
      "creator-token-transfer-validator/=lib/creator-token-transfer-validator/src/",
      "erc4626-tests/=lib/payment-processor-v2/lib/openzeppelin-contracts/lib/erc4626-tests/",
      "erc721a/=lib/creator-token-standards/lib/ERC721A/",
      "fake-contracts/=lib/fake-contracts/src/",
      "forge-gas-metering/=lib/payment-processor-v2/lib/PermitC/lib/forge-gas-metering/",
      "multisig/=lib/multisig/",
      "murky/=lib/payment-processor-v2/lib/murky/",
      "openzeppelin-contracts/=lib/payment-processor-v2/lib/openzeppelin-contracts/",
      "openzeppelin/=lib/payment-processor-v2/lib/openzeppelin-contracts/contracts/",
      "payment-processor-v2/=lib/payment-processor-v2/",
      "solady/=lib/payment-processor-v2/lib/PermitC/lib/forge-gas-metering/lib/solady/",
      "solmate/=lib/payment-processor-v2/lib/solmate/src/",
      "tm-cloner/=lib/tm-cloner/src/",
      "tm-core-lib/=lib/tm-core-lib/src/",
      "tm-extension-registry/=lib/tm-extension-registry/src/",
      "tm-role-server/=lib/tm-role-server/src/",
      "tm-template-factory/=lib/tm-template-factory/src/",
      "tm-web2-gateway/=lib/tm-web2-gateway/src/",
      "tstorish/=lib/creator-token-standards/lib/tstorish/src/",
      "wrapped-native/=lib/wrapped-native/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 9999999
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "evmVersion": "cancun",
    "viaIR": false,
    "libraries": {}
  }
}}