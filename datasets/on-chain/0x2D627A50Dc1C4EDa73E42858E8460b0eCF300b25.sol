{{
  "language": "Solidity",
  "sources": {
    "contracts/interface/RocketStorageInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketStorageInterface {\n\n    // Deploy status\n    function getDeployedStatus() external view returns (bool);\n\n    // Guardian\n    function getGuardian() external view returns(address);\n    function setGuardian(address _newAddress) external;\n    function confirmGuardian() external;\n\n    // Getters\n    function getAddress(bytes32 _key) external view returns (address);\n    function getUint(bytes32 _key) external view returns (uint);\n    function getString(bytes32 _key) external view returns (string memory);\n    function getBytes(bytes32 _key) external view returns (bytes memory);\n    function getBool(bytes32 _key) external view returns (bool);\n    function getInt(bytes32 _key) external view returns (int);\n    function getBytes32(bytes32 _key) external view returns (bytes32);\n\n    // Setters\n    function setAddress(bytes32 _key, address _value) external;\n    function setUint(bytes32 _key, uint _value) external;\n    function setString(bytes32 _key, string calldata _value) external;\n    function setBytes(bytes32 _key, bytes calldata _value) external;\n    function setBool(bytes32 _key, bool _value) external;\n    function setInt(bytes32 _key, int _value) external;\n    function setBytes32(bytes32 _key, bytes32 _value) external;\n\n    // Deleters\n    function deleteAddress(bytes32 _key) external;\n    function deleteUint(bytes32 _key) external;\n    function deleteString(bytes32 _key) external;\n    function deleteBytes(bytes32 _key) external;\n    function deleteBool(bytes32 _key) external;\n    function deleteInt(bytes32 _key) external;\n    function deleteBytes32(bytes32 _key) external;\n\n    // Arithmetic\n    function addUint(bytes32 _key, uint256 _amount) external;\n    function subUint(bytes32 _key, uint256 _amount) external;\n\n    // Protected storage\n    function getNodeWithdrawalAddress(address _nodeAddress) external view returns (address);\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external view returns (address);\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external;\n    function confirmWithdrawalAddress(address _nodeAddress) external;\n}\n"
    },
    "contracts/contract/RocketBase.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"../interface/RocketStorageInterface.sol\";\n\n/// @title Base settings / modifiers for each contract in Rocket Pool\n/// @author David Rugendyke\n\nabstract contract RocketBase {\n\n    // Calculate using this as the base\n    uint256 constant calcBase = 1 ether;\n\n    // Version of the contract\n    uint8 public version;\n\n    // The main storage contract where primary persistant storage is maintained\n    RocketStorageInterface rocketStorage = RocketStorageInterface(address(0));\n\n\n    /*** Modifiers **********************************************************/\n\n    /**\n    * @dev Throws if called by any sender that doesn't match a Rocket Pool network contract\n    */\n    modifier onlyLatestNetworkContract() {\n        require(getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        _;\n    }\n\n    /**\n    * @dev Throws if called by any sender that doesn't match one of the supplied contract or is the latest version of that contract\n    */\n    modifier onlyLatestContract(string memory _contractName, address _contractAddress) {\n        require(_contractAddress == getAddress(keccak256(abi.encodePacked(\"contract.address\", _contractName))), \"Invalid or outdated contract\");\n        _;\n    }\n\n    /**\n    * @dev Throws if called by any sender that isn't a registered node\n    */\n    modifier onlyRegisteredNode(address _nodeAddress) {\n        require(getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress))), \"Invalid node\");\n        _;\n    }\n\n    /**\n    * @dev Throws if called by any sender that isn't a trusted node DAO member\n    */\n    modifier onlyTrustedNode(address _nodeAddress) {\n        require(getBool(keccak256(abi.encodePacked(\"dao.trustednodes.\", \"member\", _nodeAddress))), \"Invalid trusted node\");\n        _;\n    }\n\n    /**\n    * @dev Throws if called by any sender that isn't a registered minipool\n    */\n    modifier onlyRegisteredMinipool(address _minipoolAddress) {\n        require(getBool(keccak256(abi.encodePacked(\"minipool.exists\", _minipoolAddress))), \"Invalid minipool\");\n        _;\n    }\n    \n\n    /**\n    * @dev Throws if called by any account other than a guardian account (temporary account allowed access to settings before DAO is fully enabled)\n    */\n    modifier onlyGuardian() {\n        require(msg.sender == rocketStorage.getGuardian(), \"Account is not a temporary guardian\");\n        _;\n    }\n\n\n\n\n    /*** Methods **********************************************************/\n\n    /// @dev Set the main Rocket Storage address\n    constructor(RocketStorageInterface _rocketStorageAddress) {\n        // Update the contract address\n        rocketStorage = RocketStorageInterface(_rocketStorageAddress);\n    }\n\n\n    /// @dev Get the address of a network contract by name\n    function getContractAddress(string memory _contractName) internal view returns (address) {\n        // Get the current contract address\n        address contractAddress = getAddress(keccak256(abi.encodePacked(\"contract.address\", _contractName)));\n        // Check it\n        require(contractAddress != address(0x0), \"Contract not found\");\n        // Return\n        return contractAddress;\n    }\n\n\n    /// @dev Get the address of a network contract by name (returns address(0x0) instead of reverting if contract does not exist)\n    function getContractAddressUnsafe(string memory _contractName) internal view returns (address) {\n        // Get the current contract address\n        address contractAddress = getAddress(keccak256(abi.encodePacked(\"contract.address\", _contractName)));\n        // Return\n        return contractAddress;\n    }\n\n\n    /// @dev Get the name of a network contract by address\n    function getContractName(address _contractAddress) internal view returns (string memory) {\n        // Get the contract name\n        string memory contractName = getString(keccak256(abi.encodePacked(\"contract.name\", _contractAddress)));\n        // Check it\n        require(bytes(contractName).length > 0, \"Contract not found\");\n        // Return\n        return contractName;\n    }\n\n    /// @dev Get revert error message from a .call method\n    function getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return \"Transaction reverted silently\";\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n\n\n\n    /*** Rocket Storage Methods ****************************************/\n\n    // Note: Unused helpers have been removed to keep contract sizes down\n\n    /// @dev Storage get methods\n    function getAddress(bytes32 _key) internal view returns (address) { return rocketStorage.getAddress(_key); }\n    function getUint(bytes32 _key) internal view returns (uint) { return rocketStorage.getUint(_key); }\n    function getString(bytes32 _key) internal view returns (string memory) { return rocketStorage.getString(_key); }\n    function getBytes(bytes32 _key) internal view returns (bytes memory) { return rocketStorage.getBytes(_key); }\n    function getBool(bytes32 _key) internal view returns (bool) { return rocketStorage.getBool(_key); }\n    function getInt(bytes32 _key) internal view returns (int) { return rocketStorage.getInt(_key); }\n    function getBytes32(bytes32 _key) internal view returns (bytes32) { return rocketStorage.getBytes32(_key); }\n\n    /// @dev Storage set methods\n    function setAddress(bytes32 _key, address _value) internal { rocketStorage.setAddress(_key, _value); }\n    function setUint(bytes32 _key, uint _value) internal { rocketStorage.setUint(_key, _value); }\n    function setString(bytes32 _key, string memory _value) internal { rocketStorage.setString(_key, _value); }\n    function setBytes(bytes32 _key, bytes memory _value) internal { rocketStorage.setBytes(_key, _value); }\n    function setBool(bytes32 _key, bool _value) internal { rocketStorage.setBool(_key, _value); }\n    function setInt(bytes32 _key, int _value) internal { rocketStorage.setInt(_key, _value); }\n    function setBytes32(bytes32 _key, bytes32 _value) internal { rocketStorage.setBytes32(_key, _value); }\n\n    /// @dev Storage delete methods\n    function deleteAddress(bytes32 _key) internal { rocketStorage.deleteAddress(_key); }\n    function deleteUint(bytes32 _key) internal { rocketStorage.deleteUint(_key); }\n    function deleteString(bytes32 _key) internal { rocketStorage.deleteString(_key); }\n    function deleteBytes(bytes32 _key) internal { rocketStorage.deleteBytes(_key); }\n    function deleteBool(bytes32 _key) internal { rocketStorage.deleteBool(_key); }\n    function deleteInt(bytes32 _key) internal { rocketStorage.deleteInt(_key); }\n    function deleteBytes32(bytes32 _key) internal { rocketStorage.deleteBytes32(_key); }\n\n    /// @dev Storage arithmetic methods\n    function addUint(bytes32 _key, uint256 _amount) internal { rocketStorage.addUint(_key, _amount); }\n    function subUint(bytes32 _key, uint256 _amount) internal { rocketStorage.subUint(_key, _amount); }\n}\n"
    },
    "contracts/interface/dao/protocol/RocketDAOProtocolVerifierInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.5.0 <0.9.0;\npragma abicoder v2;\n\ninterface Types {\n    enum ChallengeState {\n        Unchallenged,\n        Challenged,\n        Responded,\n        Paid\n    }\n\n    struct Proposal {\n        address proposer;\n        uint32 blockNumber;\n        uint128 nodeCount;\n        bytes32 hash;\n        uint256 sum;\n    }\n\n    struct Node {\n        uint256 sum;\n        bytes32 hash;\n    }\n\n    struct Leaf {\n        address nodeAddress;\n        uint256 effectiveRpl;\n    }\n}\n\ninterface RocketDAOProtocolVerifierInterface {\n    function getDefeatIndex(uint256 _proposalID) external view returns (uint256);\n    function getProposalBond(uint256 _proposalID) external view returns (uint256);\n    function getChallengeBond(uint256 _proposalID) external view returns (uint256);\n    function getChallengePeriod(uint256 _proposalID) external view returns (uint256);\n    function getDepthPerRound() external pure returns (uint256);\n    function submitProposalRoot(uint256 _proposalId, address _proposer, uint32 _blockNumber, Types.Node[] memory _treeNodes) external;\n    function burnProposalBond(uint256 _proposalID) external;\n    function createChallenge(uint256 _proposalID, uint256 _index, Types.Node calldata _node, Types.Node[] calldata _witness) external;\n    function submitRoot(uint256 propId, uint256 index, Types.Node[] memory nodes) external;\n    function getChallengeState(uint256 _proposalID, uint256 _index) external view returns (Types.ChallengeState);\n    function verifyVote(address _voter, uint256 _nodeIndex, uint256 _proposalID, uint256 _votingPower, Types.Node[] calldata _witness) external view returns (bool);\n}\n"
    },
    "contracts/interface/network/RocketNetworkVotingInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.5.0 <0.9.0;\n\ninterface RocketNetworkVotingInterface {\n    function initialiseVotingFor(address _nodeAddress) external;\n    function initialiseVoting() external;\n    function initialiseVotingWithDelegate(address _delegate) external;\n    function getVotingInitialised(address _nodeAddress) external view returns (bool);\n    function getNodeCount(uint32 _block) external view returns (uint256);\n    function getVotingPower(address _nodeAddress, uint32 _block) external view returns (uint256);\n    function setDelegate(address _newDelegate) external;\n    function getDelegate(address _nodeAddress, uint32 _block) external view returns (address);\n    function getCurrentDelegate(address _nodeAddress) external view returns (address);\n}"
    },
    "contracts/interface/dao/protocol/settings/RocketDAOProtocolSettingsProposalsInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketDAOProtocolSettingsProposalsInterface {\n    function getVotePhase1Time() external view returns(uint256);\n    function getVotePhase2Time() external view returns(uint256);\n    function getVoteDelayTime() external view returns(uint256);\n    function getExecuteTime() external view returns(uint256);\n    function getProposalBond() external view returns(uint256);\n    function getChallengeBond() external view returns(uint256);\n    function getChallengePeriod() external view returns(uint256);\n    function getProposalQuorum() external view returns (uint256);\n    function getProposalVetoQuorum() external view returns (uint256);\n    function getProposalMaxBlockAge() external view returns (uint256);\n}\n"
    },
    "contracts/interface/dao/security/RocketDAOSecurityInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.5.0 <0.9.0;\n\ninterface RocketDAOSecurityInterface {\n    function getMemberQuorumVotesRequired() external view returns (uint256);\n    function getMemberIsValid(address _nodeAddress) external view returns (bool);\n    function getMemberAt(uint256 _index) external view returns (address);\n    function getMemberCount() external view returns (uint256);\n    function getMemberID(address _nodeAddress) external view returns (string memory);\n    function getMemberJoinedTime(address _nodeAddress) external view returns (uint256);\n    function getMemberProposalExecutedTime(string memory _proposalType, address _nodeAddress) external view returns (uint256);\n}\n"
    },
    "contracts/types/SettingType.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nenum SettingType {\n  UINT256,\n  BOOL,\n  ADDRESS,\n  STRING,\n  BYTES,\n  BYTES32,\n  INT256\n}\n"
    },
    "contracts/interface/dao/security/RocketDAOSecurityProposalsInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.5.0 <0.9.0;\npragma abicoder v2;\n\nimport \"../../../types/SettingType.sol\";\n\ninterface RocketDAOSecurityProposalsInterface {\n    function propose(string memory _proposalMessage, bytes memory _payload) external returns (uint256);\n    function vote(uint256 _proposalID, bool _support) external;\n    function cancel(uint256 _proposalID) external;\n    function execute(uint256 _proposalID) external;\n\n    function proposalSettingUint(string memory _settingContractName, string memory _settingPath, uint256 _value) external;\n    function proposalSettingBool(string memory _settingContractName, string memory _settingPath, bool _value) external;\n    function proposalSettingAddress(string memory _settingContractName, string memory _settingPath, address _value) external;\n\n    function proposalInvite(string memory _id, address _memberAddress) external;\n    function proposalKick(address _memberAddress) external;\n    function proposalKickMulti(address[] calldata _memberAddresses) external;\n    function proposalReplace(address _existingMemberAddress, string calldata _newMemberId, address _newMemberAddress) external;\n}\n"
    },
    "contracts/interface/dao/protocol/RocketDAOProtocolProposalInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.5.0 <0.9.0;\npragma abicoder v2;\n\nimport \"../../../types/SettingType.sol\";\nimport \"./RocketDAOProtocolVerifierInterface.sol\";\n\ninterface RocketDAOProtocolProposalInterface {\n    // Possible states that a proposal may be in\n    enum ProposalState {\n        Pending,\n        ActivePhase1,\n        ActivePhase2,\n        Destroyed,\n        Vetoed,\n        QuorumNotMet,\n        Defeated,\n        Succeeded,\n        Expired,\n        Executed\n    }\n\n    enum VoteDirection {\n        NoVote,\n        Abstain,\n        For,\n        Against,\n        AgainstWithVeto\n    }\n\n    function getTotal() external view returns (uint256);\n    function getProposer(uint256 _proposalID) external view returns (address);\n    function getMessage(uint256 _proposalID) external view returns (string memory);\n    function getStart(uint256 _proposalID) external view returns (uint256);\n    function getPhase1End(uint256 _proposalID) external view returns (uint256);\n    function getPhase2End(uint256 _proposalID) external view returns (uint256);\n    function getExpires(uint256 _proposalID) external view returns (uint256);\n    function getCreated(uint256 _proposalID) external view returns (uint256);\n    function getVotingPowerFor(uint256 _proposalID) external view returns (uint256);\n    function getVotingPowerAgainst(uint256 _proposalID) external view returns (uint256);\n    function getVotingPowerVeto(uint256 _proposalID) external view returns (uint256);\n    function getVotingPowerAbstained(uint256 _proposalID) external view returns (uint256);\n    function getVotingPowerRequired(uint256 _proposalID) external view returns (uint256);\n    function getDestroyed(uint256 _proposalID) external view returns (bool);\n    function getFinalised(uint256 _proposalID) external view returns (bool);\n    function getExecuted(uint256 _proposalID) external view returns (bool);\n    function getVetoQuorum(uint256 _proposalID) external view returns (uint256);\n    function getVetoed(uint256 _proposalID) external view returns (bool);\n    function getPayload(uint256 _proposalID) external view returns (bytes memory);\n    function getReceiptHasVoted(uint256 _proposalID, address _nodeAddress) external view returns (bool);\n    function getReceiptHasVotedPhase1(uint256 _proposalID, address _nodeAddress) external view returns (bool);\n    function getReceiptDirection(uint256 _proposalID, address _nodeAddress) external view returns (VoteDirection);\n    function getState(uint256 _proposalID) external view returns (ProposalState);\n\n    function getProposalBlock(uint256 _proposalID) external view returns (uint256);\n    function getProposalVetoQuorum(uint256 _proposalID) external view returns (uint256);\n\n    function propose(string memory _proposalMessage, bytes memory _payload, uint32 _blockNumber, Types.Node[] calldata _treeNodes) external returns (uint256);\n    function vote(uint256 _proposalID, VoteDirection _vote, uint256 _votingPower, uint256 _nodeIndex, Types.Node[] calldata _witness) external;\n    function overrideVote(uint256 _proposalID, VoteDirection _voteDirection) external;\n    function finalise(uint256 _proposalID) external;\n    function execute(uint256 _proposalID) external;\n    function destroy(uint256 _proposalID) external;\n}\n"
    },
    "contracts/contract/dao/protocol/RocketDAOProtocolProposal.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.18;\n\nimport \"../../RocketBase.sol\";\nimport \"../../../interface/dao/protocol/RocketDAOProtocolVerifierInterface.sol\";\nimport \"../../../interface/network/RocketNetworkVotingInterface.sol\";\nimport \"../../../interface/dao/protocol/settings/RocketDAOProtocolSettingsProposalsInterface.sol\";\nimport \"../../../interface/dao/security/RocketDAOSecurityInterface.sol\";\nimport \"../../../interface/dao/security/RocketDAOSecurityProposalsInterface.sol\";\nimport \"../../../interface/dao/protocol/RocketDAOProtocolProposalInterface.sol\";\n\n/// @notice Manages protocol DAO proposals\ncontract RocketDAOProtocolProposal is RocketBase, RocketDAOProtocolProposalInterface {\n\n    // Events\n    event ProposalAdded(address indexed proposer, uint256 indexed proposalID, bytes payload, uint256 time);\n    event ProposalVoted(uint256 indexed proposalID, address indexed voter, VoteDirection direction, uint256 votingPower, uint256 time);\n    event ProposalVoteOverridden(uint256 indexed proposalID, address indexed delegate, address indexed voter, uint256 votingPower, uint256 time);\n    event ProposalExecuted(uint256 indexed proposalID, address indexed executor, uint256 time);\n    event ProposalFinalised(uint256 indexed proposalID, address indexed executor, uint256 time);\n    event ProposalDestroyed(uint256 indexed proposalID, uint256 time);\n\n    // The namespace for any data stored in the protocol DAO (do not change)\n    string constant internal daoProposalNameSpace = \"dao.protocol.proposal.\";\n\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketBase(_rocketStorageAddress) {\n        version = 2;\n    }\n\n    /*** Proposals **********************/\n\n    /// @notice Create a DAO proposal with calldata, if successful will be added to a queue where it can be executed\n    ///         A general message can be passed by the proposer along with the calldata payload that can be executed\n    ///         if the proposal passes\n    /// @param _proposalMessage A string explaining what the proposal does\n    /// @param _payload An ABI encoded payload which is executed on this contract if the proposal is successful\n    /// @param _blockNumber The block number the proposal is being made for\n    /// @param _treeNodes A merkle pollard generated at _blockNumber for the voting power state of the DAO\n    function propose(string memory _proposalMessage, bytes calldata _payload, uint32 _blockNumber, Types.Node[] calldata _treeNodes) override external onlyRegisteredNode(msg.sender) onlyLatestContract(\"rocketDAOProtocolProposal\", address(this)) returns (uint256) {\n        // Check on-chain governance has been enabled\n        {\n            uint256 enabledBlock = getUint(keccak256(abi.encodePacked(\"protocol.dao.enabled.block\")));\n            require(enabledBlock != 0 && _blockNumber >= enabledBlock, \"DAO has not been enabled\");\n        }\n        // Calculate total voting power by summing the pollard\n        uint256 totalVotingPower = 0;\n        uint256 treeNodesLength = _treeNodes.length;\n        for (uint256 i = 0; i < treeNodesLength; ++i) {\n            totalVotingPower += _treeNodes[i].sum;\n        }\n        // Create the proposal\n        uint256 proposalID = _propose(_proposalMessage, _blockNumber, totalVotingPower, _payload);\n        // Add root to verifier so it can be challenged if incorrect\n        RocketDAOProtocolVerifierInterface rocketDAOProtocolVerifier = RocketDAOProtocolVerifierInterface(getContractAddress(\"rocketDAOProtocolVerifier\"));\n        rocketDAOProtocolVerifier.submitProposalRoot(proposalID, msg.sender, _blockNumber, _treeNodes);\n        return proposalID;\n    }\n\n    /// @notice Applies a vote during phase 1\n    /// @param _proposalID ID of the proposal to vote on\n    /// @param _voteDirection Direction of the vote\n    /// @param _votingPower Total delegated voting power for the voter at the proposal block\n    /// @param _nodeIndex The index of the node voting\n    /// @param _witness A merkle proof into the network voting power tree proving the supplied voting power is correct\n    function vote(uint256 _proposalID, VoteDirection _voteDirection, uint256 _votingPower, uint256 _nodeIndex, Types.Node[] calldata _witness) external onlyRegisteredNode(msg.sender) onlyLatestContract(\"rocketDAOProtocolProposal\", address(this)) {\n        // Check valid vote\n        require(_voteDirection != VoteDirection.NoVote, \"Invalid vote\");\n        // Check the proposal is in a state that can be voted on\n        require(getState(_proposalID) == ProposalState.ActivePhase1, \"Phase 1 voting is not active\");\n        // Verify the voting power is correct\n        RocketDAOProtocolVerifierInterface rocketDAOProtocolVerifier = RocketDAOProtocolVerifierInterface(getContractAddress(\"rocketDAOProtocolVerifier\"));\n        require(rocketDAOProtocolVerifier.verifyVote(msg.sender, _nodeIndex, _proposalID, _votingPower, _witness), \"Invalid proof\");\n        // Apply vote\n        _vote(msg.sender, _votingPower, _proposalID, _voteDirection, true);\n    }\n\n    /// @notice Applies a vote during phase 2 (can be used to override vote direction of delegate)\n    /// @param _proposalID ID of the proposal to vote on\n    /// @param _voteDirection Direction of the vote\n    function overrideVote(uint256 _proposalID, VoteDirection _voteDirection) override external onlyRegisteredNode(msg.sender) onlyLatestContract(\"rocketDAOProtocolProposal\", address(this)) {\n        // Check valid vote\n        require(_voteDirection != VoteDirection.NoVote, \"Invalid vote\");\n        // Check the proposal is in a state that can be voted on\n        require(getState(_proposalID) == ProposalState.ActivePhase2, \"Phase 2 voting is not active\");\n        // Load contracts\n        RocketNetworkVotingInterface rocketNetworkVoting = RocketNetworkVotingInterface(getContractAddress(\"rocketNetworkVoting\"));\n        // Get caller's voting power and direction of their delegate\n        uint32 blockNumber = uint32(getProposalBlock(_proposalID));\n        uint256 votingPower = rocketNetworkVoting.getVotingPower(msg.sender, blockNumber);\n        address delegate = rocketNetworkVoting.getDelegate(msg.sender, blockNumber);\n        // Check if delegate voted in phase 1\n        if (getReceiptHasVotedPhase1(_proposalID, delegate)) {\n            // Get the vote direction of their delegate\n            VoteDirection delegateVote = getReceiptDirection(_proposalID, delegate);\n            require (delegateVote != _voteDirection, \"Vote direction is the same as delegate\");\n            // Reverse the delegate's vote\n            _overrideVote(delegate, msg.sender, _proposalID, votingPower, delegateVote);\n        }\n        // Apply this voter's vote\n        _vote(msg.sender, votingPower, _proposalID, _voteDirection, false);\n    }\n\n    /// @notice Finalises a vetoed proposal by burning the proposer's bond\n    /// @param _proposalID ID of the proposal to finalise\n    function finalise(uint256 _proposalID) override external onlyLatestContract(\"rocketDAOProtocolProposal\", address(this)) {\n        // Check state\n        require(getState(_proposalID) == ProposalState.Vetoed, \"Proposal has not been vetoed\");\n        bytes32 finalisedKey = keccak256(abi.encodePacked(daoProposalNameSpace, \"finalised\", _proposalID));\n        require(getBool(finalisedKey) == false, \"Proposal already finalised\");\n        setBool(finalisedKey, true);\n        // Burn the proposer's bond\n        RocketDAOProtocolVerifierInterface rocketDAOProtocolVerifier = RocketDAOProtocolVerifierInterface(getContractAddress(\"rocketDAOProtocolVerifier\"));\n        rocketDAOProtocolVerifier.burnProposalBond(_proposalID);\n        // Log it\n        emit ProposalFinalised(_proposalID, tx.origin, block.timestamp);\n    }\n\n    /// @notice Executes a successful proposal\n    /// @param _proposalID ID of the proposal to execute\n    function execute(uint256 _proposalID) override external onlyLatestContract(\"rocketDAOProtocolProposal\", address(this)) {\n        // Firstly make sure this proposal has passed\n        require(getState(_proposalID) == ProposalState.Succeeded, \"Proposal has not succeeded, has expired or has already been executed\");\n        // Set as executed now before running payload\n        setBool(keccak256(abi.encodePacked(daoProposalNameSpace, \"executed\", _proposalID)), true);\n        // Get the proposals contract\n        address daoProtocolProposalsAddress = getContractAddress(\"rocketDAOProtocolProposals\");\n        // Ok all good, lets run the payload on the dao contract that the proposal relates too, it should execute one of the methods on this contract\n        (bool success, bytes memory response) = daoProtocolProposalsAddress.call(getPayload(_proposalID));\n        // Was there an error?\n        require(success, getRevertMsg(response));\n        // Log it\n        emit ProposalExecuted(_proposalID, tx.origin, block.timestamp);\n    }\n\n    /// @dev Called by the verifier contract to destroy a proven invalid proposal\n    function destroy(uint256 _proposalID) override external onlyLatestContract(\"rocketDAOProtocolProposal\", address(this)) onlyLatestContract(\"rocketDAOProtocolVerifier\", msg.sender) {\n        // Cancel the proposal\n        bytes32 destroyedKey = keccak256(abi.encodePacked(daoProposalNameSpace, \"destroyed\", _proposalID));\n        require(getBool(destroyedKey) == false, \"Proposal already destroyed\");\n        setBool(destroyedKey, true);\n        // Log it\n        emit ProposalDestroyed(_proposalID, block.timestamp);\n    }\n\n    /// @notice Gets the block used to generate a proposal\n    /// @param _proposalID The ID of the proposal to query\n    /// @return The block used to generated the requested proposal\n    function getProposalBlock(uint256 _proposalID) override public view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(daoProposalNameSpace, \"proposal.block\", _proposalID)));\n    }\n\n    /// @notice Gets the amount of vetos required to stop a proposal\n    /// @param _proposalID The ID of the proposal to veto\n    /// @return The amount of voting power required to veto a proposal\n    function getProposalVetoQuorum(uint256 _proposalID) override external view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(daoProposalNameSpace, \"proposal.veto.quorum\", _proposalID)));\n    }\n\n    /// @notice Get the current total proposals\n    function getTotal() override public view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(daoProposalNameSpace, \"total\")));\n    }\n\n    /// @notice Get the member who proposed\n    /// @param _proposalID The ID of the proposal to query\n    function getProposer(uint256 _proposalID) override public view returns (address) {\n        return getAddress(keccak256(abi.encodePacked(daoProposalNameSpace, \"proposer\", _proposalID)));\n    }\n\n    /// @notice Get the proposal message\n    /// @param _proposalID The ID of the proposal to query\n    function getMessage(uint256 _proposalID) override external view returns (string memory) {\n        return getString(keccak256(abi.encodePacked(daoProposalNameSpace, \"message\", _proposalID)));\n    }\n\n    /// @notice Get the start of this proposal as a timestamp\n    /// @param _proposalID The ID of the proposal to query\n    function getStart(uint256 _proposalID) override public view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(daoProposalNameSpace, \"start\", _proposalID)));\n    }\n\n    /// @notice Get the end of phase1 of this proposal as a timestamp\n    /// @param _proposalID The ID of the proposal to query\n    function getPhase1End(uint256 _proposalID) override public view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(daoProposalNameSpace, \"phase1End\", _proposalID)));\n    }\n\n    /// @notice Get the end of phase2 of this proposal as a timestamp\n    /// @param _proposalID The ID of the proposal to query\n    /// @return timestamp for the end of phase2\n    function getPhase2End(uint256 _proposalID) override public view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(daoProposalNameSpace, \"phase2End\", _proposalID)));\n    }\n\n    /// @notice The timestamp where the proposal expires and can no longer be executed if it is successful\n    /// @param _proposalID The ID of the proposal to query\n    function getExpires(uint256 _proposalID) override public view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(daoProposalNameSpace, \"expires\", _proposalID)));\n    }\n\n    /// @notice Get the created status of this proposal\n    /// @param _proposalID The ID of the proposal to query\n    function getCreated(uint256 _proposalID) override external view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(daoProposalNameSpace, \"created\", _proposalID)));\n    }\n\n    /// @notice Get the for voting power count of this proposal\n    /// @param _proposalID The ID of the proposal to query\n    function getVotingPowerFor(uint256 _proposalID) override public view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(daoProposalNameSpace, \"votes.for\", _proposalID)));\n    }\n\n    /// @notice Get the against voting power count of this proposal\n    /// @param _proposalID The ID of the proposal to query\n    function getVotingPowerAgainst(uint256 _proposalID) override public view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(daoProposalNameSpace, \"votes.against\", _proposalID)));\n    }\n\n    /// @notice Get the veto voting power  count of this proposal\n    /// @param _proposalID The ID of the proposal to query\n    function getVotingPowerVeto(uint256 _proposalID) override public view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(daoProposalNameSpace, \"votes.veto\", _proposalID)));\n    }\n\n    /// @notice Get the against voteing power count of this proposal\n    /// @param _proposalID The ID of the proposal to query\n    function getVotingPowerAbstained(uint256 _proposalID) override public view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(daoProposalNameSpace, \"votes.abstained\", _proposalID)));\n    }\n\n    /// @notice How much voting power is required for the proposal to succeed\n    /// @param _proposalID The ID of the proposal to query\n    function getVotingPowerRequired(uint256 _proposalID) override public view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(daoProposalNameSpace, \"votes.required\", _proposalID)));\n    }\n\n    /// @notice Get the destroyed status of this proposal\n    /// @param _proposalID The ID of the proposal to query\n    function getDestroyed(uint256 _proposalID) override public view returns (bool) {\n        return getBool(keccak256(abi.encodePacked(daoProposalNameSpace, \"destroyed\", _proposalID)));\n    }\n\n    /// @notice Get the finalised status of this proposal\n    /// @param _proposalID The ID of the proposal to query\n    function getFinalised(uint256 _proposalID) override external view returns (bool) {\n        return getBool(keccak256(abi.encodePacked(daoProposalNameSpace, \"finalised\", _proposalID)));\n    }\n\n    /// @notice Get the executed status of this proposal\n    /// @param _proposalID The ID of the proposal to query\n    function getExecuted(uint256 _proposalID) override public view returns (bool) {\n        return getBool(keccak256(abi.encodePacked(daoProposalNameSpace, \"executed\", _proposalID)));\n    }\n\n    /// @notice Get the amount of veto votes required to veto this proposal\n    /// @param _proposalID The ID of the proposal to query\n    function getVetoQuorum(uint256 _proposalID) override public view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(daoProposalNameSpace, \"proposal.veto.quorum\", _proposalID)));\n    }\n\n    /// @notice Get the veto status of this proposal\n    /// @param _proposalID The ID of the proposal to query\n    function getVetoed(uint256 _proposalID) override public view returns (bool) {\n        uint256 votesVeto = getVotingPowerVeto(_proposalID);\n        uint256 quorum = getVetoQuorum(_proposalID);\n        return votesVeto >= quorum;\n    }\n\n    /// @notice Get the proposal payload\n    /// @param _proposalID The ID of the proposal to query\n    function getPayload(uint256 _proposalID) override public view returns (bytes memory) {\n        return getBytes(keccak256(abi.encodePacked(daoProposalNameSpace, \"payload\", _proposalID)));\n    }\n\n    /// @notice Returns true if this proposal has already been voted on by a node\n    /// @param _proposalID The ID of the proposal to query\n    /// @param _nodeAddress The node operator address to query\n    function getReceiptHasVoted(uint256 _proposalID, address _nodeAddress) override public view returns (bool) {\n        return getReceiptDirection(_proposalID, _nodeAddress) != VoteDirection.NoVote;\n    }\n\n    /// @notice Returns true if this proposal has been voted on in phase 1 by a node\n    /// @param _proposalID The ID of the proposal to query\n    /// @param _nodeAddress The node operator address to query\n    function getReceiptHasVotedPhase1(uint256 _proposalID, address _nodeAddress) override public view returns (bool) {\n        return getBool(keccak256(abi.encodePacked(daoProposalNameSpace, \"receipt.phase1\", _proposalID, _nodeAddress)));\n    }\n\n    /// @notice Returns the direction a node voted on a given proposal\n    /// @param _proposalID The ID of the proposal to query\n    /// @param _nodeAddress The node operator address to query\n    function getReceiptDirection(uint256 _proposalID, address _nodeAddress) override public view returns (VoteDirection) {\n        return VoteDirection(getUint(keccak256(abi.encodePacked(daoProposalNameSpace, \"receipt.direction\", _proposalID, _nodeAddress))));\n    }\n\n    /// @notice Return the state of the specified proposal\n    /// @param _proposalID The ID of the proposal to query\n    function getState(uint256 _proposalID) override public view returns (ProposalState) {\n        // Check the proposal ID is legit\n        require(getTotal() >= _proposalID && _proposalID > 0, \"Invalid proposal ID\");\n        // Destroyed?\n        if (getDestroyed(_proposalID)) {\n            return ProposalState.Destroyed;\n        }\n        // Has it been executed?\n        else if (getExecuted(_proposalID)) {\n            return ProposalState.Executed;\n        } else {\n            uint256 start = getStart(_proposalID);\n            // Is the proposal pending?\n            if (block.timestamp < start) {\n                return ProposalState.Pending;\n            } else {\n                // The proposal is active and can be voted on\n                uint256 phase1End = getPhase1End(_proposalID);\n                uint256 phase2End = getPhase2End(_proposalID);\n                if (block.timestamp < phase1End) {\n                    return ProposalState.ActivePhase1;\n                } else if (block.timestamp < phase2End) {\n                        return ProposalState.ActivePhase2;\n                } else {\n                    // Is the proposal vetoed?\n                    if (getVetoed(_proposalID)) {\n                        return ProposalState.Vetoed;\n                    }\n\n                    uint256 votesFor = getVotingPowerFor(_proposalID);\n                    uint256 votesAgainst = getVotingPowerAgainst(_proposalID);\n                    uint256 votesAbstained = getVotingPowerAbstained(_proposalID);\n                    uint256 totalVotes = votesFor + votesAgainst + votesAbstained;\n\n                    // Has the proposal reached quorum?\n                    if (totalVotes >= getVotingPowerRequired(_proposalID)) {\n                        if (votesFor > votesAgainst) {\n                            if (block.timestamp < getExpires(_proposalID)) {\n                                // Vote was successful, is now awaiting execution\n                                return ProposalState.Succeeded;\n                            }\n                        } else {\n                            // Vote was defeated\n                            return ProposalState.Defeated;\n                        }\n                    } else {\n                        return ProposalState.QuorumNotMet;\n                    }\n                }\n            }\n        }\n        return ProposalState.Expired;\n    }\n\n    /// @dev Internal function to generate a proposal\n    /// @param _proposalMessage the message associated with the proposal\n    /// @param _blockNumber the block number considered for the proposal snapshot\n    /// @param _totalVotingPower the total voting power for the proposal - used to calculate quorum\n    /// @param _payload A calldata payload to execute after the proposal is successful\n    /// @return The new proposal's ID\n    function _propose(string memory _proposalMessage, uint256 _blockNumber, uint256 _totalVotingPower, bytes calldata _payload) internal returns (uint256) {\n        // Validate block number\n        require(_blockNumber < block.number, \"Block must be in the past\");\n        // Load contracts\n        RocketDAOProtocolSettingsProposalsInterface rocketDAOProtocolSettingsProposals = RocketDAOProtocolSettingsProposalsInterface(getContractAddress(\"rocketDAOProtocolSettingsProposals\"));\n        require(_blockNumber + rocketDAOProtocolSettingsProposals.getProposalMaxBlockAge() > block.number, \"Block too old\");\n        // Calculate quorums\n        uint256 quorum = 0;\n        uint256 vetoQuorum = 0;\n        {\n            uint256 proposalQuorum = rocketDAOProtocolSettingsProposals.getProposalQuorum();\n            uint256 vetoProposalQuorum = rocketDAOProtocolSettingsProposals.getProposalVetoQuorum();\n            quorum = _totalVotingPower * proposalQuorum / calcBase;\n            vetoQuorum = _totalVotingPower * vetoProposalQuorum / calcBase;\n        }\n        // Add proposal\n        return _addProposal(\n            msg.sender,\n            _proposalMessage,\n            _blockNumber,\n            block.timestamp + rocketDAOProtocolSettingsProposals.getVoteDelayTime(),\n            rocketDAOProtocolSettingsProposals.getVotePhase1Time(),\n            rocketDAOProtocolSettingsProposals.getVotePhase2Time(),\n            rocketDAOProtocolSettingsProposals.getExecuteTime(),\n            quorum,\n            vetoQuorum,\n            _payload\n        );\n    }\n\n    /// @dev Add a proposal to the protocol DAO\n    function _addProposal(address _proposer, string memory _message, uint256 _blockNumber, uint256 _startTime, uint256 _phase1Duration, uint256 _phase2Duration, uint256 _expires, uint256 _votesRequired, uint256 _vetoQuorum, bytes calldata _payload) internal returns (uint256) {\n        // Basic checks\n        require(_startTime > block.timestamp, \"Proposal start time must be in the future\");\n        require(_phase1Duration > 0, \"Proposal cannot have a duration of 0\");\n        require(_phase2Duration > 0, \"Proposal cannot have a duration of 0\");\n        require(_expires > 0, \"Proposal cannot have a execution expiration of 0\");\n        require(_votesRequired > 0, \"Proposal cannot have a 0 votes required to be successful\");\n        // Set the expires block\n        uint256 expires = _startTime + _phase1Duration + _phase2Duration + _expires;\n        // Get the proposal ID\n        uint256 proposalID = getTotal() + 1;\n        // The data structure for a proposal\n        setAddress(keccak256(abi.encodePacked(daoProposalNameSpace, \"proposer\", proposalID)), _proposer);                   // Which node is making the proposal\n        setString(keccak256(abi.encodePacked(daoProposalNameSpace, \"message\", proposalID)), _message);                      // A general message that can be included with the proposal\n        setUint(keccak256(abi.encodePacked(daoProposalNameSpace, \"start\", proposalID)), _startTime);                        // The time the proposal becomes active for voting on\n        setUint(keccak256(abi.encodePacked(daoProposalNameSpace, \"phase1End\", proposalID)), _startTime + _phase1Duration);  // The time the proposal where voting ends on phase 1\n        setUint(keccak256(abi.encodePacked(daoProposalNameSpace, \"phase2End\", proposalID)), _startTime + _phase1Duration + _phase2Duration); // The time the proposal where voting ends on phase 2\n        setUint(keccak256(abi.encodePacked(daoProposalNameSpace, \"expires\", proposalID)), expires);                         // The time when the proposal expires and can no longer be executed if it is successful\n        setUint(keccak256(abi.encodePacked(daoProposalNameSpace, \"created\", proposalID)), block.timestamp);                 // The time the proposal was created at\n        setUint(keccak256(abi.encodePacked(daoProposalNameSpace, \"votes.required\", proposalID)), _votesRequired);           // How many votes are required for the proposal to pass\n        setBytes(keccak256(abi.encodePacked(daoProposalNameSpace, \"payload\", proposalID)), _payload);                       // A calldata payload to execute after it is successful\n        setUint(keccak256(abi.encodePacked(daoProposalNameSpace, \"proposal.block\", proposalID)), uint256(_blockNumber));    // The block that the network voting power tree was generated for for this proposal\n        setUint(keccak256(abi.encodePacked(daoProposalNameSpace, \"proposal.veto.quorum\", proposalID)), _vetoQuorum);        // The number of veto votes required to veto this proposal\n        // Update the total proposals\n        setUint(keccak256(abi.encodePacked(daoProposalNameSpace, \"total\")), proposalID);\n        // Log it\n        emit ProposalAdded(_proposer, proposalID, _payload, block.timestamp);\n        // Done\n        return proposalID;\n    }\n\n    /// @dev Internal method to override the vote of a delegate\n    function _overrideVote(address _delegate, address _voter, uint256 _proposalID, uint256 _votes, VoteDirection _voteDirection) internal {\n        // Check for non-zero voting power\n        require(_votes > 0, \"Cannot vote with 0 voting power\");\n        // Remove votes from proposal\n        if (_voteDirection == VoteDirection.For) {\n            subUint(keccak256(abi.encodePacked(daoProposalNameSpace, \"votes.for\", _proposalID)), _votes);\n        } else if(_voteDirection == VoteDirection.Abstain) {\n            subUint(keccak256(abi.encodePacked(daoProposalNameSpace, \"votes.abstained\", _proposalID)), _votes);\n        } else {\n            if(_voteDirection == VoteDirection.AgainstWithVeto) {\n                subUint(keccak256(abi.encodePacked(daoProposalNameSpace, \"votes.veto\", _proposalID)), _votes);\n            }\n            subUint(keccak256(abi.encodePacked(daoProposalNameSpace, \"votes.against\", _proposalID)), _votes);\n        }\n        // Reduce the voting power applied by the delegate to this proposal\n        subUint(keccak256(abi.encodePacked(daoProposalNameSpace, \"receipt.votes\", _proposalID, _delegate)), _votes);\n        // Log it\n        emit ProposalVoteOverridden(_proposalID, _delegate, _voter, _votes, block.timestamp);\n    }\n\n    /// @dev Internal method to apply voting power against a proposal\n    function _vote(address _nodeOperator, uint256 _votes, uint256 _proposalID, VoteDirection _voteDirection, bool _phase1) internal {\n        // Check for non-zero voting power\n        require(_votes > 0, \"Cannot vote with 0 voting power\");\n        // Has this node already voted on this proposal?\n        require(!getReceiptHasVoted(_proposalID, _nodeOperator), \"Node operator has already voted on proposal\");\n        // Add votes to proposal\n        if (_voteDirection == VoteDirection.For) {\n            addUint(keccak256(abi.encodePacked(daoProposalNameSpace, \"votes.for\", _proposalID)), _votes);\n        } else if(_voteDirection == VoteDirection.Abstain) {\n            addUint(keccak256(abi.encodePacked(daoProposalNameSpace, \"votes.abstained\", _proposalID)), _votes);\n        } else {\n            if(_voteDirection == VoteDirection.AgainstWithVeto) {\n                addUint(keccak256(abi.encodePacked(daoProposalNameSpace, \"votes.veto\", _proposalID)), _votes);\n            }\n            addUint(keccak256(abi.encodePacked(daoProposalNameSpace, \"votes.against\", _proposalID)), _votes);\n        }\n        // Record the vote receipt now\n        setUint(keccak256(abi.encodePacked(daoProposalNameSpace, \"receipt.votes\", _proposalID, _nodeOperator)), _votes);\n        setUint(keccak256(abi.encodePacked(daoProposalNameSpace, \"receipt.direction\", _proposalID, _nodeOperator)), uint256(_voteDirection));\n        // Record delegate voted in phase 1\n        if (_phase1) {\n            setBool(keccak256(abi.encodePacked(daoProposalNameSpace, \"receipt.phase1\", _proposalID, _nodeOperator)), true);\n        }\n        // Log it\n        emit ProposalVoted(_proposalID, _nodeOperator, _voteDirection, _votes, block.timestamp);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 15000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}