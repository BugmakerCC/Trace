{{
  "language": "Vyper",
  "sources": {
    "contracts/Agent.vy": {
      "content": "# pragma version 0.4.0\n# pragma evm-version shanghai\n\"\"\"\n@title Agent\n@author CurveFi\n@license MIT\n@custom:version 1.0.0\n\"\"\"\n\nversion: public(constant(String[8])) = \"1.0.0\"\n\ninterface IAgent:\n    def execute(_messages: DynArray[Message, MAX_MESSAGES]): nonpayable\n    def RELAYER() -> address: view\n\n\nstruct Message:\n    target: address\n    data: Bytes[MAX_BYTES]\n\n\nflag Agent:\n    OWNERSHIP\n    PARAMETER\n    EMERGENCY\n\n\nMAX_BYTES: constant(uint256) = 1024\nMAX_MESSAGES: constant(uint256) = 8\n\n\nRELAYER: public(immutable(address))\n\n\n@deploy\ndef __init__():\n    RELAYER = msg.sender\n\n\n@external\ndef execute(_messages: DynArray[Message, MAX_MESSAGES]):\n    \"\"\"\n    @notice Execute a sequence of messages.\n    @param _messages An array of messages to be executed.\n    \"\"\"\n    assert msg.sender == RELAYER\n\n    for message: Message in _messages:\n        raw_call(message.target, message.data)\n",
      "sha256sum": "dc2516500d049bf222b5b6c2ac9b44b385a1d17b808c897dfd9d97af0d9244f4"
    },
    "contracts/Broadcaster.vy": {
      "content": "# pragma version 0.4.0\n\"\"\"\n@title Broadcaster\n@author Curve.Fi\n@license Copyright (c) Curve.Fi, 2020-2024 - all rights reserved\n@custom:version 0.0.1\n@notice Governance message broadcaster\n\"\"\"\n\nimport Agent as agent_lib\n\n\nevent Broadcast:\n    chain_id: indexed(uint256)\n    agent: indexed(agent_lib.Agent)\n    messages: DynArray[agent_lib.Message, agent_lib.MAX_MESSAGES]\n\n\nevent ApplyAdmins:\n    admins: AdminSet\n\nevent CommitAdmins:\n    future_admins: AdminSet\n\n\nstruct AdminSet:\n    ownership: address\n    parameter: address\n    emergency: address\n\n\nadmins: public(AdminSet)\nfuture_admins: public(AdminSet)\n\nagent: public(HashMap[address, agent_lib.Agent])\n\n\n\n@deploy\ndef __init__(_admins: AdminSet):\n    assert _admins.ownership != _admins.parameter  # a != b\n    assert _admins.ownership != _admins.emergency  # a != c\n    assert _admins.parameter != _admins.emergency  # b != c\n\n    self.admins = _admins\n\n    self.agent[_admins.ownership] = agent_lib.Agent.OWNERSHIP\n    self.agent[_admins.parameter] = agent_lib.Agent.PARAMETER\n    self.agent[_admins.emergency] = agent_lib.Agent.EMERGENCY\n\n    log ApplyAdmins(_admins)\n\n\n@internal\ndef _broadcast_check(chain_id: uint256, messages: DynArray[agent_lib.Message, agent_lib.MAX_MESSAGES]) -> agent_lib.Agent:\n    \"\"\"\n    @notice Broadcast a sequence of messages.\n    @param _chain_id Chain ID of L2\n    @param _messages The sequence of messages to broadcast.\n    \"\"\"\n    agent: agent_lib.Agent = self.agent[msg.sender]\n    assert agent != empty(agent_lib.Agent)\n    log Broadcast(chain_id, agent, messages)\n\n    return agent\n\n\n@external\ndef commit_admins(_future_admins: AdminSet):\n    \"\"\"\n    @notice Commit an admin set to use in the future.\n    \"\"\"\n    assert msg.sender == self.admins.ownership\n\n    assert _future_admins.ownership != _future_admins.parameter  # a != b\n    assert _future_admins.ownership != _future_admins.emergency  # a != c\n    assert _future_admins.parameter != _future_admins.emergency  # b != c\n\n    self.future_admins = _future_admins\n    log CommitAdmins(_future_admins)\n\n\n@external\ndef apply_admins():\n    \"\"\"\n    @notice Apply the future admin set.\n    \"\"\"\n    admins: AdminSet = self.admins\n    assert msg.sender == admins.ownership\n\n    # reset old admins\n    self.agent[admins.ownership] = empty(agent_lib.Agent)\n    self.agent[admins.parameter] = empty(agent_lib.Agent)\n    self.agent[admins.emergency] = empty(agent_lib.Agent)\n\n    # set new admins\n    future_admins: AdminSet = self.future_admins\n    self.agent[future_admins.ownership] = agent_lib.Agent.OWNERSHIP\n    self.agent[future_admins.parameter] = agent_lib.Agent.PARAMETER\n    self.agent[future_admins.emergency] = agent_lib.Agent.EMERGENCY\n\n    self.admins = future_admins\n    log ApplyAdmins(future_admins)\n",
      "sha256sum": "1b0646aebd18e590b3e5931fa7490e256429c34b646fb85967770698d84fa144"
    },
    "contracts/taiko/TaikoBroadcaster.vy": {
      "content": "# pragma version 0.4.0\n\"\"\"\n@title CurveXGovTaikoBroadcaster\n@author Curve.Fi\n@license Copyright (c) Curve.Fi, 2020-2024 - all rights reserved\n@custom:version 0.0.1\n@notice Taiko governance message broadcaster\n\"\"\"\n\nversion: public(constant(String[8])) = \"0.0.1\"\n\nimport contracts.Broadcaster as Broadcaster\n\ninitializes: Broadcaster\n\n\ninterface Bridge:\n    def sendMessage(_message: Message) -> (bytes32, Message): payable\n\n\nevent SetDestinationData:\n    chain_id: indexed(uint256)\n    destination_data: DestinationData\n\n\nstruct Message:\n    id: uint64  # Message ID whose value is automatically assigned.\n    fee: uint64  # The max processing fee for the relayer. This fee has 3 parts:\n                 # - the fee for message calldata.\n                 # - the minimal fee reserve for general processing, excluding function call.\n                 # - the invocation fee for the function call.\n                 # Any unpaid fee will be refunded to the destOwner on the destination chain.\n                 # Note that fee must be 0 if gasLimit is 0, or large enough to make the invocation fee\n                 # non-zero.\n    gasLimit: uint32  # gasLimit that the processMessage call must have.\n    _from: address  # The address, EOA or contract, that interacts with this bridge.\n                    # The value is automatically assigned.\n    srcChainId: uint64  # Source chain ID whose value is automatically assigned.\n    srcOwner: address  # The owner of the message on the source chain.\n    destChainId: uint64  # Destination chain ID where the `to` address lives.\n    destOwner: address  # The owner of the message on the destination chain.\n    to: address  # The destination address on the destination chain.\n    value: uint256  # value to invoke on the destination chain.\n    data: Bytes[MAX_MESSAGE_RECEIVED]  # callData to invoke on the destination chain.\n\n\nstruct DestinationData:\n    gas_price: uint256\n    gas_limit: uint256\n    dest_owner: address  # FeeCollector or Curve Vault\n    relayer: address\n    allow_manual_parameters: bool\n\nstruct ManualParameters:\n    dest_owner: address\n\n\nMAX_MESSAGE_RECEIVED: constant(uint256) = 9400\n\nBRIDGE: public(constant(Bridge)) = Bridge(0xd60247c6848B7Ca29eDdF63AA924E53dB6Ddd8EC)\n\ndestination_data: public(HashMap[uint256, DestinationData])\n\nmanual_parameters: transient(ManualParameters)\n\n\n@deploy\ndef __init__(_admins: Broadcaster.AdminSet):\n    Broadcaster.__init__(_admins)\n\nexports: Broadcaster.__interface__\n\n\n@payable\n@external\ndef __default__():\n    assert len(msg.data) == 0\n\n\n@internal\ndef _applied_destination_data(data: DestinationData) -> DestinationData:\n    \"\"\"\n    @notice Apply manual parameters\n    \"\"\"\n    if data.allow_manual_parameters:\n        dest_owner: address = self.manual_parameters.dest_owner\n        if dest_owner != empty(address):\n            data.dest_owner = dest_owner\n\n    return data\n\n\n@payable\n@external\ndef broadcast(_chain_id: uint256, _messages: DynArray[Broadcaster.agent_lib.Message, Broadcaster.agent_lib.MAX_MESSAGES], _destination_data: DestinationData=empty(DestinationData)):\n    \"\"\"\n    @notice Broadcast a sequence of messages.\n    @param _chain_id Chain ID of L2\n    @param _messages The sequence of messages to broadcast.\n    @param _destination_data Specific DestinationData (self.destination_data by default)\n    \"\"\"\n    agent: Broadcaster.agent_lib.Agent = Broadcaster._broadcast_check(_chain_id, _messages)\n\n    destination: DestinationData = _destination_data\n    if destination.relayer == empty(address):\n        destination = self.destination_data[_chain_id]\n    assert destination.relayer != empty(address)\n\n    data: DestinationData = self._applied_destination_data(destination)\n\n    fee: uint256 = data.gas_price * data.gas_limit\n    extcall BRIDGE.sendMessage(\n        Message(\n            id=0,  # Message ID whose value is automatically assigned.\n            fee=convert(fee, uint64),\n            gasLimit=convert(data.gas_limit, uint32),\n            _from=empty(address),  # The value is automatically assigned.\n            srcChainId=0,  # Source chain ID whose value is automatically assigned.\n            srcOwner=msg.sender,\n            destChainId=convert(_chain_id, uint64),\n            destOwner=data.dest_owner,\n            to=data.relayer,\n            value=0,\n            data=abi_encode(\n                abi_encode(  # relay(uint256,(address,bytes)[])\n                    agent,\n                    _messages,\n                ),\n                method_id=method_id(\"onMessageInvocation(bytes)\")\n            ),  # callData to invoke on the destination chain.\n        ),\n        value=fee,\n    )\n\n\n@view\n@external\ndef cost(_chain_id: uint256) -> uint256:\n    \"\"\"\n    @notice Cost in ETH to bridge\n    \"\"\"\n    data: DestinationData = self.destination_data[_chain_id]\n    return data.gas_price * data.gas_limit\n\n\n@external\ndef set_manual_parameters(_manual_parameters: ManualParameters):\n    \"\"\"\n    @notice Set manual parameters that will be actual within current transaction\n    \"\"\"\n    self.manual_parameters = _manual_parameters\n\n\n@external\ndef set_destination_data(_chain_id: uint256, _destination_data: DestinationData):\n    \"\"\"\n    @notice Set custom destination data. In order to turn off chain id set bridge=0xdead\n    \"\"\"\n    assert msg.sender == Broadcaster.admins.ownership\n    self.destination_data[_chain_id] = _destination_data\n    log SetDestinationData(_chain_id, _destination_data)\n",
      "sha256sum": "1d589e6d8bac3ccf93558e912fd8633987e2ac558c2a0be3634dc730d0ddaf51"
    }
  },
  "settings": {
    "outputSelection": {
      "contracts/taiko/TaikoBroadcaster.vy": [
        "evm.bytecode",
        "evm.deployedBytecode",
        "abi"
      ]
    },
    "search_paths": [
      "."
    ]
  },
  "compiler_version": "v0.4.0+commit.e9db8d9",
  "integrity": "c7ed09e8c27f55579709657f63fb16c8284225e9c1bae893d3f09f8669dc7431"
}}