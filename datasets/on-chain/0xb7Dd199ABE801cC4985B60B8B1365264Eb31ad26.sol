{{
  "language": "Solidity",
  "sources": {
    "src/base/DecodersAndSanitizers/EtherFiEigenDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\nimport {EigenLayerLSTStakingDecoderAndSanitizer} from\n    \"src/base/DecodersAndSanitizers/Protocols/EigenLayerLSTStakingDecoderAndSanitizer.sol\";\n\ncontract EtherFiEigenDecoderAndSanitizer is BaseDecoderAndSanitizer, EigenLayerLSTStakingDecoderAndSanitizer {\n    constructor(address _boringVault) BaseDecoderAndSanitizer(_boringVault) {}\n\n    function execute(address _to, uint256, bytes calldata) external pure returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(_to);\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {DecoderCustomTypes} from \"src/interfaces/DecoderCustomTypes.sol\";\n\ncontract BaseDecoderAndSanitizer {\n    error BaseDecoderAndSanitizer__FunctionSelectorNotSupported();\n    //============================== IMMUTABLES ===============================\n\n    /**\n     * @notice The BoringVault contract address.\n     */\n    address internal immutable boringVault;\n\n    constructor(address _boringVault) {\n        boringVault = _boringVault;\n    }\n\n    function approve(address spender, uint256) external pure returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(spender);\n    }\n\n    function transfer(address _to, uint256) external pure returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(_to);\n    }\n\n    function claimFees(address feeAsset) external pure returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(feeAsset);\n    }\n\n    function withdrawNonBoringToken(address token, uint256 /*amount*/ )\n        external\n        pure\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(token);\n    }\n\n    function withdrawNativeFromDrone() external pure returns (bytes memory addressesFound) {\n        return addressesFound;\n    }\n\n    //============================== FALLBACK ===============================\n    /**\n     * @notice The purpose of this function is to revert with a known error,\n     *         so that during merkle tree creation we can verify that a\n     *         leafs decoder and sanitizer implments the required function\n     *         selector.\n     */\n    fallback() external {\n        revert BaseDecoderAndSanitizer__FunctionSelectorNotSupported();\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/EigenLayerLSTStakingDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract EigenLayerLSTStakingDecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== ERRORS ===============================\n\n    error EigenLayerLSTStakingDecoderAndSanitizer__CanOnlyReceiveAsTokens();\n\n    //============================== EIGEN LAYER ===============================\n\n    function depositIntoStrategy(address strategy, address token, uint256 /*amount*/ )\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(strategy, token);\n    }\n\n    function queueWithdrawals(DecoderCustomTypes.QueuedWithdrawalParams[] calldata queuedWithdrawalParams)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        for (uint256 i = 0; i < queuedWithdrawalParams.length; i++) {\n            for (uint256 j = 0; j < queuedWithdrawalParams[i].strategies.length; j++) {\n                addressesFound = abi.encodePacked(addressesFound, queuedWithdrawalParams[i].strategies[j]);\n            }\n            addressesFound = abi.encodePacked(addressesFound, queuedWithdrawalParams[i].withdrawer);\n        }\n    }\n\n    function completeQueuedWithdrawals(\n        DecoderCustomTypes.Withdrawal[] calldata withdrawals,\n        address[][] calldata tokens,\n        uint256[] calldata, /*middlewareTimesIndexes*/\n        bool[] calldata receiveAsTokens\n    ) external pure virtual returns (bytes memory addressesFound) {\n        for (uint256 i = 0; i < withdrawals.length; i++) {\n            if (!receiveAsTokens[i]) revert EigenLayerLSTStakingDecoderAndSanitizer__CanOnlyReceiveAsTokens();\n\n            addressesFound = abi.encodePacked(\n                addressesFound, withdrawals[i].staker, withdrawals[i].delegatedTo, withdrawals[i].withdrawer\n            );\n            for (uint256 j = 0; j < withdrawals[i].strategies.length; j++) {\n                addressesFound = abi.encodePacked(addressesFound, withdrawals[i].strategies[j]);\n            }\n            for (uint256 j = 0; j < tokens.length; j++) {\n                addressesFound = abi.encodePacked(addressesFound, tokens[i][j]);\n            }\n        }\n    }\n\n    function delegateTo(\n        address operator,\n        DecoderCustomTypes.SignatureWithExpiry calldata, /*approverSignatureAndExpiry*/\n        bytes32 /*approverSalt*/\n    ) external pure returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(operator);\n    }\n\n    function undelegate(address staker) external pure returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(staker);\n    }\n\n    function setClaimerFor(address claimer) external pure returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(claimer);\n    }\n\n    /**\n     * @notice We intentionally do not report claim.earnerLeaf.earner, and claim.tokenLeaves[i].token\n     *         These addresses are not important for the security of the call.\n     */\n    function processClaim(DecoderCustomTypes.RewardsMerkleClaim calldata, /*claim*/ address recipient)\n        external\n        pure\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(recipient);\n    }\n}\n"
    },
    "src/interfaces/DecoderCustomTypes.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\ncontract DecoderCustomTypes {\n    // ========================================= BALANCER =========================================\n    struct JoinPoolRequest {\n        address[] assets;\n        uint256[] maxAmountsIn;\n        bytes userData;\n        bool fromInternalBalance;\n    }\n\n    struct ExitPoolRequest {\n        address[] assets;\n        uint256[] minAmountsOut;\n        bytes userData;\n        bool toInternalBalance;\n    }\n\n    enum SwapKind {\n        GIVEN_IN,\n        GIVEN_OUT\n    }\n\n    struct SingleSwap {\n        bytes32 poolId;\n        SwapKind kind;\n        address assetIn;\n        address assetOut;\n        uint256 amount;\n        bytes userData;\n    }\n\n    struct FundManagement {\n        address sender;\n        bool fromInternalBalance;\n        address recipient;\n        bool toInternalBalance;\n    }\n\n    // ========================================= UNISWAP V3 =========================================\n\n    struct MintParams {\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n    }\n\n    struct IncreaseLiquidityParams {\n        uint256 tokenId;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    struct DecreaseLiquidityParams {\n        uint256 tokenId;\n        uint128 liquidity;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    struct CollectParams {\n        uint256 tokenId;\n        address recipient;\n        uint128 amount0Max;\n        uint128 amount1Max;\n    }\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    struct PancakeSwapExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    // ========================================= MORPHO BLUE =========================================\n\n    struct MarketParams {\n        address loanToken;\n        address collateralToken;\n        address oracle;\n        address irm;\n        uint256 lltv;\n    }\n\n    // ========================================= 1INCH =========================================\n\n    struct SwapDescription {\n        address srcToken;\n        address dstToken;\n        address payable srcReceiver;\n        address payable dstReceiver;\n        uint256 amount;\n        uint256 minReturnAmount;\n        uint256 flags;\n    }\n\n    // ========================================= PENDLE =========================================\n    struct TokenInput {\n        // TOKEN DATA\n        address tokenIn;\n        uint256 netTokenIn;\n        address tokenMintSy;\n        // AGGREGATOR DATA\n        address pendleSwap;\n        SwapData swapData;\n    }\n\n    struct TokenOutput {\n        // TOKEN DATA\n        address tokenOut;\n        uint256 minTokenOut;\n        address tokenRedeemSy;\n        // AGGREGATOR DATA\n        address pendleSwap;\n        SwapData swapData;\n    }\n\n    struct ApproxParams {\n        uint256 guessMin;\n        uint256 guessMax;\n        uint256 guessOffchain; // pass 0 in to skip this variable\n        uint256 maxIteration; // every iteration, the diff between guessMin and guessMax will be divided by 2\n        uint256 eps; // the max eps between the returned result & the correct result, base 1e18. Normally this number will be set\n            // to 1e15 (1e18/1000 = 0.1%)\n    }\n\n    struct SwapData {\n        SwapType swapType;\n        address extRouter;\n        bytes extCalldata;\n        bool needScale;\n    }\n\n    enum SwapType {\n        NONE,\n        KYBERSWAP,\n        ONE_INCH,\n        // ETH_WETH not used in Aggregator\n        ETH_WETH\n    }\n\n    struct LimitOrderData {\n        address limitRouter;\n        uint256 epsSkipMarket; // only used for swap operations, will be ignored otherwise\n        FillOrderParams[] normalFills;\n        FillOrderParams[] flashFills;\n        bytes optData;\n    }\n\n    struct FillOrderParams {\n        Order order;\n        bytes signature;\n        uint256 makingAmount;\n    }\n\n    struct Order {\n        uint256 salt;\n        uint256 expiry;\n        uint256 nonce;\n        OrderType orderType;\n        address token;\n        address YT;\n        address maker;\n        address receiver;\n        uint256 makingAmount;\n        uint256 lnImpliedRate;\n        uint256 failSafeRate;\n        bytes permit;\n    }\n\n    enum OrderType {\n        SY_FOR_PT,\n        PT_FOR_SY,\n        SY_FOR_YT,\n        YT_FOR_SY\n    }\n\n    // ========================================= EIGEN LAYER =========================================\n\n    struct QueuedWithdrawalParams {\n        // Array of strategies that the QueuedWithdrawal contains\n        address[] strategies;\n        // Array containing the amount of shares in each Strategy in the `strategies` array\n        uint256[] shares;\n        // The address of the withdrawer\n        address withdrawer;\n    }\n\n    struct Withdrawal {\n        // The address that originated the Withdrawal\n        address staker;\n        // The address that the staker was delegated to at the time that the Withdrawal was created\n        address delegatedTo;\n        // The address that can complete the Withdrawal + will receive funds when completing the withdrawal\n        address withdrawer;\n        // Nonce used to guarantee that otherwise identical withdrawals have unique hashes\n        uint256 nonce;\n        // Block number when the Withdrawal was created\n        uint32 startBlock;\n        // Array of strategies that the Withdrawal contains\n        address[] strategies;\n        // Array containing the amount of shares in each Strategy in the `strategies` array\n        uint256[] shares;\n    }\n\n    struct SignatureWithExpiry {\n        // the signature itself, formatted as a single bytes object\n        bytes signature;\n        // the expiration timestamp (UTC) of the signature\n        uint256 expiry;\n    }\n\n    struct EarnerTreeMerkleLeaf {\n        address earner;\n        bytes32 earnerTokenRoot;\n    }\n\n    struct TokenTreeMerkleLeaf {\n        address token;\n        uint256 cumulativeEarnings;\n    }\n\n    struct RewardsMerkleClaim {\n        uint32 rootIndex;\n        uint32 earnerIndex;\n        bytes earnerTreeProof;\n        EarnerTreeMerkleLeaf earnerLeaf;\n        uint32[] tokenIndices;\n        bytes[] tokenTreeProofs;\n        TokenTreeMerkleLeaf[] tokenLeaves;\n    }\n\n    // ========================================= CCIP =========================================\n\n    // If extraArgs is empty bytes, the default is 200k gas limit.\n    struct EVM2AnyMessage {\n        bytes receiver; // abi.encode(receiver address) for dest EVM chains\n        bytes data; // Data payload\n        EVMTokenAmount[] tokenAmounts; // Token transfers\n        address feeToken; // Address of feeToken. address(0) means you will send msg.value.\n        bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV2)\n    }\n\n    /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n    struct EVMTokenAmount {\n        address token; // token address on the local chain.\n        uint256 amount; // Amount of tokens.\n    }\n\n    struct EVMExtraArgsV1 {\n        uint256 gasLimit;\n    }\n\n    // ========================================= OFT =========================================\n\n    struct SendParam {\n        uint32 dstEid; // Destination endpoint ID.\n        bytes32 to; // Recipient address.\n        uint256 amountLD; // Amount to send in local decimals.\n        uint256 minAmountLD; // Minimum amount to send in local decimals.\n        bytes extraOptions; // Additional options supplied by the caller to be used in the LayerZero message.\n        bytes composeMsg; // The composed message for the send() operation.\n        bytes oftCmd; // The OFT command to be executed, unused in default OFT implementations.\n    }\n\n    struct MessagingFee {\n        uint256 nativeFee;\n        uint256 lzTokenFee;\n    }\n    // ========================================= L1StandardBridge =========================================\n\n    struct WithdrawalTransaction {\n        uint256 nonce;\n        address sender;\n        address target;\n        uint256 value;\n        uint256 gasLimit;\n        bytes data;\n    }\n\n    struct OutputRootProof {\n        bytes32 version;\n        bytes32 stateRoot;\n        bytes32 messagePasserStorageRoot;\n        bytes32 latestBlockhash;\n    }\n\n    // ========================================= Mantle L1StandardBridge =========================================\n\n    struct MantleWithdrawalTransaction {\n        uint256 nonce;\n        address sender;\n        address target;\n        uint256 mntValue;\n        uint256 value;\n        uint256 gasLimit;\n        bytes data;\n    }\n\n    // ========================================= Linea Bridge =========================================\n\n    struct ClaimMessageWithProofParams {\n        bytes32[] proof;\n        uint256 messageNumber;\n        uint32 leafIndex;\n        address from;\n        address to;\n        uint256 fee;\n        uint256 value;\n        address payable feeRecipient;\n        bytes32 merkleRoot;\n        bytes data;\n    }\n\n    // ========================================= Scroll Bridge =========================================\n\n    struct L2MessageProof {\n        uint256 batchIndex;\n        bytes merkleProof;\n    }\n\n    // ========================================= Camelot V3 =========================================\n\n    struct CamelotMintParams {\n        address token0;\n        address token1;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n    }\n    // ========================================= Velodrome V3 =========================================\n\n    struct VelodromeMintParams {\n        address token0;\n        address token1;\n        int24 tickSpacing;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n        uint160 sqrtPriceX96;\n    }\n\n    // ========================================= Karak =========================================\n\n    struct QueuedWithdrawal {\n        address staker;\n        address delegatedTo;\n        uint256 nonce;\n        uint256 start;\n        WithdrawRequest request;\n    }\n\n    struct WithdrawRequest {\n        address[] vaults;\n        uint256[] shares;\n        address withdrawer;\n    }\n\n    // ========================================= Term Finance ==================================\n\n    /// @dev TermAuctionOfferSubmission represents an offer submission to offeror an amount of money for a specific interest rate\n    struct TermAuctionOfferSubmission {\n        /// @dev For an existing offer this is the unique onchain identifier for this offer. For a new offer this is a randomized input that will be used to generate the unique onchain identifier.\n        bytes32 id;\n        /// @dev The address of the offeror\n        address offeror;\n        /// @dev Hash of the offered price as a percentage of the initial loaned amount vs amount returned at maturity. This stores 9 decimal places\n        bytes32 offerPriceHash;\n        /// @dev The maximum amount of purchase tokens that can be lent\n        uint256 amount;\n        /// @dev The address of the ERC20 purchase token\n        address purchaseToken;\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@solmate/=lib/solmate/src/",
      "@forge-std/=lib/forge-std/src/",
      "@ds-test/=lib/forge-std/lib/ds-test/src/",
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "@openzeppelin/=lib/openzeppelin-contracts/",
      "@ccip/=lib/ccip/",
      "@devtools-oapp-evm/=lib/OAppAuth/lib/devtools/packages/oapp-evm/contracts/oapp/",
      "@layerzerolabs/lz-evm-messagelib-v2/=lib/OAppAuth/node_modules/@layerzerolabs/lz-evm-messagelib-v2/",
      "@layerzerolabs/lz-evm-protocol-v2/=lib/OAppAuth/lib/LayerZero-V2/packages/layerzero-v2/evm/protocol/",
      "@layerzerolabs/oapp-evm/=lib/OAppAuth/lib/devtools/packages/oapp-evm/",
      "@lz-oapp-evm/=lib/OAppAuth/lib/LayerZero-V2/packages/layerzero-v2/evm/oapp/contracts/oapp/",
      "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
      "LayerZero-V2/=lib/OAppAuth/lib/",
      "LayerZero-v2/=lib/LayerZero-v2/",
      "OAppAuth/=lib/OAppAuth/",
      "ccip/=lib/ccip/contracts/",
      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      "forge-std/=lib/forge-std/src/",
      "halmos-cheatcodes/=lib/OAppAuth/lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/",
      "solidity-bytes-utils/=lib/OAppAuth/node_modules/solidity-bytes-utils/",
      "solmate/=lib/solmate/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "evmVersion": "shanghai",
    "viaIR": false,
    "libraries": {}
  }
}}