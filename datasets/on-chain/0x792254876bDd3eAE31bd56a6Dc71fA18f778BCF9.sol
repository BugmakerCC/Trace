{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "istanbul",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMathUpgradeable {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"../../math/SafeMathUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using SafeMathUpgradeable for uint256;\n    using AddressUpgradeable for address;\n\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "src/TokenBase/Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"../interface/IFlashloanExecutor.sol\";\nimport \"../library/SafeRatioMath.sol\";\n\nimport \"./TokenERC20.sol\";\n\n/**\n * @title dForce's lending Base Contract\n * @author dForce\n */\nabstract contract Base is TokenERC20 {\n    using SafeRatioMath for uint256;\n\n    /**\n     * @notice Expects to call only once to create a new lending market.\n     * @param _name Token name.\n     * @param _symbol Token symbol.\n     * @param _controller Core controller contract address.\n     * @param _interestRateModel Token interest rate model contract address.\n     */\n    function _initialize(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        IController _controller,\n        IInterestRateModel _interestRateModel\n    ) internal virtual {\n        controller = _controller;\n        interestRateModel = _interestRateModel;\n        _updateAccrualInterestUnit(_getInterestUnit());\n        borrowIndex = BASE;\n        flashloanFeeRatio = 0.0008e18;\n        protocolFeeRatio = 0.25e18;\n        __Ownable_init();\n        __ERC20_init(_name, _symbol, _decimals);\n        __ReentrancyGuard_init();\n\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(_name)),\n                keccak256(bytes(\"1\")),\n                _getChainId(),\n                address(this)\n            )\n        );\n    }\n\n    /*********************************/\n    /******** Security Check *********/\n    /*********************************/\n\n    /**\n     * @notice Check whether is a iToken contract, return false for iMSD contract.\n     */\n    function isiToken() external pure virtual returns (bool) {\n        return true;\n    }\n\n    //----------------------------------\n    //******** Main calculation ********\n    //----------------------------------\n\n    struct InterestLocalVars {\n        uint256 borrowRate;\n        uint256 currentInterestUnit;\n        uint256 currentCash;\n        uint256 totalBorrows;\n        uint256 totalReserves;\n        uint256 borrowIndex;\n        uint256 unitDelta;\n        uint256 simpleInterestFactor;\n        uint256 interestAccumulated;\n        uint256 newTotalBorrows;\n        uint256 newTotalReserves;\n        uint256 newBorrowIndex;\n    }\n\n    function _getInterestUnit()\n        internal\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return block.number;\n    }\n\n    function getAccrualInterestUnit()\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return accrualBlockNumber;\n    }\n\n    function _updateAccrualInterestUnit(\n        uint256 _unit\n    ) internal virtual override {\n        accrualBlockNumber = _unit;\n    }\n\n    /**\n     * @notice Calculates interest and update total borrows and reserves.\n     * @dev Updates total borrows and reserves with any accumulated interest.\n     */\n    function _updateInterest() internal virtual override {\n        // When more calls in the same timestamp, only the first one takes effect, so for the\n        // following calls, nothing updates.\n        if (_getInterestUnit() != getAccrualInterestUnit()) {\n            InterestLocalVars memory _vars;\n            _vars.currentCash = _getCurrentCash();\n            _vars.totalBorrows = totalBorrows;\n            _vars.totalReserves = totalReserves;\n\n            // Gets the current borrow interest rate.\n            _vars.borrowRate = interestRateModel.getBorrowRate(\n                _vars.currentCash,\n                _vars.totalBorrows,\n                _vars.totalReserves\n            );\n            require(\n                _vars.borrowRate <= maxBorrowRate,\n                \"_updateInterest: Borrow rate is too high!\"\n            );\n\n            // Records the current block number.\n            _vars.currentInterestUnit = _getInterestUnit();\n\n            // Calculates the number of blocks elapsed since the last accrual.\n            _vars.unitDelta = _vars.currentInterestUnit.sub(\n                getAccrualInterestUnit()\n            );\n\n            /**\n             * Calculates the interest accumulated into borrows and reserves and the new index:\n             *  simpleInterestFactor = borrowRate * secsDelta\n             *  interestAccumulated = simpleInterestFactor * totalBorrows\n             *  newTotalBorrows = interestAccumulated + totalBorrows\n             *  newTotalReserves = interestAccumulated * reserveFactor + totalReserves\n             *  newBorrowIndex = simpleInterestFactor * borrowIndex + borrowIndex\n             */\n            _vars.simpleInterestFactor = _vars.borrowRate.mul(_vars.unitDelta);\n            _vars.interestAccumulated = _vars.simpleInterestFactor.rmul(\n                _vars.totalBorrows\n            );\n            _vars.newTotalBorrows = _vars.interestAccumulated.add(\n                _vars.totalBorrows\n            );\n            _vars.newTotalReserves = reserveRatio\n                .rmul(_vars.interestAccumulated)\n                .add(_vars.totalReserves);\n\n            _vars.borrowIndex = borrowIndex;\n            _vars.newBorrowIndex = _vars\n                .simpleInterestFactor\n                .rmul(_vars.borrowIndex)\n                .add(_vars.borrowIndex);\n\n            // Writes the previously calculated values into storage.\n            _updateAccrualInterestUnit(_vars.currentInterestUnit);\n            borrowIndex = _vars.newBorrowIndex;\n            totalBorrows = _vars.newTotalBorrows;\n            totalReserves = _vars.newTotalReserves;\n\n            // Emits an `UpdateInterest` event.\n            emit UpdateInterest(\n                _vars.currentInterestUnit,\n                _vars.interestAccumulated,\n                _vars.newBorrowIndex,\n                _vars.currentCash,\n                _vars.newTotalBorrows,\n                _vars.newTotalReserves\n            );\n        }\n    }\n\n    struct MintLocalVars {\n        uint256 exchangeRate;\n        uint256 mintTokens;\n        uint256 actualMintAmout;\n    }\n\n    /**\n     * @dev User deposits token into the market and `_recipient` gets iToken.\n     * @param _recipient The address of the user to get iToken.\n     * @param _mintAmount The amount of the underlying token to deposit.\n     */\n    function _mintInternal(\n        address _recipient,\n        uint256 _mintAmount\n    ) internal virtual {\n        controller.beforeMint(address(this), _recipient, _mintAmount);\n\n        MintLocalVars memory _vars;\n\n        /**\n         * Gets the current exchange rate and calculate the number of iToken to be minted:\n         *  mintTokens = mintAmount / exchangeRate\n         */\n        _vars.exchangeRate = _exchangeRateInternal();\n\n        // Transfers `_mintAmount` from caller to contract, and returns the actual amount the contract\n        // get, cause some tokens may be charged.\n\n        _vars.actualMintAmout = _doTransferIn(msg.sender, _mintAmount);\n\n        // Supports deflationary tokens.\n        _vars.mintTokens = _vars.actualMintAmout.rdiv(_vars.exchangeRate);\n\n        // Mints `mintTokens` iToken to `_recipient`.\n        _mint(_recipient, _vars.mintTokens);\n\n        require(\n            totalSupply >= TOTAL_SUPPLY_THRESHOLD,\n            \"_mintInternal: totalSupply too small!\"\n        );\n\n        controller.afterMint(\n            address(this),\n            _recipient,\n            _mintAmount,\n            _vars.mintTokens\n        );\n\n        emit Mint(msg.sender, _recipient, _mintAmount, _vars.mintTokens);\n    }\n\n    /**\n     * @notice This is a common function to redeem, so only one of `_redeemiTokenAmount` or\n     *         `_redeemUnderlyingAmount` may be non-zero.\n     * @dev Caller redeems undelying token based on the input amount of iToken or underlying token.\n     * @param _from The address of the account which will spend underlying token.\n     * @param _redeemiTokenAmount The number of iTokens to redeem into underlying.\n     * @param _redeemUnderlyingAmount The number of underlying tokens to receive.\n     */\n    function _redeemInternal(\n        address _from,\n        uint256 _redeemiTokenAmount,\n        uint256 _redeemUnderlyingAmount\n    ) internal virtual {\n        require(\n            _redeemiTokenAmount > 0,\n            \"_redeemInternal: Redeem iToken amount should be greater than zero!\"\n        );\n\n        controller.beforeRedeem(address(this), _from, _redeemiTokenAmount);\n\n        _burnFrom(_from, _redeemiTokenAmount);\n\n        // Allow totalSupply reset to 0\n        require(\n            totalSupply >= TOTAL_SUPPLY_THRESHOLD || totalSupply == 0,\n            \"_redeemInternal: totalSupply too small!\"\n        );\n\n        /**\n         * Transfers `_redeemUnderlyingAmount` underlying token to caller.\n         */\n        _doTransferOut(msg.sender, _redeemUnderlyingAmount);\n\n        controller.afterRedeem(\n            address(this),\n            _from,\n            _redeemiTokenAmount,\n            _redeemUnderlyingAmount\n        );\n\n        emit Redeem(\n            _from,\n            msg.sender,\n            _redeemiTokenAmount,\n            _redeemUnderlyingAmount\n        );\n    }\n\n    /**\n     * @dev Caller borrows assets from the protocol.\n     * @param _borrower The account that will borrow tokens.\n     * @param _borrowAmount The amount of the underlying asset to borrow.\n     */\n    function _borrowInternal(\n        address payable _borrower,\n        uint256 _borrowAmount\n    ) internal virtual {\n        controller.beforeBorrow(address(this), _borrower, _borrowAmount);\n\n        // Calculates the new borrower and total borrow balances:\n        //  newAccountBorrows = accountBorrows + borrowAmount\n        //  newTotalBorrows = totalBorrows + borrowAmount\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[_borrower];\n        borrowSnapshot.principal = _borrowBalanceInternal(_borrower).add(\n            _borrowAmount\n        );\n        borrowSnapshot.interestIndex = borrowIndex;\n        totalBorrows = totalBorrows.add(_borrowAmount);\n\n        // Transfers token to borrower.\n        _doTransferOut(_borrower, _borrowAmount);\n\n        controller.afterBorrow(address(this), _borrower, _borrowAmount);\n\n        emit Borrow(\n            _borrower,\n            _borrowAmount,\n            borrowSnapshot.principal,\n            borrowSnapshot.interestIndex,\n            totalBorrows\n        );\n    }\n\n    /**\n     * @notice Please approve enough amount at first!!! If not,\n     *         maybe you will get an error: `SafeMath: subtraction overflow`\n     * @dev `_payer` repays `_repayAmount` tokens for `_borrower`.\n     * @param _payer The account to pay for the borrowed.\n     * @param _borrower The account with the debt being payed off.\n     * @param _repayAmount The amount to repay (or -1 for max).\n     */\n    function _repayInternal(\n        address _payer,\n        address _borrower,\n        uint256 _repayAmount\n    ) internal virtual returns (uint256) {\n        controller.beforeRepayBorrow(\n            address(this),\n            _payer,\n            _borrower,\n            _repayAmount\n        );\n\n        // Calculates the latest borrowed amount by the new market borrowed index.\n        uint256 _accountBorrows = _borrowBalanceInternal(_borrower);\n\n        // Transfers the token into the market to repay.\n        uint256 _actualRepayAmount = _doTransferIn(\n            _payer,\n            _repayAmount > _accountBorrows ? _accountBorrows : _repayAmount\n        );\n\n        // Calculates the `_borrower` new borrow balance and total borrow balances:\n        //  accountBorrows[_borrower].principal = accountBorrows - actualRepayAmount\n        //  newTotalBorrows = totalBorrows - actualRepayAmount\n\n        // Saves borrower updates.\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[_borrower];\n        borrowSnapshot.principal = _accountBorrows.sub(_actualRepayAmount);\n        borrowSnapshot.interestIndex = borrowIndex;\n\n        totalBorrows = totalBorrows < _actualRepayAmount\n            ? 0\n            : totalBorrows.sub(_actualRepayAmount);\n\n        // Defense hook.\n        controller.afterRepayBorrow(\n            address(this),\n            _payer,\n            _borrower,\n            _actualRepayAmount\n        );\n\n        emit RepayBorrow(\n            _payer,\n            _borrower,\n            _actualRepayAmount,\n            borrowSnapshot.principal,\n            borrowSnapshot.interestIndex,\n            totalBorrows\n        );\n\n        return _actualRepayAmount;\n    }\n\n    /**\n     * @dev The caller repays some of borrow and receive collateral.\n     * @param _borrower The account whose borrow should be liquidated.\n     * @param _repayAmount The amount to repay.\n     * @param _assetCollateral The market in which to seize collateral from the borrower.\n     */\n    function _liquidateBorrowInternal(\n        address _borrower,\n        uint256 _repayAmount,\n        address _assetCollateral\n    ) internal virtual {\n        require(\n            msg.sender != _borrower,\n            \"_liquidateBorrowInternal: Liquidator can not be borrower!\"\n        );\n        // According to the parameter `_repayAmount` to see what is the exact error.\n        require(\n            _repayAmount != 0,\n            \"_liquidateBorrowInternal: Liquidate amount should be greater than 0!\"\n        );\n\n        // Accrues interest for collateral asset.\n        Base _dlCollateral = Base(_assetCollateral);\n        _dlCollateral.updateInterest();\n\n        controller.beforeLiquidateBorrow(\n            address(this),\n            _assetCollateral,\n            msg.sender,\n            _borrower,\n            _repayAmount\n        );\n\n        require(\n            _dlCollateral.getAccrualInterestUnit() == _getInterestUnit(),\n            \"_liquidateBorrowInternal: Failed to update block timestamp in collateral asset!\"\n        );\n\n        uint256 _actualRepayAmount = _repayInternal(\n            msg.sender,\n            _borrower,\n            _repayAmount\n        );\n\n        // Calculates the number of collateral tokens that will be seized\n        uint256 _seizeTokens = controller.liquidateCalculateSeizeTokens(\n            address(this),\n            _assetCollateral,\n            _actualRepayAmount\n        );\n\n        // If this is also the collateral, calls seizeInternal to avoid re-entrancy,\n        // otherwise make an external call.\n        if (_assetCollateral == address(this)) {\n            _seizeInternal(address(this), msg.sender, _borrower, _seizeTokens);\n        } else {\n            _dlCollateral.seize(msg.sender, _borrower, _seizeTokens);\n        }\n\n        controller.afterLiquidateBorrow(\n            address(this),\n            _assetCollateral,\n            msg.sender,\n            _borrower,\n            _actualRepayAmount,\n            _seizeTokens\n        );\n\n        emit LiquidateBorrow(\n            msg.sender,\n            _borrower,\n            _actualRepayAmount,\n            _assetCollateral,\n            _seizeTokens\n        );\n    }\n\n    /**\n     * @dev Transfers this token to the liquidator.\n     * @param _seizerToken The contract seizing the collateral.\n     * @param _liquidator The account receiving seized collateral.\n     * @param _borrower The account having collateral seized.\n     * @param _seizeTokens The number of iTokens to seize.\n     */\n    function _seizeInternal(\n        address _seizerToken,\n        address _liquidator,\n        address _borrower,\n        uint256 _seizeTokens\n    ) internal virtual {\n        require(\n            _borrower != _liquidator,\n            \"seize: Liquidator can not be borrower!\"\n        );\n\n        controller.beforeSeize(\n            address(this),\n            _seizerToken,\n            _liquidator,\n            _borrower,\n            _seizeTokens\n        );\n\n        /**\n         * Calculates the new _borrower and _liquidator token balances,\n         * that is transfer `_seizeTokens` iToken from `_borrower` to `_liquidator`.\n         */\n        _transfer(_borrower, _liquidator, _seizeTokens);\n\n        // Hook checks.\n        controller.afterSeize(\n            address(this),\n            _seizerToken,\n            _liquidator,\n            _borrower,\n            _seizeTokens\n        );\n    }\n\n    /**\n     * @param _account The address whose balance should be calculated.\n     */\n    function _borrowBalanceInternal(\n        address _account\n    ) internal view virtual returns (uint256) {\n        // Gets stored borrowed data of the `_account`.\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[_account];\n\n        // If borrowBalance = 0, return 0 directly.\n        if (borrowSnapshot.principal == 0 || borrowSnapshot.interestIndex == 0)\n            return 0;\n\n        // Calculate new borrow balance with market new borrow index:\n        //   recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n        return\n            borrowSnapshot.principal.mul(borrowIndex).divup(\n                borrowSnapshot.interestIndex\n            );\n    }\n\n    /**\n     * @dev Calculates the exchange rate from the underlying token to the iToken.\n     */\n    function _exchangeRateInternal() internal view virtual returns (uint256) {\n        if (totalSupply == 0) {\n            // This is the first time to mint, so current exchange rate is equal to initial exchange rate.\n            return initialExchangeRate;\n        } else {\n            // exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n            return\n                _getCurrentCash().add(totalBorrows).sub(totalReserves).rdiv(\n                    totalSupply\n                );\n        }\n    }\n\n    function updateInterest() external virtual returns (bool);\n\n    /**\n     * @dev EIP2612 permit function. For more details, please look at here:\n     * https://eips.ethereum.org/EIPS/eip-2612\n     * @param _owner The owner of the funds.\n     * @param _spender The spender.\n     * @param _value The amount.\n     * @param _deadline The deadline timestamp, type(uint256).max for max deadline.\n     * @param _v Signature param.\n     * @param _s Signature param.\n     * @param _r Signature param.\n     */\n    function permit(\n        address _owner,\n        address _spender,\n        uint256 _value,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external {\n        require(_deadline >= block.timestamp, \"permit: EXPIRED!\");\n        uint256 _currentNonce = nonces[_owner];\n\n        bytes32 _digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        PERMIT_TYPEHASH,\n                        _owner,\n                        _spender,\n                        _getChainId(),\n                        _value,\n                        _currentNonce,\n                        _deadline\n                    )\n                )\n            )\n        );\n        address _recoveredAddress = ecrecover(_digest, _v, _r, _s);\n        require(\n            _recoveredAddress != address(0) && _recoveredAddress == _owner,\n            \"permit: INVALID_SIGNATURE!\"\n        );\n        nonces[_owner] = _currentNonce.add(1);\n        _approve(_owner, _spender, _value);\n    }\n\n    function _getChainId() internal pure returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n\n    /**\n     * @dev Transfers this tokens to the liquidator.\n     * @param _liquidator The account receiving seized collateral.\n     * @param _borrower The account having collateral seized.\n     * @param _seizeTokens The number of iTokens to seize.\n     */\n    function seize(\n        address _liquidator,\n        address _borrower,\n        uint256 _seizeTokens\n    ) external virtual;\n\n    /**\n     * @notice Users are expected to have enough allowance and balance before calling.\n     * @dev Transfers asset in.\n     */\n    function _doTransferIn(\n        address _sender,\n        uint256 _amount\n    ) internal virtual returns (uint256);\n\n    function exchangeRateStored() external view virtual returns (uint256);\n\n    function borrowBalanceStored(\n        address _account\n    ) external view virtual returns (uint256);\n}\n"
    },
    "src/TokenBase/InterestUnit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nabstract contract InterestUnit {\n    function _getInterestUnit() internal view virtual returns (uint256) {}\n\n    function getAccrualInterestUnit() public view virtual returns (uint256) {}\n\n    function _updateAccrualInterestUnit(uint256 _unit) internal virtual {}\n}\n"
    },
    "src/TokenBase/TokenAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./TokenEvent.sol\";\nimport \"./InterestUnit.sol\";\n\n/**\n * @title dForce's lending Token admin Contract\n * @author dForce\n */\nabstract contract TokenAdmin is TokenEvent, InterestUnit {\n    //----------------------------------\n    //********* Owner Actions **********\n    //----------------------------------\n\n    modifier settleInterest() {\n        // Accrues interest.\n        _updateInterest();\n        require(\n            getAccrualInterestUnit() == _getInterestUnit(),\n            \"settleInterest: Fail to accrue interest!\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Sets a new controller.\n     */\n    function _setController(\n        IController _newController\n    ) external virtual onlyOwner {\n        IController _oldController = controller;\n        // Ensures the input address is a controller contract.\n        require(\n            _newController.isController(),\n            \"_setController: This is not the controller contract!\"\n        );\n\n        // Sets to new controller.\n        controller = _newController;\n\n        emit NewController(_oldController, _newController);\n    }\n\n    /**\n     * @dev Sets a new interest rate model.\n     * @param _newInterestRateModel The new interest rate model.\n     */\n    function _setInterestRateModel(\n        IInterestRateModel _newInterestRateModel\n    ) external virtual onlyOwner {\n        // Gets current interest rate model.\n        IInterestRateModel _oldInterestRateModel = interestRateModel;\n\n        // Ensures the input address is the interest model contract.\n        require(\n            _newInterestRateModel.isInterestRateModel(),\n            \"_setInterestRateModel: This is not the rate model contract!\"\n        );\n\n        // Set to the new interest rate model.\n        interestRateModel = _newInterestRateModel;\n\n        emit NewInterestRateModel(_oldInterestRateModel, _newInterestRateModel);\n    }\n\n    /**\n     * @dev Sets a new reserve ratio.\n     */\n    function _setNewReserveRatio(\n        uint256 _newReserveRatio\n    ) external virtual onlyOwner settleInterest {\n        require(\n            _newReserveRatio <= maxReserveRatio,\n            \"_setNewReserveRatio: New reserve ratio too large!\"\n        );\n\n        // Gets current reserve ratio.\n        uint256 _oldReserveRatio = reserveRatio;\n\n        // Sets new reserve ratio.\n        reserveRatio = _newReserveRatio;\n\n        emit NewReserveRatio(_oldReserveRatio, _newReserveRatio);\n    }\n\n    /**\n     * @dev Sets a new flashloan fee ratio.\n     */\n    function _setNewFlashloanFeeRatio(\n        uint256 _newFlashloanFeeRatio\n    ) external virtual onlyOwner settleInterest {\n        require(\n            _newFlashloanFeeRatio <= BASE,\n            \"setNewFlashloanFeeRatio: New flashloan ratio too large!\"\n        );\n\n        // Gets current reserve ratio.\n        uint256 _oldFlashloanFeeRatio = flashloanFeeRatio;\n\n        // Sets new reserve ratio.\n        flashloanFeeRatio = _newFlashloanFeeRatio;\n\n        emit NewFlashloanFeeRatio(_oldFlashloanFeeRatio, _newFlashloanFeeRatio);\n    }\n\n    /**\n     * @dev Sets a new protocol fee ratio.\n     */\n    function _setNewProtocolFeeRatio(\n        uint256 _newProtocolFeeRatio\n    )\n        external\n        virtual\n        onlyOwner\n        settleInterest // nonReentrant\n    {\n        require(\n            _newProtocolFeeRatio <= BASE,\n            \"_setNewProtocolFeeRatio: New protocol ratio too large!\"\n        );\n\n        // Gets current reserve ratio.\n        uint256 _oldProtocolFeeRatio = protocolFeeRatio;\n\n        // Sets new reserve ratio.\n        protocolFeeRatio = _newProtocolFeeRatio;\n\n        emit NewProtocolFeeRatio(_oldProtocolFeeRatio, _newProtocolFeeRatio);\n    }\n\n    /**\n     * @dev Admin withdraws `_withdrawAmount` of the iToken.\n     * @param _withdrawAmount Amount of reserves to withdraw.\n     */\n    function _withdrawReserves(\n        uint256 _withdrawAmount\n    )\n        external\n        virtual\n        onlyOwner\n        settleInterest // nonReentrant\n    {\n        require(\n            _withdrawAmount <= totalReserves &&\n                _withdrawAmount <= _getCurrentCash(),\n            \"_withdrawReserves: Invalid withdraw amount and do not have enough cash!\"\n        );\n\n        uint256 _oldTotalReserves = totalReserves;\n        // Updates total amount of the reserves.\n        totalReserves = totalReserves.sub(_withdrawAmount);\n\n        // Transfers reserve to the owner.\n        _doTransferOut(owner, _withdrawAmount);\n\n        emit ReservesWithdrawn(\n            owner,\n            _withdrawAmount,\n            totalReserves,\n            _oldTotalReserves\n        );\n    }\n\n    /**\n     * @notice Calculates interest and update total borrows and reserves.\n     * @dev Updates total borrows and reserves with any accumulated interest.\n     */\n    function _updateInterest() internal virtual;\n\n    /**\n     * @dev Transfers underlying token out.\n     */\n    function _doTransferOut(\n        address payable _recipient,\n        uint256 _amount\n    ) internal virtual;\n\n    /**\n     * @dev Total amount of reserves owned by this contract.\n     */\n    function _getCurrentCash() internal view virtual returns (uint256);\n}\n"
    },
    "src/TokenBase/TokenERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./TokenAdmin.sol\";\n\n/**\n * @title dForce's lending Token ERC20 Contract\n * @author dForce\n */\nabstract contract TokenERC20 is TokenAdmin {\n    /**\n     * @dev Transfers `_amount` tokens from `_sender` to `_recipient`.\n     * @param _sender The address of the source account.\n     * @param _recipient The address of the destination account.\n     * @param _amount The number of tokens to transfer.\n     */\n    function _transferTokens(\n        address _sender,\n        address _recipient,\n        uint256 _amount\n    ) internal returns (bool) {\n        require(\n            _sender != _recipient,\n            \"_transferTokens: Do not self-transfer!\"\n        );\n\n        controller.beforeTransfer(address(this), _sender, _recipient, _amount);\n\n        _transfer(_sender, _recipient, _amount);\n\n        controller.afterTransfer(address(this), _sender, _recipient, _amount);\n\n        return true;\n    }\n\n    //----------------------------------\n    //********* ERC20 Actions **********\n    //----------------------------------\n\n    /**\n     * @notice Cause iToken is an ERC20 token, so users can `transfer` them,\n     *         but this action is only allowed when after transferring tokens, the caller\n     *         does not have a shortfall.\n     * @dev Moves `_amount` tokens from caller to `_recipient`.\n     * @param _recipient The address of the destination account.\n     * @param _amount The number of tokens to transfer.\n     */\n    function transfer(\n        address _recipient,\n        uint256 _amount\n    ) public virtual override nonReentrant returns (bool) {\n        return _transferTokens(msg.sender, _recipient, _amount);\n    }\n\n    /**\n     * @notice Cause iToken is an ERC20 token, so users can `transferFrom` them,\n     *         but this action is only allowed when after transferring tokens, the `_sender`\n     *         does not have a shortfall.\n     * @dev Moves `_amount` tokens from `_sender` to `_recipient`.\n     * @param _sender The address of the source account.\n     * @param _recipient The address of the destination account.\n     * @param _amount The number of tokens to transfer.\n     */\n    function transferFrom(\n        address _sender,\n        address _recipient,\n        uint256 _amount\n    ) public virtual override nonReentrant returns (bool) {\n        _approve(\n            _sender,\n            msg.sender, // spender\n            allowance[_sender][msg.sender].sub(_amount)\n        );\n        return _transferTokens(_sender, _recipient, _amount);\n    }\n}\n"
    },
    "src/TokenBase/TokenEvent.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./TokenStorage.sol\";\n\n/**\n * @title dForce's lending Token event Contract\n * @author dForce\n */\ncontract TokenEvent is TokenStorage {\n    //----------------------------------\n    //********** User Events ***********\n    //----------------------------------\n\n    event UpdateInterest(\n        uint256 currentBlockNumber,\n        uint256 interestAccumulated,\n        uint256 borrowIndex,\n        uint256 cash,\n        uint256 totalBorrows,\n        uint256 totalReserves\n    );\n\n    event Mint(\n        address sender,\n        address recipient,\n        uint256 mintAmount,\n        uint256 mintTokens\n    );\n\n    event Redeem(\n        address from,\n        address recipient,\n        uint256 redeemiTokenAmount,\n        uint256 redeemUnderlyingAmount\n    );\n\n    /**\n     * @dev Emits when underlying is borrowed.\n     */\n    event Borrow(\n        address borrower,\n        uint256 borrowAmount,\n        uint256 accountBorrows,\n        uint256 accountInterestIndex,\n        uint256 totalBorrows\n    );\n\n    event RepayBorrow(\n        address payer,\n        address borrower,\n        uint256 repayAmount,\n        uint256 accountBorrows,\n        uint256 accountInterestIndex,\n        uint256 totalBorrows\n    );\n\n    event LiquidateBorrow(\n        address liquidator,\n        address borrower,\n        uint256 repayAmount,\n        address iTokenCollateral,\n        uint256 seizeTokens\n    );\n\n    event Flashloan(\n        address loaner,\n        uint256 loanAmount,\n        uint256 flashloanFee,\n        uint256 protocolFee,\n        uint256 timestamp\n    );\n\n    //----------------------------------\n    //********** Owner Events **********\n    //----------------------------------\n\n    event NewReserveRatio(uint256 oldReserveRatio, uint256 newReserveRatio);\n    event NewFlashloanFeeRatio(\n        uint256 oldFlashloanFeeRatio,\n        uint256 newFlashloanFeeRatio\n    );\n    event NewProtocolFeeRatio(\n        uint256 oldProtocolFeeRatio,\n        uint256 newProtocolFeeRatio\n    );\n    event NewFlashloanFee(\n        uint256 oldFlashloanFeeRatio,\n        uint256 newFlashloanFeeRatio,\n        uint256 oldProtocolFeeRatio,\n        uint256 newProtocolFeeRatio\n    );\n\n    event NewInterestRateModel(\n        IInterestRateModel oldInterestRateModel,\n        IInterestRateModel newInterestRateModel\n    );\n\n    event NewController(IController oldController, IController newController);\n\n    event ReservesWithdrawn(\n        address admin,\n        uint256 amount,\n        uint256 newTotalReserves,\n        uint256 oldTotalReserves\n    );\n}\n"
    },
    "src/TokenBase/TokenStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"../library/Initializable.sol\";\nimport \"../library/ReentrancyGuard.sol\";\nimport \"../library/Ownable.sol\";\nimport \"../library/ERC20.sol\";\n\nimport \"../interface/IInterestRateModel.sol\";\nimport \"../interface/IController.sol\";\n\n/**\n * @title dForce's lending Token storage Contract\n * @author dForce\n */\ncontract TokenStorage is Initializable, ReentrancyGuard, Ownable, ERC20 {\n    //----------------------------------\n    //********* Token Storage **********\n    //----------------------------------\n\n    uint256 constant BASE = 1e18;\n\n    /**\n     * @dev Whether this token is supported in the market or not.\n     */\n    bool public constant isSupported = true;\n\n    /**\n     * @dev Maximum borrow rate(0.1% per block, scaled by 1e18).\n     */\n    uint256 constant maxBorrowRate = 0.001e18;\n\n    /**\n     * @dev Interest ratio set aside for reserves(scaled by 1e18).\n     */\n    uint256 public reserveRatio;\n\n    /**\n     * @dev Maximum interest ratio that can be set aside for reserves(scaled by 1e18).\n     */\n    uint256 constant maxReserveRatio = 1e18;\n\n    /**\n     * @notice This ratio is relative to the total flashloan fee.\n     * @dev Flash loan fee rate(scaled by 1e18).\n     */\n    uint256 public flashloanFeeRatio;\n\n    /**\n     * @notice This ratio is relative to the total flashloan fee.\n     * @dev Protocol fee rate when a flashloan happens(scaled by 1e18);\n     */\n    uint256 public protocolFeeRatio;\n\n    /**\n     * @dev Underlying token address.\n     */\n    IERC20Upgradeable public underlying;\n\n    /**\n     * @dev Current interest rate model contract.\n     */\n    IInterestRateModel public interestRateModel;\n\n    /**\n     * @dev Core control of the contract.\n     */\n    IController public controller;\n\n    /**\n     * @dev Initial exchange rate(scaled by 1e18).\n     */\n    uint256 constant initialExchangeRate = 1e18;\n\n    /**\n     * @dev The interest index for borrows of asset as of blockNumber.\n     */\n    uint256 public borrowIndex;\n\n    /**\n     * @dev Block number that interest was last accrued at.\n     */\n    uint256 public accrualBlockNumber;\n\n    /**\n     * @dev Total amount of this reserve borrowed.\n     */\n    uint256 public totalBorrows;\n\n    /**\n     * @dev Total amount of this reserves accrued.\n     */\n    uint256 public totalReserves;\n\n    /**\n     * @dev Container for user balance information written to storage.\n     * @param principal User total balance with accrued interest after applying the user's most recent balance-changing action.\n     * @param interestIndex The total interestIndex as calculated after applying the user's most recent balance-changing action.\n     */\n    struct BorrowSnapshot {\n        uint256 principal;\n        uint256 interestIndex;\n    }\n\n    /**\n     * @dev 2-level map: userAddress -> assetAddress -> balance for borrows.\n     */\n    mapping(address => BorrowSnapshot) internal accountBorrows;\n\n    bytes32 public DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 chainId, uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH =\n        0x576144ed657c8304561e56ca632e17751956250114636e8c01f64a7f2c6d98cf;\n    mapping(address => uint256) public nonces;\n\n    /// @notice The threshold of totalSupply, to mitigate exchage rate inflation by donation\n    uint256 public constant TOTAL_SUPPLY_THRESHOLD = 10_000;\n}\n"
    },
    "src/iToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\n\nimport \"./TokenBase/Base.sol\";\n\n/**\n * @title dForce's Lending Protocol Contract.\n * @notice iTokens which wrap an EIP-20 underlying.\n * @author dForce Team.\n */\ncontract iToken is Base {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * @notice Expects to call only once to initialize a new market.\n     * @param _underlyingToken The underlying token address.\n     * @param _name Token name.\n     * @param _symbol Token symbol.\n     * @param _controller Core controller contract address.\n     * @param _interestRateModel Token interest rate model contract address.\n     */\n    function initialize(\n        address _underlyingToken,\n        string memory _name,\n        string memory _symbol,\n        IController _controller,\n        IInterestRateModel _interestRateModel\n    ) external initializer {\n        require(\n            address(_underlyingToken) != address(0),\n            \"initialize: underlying address should not be zero address!\"\n        );\n        require(\n            address(_controller) != address(0),\n            \"initialize: controller address should not be zero address!\"\n        );\n        require(\n            address(_interestRateModel) != address(0),\n            \"initialize: interest model address should not be zero address!\"\n        );\n        _initialize(\n            _name,\n            _symbol,\n            ERC20(_underlyingToken).decimals(),\n            _controller,\n            _interestRateModel\n        );\n\n        underlying = IERC20Upgradeable(_underlyingToken);\n    }\n\n    /**\n     * @notice In order to support deflationary token, returns the changed amount.\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom`.\n     */\n    function _doTransferIn(\n        address _sender,\n        uint256 _amount\n    ) internal override returns (uint256) {\n        uint256 _balanceBefore = underlying.balanceOf(address(this));\n        underlying.safeTransferFrom(_sender, address(this), _amount);\n        return underlying.balanceOf(address(this)).sub(_balanceBefore);\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transfer`.\n     */\n    function _doTransferOut(\n        address payable _recipient,\n        uint256 _amount\n    ) internal virtual override {\n        underlying.safeTransfer(_recipient, _amount);\n    }\n\n    /**\n     * @dev Gets balance of this contract in terms of the underlying\n     */\n    function _getCurrentCash() internal view override returns (uint256) {\n        return underlying.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Caller deposits assets into the market and `_recipient` receives iToken in exchange.\n     * @param _recipient The account that would receive the iToken.\n     * @param _mintAmount The amount of the underlying token to deposit.\n     */\n    function mint(\n        address _recipient,\n        uint256 _mintAmount\n    ) public nonReentrant settleInterest {\n        _mintInternal(_recipient, _mintAmount);\n    }\n\n    /**\n     * @dev Caller deposits assets into the market and caller receives iToken in exchange,\n     *        and add markets to caller's markets list for liquidity calculations.\n     * @param _mintAmount The amount of the underlying token to deposit.\n     */\n    function mintForSelfAndEnterMarket(\n        uint256 _mintAmount\n    ) public nonReentrant settleInterest {\n        _mintInternal(msg.sender, _mintAmount);\n        controller.enterMarketFromiToken(address(this), msg.sender);\n    }\n\n    /**\n     * @dev Caller redeems specified iToken from `_from` to get underlying token.\n     * @param _from The account that would burn the iToken.\n     * @param _redeemiToken The number of iToken to redeem.\n     */\n    function redeem(\n        address _from,\n        uint256 _redeemiToken\n    ) public nonReentrant settleInterest {\n        _redeemInternal(\n            _from,\n            _redeemiToken,\n            _redeemiToken.rmul(_exchangeRateInternal())\n        );\n    }\n\n    /**\n     * @dev Caller redeems specified underlying from `_from` to get underlying token.\n     * @param _from The account that would burn the iToken.\n     * @param _redeemUnderlying The number of underlying to redeem.\n     */\n    function redeemUnderlying(\n        address _from,\n        uint256 _redeemUnderlying\n    ) public nonReentrant settleInterest {\n        _redeemInternal(\n            _from,\n            _redeemUnderlying.rdivup(_exchangeRateInternal()),\n            _redeemUnderlying\n        );\n    }\n\n    /**\n     * @dev Caller borrows tokens from the protocol to their own address.\n     * @param _borrowAmount The amount of the underlying token to borrow.\n     */\n    function borrow(uint256 _borrowAmount) public nonReentrant settleInterest {\n        _borrowInternal(msg.sender, _borrowAmount);\n    }\n\n    /**\n     * @dev Caller repays their own borrow.\n     * @param _repayAmount The amount to repay.\n     */\n    function repayBorrow(\n        uint256 _repayAmount\n    ) public nonReentrant settleInterest {\n        _repayInternal(msg.sender, msg.sender, _repayAmount);\n    }\n\n    /**\n     * @dev Caller repays a borrow belonging to borrower.\n     * @param _borrower the account with the debt being payed off.\n     * @param _repayAmount The amount to repay.\n     */\n    function repayBorrowBehalf(\n        address _borrower,\n        uint256 _repayAmount\n    ) public nonReentrant settleInterest {\n        _repayInternal(msg.sender, _borrower, _repayAmount);\n    }\n\n    /**\n     * @dev The caller liquidates the borrowers collateral.\n     * @param _borrower The account whose borrow should be liquidated.\n     * @param _assetCollateral The market in which to seize collateral from the borrower.\n     * @param _repayAmount The amount to repay.\n     */\n    function liquidateBorrow(\n        address _borrower,\n        uint256 _repayAmount,\n        address _assetCollateral\n    ) public nonReentrant settleInterest {\n        _liquidateBorrowInternal(_borrower, _repayAmount, _assetCollateral);\n    }\n\n    /**\n     * @dev Transfers this tokens to the liquidator.\n     * @param _liquidator The account receiving seized collateral.\n     * @param _borrower The account having collateral seized.\n     * @param _seizeTokens The number of iTokens to seize.\n     */\n    function seize(\n        address _liquidator,\n        address _borrower,\n        uint256 _seizeTokens\n    ) external override nonReentrant {\n        _seizeInternal(msg.sender, _liquidator, _borrower, _seizeTokens);\n    }\n\n    /**\n     * @notice Calculates interest and update total borrows and reserves.\n     * @dev Updates total borrows and reserves with any accumulated interest.\n     */\n    function updateInterest() external override returns (bool) {\n        _updateInterest();\n        return true;\n    }\n\n    /**\n     * @dev Gets the newest exchange rate by accruing interest.\n     */\n    function exchangeRateCurrent() external returns (uint256) {\n        // Accrues interest.\n        _updateInterest();\n\n        return _exchangeRateInternal();\n    }\n\n    /**\n     * @dev Calculates the exchange rate without accruing interest.\n     */\n    function exchangeRateStored() external view override returns (uint256) {\n        return _exchangeRateInternal();\n    }\n\n    /**\n     * @dev Gets the underlying balance of the `_account`.\n     * @param _account The address of the account to query.\n     */\n    function balanceOfUnderlying(address _account) external returns (uint256) {\n        // Accrues interest.\n        _updateInterest();\n\n        return _exchangeRateInternal().rmul(balanceOf[_account]);\n    }\n\n    /**\n     * @dev Gets the user's borrow balance with the latest `borrowIndex`.\n     */\n    function borrowBalanceCurrent(\n        address _account\n    ) external nonReentrant returns (uint256) {\n        // Accrues interest.\n        _updateInterest();\n\n        return _borrowBalanceInternal(_account);\n    }\n\n    /**\n     * @dev Gets the borrow balance of user without accruing interest.\n     */\n    function borrowBalanceStored(\n        address _account\n    ) external view override returns (uint256) {\n        return _borrowBalanceInternal(_account);\n    }\n\n    /**\n     * @dev Gets user borrowing information.\n     */\n    function borrowSnapshot(\n        address _account\n    ) external view returns (uint256, uint256) {\n        return (\n            accountBorrows[_account].principal,\n            accountBorrows[_account].interestIndex\n        );\n    }\n\n    /**\n     * @dev Gets the current total borrows by accruing interest.\n     */\n    function totalBorrowsCurrent() external returns (uint256) {\n        // Accrues interest.\n        _updateInterest();\n\n        return totalBorrows;\n    }\n\n    /**\n     * @dev Returns the current per-unit(block/second) borrow interest rate.\n     */\n    function borrowRatePerUnit() public view returns (uint256) {\n        return\n            interestRateModel.getBorrowRate(\n                _getCurrentCash(),\n                totalBorrows,\n                totalReserves\n            );\n    }\n\n    /**\n     * @dev Returns the current per-unit(block/second) supply interest rate.\n     *  Calculates the supply rate:\n     *  underlying = totalSupply × exchangeRate\n     *  borrowsPer = totalBorrows ÷ underlying\n     *  supplyRate = borrowRate × (1-reserveFactor) × borrowsPer\n     */\n    function supplyRatePerUnit() external view returns (uint256) {\n        // `_underlyingScaled` is scaled by 1e36.\n        uint256 _underlyingScaled = totalSupply.mul(_exchangeRateInternal());\n        if (_underlyingScaled == 0) return 0;\n        uint256 _totalBorrowsScaled = totalBorrows.mul(BASE);\n\n        return\n            borrowRatePerUnit().tmul(\n                BASE.sub(reserveRatio),\n                _totalBorrowsScaled.rdiv(_underlyingScaled)\n            );\n    }\n\n    /**\n     * @dev Get cash balance of this iToken in the underlying token.\n     */\n    function getCash() external view returns (uint256) {\n        return _getCurrentCash();\n    }\n}\n"
    },
    "src/iTokenV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./iToken.sol\";\n\n/**\n * @title dForce's Lending Protocol Contract.\n * @notice iTokens which wrap an EIP-20 underlying.\n * @author dForce Team.\n */\ncontract iTokenV2 is iToken {\n    uint256 public accrualBlockTimestamp;\n\n    function _getInterestUnit()\n        internal\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return block.timestamp;\n    }\n\n    function getAccrualInterestUnit()\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return accrualBlockTimestamp;\n    }\n\n    function _updateAccrualInterestUnit(\n        uint256 _unit\n    ) internal virtual override {\n        accrualBlockTimestamp = _unit;\n    }\n\n    // Record time to calculate interests later.\n    function _upgrade() external onlyOwner {\n        require(accrualBlockTimestamp == 0, \"_upgrade: Have upgraded!\");\n        _updateAccrualInterestUnit(block.timestamp);\n    }\n\n    /**\n     * @dev Sets a new interest rate model.\n     * @param _newInterestRateModel The new interest rate model.\n     */\n    function _setInterestRateModel(\n        IInterestRateModel _newInterestRateModel\n    ) external virtual override onlyOwner {\n        // Gets current interest rate model.\n        IInterestRateModel _oldInterestRateModel = interestRateModel;\n\n        // Ensures the input address is the interest model contract.\n        require(\n            IInterestRateSecondModelV2(address(_newInterestRateModel))\n                .isInterestRateSecondModel(),\n            \"_setInterestRateModel: This is not the rate second model contract!\"\n        );\n\n        // Set to the new interest rate model.\n        interestRateModel = _newInterestRateModel;\n\n        emit NewInterestRateModel(_oldInterestRateModel, _newInterestRateModel);\n    }\n\n    /**\n     * @dev Similar to EIP20 transfer, except it handles a False result from `transfer`.\n     */\n    function _doTransferOut(\n        address payable _recipient,\n        uint256 _amount\n    ) internal virtual override {\n        address _dst = controller.beforeTransferUnderlying(\n            address(this),\n            address(underlying),\n            _amount,\n            _recipient\n        );\n\n        underlying.safeTransfer(_dst, _amount);\n    }\n\n    function _liquidateBorrowInternal(\n        address _borrower,\n        uint256 _repayAmount,\n        address _assetCollateral\n    ) internal virtual override {\n        require(\n            msg.sender != _borrower,\n            \"_liquidateBorrowInternal: Liquidator can not be borrower!\"\n        );\n        // According to the parameter `_repayAmount` to see what is the exact error.\n        require(\n            _repayAmount != 0,\n            \"_liquidateBorrowInternal: Liquidate amount should be greater than 0!\"\n        );\n\n        // Accrues interest for collateral asset.\n        Base _dlCollateral = Base(_assetCollateral);\n        _dlCollateral.updateInterest();\n\n        controller.beforeLiquidateBorrow(\n            address(this),\n            _assetCollateral,\n            msg.sender,\n            _borrower,\n            _repayAmount\n        );\n\n        require(\n            _dlCollateral.getAccrualInterestUnit() == _getInterestUnit(),\n            \"_liquidateBorrowInternal: Failed to update block timestamp in collateral asset!\"\n        );\n\n        uint256 _actualRepayAmount = _repayInternal(\n            msg.sender,\n            _borrower,\n            _repayAmount\n        );\n\n        // Calculates the number of collateral tokens that will be seized\n        uint256 _seizeTokens = controller.liquidateCalculateSeizeTokensV2(\n            address(this),\n            _assetCollateral,\n            _actualRepayAmount,\n            _borrower\n        );\n\n        // If this is also the collateral, calls seizeInternal to avoid re-entrancy,\n        // otherwise make an external call.\n        if (_assetCollateral == address(this)) {\n            _seizeInternal(address(this), msg.sender, _borrower, _seizeTokens);\n        } else {\n            _dlCollateral.seize(msg.sender, _borrower, _seizeTokens);\n        }\n\n        controller.afterLiquidateBorrow(\n            address(this),\n            _assetCollateral,\n            msg.sender,\n            _borrower,\n            _actualRepayAmount,\n            _seizeTokens\n        );\n\n        emit LiquidateBorrow(\n            msg.sender,\n            _borrower,\n            _actualRepayAmount,\n            _assetCollateral,\n            _seizeTokens\n        );\n    }\n\n    /**\n     * @dev Caller redeems assets from the market and caller receives underlying,\n     *        and exit markets.\n     * @param _redeemiToken The amount of the iToken to redeem.\n     */\n    function redeemFromSelfAndExitMarket(\n        uint256 _redeemiToken\n    ) public nonReentrant settleInterest {\n        _redeemInternal(\n            msg.sender,\n            _redeemiToken,\n            _redeemiToken.rmul(_exchangeRateInternal())\n        );\n        controller.exitMarketFromiToken(address(this), msg.sender);\n    }\n}\n"
    },
    "src/iTokenV2BLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./iTokenV2.sol\";\n\ninterface IControllerBLP {\n    function refreshEligibility(address _accounts) external;\n\n    function refreshEligibilities(address[] memory _accounts) external;\n}\n\n/**\n * @title dForce's Lending Protocol Contract.\n * @notice iTokens which wrap an EIP-20 underlying.\n * @author dForce Team.\n */\ncontract iTokenV2BLP is iTokenV2 {\n    function mint(\n        address _recipient,\n        uint256 _mintAmount,\n        bool refreshEligibility\n    ) external {\n        super.mint(_recipient, _mintAmount);\n\n        if (refreshEligibility) {\n            IControllerBLP(address(controller)).refreshEligibility(_recipient);\n        }\n    }\n\n    function redeem(\n        address _from,\n        uint256 _redeemiToken,\n        bool refreshEligibility\n    ) external {\n        super.redeem(_from, _redeemiToken);\n\n        if (refreshEligibility) {\n            IControllerBLP(address(controller)).refreshEligibility(_from);\n        }\n    }\n\n    function redeemUnderlying(\n        address _from,\n        uint256 _redeemUnderlying,\n        bool refreshEligibility\n    ) external {\n        super.redeemUnderlying(_from, _redeemUnderlying);\n\n        if (refreshEligibility) {\n            IControllerBLP(address(controller)).refreshEligibility(_from);\n        }\n    }\n\n    function borrow(uint256 _borrowAmount, bool refreshEligibility) external {\n        super.borrow(_borrowAmount);\n\n        if (refreshEligibility) {\n            IControllerBLP(address(controller)).refreshEligibility(msg.sender);\n        }\n    }\n\n    function repayBorrow(\n        uint256 _repayAmount,\n        bool refreshEligibility\n    ) external {\n        super.repayBorrow(_repayAmount);\n\n        if (refreshEligibility) {\n            IControllerBLP(address(controller)).refreshEligibility(msg.sender);\n        }\n    }\n\n    /**\n     * @dev Caller repays a borrow belonging to borrower.\n     * @param _borrower the account with the debt being payed off.\n     * @param _repayAmount The amount to repay.\n     */\n    function repayBorrowBehalf(\n        address _borrower,\n        uint256 _repayAmount,\n        bool refreshEligibility\n    ) external {\n        super.repayBorrowBehalf(_borrower, _repayAmount);\n\n        if (refreshEligibility) {\n            IControllerBLP(address(controller)).refreshEligibility(_borrower);\n        }\n    }\n\n    function liquidateBorrow(\n        address _borrower,\n        uint256 _repayAmount,\n        address _assetCollateral,\n        bool refreshEligibility\n    ) external {\n        super.liquidateBorrow(_borrower, _repayAmount, _assetCollateral);\n\n        if (refreshEligibility) {\n            address[] memory accounts = new address[](2);\n            accounts[0] = _borrower;\n            accounts[1] = msg.sender;\n            IControllerBLP(address(controller)).refreshEligibilities(accounts);\n        }\n    }\n\n    function mintForSelfAndEnterMarket(\n        uint256 _mintAmount,\n        bool refreshEligibility\n    ) external {\n        super.mintForSelfAndEnterMarket(_mintAmount);\n\n        if (refreshEligibility) {\n            IControllerBLP(address(controller)).refreshEligibility(msg.sender);\n        }\n    }\n\n    function redeemFromSelfAndExitMarket(\n        uint256 _redeemiToken,\n        bool refreshEligibility\n    ) external {\n        super.redeemFromSelfAndExitMarket(_redeemiToken);\n\n        if (refreshEligibility) {\n            IControllerBLP(address(controller)).refreshEligibility(msg.sender);\n        }\n    }\n}\n"
    },
    "src/interface/IController.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface IControllerAdminV1 {\n    /// @notice Emitted when an admin supports a market\n    event MarketAdded(\n        address iToken,\n        uint256 collateralFactor,\n        uint256 borrowFactor,\n        uint256 supplyCapacity,\n        uint256 borrowCapacity,\n        uint256 distributionFactor\n    );\n\n    function _addMarket(\n        address _iToken,\n        uint256 _collateralFactor,\n        uint256 _borrowFactor,\n        uint256 _supplyCapacity,\n        uint256 _borrowCapacity,\n        uint256 _distributionFactor\n    ) external;\n\n    /// @notice Emitted when new price oracle is set\n    event NewPriceOracle(address oldPriceOracle, address newPriceOracle);\n\n    function _setPriceOracle(address newOracle) external;\n\n    /// @notice Emitted when close factor is changed by admin\n    event NewCloseFactor(\n        uint256 oldCloseFactorMantissa,\n        uint256 newCloseFactorMantissa\n    );\n\n    function _setCloseFactor(uint256 newCloseFactorMantissa) external;\n\n    /// @notice Emitted when liquidation incentive is changed by admin\n    event NewLiquidationIncentive(\n        uint256 oldLiquidationIncentiveMantissa,\n        uint256 newLiquidationIncentiveMantissa\n    );\n\n    function _setLiquidationIncentive(\n        uint256 newLiquidationIncentiveMantissa\n    ) external;\n\n    /// @notice Emitted when iToken's collateral factor is changed by admin\n    event NewCollateralFactor(\n        address iToken,\n        uint256 oldCollateralFactorMantissa,\n        uint256 newCollateralFactorMantissa\n    );\n\n    function _setCollateralFactor(\n        address iToken,\n        uint256 newCollateralFactorMantissa\n    ) external;\n\n    /// @notice Emitted when iToken's borrow factor is changed by admin\n    event NewBorrowFactor(\n        address iToken,\n        uint256 oldBorrowFactorMantissa,\n        uint256 newBorrowFactorMantissa\n    );\n\n    function _setBorrowFactor(\n        address iToken,\n        uint256 newBorrowFactorMantissa\n    ) external;\n\n    /// @notice Emitted when iToken's borrow capacity is changed by admin\n    event NewBorrowCapacity(\n        address iToken,\n        uint256 oldBorrowCapacity,\n        uint256 newBorrowCapacity\n    );\n\n    function _setBorrowCapacity(\n        address iToken,\n        uint256 newBorrowCapacity\n    ) external;\n\n    /// @notice Emitted when iToken's supply capacity is changed by admin\n    event NewSupplyCapacity(\n        address iToken,\n        uint256 oldSupplyCapacity,\n        uint256 newSupplyCapacity\n    );\n\n    function _setSupplyCapacity(\n        address iToken,\n        uint256 newSupplyCapacity\n    ) external;\n\n    /// @notice Emitted when pause guardian is changed by admin\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\n\n    function _setPauseGuardian(address newPauseGuardian) external;\n\n    /// @notice Emitted when mint is paused/unpaused by admin or pause guardian\n    event MintPaused(address iToken, bool paused);\n\n    function _setMintPaused(address iToken, bool paused) external;\n\n    function _setAllMintPaused(bool paused) external;\n\n    /// @notice Emitted when redeem is paused/unpaused by admin or pause guardian\n    event RedeemPaused(address iToken, bool paused);\n\n    function _setRedeemPaused(address iToken, bool paused) external;\n\n    function _setAllRedeemPaused(bool paused) external;\n\n    /// @notice Emitted when borrow is paused/unpaused by admin or pause guardian\n    event BorrowPaused(address iToken, bool paused);\n\n    function _setBorrowPaused(address iToken, bool paused) external;\n\n    function _setAllBorrowPaused(bool paused) external;\n\n    /// @notice Emitted when transfer is paused/unpaused by admin or pause guardian\n    event TransferPaused(bool paused);\n\n    function _setTransferPaused(bool paused) external;\n\n    /// @notice Emitted when seize is paused/unpaused by admin or pause guardian\n    event SeizePaused(bool paused);\n\n    function _setSeizePaused(bool paused) external;\n\n    function _setiTokenPaused(address iToken, bool paused) external;\n\n    function _setProtocolPaused(bool paused) external;\n\n    event NewRewardDistributor(\n        address oldRewardDistributor,\n        address _newRewardDistributor\n    );\n\n    function _setRewardDistributor(address _newRewardDistributor) external;\n}\n\ninterface IControllerPolicyV1 {\n    function beforeMint(\n        address iToken,\n        address account,\n        uint256 mintAmount\n    ) external;\n\n    function afterMint(\n        address iToken,\n        address minter,\n        uint256 mintAmount,\n        uint256 mintedAmount\n    ) external;\n\n    function beforeRedeem(\n        address iToken,\n        address redeemer,\n        uint256 redeemAmount\n    ) external;\n\n    function afterRedeem(\n        address iToken,\n        address redeemer,\n        uint256 redeemAmount,\n        uint256 redeemedAmount\n    ) external;\n\n    function beforeBorrow(\n        address iToken,\n        address borrower,\n        uint256 borrowAmount\n    ) external;\n\n    function afterBorrow(\n        address iToken,\n        address borrower,\n        uint256 borrowedAmount\n    ) external;\n\n    function beforeRepayBorrow(\n        address iToken,\n        address payer,\n        address borrower,\n        uint256 repayAmount\n    ) external;\n\n    function afterRepayBorrow(\n        address iToken,\n        address payer,\n        address borrower,\n        uint256 repayAmount\n    ) external;\n\n    function beforeLiquidateBorrow(\n        address iTokenBorrowed,\n        address iTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 repayAmount\n    ) external;\n\n    function afterLiquidateBorrow(\n        address iTokenBorrowed,\n        address iTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 repaidAmount,\n        uint256 seizedAmount\n    ) external;\n\n    function beforeSeize(\n        address iTokenBorrowed,\n        address iTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 seizeAmount\n    ) external;\n\n    function afterSeize(\n        address iTokenBorrowed,\n        address iTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 seizedAmount\n    ) external;\n\n    function beforeTransfer(\n        address iToken,\n        address from,\n        address to,\n        uint256 amount\n    ) external;\n\n    function afterTransfer(\n        address iToken,\n        address from,\n        address to,\n        uint256 amount\n    ) external;\n\n    function beforeFlashloan(\n        address iToken,\n        address to,\n        uint256 amount\n    ) external;\n\n    function afterFlashloan(\n        address iToken,\n        address to,\n        uint256 amount\n    ) external;\n}\n\ninterface IControllerAccountEquityV1 {\n    function calcAccountEquity(\n        address account\n    ) external view returns (uint256, uint256, uint256, uint256);\n\n    function liquidateCalculateSeizeTokens(\n        address iTokenBorrowed,\n        address iTokenCollateral,\n        uint256 actualRepayAmount\n    ) external view returns (uint256);\n}\n\ninterface IControllerAccountV1 {\n    function hasEnteredMarket(\n        address account,\n        address iToken\n    ) external view returns (bool);\n\n    function getEnteredMarkets(\n        address account\n    ) external view returns (address[] memory);\n\n    /// @notice Emitted when an account enters a market\n    event MarketEntered(address iToken, address account);\n\n    function enterMarkets(\n        address[] calldata iTokens\n    ) external returns (bool[] memory);\n\n    function enterMarketFromiToken(address _market, address _account) external;\n\n    /// @notice Emitted when an account exits a market\n    event MarketExited(address iToken, address account);\n\n    function exitMarkets(\n        address[] calldata iTokens\n    ) external returns (bool[] memory);\n\n    /// @notice Emitted when an account add a borrow asset\n    event BorrowedAdded(address iToken, address account);\n\n    /// @notice Emitted when an account remove a borrow asset\n    event BorrowedRemoved(address iToken, address account);\n\n    function hasBorrowed(\n        address account,\n        address iToken\n    ) external view returns (bool);\n\n    function getBorrowedAssets(\n        address account\n    ) external view returns (address[] memory);\n}\n\ninterface IControllerV1 is\n    IControllerAdminV1,\n    IControllerPolicyV1,\n    IControllerAccountEquityV1,\n    IControllerAccountV1\n{\n    /**\n     * @notice Security checks when updating the comptroller of a market, always expect to return true.\n     */\n    function isController() external view returns (bool);\n\n    /**\n     * @notice Return all of the iTokens\n     * @return The list of iToken addresses\n     */\n    function getAlliTokens() external view returns (address[] memory);\n\n    /**\n     * @notice Check whether a iToken is listed in controller\n     * @param _iToken The iToken to check for\n     * @return true if the iToken is listed otherwise false\n     */\n    function hasiToken(address _iToken) external view returns (bool);\n}\n\ninterface IControllerV2 {\n    event NewExtraExplicit(\n        address _oldExtraExplicit,\n        address _newExtraExplicit\n    );\n\n    function _setExtraExplicit(address _newExtraExplicit) external;\n\n    event NewExtraImplicit(\n        address _oldExtraImplicit,\n        address _newExtraImplicit\n    );\n\n    function _setExtraImplicit(address _newExtraImplicit) external;\n\n    function _upgrade(\n        address _newExtraImplicit,\n        address _newExtraExplicit\n    ) external;\n\n    /**\n     * @param _iToken The _iToken to add\n     * @param _collateralFactor The _collateralFactor of _iToken\n     * @param _borrowFactor The _borrowFactor of _iToken\n     * @param _supplyCapacity The _supplyCapacity of _iToken\n     * @param _borrowCapacity The _borrowCapacity of _iToken\n     * @param _distributionFactor The _distributionFactor of _iToken\n     * @param _iTokenSModeID The SMode ID of _iToken\n     * @param _sModeLtv The collateral factor of _iToken in the sMode\n     * @param _sModeLiqThreshold The liquidation Threshold of _iToken in the  sMode\n     * @param _liquidationThreshold The liquidation Threshold of _iToken\n     * @param _debtCeiling The _debtCeiling of _iToken in segregation mode, notice its decimal `DEBT_CEILING_DECIMALS`\n     * @param _borrowableInSegregation True if the _iToken is borrowable in segregation mode\n     */\n    struct AddMarketV2LocalVars {\n        address _iToken;\n        uint256 _collateralFactor;\n        uint256 _borrowFactor;\n        uint256 _supplyCapacity;\n        uint256 _borrowCapacity;\n        uint256 _distributionFactor;\n        uint8 _sModeID;\n        uint256 _sModeLtv;\n        uint256 _sModeLiqThreshold;\n        uint256 _liquidationThreshold;\n        uint256 _debtCeiling;\n        bool _borrowableInSegregation;\n    }\n\n    function _addMarketV2(AddMarketV2LocalVars memory _vars) external;\n\n    function exitMarketFromiToken(address _market, address _account) external;\n}\n\ninterface IControllerV2ExtraBase {\n    event DebtCeilingChanged(\n        address iToken,\n        uint256 oldDebtCeiling,\n        uint256 newDebtCeiling\n    );\n\n    event BorrowableInSegregationChanged(address iToken, bool borrowable);\n\n    event NewTimeLock(address oldTimeLock, address newTimeLock);\n\n    event NewTimeLockStrategy(\n        address oldTimeLockStrategy,\n        address newTimeLockStrategy\n    );\n\n    event SModeAdded(\n        uint8 sModeId,\n        uint256 liquidationIncentive,\n        uint256 closeFactor,\n        string label\n    );\n\n    event SModeChanged(\n        address iToken,\n        uint8 oldCategoryId,\n        uint8 newCategoryId\n    );\n\n    event NewLiquidationThreshold(\n        address _iToken,\n        uint256 _oldLiquidationThresholdMantissa,\n        uint256 _newLiquidationThresholdMantissa\n    );\n\n    event NewSModeLiquidationIncentive(\n        uint8 _sModeID,\n        uint256 _oldSModeLiquidationIncentive,\n        uint256 _newSModeLiquidationIncentive\n    );\n\n    event NewSModeCloseFactor(\n        uint8 _sModeID,\n        uint256 _oldSModeCloseFactor,\n        uint256 _newSModeCloseFactor\n    );\n\n    event NewSModeLTV(\n        address _iToken,\n        uint256 _oldSModeLTV,\n        uint256 _newSModeLTV\n    );\n\n    event NewSModeLiquidationThreshold(\n        address _iToken,\n        uint256 _oldSModeLiquidationThreshold,\n        uint256 _newSModeLiquidationThreshold\n    );\n\n    event SModeEntered(uint8 oldSModeId, uint8 newSModeId, address account);\n\n    function getSegregationModeState(\n        address _account\n    ) external view returns (bool, address);\n\n    function getLiquidationIncentive(\n        address _iToken,\n        address _account\n    ) external view returns (uint256);\n}\n\ninterface IControllerV2ExtraExplicit is IControllerV2ExtraBase {\n    function isControllerExtraExplicit() external view returns (bool);\n\n    function initialize() external;\n\n    function _upgrade() external;\n\n    function _addMarketV2(\n        IControllerV2.AddMarketV2LocalVars memory _vars\n    ) external;\n\n    function _setCollateralFactor(\n        address iToken,\n        uint256 newCollateralFactorMantissa\n    ) external;\n\n    function _setCloseFactor(uint256 newCloseFactorMantissa) external;\n\n    function _setLiquidationIncentive(\n        uint256 newLiquidationIncentiveMantissa\n    ) external;\n\n    function beforeBorrow(\n        address iToken,\n        address borrower,\n        uint256 borrowAmount\n    ) external;\n\n    function afterRepayBorrow(\n        address iToken,\n        address payer,\n        address borrower,\n        uint256 repayAmount\n    ) external;\n\n    function beforeEnterMarket(address _iToken, address _account) external view;\n\n    function getCloseFactor(\n        address _iToken,\n        address _account\n    ) external view returns (uint256);\n}\n\ninterface IControllerV2ExtraImplicit is IControllerV2ExtraBase {\n    function isControllerExtraImplicit() external view returns (bool);\n\n    function _setDebtCeiling(address _iToken, uint256 _newDebtCeiling) external;\n\n    function _setBorrowableInSegregation(\n        address _iToken,\n        bool _borrowable\n    ) external;\n\n    function _setTimeLock(address _newTimeLock) external;\n\n    function _setTimeLockStrategy(address _newTimeLockStrategy) external;\n\n    function _addSMode(\n        uint256 _liquidationIncentive,\n        uint256 _closeFactor,\n        string memory _label\n    ) external;\n\n    function _setSMode(\n        address _iToken,\n        uint8 _sModeID,\n        uint256 _sModeLtv,\n        uint256 _sModeLiqThreshold\n    ) external;\n\n    function _setLiquidationThreshold(\n        address _iToken,\n        uint256 _newLiquidationThresholdMantissa\n    ) external;\n\n    function _setSModeLiquidationIncentive(\n        uint8 _sModeID,\n        uint256 _liquidationIncentive\n    ) external;\n\n    function _setSModeCloseFactor(\n        uint8 _sModeID,\n        uint256 _closeFactor\n    ) external;\n\n    function _setSModeLTV(address _iToken, uint256 _ltv) external;\n\n    function _setSModeLiquidationThreshold(\n        address _iToken,\n        uint256 _liquidationThreshold\n    ) external;\n\n    function beforeTransferUnderlying(\n        address _asset,\n        address _underlying,\n        uint256 _amount,\n        address _recipient\n    ) external returns (address _dst);\n\n    function liquidateCalculateSeizeTokensV2(\n        address iTokenBorrowed,\n        address iTokenCollateral,\n        uint256 actualRepayAmount,\n        address borrower\n    ) external view returns (uint256);\n\n    function calcAccountEquityWithEffectV2(\n        address _account,\n        address _tokenToEffect,\n        uint256 _redeemAmount,\n        uint256 _borrowAmount,\n        bool _isLiquidation\n    ) external view returns (uint256, uint256, uint256, uint256);\n\n    function enterSMode(uint8 _newSModeId) external;\n\n    function getSModeLength() external view returns (uint256 _sModeLength);\n\n    function getCollateralFactor(\n        address _iToken,\n        uint8 _accountSModeID,\n        uint8 _iTokenSModeID,\n        bool _isLiquidation\n    ) external view returns (uint256 _collateralFactor);\n\n    function getLTV(address _iToken) external view returns (uint256);\n\n    function getLiquidationThreshold(\n        address _iToken\n    ) external view returns (uint256);\n\n    function getSModeLTV(address _iToken) external view returns (uint256);\n\n    function getSModeLiquidationThreshold(\n        address _iToken\n    ) external view returns (uint256);\n}\n\n/**\n * @dev External Interfaces for test cases and front end\n */\ninterface IController is\n    IControllerV1,\n    IControllerV2,\n    IControllerV2ExtraImplicit\n{\n    struct MarketV2 {\n        /*\n         *  Multiplier representing the most one can borrow against their collateral in this market.\n         *  For instance, 0.9 to allow borrowing 90% of collateral value.\n         *  Must be in [0, 0.9], and stored as a mantissa.\n         */\n        uint256 collateralFactorMantissa;\n        /*\n         *  Multiplier representing the most one can borrow the asset.\n         *  For instance, 0.5 to allow borrowing this asset 50% * collateral value * collateralFactor.\n         *  When calculating equity, 0.5 with 100 borrow balance will produce 200 borrow value\n         *  Must be between (0, 1], and stored as a mantissa.\n         */\n        uint256 borrowFactorMantissa;\n        /*\n         *  The borrow capacity of the asset, will be checked in beforeBorrow()\n         *  -1 means there is no limit on the capacity\n         *  0 means the asset can not be borrowed any more\n         */\n        uint256 borrowCapacity;\n        /*\n         *  The supply capacity of the asset, will be checked in beforeMint()\n         *  -1 means there is no limit on the capacity\n         *  0 means the asset can not be supplied any more\n         */\n        uint256 supplyCapacity;\n        // Whether market's mint is paused\n        bool mintPaused;\n        // Whether market's redeem is paused\n        bool redeemPaused;\n        // Whether market's borrow is paused\n        bool borrowPaused;\n        // sMode config\n        // TODO: explanation\n        uint8 sModeID;\n        //  Whether market can be borrowed in segregation mode\n        bool borrowableInSegregation;\n        // Debt ceiling for the market\n        uint256 debtCeiling;\n        // Current debt in segregation mode\n        uint256 currentDebt;\n    }\n\n    function extraImplicit() external view returns (address);\n\n    function extraExplicit() external view returns (address);\n\n    function timeLock() external view returns (address);\n\n    function timeLockStrategy() external view returns (address);\n\n    function marketsV2(address _iToken) external view returns (MarketV2 memory);\n\n    function DEBT_CEILING_DECIMALS() external view returns (uint256);\n\n    function accountsSMode(\n        address account\n    ) external view returns (uint8 sModeID);\n\n    function sModes(\n        uint256 index\n    )\n        external\n        view\n        returns (\n            uint256 liquidationIncentive,\n            uint256 closeFactor,\n            string calldata label\n        );\n\n    function liquidationIncentiveMantissa() external view returns (uint256);\n\n    function closeFactorMantissa() external view returns (uint256);\n\n    function initializeV2(\n        address _newExtraImplicit,\n        address _newExtraExplicit\n    ) external;\n\n    function initialize() external;\n}\n"
    },
    "src/interface/IFlashloanExecutor.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface IFlashloanExecutor {\n    function executeOperation(\n        address reserve,\n        uint256 amount,\n        uint256 fee,\n        bytes memory data\n    ) external;\n}\n"
    },
    "src/interface/IInterestRateModel.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\n/**\n * @title dForce Lending Protocol's InterestRateModel Interface.\n * @author dForce Team.\n */\ninterface IInterestRateModel {\n    function isInterestRateModel() external view returns (bool);\n\n    /**\n     * @dev Calculates the current borrow interest rate per block.\n     * @param cash The total amount of cash the market has.\n     * @param borrows The total amount of borrows the market has.\n     * @param reserves The total amnount of reserves the market has.\n     * @return The borrow rate per block (as a percentage, and scaled by 1e18).\n     */\n    function getBorrowRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves\n    ) external view returns (uint256);\n\n    /**\n     * @dev Calculates the current supply interest rate per block.\n     * @param cash The total amount of cash the market has.\n     * @param borrows The total amount of borrows the market has.\n     * @param reserves The total amnount of reserves the market has.\n     * @param reserveRatio The current reserve factor the market has.\n     * @return The supply rate per block (as a percentage, and scaled by 1e18).\n     */\n    function getSupplyRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves,\n        uint256 reserveRatio\n    ) external view returns (uint256);\n}\n\ninterface IInterestRateSecondModelV2 {\n    function isInterestRateSecondModel() external view returns (bool);\n}\n"
    },
    "src/library/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 {\n    using SafeMathUpgradeable for uint256;\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    uint256 public totalSupply;\n\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) internal {\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(\n        address recipient,\n        uint256 amount\n    ) public virtual returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(\n        address spender,\n        uint256 amount\n    ) public virtual returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, allowance[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(\n        address spender,\n        uint256 addedValue\n    ) public virtual returns (bool) {\n        _approve(\n            msg.sender,\n            spender,\n            allowance[msg.sender][spender].add(addedValue)\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(\n        address spender,\n        uint256 subtractedValue\n    ) public virtual returns (bool) {\n        _approve(\n            msg.sender,\n            spender,\n            allowance[msg.sender][spender].sub(subtractedValue)\n        );\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        balanceOf[sender] = balanceOf[sender].sub(amount);\n        balanceOf[recipient] = balanceOf[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        totalSupply = totalSupply.add(amount);\n        balanceOf[account] = balanceOf[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        balanceOf[account] = balanceOf[account].sub(amount);\n        totalSupply = totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance if caller is not the `account`.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller other than `msg.sender` must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function _burnFrom(address account, uint256 amount) internal virtual {\n        if (msg.sender != account)\n            _approve(\n                account,\n                msg.sender,\n                allowance[account][msg.sender].sub(amount)\n            );\n\n        _burn(account, amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        allowance[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "src/library/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(\n            !_initialized,\n            \"Initializable: contract is already initialized\"\n        );\n\n        _;\n\n        _initialized = true;\n    }\n}\n"
    },
    "src/library/Ownable.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {_setPendingOwner} and {_acceptOwner}.\n */\ncontract Ownable {\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    address payable public owner;\n\n    /**\n     * @dev Returns the address of the current pending owner.\n     */\n    address payable public pendingOwner;\n\n    event NewOwner(address indexed previousOwner, address indexed newOwner);\n    event NewPendingOwner(\n        address indexed oldPendingOwner,\n        address indexed newPendingOwner\n    );\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"onlyOwner: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal {\n        owner = msg.sender;\n        emit NewOwner(address(0), msg.sender);\n    }\n\n    /**\n     * @notice Base on the inputing parameter `newPendingOwner` to check the exact error reason.\n     * @dev Transfer contract control to a new owner. The newPendingOwner must call `_acceptOwner` to finish the transfer.\n     * @param newPendingOwner New pending owner.\n     */\n    function _setPendingOwner(\n        address payable newPendingOwner\n    ) external onlyOwner {\n        require(\n            newPendingOwner != address(0) && newPendingOwner != pendingOwner,\n            \"_setPendingOwner: New owenr can not be zero address and owner has been set!\"\n        );\n\n        // Gets current owner.\n        address oldPendingOwner = pendingOwner;\n\n        // Sets new pending owner.\n        pendingOwner = newPendingOwner;\n\n        emit NewPendingOwner(oldPendingOwner, newPendingOwner);\n    }\n\n    /**\n     * @dev Accepts the admin rights, but only for pendingOwenr.\n     */\n    function _acceptOwner() external {\n        require(\n            msg.sender == pendingOwner,\n            \"_acceptOwner: Only for pending owner!\"\n        );\n\n        // Gets current values for events.\n        address oldOwner = owner;\n        address oldPendingOwner = pendingOwner;\n\n        // Set the new contract owner.\n        owner = pendingOwner;\n\n        // Clear the pendingOwner.\n        pendingOwner = address(0);\n\n        emit NewOwner(oldOwner, owner);\n        emit NewPendingOwner(oldPendingOwner, pendingOwner);\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "src/library/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\n// abstract contract ReentrancyGuardUpgradeable is Initializable {\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "src/library/SafeRatioMath.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\n\nlibrary SafeRatioMath {\n    using SafeMathUpgradeable for uint256;\n\n    uint256 private constant BASE = 10 ** 18;\n    uint256 private constant DOUBLE = 10 ** 36;\n\n    function divup(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x.add(y.sub(1)).div(y);\n    }\n\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x.mul(y).div(BASE);\n    }\n\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x.mul(BASE).div(y);\n    }\n\n    function rdivup(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x.mul(BASE).add(y.sub(1)).div(y);\n    }\n\n    function tmul(\n        uint256 x,\n        uint256 y,\n        uint256 z\n    ) internal pure returns (uint256 result) {\n        result = x.mul(y).mul(z).div(DOUBLE);\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 base\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    z := base\n                }\n                default {\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    z := base\n                }\n                default {\n                    z := x\n                }\n                let half := div(base, 2) // for rounding.\n\n                for {\n                    n := div(n, 2)\n                } n {\n                    n := div(n, 2)\n                } {\n                    let xx := mul(x, x)\n                    if iszero(eq(div(xx, x), x)) {\n                        revert(0, 0)\n                    }\n                    let xxRound := add(xx, half)\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n                    x := div(xxRound, base)\n                    if mod(n, 2) {\n                        let zx := mul(z, x)\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) {\n                            revert(0, 0)\n                        }\n                        let zxRound := add(zx, half)\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n                        z := div(zxRound, base)\n                    }\n                }\n            }\n        }\n    }\n}\n"
    }
  }
}}