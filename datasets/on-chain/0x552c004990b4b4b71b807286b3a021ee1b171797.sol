{{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line interface-starts-with-i\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "@openzeppelin-4.5.0/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin-4.5.0/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin-4.5.0/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin-4.5.0/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin-4.5.0/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin-4.5.0/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin-4.5.0/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin-4.5.0/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.20;\n\nimport {OwnableUpgradeable} from \"./OwnableUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2StepUpgradeable is Initializable, OwnableUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable2Step\n    struct Ownable2StepStorage {\n        address _pendingOwner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Ownable2Step\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant Ownable2StepStorageLocation = 0x237e158222e3e6968b72b9db0d8043aacf074ad9f650f0d1606b4d82ee432c00;\n\n    function _getOwnable2StepStorage() private pure returns (Ownable2StepStorage storage $) {\n        assembly {\n            $.slot := Ownable2StepStorageLocation\n        }\n    }\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    function __Ownable2Step_init() internal onlyInitializing {\n    }\n\n    function __Ownable2Step_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        Ownable2StepStorage storage $ = _getOwnable2StepStorage();\n        return $._pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        Ownable2StepStorage storage $ = _getOwnable2StepStorage();\n        $._pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        Ownable2StepStorage storage $ = _getOwnable2StepStorage();\n        delete $._pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Ownable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC1822Proxiable} from \"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\";\nimport {ERC1967Utils} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\nimport {Initializable} from \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822Proxiable {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable __self = address(this);\n\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\n     * If the getter returns `\"5.0.0\"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = \"5.0.0\";\n\n    /**\n     * @dev The call is from an unauthorized context.\n     */\n    error UUPSUnauthorizedCallContext();\n\n    /**\n     * @dev The storage `slot` is unsupported as a UUID.\n     */\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n\n    /**\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\n     * context is not of a proxy with an ERC1967-compliant implementation pointing to self.\n     * See {_onlyProxy}.\n     */\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || // Must be called through delegatecall\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Reverts if the execution is performed via delegatecall.\n     * See {notDelegated}.\n     */\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            // Must not be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\n     *\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\n     * is expected to be the implementation slot in ERC1967.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            // The implementation is not UUPS\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Pausable\n    struct PausableStorage {\n        bool _paused;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Pausable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\n\n    function _getPausableStorage() private pure returns (PausableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageLocation\n        }\n    }\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        PausableStorage storage $ = _getPausableStorage();\n        return $._paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable2Step.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.20;\n\nimport {Ownable} from \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {UpgradeableBeacon} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Utils.sol)\n\npragma solidity ^0.8.20;\n\nimport {IBeacon} from \"../beacon/IBeacon.sol\";\nimport {Address} from \"../../utils/Address.sol\";\nimport {StorageSlot} from \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n */\nlibrary ERC1967Utils {\n    // We re-declare ERC-1967 events here because they can't be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of \"eip1967.proxy.beacon\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn't perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "contracts/AbstractMost.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {Ownable2StepUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport {IWETH9} from \"./IWETH9.sol\";\nimport {IWrappedToken} from \"./IWrappedToken.sol\";\n\n/// @title Most\n/// @author Cardinal Cryptography\nabstract contract AbstractMost is\n    Initializable,\n    UUPSUpgradeable,\n    Ownable2StepUpgradeable,\n    PausableUpgradeable\n{\n    using SafeERC20 for IERC20;\n\n    /// @dev This amount of gas should be sufficient for ether transfers\n    /// and simple fallback function execution, yet still protecting against reentrancy attack.\n    uint256 public constant GAS_LIMIT = 3500;\n\n    uint256 public requestNonce;\n    uint256 public committeeId;\n    address payable public wethAddress;\n\n    mapping(bytes32 from => bytes32 to) public supportedPairs;\n    mapping(bytes32 requestHash => Request) public pendingRequests;\n    mapping(bytes32 requestHash => bool) public processedRequests;\n    /// @dev committeeMemberId = keccak256(abi.encodePacked(committeeId, comitteeMemberAddress))\n    mapping(bytes32 committeeMemberId => bool) private committee;\n    mapping(uint256 committeeId => uint256) public committeeSize;\n    mapping(uint256 committeeId => uint256) public signatureThreshold;\n    mapping(address => bool) public isLocalToken;\n\n    address public wrappedAzeroAddress;\n\n    struct Request {\n        uint256 signatureCount;\n        mapping(address => bool) signatures;\n    }\n\n    event CrosschainTransferRequest(\n        uint256 indexed committeeId,\n        bytes32 indexed destTokenAddress,\n        uint256 amount,\n        bytes32 indexed destReceiverAddress,\n        uint256 requestNonce\n    );\n\n    event RequestSigned(bytes32 requestHash, address signer);\n\n    event RequestProcessed(bytes32 requestHash);\n\n    /// @notice Emitted when guardian signs a request that has already been processed\n    event ProcessedRequestSigned(bytes32 requestHash, address signer);\n\n    event RequestAlreadySigned(bytes32 requestHash, address signer);\n\n    event EthTransferFailed(bytes32 requestHash);\n\n    event TokenTransferFailed(bytes32 requestHash);\n\n    event CommitteeUpdated(uint256 newCommitteeId);\n\n    modifier _onlyCommitteeMember(uint256 _committeeId) {\n        if (!isInCommittee(_committeeId, msg.sender)) revert NotInCommittee();\n        _;\n    }\n\n    error NotInCommittee();\n    error ZeroSignatureTreshold();\n    error DuplicateCommitteeMember();\n    error NotEnoughGuardians();\n    error UnsupportedPair();\n    error DataHashMismatch();\n    error ZeroAmount();\n    error WrappingEth();\n    error UnwrappingEth();\n    error EthTransfer();\n    error ZeroAddress();\n    error AzeroAddressNotSet();\n    error LimitExceeded();\n\n    function __AbstractMost_init(\n        address[] calldata _committee,\n        uint256 _signatureThreshold,\n        address payable _wethAddress\n    ) internal onlyInitializing {\n        __AbstractMost_init_unchained(\n            _committee,\n            _signatureThreshold,\n            _wethAddress\n        );\n    }\n\n    function __AbstractMost_init_unchained(\n        address[] calldata _committee,\n        uint256 _signatureThreshold,\n        address payable _wethAddress\n    ) internal onlyInitializing {\n        requestNonce = 0;\n        committeeId = 0;\n        wethAddress = _wethAddress;\n\n        _setCommittee(_committee, _signatureThreshold);\n    }\n\n    /// @dev required by the OZ UUPS module\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n\n    /// @dev disable possibility to renounce ownership\n    function renounceOwnership() public virtual override onlyOwner {}\n\n    function _setCommittee(\n        address[] calldata _committee,\n        uint256 _signatureThreshold\n    ) internal {\n        if (_signatureThreshold == 0) revert ZeroSignatureTreshold();\n        if (_committee.length < _signatureThreshold)\n            revert NotEnoughGuardians();\n\n        for (uint256 i; i < _committee.length; ++i) {\n            if (_committee[i] == address(0)) revert ZeroAddress();\n            bytes32 committeeMemberId = keccak256(\n                abi.encodePacked(committeeId, _committee[i])\n            );\n            // avoid duplicates\n            if (committee[committeeMemberId]) {\n                revert DuplicateCommitteeMember();\n            }\n            committee[committeeMemberId] = true;\n        }\n\n        committeeSize[committeeId] = _committee.length;\n        signatureThreshold[committeeId] = _signatureThreshold;\n    }\n\n    /// @notice Invoke this tx to transfer funds to the destination chain.\n    /// Account needs to approve the Most contract to spend the `srcTokenAmount`\n    /// of `srcTokenAddress` tokens on their behalf before executing the tx.\n    ///\n    /// @dev Tx emits a CrosschainTransferRequest event that the relayers listen to\n    /// & forward to the destination chain.\n    function sendRequest(\n        bytes32 srcTokenAddress,\n        uint256 amount,\n        bytes32 destReceiverAddress\n    ) external virtual whenNotPaused {\n        if (amount == 0) revert ZeroAmount();\n        if (destReceiverAddress == bytes32(0)) revert ZeroAddress();\n\n        bytes32 destTokenAddress = supportedPairs[srcTokenAddress];\n        if (destTokenAddress == 0x0) revert UnsupportedPair();\n\n        address token = bytes32ToAddress(srcTokenAddress);\n        checkTransferAllowed(token, amount);\n\n        // burn or lock tokens in this contract\n        // message sender needs to give approval else this tx will revert\n        IERC20 tokenERC20 = IERC20(token);\n        tokenERC20.safeTransferFrom(msg.sender, address(this), amount);\n\n        if (!isLocalToken[token]) {\n            IWrappedToken burnableToken = IWrappedToken(token);\n            burnableToken.burn(amount);\n        }\n\n        emit CrosschainTransferRequest(\n            committeeId,\n            destTokenAddress,\n            amount,\n            destReceiverAddress,\n            requestNonce\n        );\n\n        ++requestNonce;\n    }\n\n    /// @notice Invoke this tx to transfer funds to the destination chain.\n    /// Account needs to send native ETH which are wrapped to wETH\n    /// tokens.\n    ///\n    /// @dev Tx emits a CrosschainTransferRequest event that the relayers listen to\n    /// & forward to the destination chain.\n    function sendRequestNative(\n        bytes32 destReceiverAddress\n    ) external payable virtual whenNotPaused {\n        uint256 amount = msg.value;\n        if (amount == 0) revert ZeroAmount();\n        if (destReceiverAddress == bytes32(0)) revert ZeroAddress();\n\n        bytes32 destTokenAddress = supportedPairs[\n            addressToBytes32(wethAddress)\n        ];\n\n        if (destTokenAddress == 0x0) revert UnsupportedPair();\n        checkTransferAllowed(wethAddress, amount);\n\n        (bool success, ) = wethAddress.call{value: amount}(\n            abi.encodeCall(IWETH9.deposit, ())\n        );\n\n        if (!success) revert WrappingEth();\n\n        emit CrosschainTransferRequest(\n            committeeId,\n            destTokenAddress,\n            amount,\n            destReceiverAddress,\n            requestNonce\n        );\n\n        ++requestNonce;\n    }\n\n    function sendRequestAzeroToNative(\n        uint256 amount,\n        bytes32 destReceiverAddress\n    ) external virtual whenNotPaused {\n        if (amount == 0) revert ZeroAmount();\n        if (destReceiverAddress == bytes32(0)) revert ZeroAddress();\n        if (wrappedAzeroAddress == address(0)) revert AzeroAddressNotSet();\n\n        checkTransferAllowed(wrappedAzeroAddress, amount);\n\n        IERC20 azeroToken = IERC20(wrappedAzeroAddress);\n        azeroToken.safeTransferFrom(msg.sender, address(this), amount);\n        IWrappedToken burnableToken = IWrappedToken(wrappedAzeroAddress);\n        burnableToken.burn(amount);\n\n        emit CrosschainTransferRequest(\n            committeeId,\n            0x0,\n            amount,\n            destReceiverAddress,\n            requestNonce\n        );\n\n        ++requestNonce;\n    }\n\n    function onReceiveRequestThresholdMet(\n        bytes32 requestHash,\n        bytes32 destTokenAddress,\n        uint256 amount,\n        bytes32 destReceiverAddress\n    ) internal virtual {\n        processedRequests[requestHash] = true;\n        delete pendingRequests[requestHash];\n\n        address _destTokenAddress = bytes32ToAddress(destTokenAddress);\n        address _destReceiverAddress = bytes32ToAddress(destReceiverAddress);\n\n        // return the locked tokens\n        // address(0) indicates bridging native ether\n        if (_destTokenAddress == address(0)) {\n            (bool unwrapSuccess, ) = wethAddress.call(\n                abi.encodeCall(IWETH9.withdraw, (amount))\n            );\n            if (!unwrapSuccess) revert UnwrappingEth();\n            (bool sendNativeEthSuccess, ) = _destReceiverAddress.call{\n                value: amount,\n                gas: GAS_LIMIT\n            }(\"\");\n            if (!sendNativeEthSuccess) {\n                emit EthTransferFailed(requestHash);\n            }\n        } else if (!isLocalToken[_destTokenAddress]) {\n            // Mint representation of the remote token\n            IWrappedToken mintableToken = IWrappedToken(_destTokenAddress);\n            mintableToken.mint(_destReceiverAddress, amount);\n        } else {\n            IERC20 token = IERC20(_destTokenAddress);\n            if (\n                !tokenTransferReturnSuccess(token, _destReceiverAddress, amount)\n            ) {\n                emit TokenTransferFailed(requestHash);\n            }\n        }\n\n        emit RequestProcessed(requestHash);\n    }\n\n    /// @notice Aggregates relayer signatures and returns the locked tokens.\n    /// @dev When the ether is being bridged and the receiver is a contractRequestSigned\n    /// that does not accept ether or fallback function consumes more than `GAS_LIMIT` gas units,\n    /// the request is processed without revert and the ether is locked\n    /// in this contract. Governance action must be taken to retrieve the tokens.\n    function receiveRequest(\n        bytes32 _requestHash,\n        uint256 _committeeId,\n        bytes32 destTokenAddress,\n        uint256 amount,\n        bytes32 destReceiverAddress,\n        uint256 _requestNonce\n    ) external whenNotPaused _onlyCommitteeMember(_committeeId) {\n        // Don't revert if the request has already been processed as\n        // such a call can be made during regular guardian operation.\n        if (processedRequests[_requestHash]) {\n            emit ProcessedRequestSigned(_requestHash, msg.sender);\n            return;\n        }\n\n        bytes32 requestHash = keccak256(\n            abi.encodePacked(\n                _committeeId,\n                destTokenAddress,\n                amount,\n                destReceiverAddress,\n                _requestNonce\n            )\n        );\n\n        Request storage request = pendingRequests[requestHash];\n        if (request.signatures[msg.sender]) {\n            emit RequestAlreadySigned(requestHash, msg.sender);\n            return;\n        }\n\n        if (_requestHash != requestHash) revert DataHashMismatch();\n\n        request.signatures[msg.sender] = true;\n        ++request.signatureCount;\n\n        emit RequestSigned(requestHash, msg.sender);\n\n        if (request.signatureCount >= signatureThreshold[_committeeId]) {\n            onReceiveRequestThresholdMet(\n                requestHash,\n                destTokenAddress,\n                amount,\n                destReceiverAddress\n            );\n        }\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function recoverERC20(\n        address token,\n        address to,\n        uint256 amount\n    ) external onlyOwner {\n        IERC20(token).safeTransfer(to, amount);\n    }\n\n    function recoverNative(\n        address payable to,\n        uint256 amount\n    ) external onlyOwner {\n        (bool success, ) = to.call{value: amount, gas: GAS_LIMIT}(\"\");\n        if (!success) revert EthTransfer();\n    }\n\n    function setCommittee(\n        address[] calldata _committee,\n        uint256 _signatureThreshold\n    ) external onlyOwner whenPaused {\n        ++committeeId;\n        _setCommittee(_committee, _signatureThreshold);\n        emit CommitteeUpdated(committeeId);\n    }\n\n    function setWrappedAzeroAddress(\n        address _wrappedAzeroAddress\n    ) external onlyOwner whenPaused {\n        wrappedAzeroAddress = _wrappedAzeroAddress;\n    }\n\n    function addPair(\n        bytes32 from,\n        bytes32 to,\n        bool isLocal\n    ) external virtual onlyOwner whenPaused {\n        supportedPairs[from] = to;\n        isLocalToken[bytes32ToAddress(from)] = isLocal;\n    }\n\n    function setLocalToken(\n        bytes32 token,\n        bool isLocal\n    ) external onlyOwner whenPaused {\n        isLocalToken[bytes32ToAddress(token)] = isLocal;\n    }\n\n    function removePair(bytes32 from) external onlyOwner whenPaused {\n        delete supportedPairs[from];\n    }\n\n    function hasSignedRequest(\n        address guardian,\n        bytes32 hash\n    ) public view returns (bool) {\n        return pendingRequests[hash].signatures[guardian];\n    }\n\n    function needsSignature(\n        bytes32 requestHash,\n        address account,\n        uint256 _committeeId\n    ) external view returns (bool) {\n        if (!isInCommittee(_committeeId, account)) {\n            return false;\n        }\n        if (processedRequests[requestHash]) {\n            return false;\n        }\n        if (hasSignedRequest(account, requestHash)) {\n            return false;\n        }\n        return true;\n    }\n\n    function isInCommittee(\n        uint256 _committeeId,\n        address account\n    ) public view returns (bool) {\n        return committee[keccak256(abi.encodePacked(_committeeId, account))];\n    }\n\n    function bytes32ToAddress(bytes32 data) internal pure returns (address) {\n        return address(uint160(uint256(data)));\n    }\n\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    /// @dev Adapted from Openzeppelin SafeERC20 - check if the ERC20 token transfer succeeded\n    function tokenTransferReturnSuccess(\n        IERC20 token,\n        address receiver,\n        uint256 amount\n    ) internal returns (bool) {\n        (bool success, bytes memory returndata) = address(token).call(\n            abi.encodeCall(token.transfer, (receiver, amount))\n        );\n        return\n            success &&\n            (returndata.length == 0 || abi.decode(returndata, (bool))) &&\n            address(token).code.length > 0;\n    }\n\n    /// @dev Accept ether only from weth contract or through payable methods\n    receive() external payable virtual {\n        require(msg.sender == wethAddress);\n    }\n\n    function checkTransferAllowed(\n        address token,\n        uint256 amount\n    ) internal view virtual {}\n}\n"
    },
    "contracts/ITransferLimit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface ITransferLimit {\n    function isRequestAllowed(\n        address _token,\n        uint256 _amount\n    ) external view returns (bool);\n}\n"
    },
    "contracts/IWETH9.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.2;\n\n/// @title Interface for WETH9\ninterface IWETH9 {\n    /// @notice Deposit ether to get wrapped ether\n    function deposit() external payable;\n\n    /// @notice Withdraw wrapped ether to get ether\n    function withdraw(uint256) external;\n}\n"
    },
    "contracts/IWrappedToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\n/// @title Interface for WrappedToken\ninterface IWrappedToken {\n    /// @notice Mint a given amount of remote PSP22 token representation to a given address\n    function mint(address, uint256) external;\n\n    /// @notice Burn a given amount of remote PSP22 token representation\n    function burn(uint256) external;\n\n    /// @notice Approve spending a given amount of token to the spender\n    function approve(address spender, uint256 value) external returns (bool);\n}\n"
    },
    "contracts/MockOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/// @title MockOracle\n/// @author Cardinal Cryptography\n/// @notice Mock Chainlink oracle for testing purposes\ncontract MockOracle {\n    int public price;\n\n    function setPrice(int _price) public {\n        price = _price;\n    }\n\n    function latestRoundData()\n        public\n        view\n        returns (uint80, int, uint, uint, uint80)\n    {\n        return (0, price, 0, 0, 0);\n    }\n\n    function decimals() public pure returns (uint8) {\n        return 8;\n    }\n}\n"
    },
    "contracts/Most.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {AbstractMost} from \"./AbstractMost.sol\";\nimport {ITransferLimit} from \"./ITransferLimit.sol\";\n\n/// @title Most\n/// @author Cardinal Cryptography\ncontract Most is AbstractMost {\n    ITransferLimit public transferLimit;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function setTransferLimitContract(\n        ITransferLimit _transferLimit\n    ) external onlyOwner {\n        transferLimit = _transferLimit;\n    }\n\n    function initialize(\n        address[] calldata _committee,\n        uint256 _signatureThreshold,\n        address owner,\n        address payable _wethAddress\n    ) public initializer {\n        __AbstractMost_init(_committee, _signatureThreshold, _wethAddress);\n        __Ownable_init(owner);\n        __Pausable_init();\n\n        _pause();\n    }\n\n    function checkTransferAllowed(\n        address token,\n        uint256 amount\n    ) internal view override {\n        if (transferLimit != ITransferLimit(address(0))) {\n            try transferLimit.isRequestAllowed(token, amount) returns (\n                bool result\n            ) {\n                if (!result) {\n                    revert LimitExceeded();\n                }\n            } catch {\n                // Ignore - behave as if the transferLimit is not set if it doesn't work for any reason\n            }\n        }\n    }\n}\n"
    },
    "contracts/MostL2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {AbstractMost} from \"./AbstractMost.sol\";\nimport {StableSwapTwoPool} from \"./StableSwap/StableSwapTwoPool.sol\";\nimport {IWrappedToken} from \"./IWrappedToken.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/// @title MostL2.sol\n/// @author Cardinal Cryptography\ncontract MostL2 is AbstractMost {\n    using SafeERC20 for IERC20;\n\n    /// Ratio between bridged azero (12 decimals) and native token on L2 (18 decimals)\n    uint256 public constant BAZERO_TO_NATIVE_RATIO = 1e6;\n\n    address payable public stableSwapAddress;\n    address public bAzeroAddress;\n\n    /// Rate of swap in stable swap we are content with\n    uint256 public constant MIN_SWAP_RATE = 99;\n\n    event NativeTransferFailed(bytes32 requestHash);\n    event NativeTransferSwap(bytes32 requestHash, uint256 amount_out);\n    event SwapFailed(bytes32 requestHash, uint256 amount_in);\n\n    error SwapError();\n\n    bytes32 internal constant EMPTY_STORAGE = 0x0;\n    bytes32 internal constant NATIVE_MARKER_BYTES = 0x0;\n    address internal constant NATIVE_MARKER_ADDRESS = address(0);\n\n    /// flat fee paid upon requesting transfer\n    uint256 public flat_fee;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address[] calldata _committee,\n        uint256 _signatureThreshold,\n        address owner,\n        address payable _stableSwapAddress,\n        address _bAzeroAddress\n    ) public initializer {\n        stableSwapAddress = _stableSwapAddress;\n        bAzeroAddress = _bAzeroAddress;\n        // Initial fee set to 0.5 Azero\n        flat_fee = 1e18 / 2;\n\n        // Set the weth address to zero address. We dont use this in L2 most\n        __AbstractMost_init(\n            _committee,\n            _signatureThreshold,\n            payable(address(0))\n        );\n        __Ownable_init(owner);\n        __Pausable_init();\n\n        _pause();\n    }\n\n    /// Calculates min value of the swap we are happy with.\n    /// Takes into account the difference in number of decimals between bazero and native token.\n    function calc_min_amount_out_swap(\n        uint256 amount,\n        bool to_bazero\n    ) internal pure returns (uint256) {\n        if (to_bazero) {\n            return ((amount / 100) * MIN_SWAP_RATE) / BAZERO_TO_NATIVE_RATIO;\n        } else {\n            return (amount / 100) * MIN_SWAP_RATE * BAZERO_TO_NATIVE_RATIO;\n        }\n    }\n\n    function swap_from_bazero(uint256 amount) internal returns (bool, uint256) {\n        IWrappedToken bazero = IWrappedToken(bAzeroAddress);\n        StableSwapTwoPool stablePool = StableSwapTwoPool(stableSwapAddress);\n\n        // Allow swap to spend that many tokens\n        bazero.approve(address(stableSwapAddress), amount);\n        // at least 99% of what we gave to the swap\n        uint256 min_amount_out = calc_min_amount_out_swap(amount, false);\n\n        (bool swapSuccess, bytes memory returndata) = address(stablePool).call(\n            abi.encodeCall(\n                stablePool.exchange_to_native,\n                (amount, min_amount_out)\n            )\n        );\n        if (swapSuccess) {\n            uint256 amount_out = abi.decode(returndata, (uint256));\n            return (swapSuccess, amount_out);\n        }\n        return (false, 0);\n    }\n\n    function swap_for_bazero(uint256 amount) internal returns (uint256) {\n        // at least 99% of what we gave to the swap\n        uint256 min_amount_out = calc_min_amount_out_swap(amount, true);\n\n        StableSwapTwoPool stablePool = StableSwapTwoPool(stableSwapAddress);\n        return stablePool.exchange_from_native{value: amount}(min_amount_out);\n    }\n\n    function native_transfer(\n        bytes32 requestHash,\n        uint256 amount,\n        address _destReceiverAddress\n    ) internal {\n        // What we do here is:\n        // 1. Mint `amount` Bazero\n        // 2. Allow spending that many Bazero for swap contract\n        // 3. exchange bazero for native tokens, here the swap spends its allowance and sends native to this contract\n        // 4. transfer exchanged native to the receiver.\n        IWrappedToken bazero = IWrappedToken(bAzeroAddress);\n        bazero.mint(address(this), amount);\n\n        (bool swapSuccess, uint256 amount_out) = swap_from_bazero(amount);\n\n        if (!swapSuccess) {\n            IERC20(bAzeroAddress).safeTransfer(_destReceiverAddress, amount);\n            emit SwapFailed(requestHash, amount);\n            return;\n        }\n\n        // payout to receiver\n        (bool sendNativeEthSuccess, ) = _destReceiverAddress.call{\n            value: amount_out,\n            gas: GAS_LIMIT\n        }(\"\");\n\n        if (!sendNativeEthSuccess) {\n            emit NativeTransferFailed(requestHash);\n        } else {\n            emit NativeTransferSwap(requestHash, amount_out);\n        }\n    }\n\n    function remote_token_transfer(\n        address _destTokenAddress,\n        uint256 amount,\n        address _destReceiverAddress\n    ) internal {\n        // Mint representation of the remote token\n        IWrappedToken mintableToken = IWrappedToken(_destTokenAddress);\n        mintableToken.mint(_destReceiverAddress, amount);\n    }\n\n    function onReceiveRequestThresholdMet(\n        bytes32 requestHash,\n        bytes32 destTokenAddress,\n        uint256 amount,\n        bytes32 destReceiverAddress\n    ) internal override {\n        processedRequests[requestHash] = true;\n        delete pendingRequests[requestHash];\n\n        address _destTokenAddress = bytes32ToAddress(destTokenAddress);\n        address _destReceiverAddress = bytes32ToAddress(destReceiverAddress);\n\n        require(\n            !isLocalToken[_destTokenAddress],\n            \"We dont bridge non local token\"\n        );\n\n        // transfer native\n        if (_destTokenAddress == NATIVE_MARKER_ADDRESS) {\n            native_transfer(requestHash, amount, _destReceiverAddress);\n        } else {\n            remote_token_transfer(\n                _destTokenAddress,\n                amount,\n                _destReceiverAddress\n            );\n        }\n\n        emit RequestProcessed(requestHash);\n    }\n\n    function burn_bazero(uint256 amount) internal {\n        IWrappedToken bazero = IWrappedToken(bAzeroAddress);\n        bazero.burn(amount);\n    }\n\n    /// This function, if it is possible, transfer flat fee to owner\n    /// and returns the surplus to the caller.\n    function handle_flat_fee(uint256 native_amount) internal {\n        uint256 transferred = msg.value;\n\n        require(\n            transferred >= native_amount,\n            \"Not enough value send for transfer\"\n        );\n\n        transferred -= native_amount;\n        require(transferred >= flat_fee, \"Not enough value send for fees\");\n\n        uint256 surplus = transferred - flat_fee;\n\n        (bool sent, ) = owner().call{value: flat_fee}(\"\");\n        require(sent, \"Failed to send fee to owner\");\n\n        if (surplus > 0) {\n            (bool sent, ) = msg.sender.call{value: surplus}(\"\");\n            require(sent, \"Failed to return surplus\");\n        }\n    }\n\n    function sendRequestNative(\n        bytes32\n    ) external payable override whenNotPaused {\n        revert(\n            \"Not supported on L2 bridge, use `sendRequestNative` with additional arg\"\n        );\n    }\n\n    /// @notice Invoke this tx to transfer funds to the destination chain.\n    /// Account needs to send native Azero which are swapped for bazero\n    /// tokens. Since the Bazero have 12 decimals and Azero have 18,\n    /// user need to send at leas 10e6 tokens with this call.\n    ///\n    /// @dev Tx emits a CrosschainTransferRequest event that the relayers listen to\n    /// & forward to the destination chain.\n    function sendRequestNative(\n        bytes32 destReceiverAddress,\n        uint256 amount_to_bridge\n    ) external payable whenNotPaused {\n        require(\n            amount_to_bridge >= BAZERO_TO_NATIVE_RATIO,\n            \"Value must be at least 10e6\"\n        );\n        if (destReceiverAddress == bytes32(0)) {\n            revert ZeroAddress();\n        }\n        handle_flat_fee(amount_to_bridge);\n\n        uint256 amount_out = swap_for_bazero(amount_to_bridge);\n        burn_bazero(amount_out);\n\n        emit CrosschainTransferRequest(\n            committeeId,\n            NATIVE_MARKER_BYTES,\n            amount_out,\n            destReceiverAddress,\n            requestNonce\n        );\n\n        ++requestNonce;\n    }\n\n    function sendRequest(\n        bytes32,\n        uint256,\n        bytes32\n    ) external override whenNotPaused {\n        revert(\"Not supported on L2 bridge, use `SendTokenRequest` instead\");\n    }\n\n    /// @notice Invoke this tx to transfer funds to the destination chain.\n    /// Account needs to approve the Most contract to spend the `srcTokenAmount`\n    /// of `srcTokenAddress` tokens on their behalf before executing the tx.\n    ///\n    /// @dev Tx emits a CrosschainTransferRequest event that the relayers listen to\n    /// & forward to the destination chain.\n    function sendTokenRequest(\n        bytes32 srcTokenAddress,\n        uint256 amount,\n        bytes32 destReceiverAddress\n    ) external payable whenNotPaused {\n        if (amount == 0) revert ZeroAmount();\n        if (destReceiverAddress == bytes32(0)) revert ZeroAddress();\n        handle_flat_fee(0);\n\n        address token = bytes32ToAddress(srcTokenAddress);\n\n        bytes32 destTokenAddress = supportedPairs[srcTokenAddress];\n\n        if (destTokenAddress == EMPTY_STORAGE) revert UnsupportedPair();\n        // Should not happen, see `addPair` function where we allow only nonLocal tokens.\n        require(\n            !isLocalToken[token],\n            \"We dont bridge local tokens on L2 bridge\"\n        );\n\n        // Burn tokens in this contract\n        // message sender needs to give approval else this tx will revert\n        IERC20 tokenERC20 = IERC20(token);\n        tokenERC20.safeTransferFrom(msg.sender, address(this), amount);\n        IWrappedToken burnableToken = IWrappedToken(token);\n        burnableToken.burn(amount);\n\n        emit CrosschainTransferRequest(\n            committeeId,\n            destTokenAddress,\n            amount,\n            destReceiverAddress,\n            requestNonce\n        );\n\n        ++requestNonce;\n    }\n\n    function setBridgedAzeroAddress(\n        address _bAzeroAddress\n    ) external onlyOwner whenPaused {\n        bAzeroAddress = _bAzeroAddress;\n    }\n\n    function sendRequestAzeroToNative(uint256, bytes32) external pure override {\n        revert(\"Not supported on L2 bridge\");\n    }\n\n    function addPair(\n        bytes32 from,\n        bytes32 to,\n        bool isLocal\n    ) external override onlyOwner whenPaused {\n        require(!isLocal, \"L2 Most dont bridge local tokens\");\n        supportedPairs[from] = to;\n        isLocalToken[bytes32ToAddress(from)] = false;\n    }\n\n    function setFlatFee(uint256 new_flat_fee) external onlyOwner {\n        flat_fee = new_flat_fee;\n    }\n\n    /// @dev Accept ether only from pool contract or through payable methods\n    receive() external payable override {\n        require(msg.sender == stableSwapAddress);\n    }\n}\n"
    },
    "contracts/StableSwap/IStableSwapLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\ninterface IStableSwapLP {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    function mint(address _to, uint256 _amount) external;\n\n    function burnFrom(address _to, uint256 _amount) external;\n\n    function setMinter(address _newMinter) external;\n}\n"
    },
    "contracts/StableSwap/StableSwapLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin-4.5.0/contracts/token/ERC20/ERC20.sol\";\n\ncontract StableSwapLP is ERC20 {\n    address public minter;\n\n    constructor() ERC20(\"StableSwap LPs\", \"Stable-LP\") {\n        minter = msg.sender;\n    }\n\n    /**\n     * @notice Checks if the msg.sender is the minter address.\n     */\n    modifier onlyMinter() {\n        require(msg.sender == minter, \"Not minter\");\n        _;\n    }\n\n    function setMinter(address _newMinter) external onlyMinter {\n        minter = _newMinter;\n    }\n\n    function mint(address _to, uint256 _amount) external onlyMinter {\n        _mint(_to, _amount);\n    }\n\n    function burnFrom(address _to, uint256 _amount) external onlyMinter {\n        _burn(_to, _amount);\n    }\n}\n"
    },
    "contracts/StableSwap/StableSwapTwoPool.sol": {
      "content": "// MIT License\n//\n// Copyright (c) 2024 PancakeSwap\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin-4.5.0/contracts/access/Ownable.sol\";\nimport \"@openzeppelin-4.5.0/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin-4.5.0/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin-4.5.0/contracts/security/ReentrancyGuard.sol\";\nimport \"./IStableSwapLP.sol\";\n\ncontract StableSwapTwoPool is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    uint256 public constant N_COINS = 2;\n\n    uint256 public constant MAX_DECIMAL = 18;\n    uint256 public constant FEE_DENOMINATOR = 1e10;\n    uint256 public constant PRECISION = 1e18;\n    uint256[N_COINS] public PRECISION_MUL;\n    uint256[N_COINS] public RATES;\n\n    uint256 public constant MAX_ADMIN_FEE = 1e10;\n    uint256 public constant MAX_FEE = 5e9;\n    uint256 public constant MAX_AMPLIFICATION_COEFFICIENT = 1e6;\n    uint256 public constant MAX_AMPLIFICATION_COEFFICIENT_CHANGE = 10;\n    uint256 public constant MIN_NATIVE_GAS = 2300;\n    uint256 public constant MAX_NATIVE_GAS = 23000;\n\n    uint256 public constant ADMIN_ACTIONS_DELAY = 3 days;\n    uint256 public constant MIN_RAMP_TIME = 1 days;\n\n    address[N_COINS] public coins;\n    uint256[N_COINS] public balances;\n    uint256 public fee; // fee * 1e10.\n    uint256 public admin_fee; // admin_fee * 1e10.\n    uint256 public native_gas = 4029; // transfer native gas.\n\n    IStableSwapLP public token;\n\n    address constant NATIVE_ADDRESS =\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    bool support_native;\n\n    uint256 public initial_amplification_coefficient;\n    uint256 public future_amplification_coefficient;\n    uint256 public initial_amplification_coefficient_time;\n    uint256 public future_amplification_coefficient_time;\n\n    uint256 public admin_actions_deadline;\n    uint256 public future_fee;\n    uint256 public future_admin_fee;\n\n    uint256 public kill_deadline;\n    uint256 public constant KILL_DEADLINE_DT = 2 * 30 days;\n    bool public is_killed;\n\n    address public immutable STABLESWAP_FACTORY;\n    bool public isInitialized;\n\n    event TokenExchange(\n        address indexed buyer,\n        uint256 sold_id,\n        uint256 tokens_sold,\n        uint256 bought_id,\n        uint256 tokens_bought\n    );\n    event AddLiquidity(\n        address indexed provider,\n        uint256[N_COINS] token_amounts,\n        uint256[N_COINS] fees,\n        uint256 invariant,\n        uint256 token_supply\n    );\n    event RemoveLiquidity(\n        address indexed provider,\n        uint256[N_COINS] token_amounts,\n        uint256[N_COINS] fees,\n        uint256 token_supply\n    );\n    event RemoveLiquidityOne(\n        address indexed provider,\n        uint256 index,\n        uint256 token_amount,\n        uint256 coin_amount\n    );\n    event RemoveLiquidityImbalance(\n        address indexed provider,\n        uint256[N_COINS] token_amounts,\n        uint256[N_COINS] fees,\n        uint256 invariant,\n        uint256 token_supply\n    );\n    event CommitNewFee(\n        uint256 indexed deadline,\n        uint256 fee,\n        uint256 admin_fee\n    );\n    event NewFee(uint256 fee, uint256 admin_fee);\n    event RampA(\n        uint256 old_A,\n        uint256 new_A,\n        uint256 initial_time,\n        uint256 future_time\n    );\n    event StopRampA(uint256 A, uint256 t);\n    event SetNativeGas(uint256 native_gas);\n    event RevertParameters();\n    event DonateAdminFees();\n    event Kill();\n    event Unkill();\n\n    /**\n     * @notice constructor\n     */\n    constructor() {\n        STABLESWAP_FACTORY = msg.sender;\n    }\n\n    /**\n     * @notice initialize\n     * @param _coins: Addresses of ERC20 conracts of coins (c-tokens) involved\n     * @param _amplification_coefficient: Amplification coefficient multiplied by n * (n - 1)\n     * @param _fee: Fee to charge for exchanges\n     * @param _admin_fee: Admin fee\n     * @param _owner: Owner\n     * @param _liquidity_pool: LP address\n     */\n    function initialize(\n        address[N_COINS] memory _coins,\n        uint256 _amplification_coefficient,\n        uint256 _fee,\n        uint256 _admin_fee,\n        address _owner,\n        address _liquidity_pool\n    ) external {\n        require(!isInitialized, \"Operations: Already initialized\");\n        require(msg.sender == STABLESWAP_FACTORY, \"Operations: Not factory\");\n        require(\n            _amplification_coefficient <= MAX_AMPLIFICATION_COEFFICIENT,\n            \"_amplification_coefficient exceeds maximum\"\n        );\n        require(_fee <= MAX_FEE, \"_fee exceeds maximum\");\n        require(_admin_fee <= MAX_ADMIN_FEE, \"_admin_fee exceeds maximum\");\n        isInitialized = true;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            require(_coins[i] != address(0), \"ZERO Address\");\n            uint256 coinDecimal;\n            if (_coins[i] == NATIVE_ADDRESS) {\n                coinDecimal = 18;\n                support_native = true;\n            } else {\n                coinDecimal = IERC20Metadata(_coins[i]).decimals();\n            }\n            require(\n                coinDecimal <= MAX_DECIMAL,\n                \"The maximum decimal cannot exceed 18\"\n            );\n            //set PRECISION_MUL and  RATES\n            PRECISION_MUL[i] = 10 ** (MAX_DECIMAL - coinDecimal);\n            RATES[i] = PRECISION * PRECISION_MUL[i];\n        }\n        coins = _coins;\n        initial_amplification_coefficient = _amplification_coefficient;\n        future_amplification_coefficient = _amplification_coefficient;\n        fee = _fee;\n        admin_fee = _admin_fee;\n        kill_deadline = block.timestamp + KILL_DEADLINE_DT;\n        token = IStableSwapLP(_liquidity_pool);\n\n        transferOwnership(_owner);\n    }\n\n    function get_amplification_coefficient() internal view returns (uint256) {\n        //Handle ramping A up or down\n        uint256 t1 = future_amplification_coefficient_time;\n        uint256 A1 = future_amplification_coefficient;\n        if (block.timestamp < t1) {\n            uint256 A0 = initial_amplification_coefficient;\n            uint256 t0 = initial_amplification_coefficient_time;\n            // Expressions in uint256 cannot have negative numbers, thus \"if\"\n            if (A1 > A0) {\n                return A0 + ((A1 - A0) * (block.timestamp - t0)) / (t1 - t0);\n            } else {\n                return A0 - ((A0 - A1) * (block.timestamp - t0)) / (t1 - t0);\n            }\n        } else {\n            // when t1 == 0 or block.timestamp >= t1\n            return A1;\n        }\n    }\n\n    function amplification_coefficient() external view returns (uint256) {\n        return get_amplification_coefficient();\n    }\n\n    function _xp() internal view returns (uint256[N_COINS] memory result) {\n        result = RATES;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            result[i] = (result[i] * balances[i]) / PRECISION;\n        }\n    }\n\n    function _xp_mem(\n        uint256[N_COINS] memory _balances\n    ) internal view returns (uint256[N_COINS] memory result) {\n        result = RATES;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            result[i] = (result[i] * _balances[i]) / PRECISION;\n        }\n    }\n\n    function get_D(\n        uint256[N_COINS] memory xp,\n        uint256 amp\n    ) internal pure returns (uint256) {\n        uint256 S;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            S += xp[i];\n        }\n        if (S == 0) {\n            return 0;\n        }\n\n        uint256 Dprev;\n        uint256 D = S;\n        uint256 Ann = amp * N_COINS;\n        for (uint256 j = 0; j < 255; j++) {\n            uint256 D_P = D;\n            for (uint256 k = 0; k < N_COINS; k++) {\n                D_P = (D_P * D) / (xp[k] * N_COINS); // If division by 0, this will be borked: only withdrawal will work. And that is good\n            }\n            Dprev = D;\n            D =\n                ((Ann * S + D_P * N_COINS) * D) /\n                ((Ann - 1) * D + (N_COINS + 1) * D_P);\n            // Equality with the precision of 1\n            if (D > Dprev) {\n                if (D - Dprev <= 1) {\n                    break;\n                }\n            } else {\n                if (Dprev - D <= 1) {\n                    break;\n                }\n            }\n        }\n        return D;\n    }\n\n    function get_D_mem(\n        uint256[N_COINS] memory _balances,\n        uint256 amp\n    ) internal view returns (uint256) {\n        return get_D(_xp_mem(_balances), amp);\n    }\n\n    function get_virtual_price() external view returns (uint256) {\n        /**\n        Returns portfolio virtual price (for calculating profit)\n        scaled up by 1e18\n        */\n        uint256 D = get_D(_xp(), get_amplification_coefficient());\n        /**\n        D is in the units similar to DAI (e.g. converted to precision 1e18)\n        When balanced, D = n * x_u - total virtual value of the portfolio\n        */\n        uint256 token_supply = token.totalSupply();\n        return (D * PRECISION) / token_supply;\n    }\n\n    function calc_token_amount(\n        uint256[N_COINS] memory amounts,\n        bool deposit\n    ) external view returns (uint256) {\n        /**\n        Simplified method to calculate addition or reduction in token supply at\n        deposit or withdrawal without taking fees into account (but looking at\n        slippage).\n        Needed to prevent front-running, not for precise calculations!\n        */\n        uint256[N_COINS] memory _balances = balances;\n        uint256 amp = get_amplification_coefficient();\n        uint256 D0 = get_D_mem(_balances, amp);\n        for (uint256 i = 0; i < N_COINS; i++) {\n            if (deposit) {\n                _balances[i] += amounts[i];\n            } else {\n                _balances[i] -= amounts[i];\n            }\n        }\n        uint256 D1 = get_D_mem(_balances, amp);\n        uint256 token_amount = token.totalSupply();\n        uint256 difference;\n        if (deposit) {\n            difference = D1 - D0;\n        } else {\n            difference = D0 - D1;\n        }\n        return (difference * token_amount) / D0;\n    }\n\n    function add_liquidity(\n        uint256[N_COINS] memory amounts,\n        uint256 min_mint_amount\n    ) external payable nonReentrant {\n        //Amounts is amounts of c-tokens\n        require(!is_killed, \"Killed\");\n        if (!support_native) {\n            require(msg.value == 0, \"Inconsistent quantity\"); // Avoid sending native by mistake.\n        }\n        uint256[N_COINS] memory fees;\n        uint256 _fee = (fee * N_COINS) / (4 * (N_COINS - 1));\n        uint256 _admin_fee = admin_fee;\n        uint256 amp = get_amplification_coefficient();\n\n        uint256 token_supply = token.totalSupply();\n        //Initial invariant\n        uint256 D0;\n        uint256[N_COINS] memory old_balances = balances;\n        if (token_supply > 0) {\n            D0 = get_D_mem(old_balances, amp);\n        }\n        uint256[N_COINS] memory new_balances = [\n            old_balances[0],\n            old_balances[1]\n        ];\n\n        for (uint256 i = 0; i < N_COINS; i++) {\n            if (token_supply == 0) {\n                require(amounts[i] > 0, \"Initial deposit requires all coins\");\n            }\n            // balances store amounts of c-tokens\n            new_balances[i] = old_balances[i] + amounts[i];\n        }\n\n        // Invariant after change\n        uint256 D1 = get_D_mem(new_balances, amp);\n        require(D1 > D0, \"D1 must be greater than D0\");\n\n        // We need to recalculate the invariant accounting for fees\n        // to calculate fair user's share\n        uint256 D2 = D1;\n        if (token_supply > 0) {\n            // Only account for fees if we are not the first to deposit\n            for (uint256 i = 0; i < N_COINS; i++) {\n                uint256 ideal_balance = (D1 * old_balances[i]) / D0;\n                uint256 difference;\n                if (ideal_balance > new_balances[i]) {\n                    difference = ideal_balance - new_balances[i];\n                } else {\n                    difference = new_balances[i] - ideal_balance;\n                }\n\n                fees[i] = (_fee * difference) / FEE_DENOMINATOR;\n                balances[i] =\n                    new_balances[i] -\n                    ((fees[i] * _admin_fee) / FEE_DENOMINATOR);\n                new_balances[i] -= fees[i];\n            }\n            D2 = get_D_mem(new_balances, amp);\n        } else {\n            balances = new_balances;\n        }\n\n        // Calculate, how much pool tokens to mint\n        uint256 mint_amount;\n        if (token_supply == 0) {\n            mint_amount = D1; // Take the dust if there was any\n        } else {\n            mint_amount = (token_supply * (D2 - D0)) / D0;\n        }\n        require(mint_amount >= min_mint_amount, \"Slippage screwed you\");\n\n        // Take coins from the sender\n        for (uint256 i = 0; i < N_COINS; i++) {\n            uint256 amount = amounts[i];\n            address coin = coins[i];\n            transfer_in(coin, amount);\n        }\n\n        // Mint pool tokens\n        token.mint(msg.sender, mint_amount);\n\n        emit AddLiquidity(\n            msg.sender,\n            amounts,\n            fees,\n            D1,\n            token_supply + mint_amount\n        );\n    }\n\n    function get_y(\n        uint256 i,\n        uint256 j,\n        uint256 x,\n        uint256[N_COINS] memory xp_\n    ) internal view returns (uint256) {\n        // x in the input is converted to the same price/precision\n        require(\n            (i != j) && (i < N_COINS) && (j < N_COINS),\n            \"Illegal parameter\"\n        );\n        uint256 amp = get_amplification_coefficient();\n        uint256 D = get_D(xp_, amp);\n        uint256 c = D;\n        uint256 S_;\n        uint256 Ann = amp * N_COINS;\n\n        uint256 _x;\n        for (uint256 k = 0; k < N_COINS; k++) {\n            if (k == i) {\n                _x = x;\n            } else if (k != j) {\n                _x = xp_[k];\n            } else {\n                continue;\n            }\n            S_ += _x;\n            c = (c * D) / (_x * N_COINS);\n        }\n        c = (c * D) / (Ann * N_COINS);\n        uint256 b = S_ + D / Ann; // - D\n        uint256 y_prev;\n        uint256 y = D;\n\n        for (uint256 m = 0; m < 255; m++) {\n            y_prev = y;\n            y = (y * y + c) / (2 * y + b - D);\n            // Equality with the precision of 1\n            if (y > y_prev) {\n                if (y - y_prev <= 1) {\n                    break;\n                }\n            } else {\n                if (y_prev - y <= 1) {\n                    break;\n                }\n            }\n        }\n        return y;\n    }\n\n    function get_amount_out(\n        uint256 source_token,\n        uint256 dest_token,\n        uint256 amount_in\n    ) external view returns (uint256) {\n        // dx and dy in c-units\n        uint256[N_COINS] memory rates = RATES;\n        uint256[N_COINS] memory xp = _xp();\n\n        uint256 x = xp[source_token] +\n            ((amount_in * rates[source_token]) / PRECISION);\n        uint256 y = get_y(source_token, dest_token, x, xp);\n        uint256 dy = ((xp[dest_token] - y - 1) * PRECISION) / rates[dest_token];\n        uint256 _fee = (fee * dy) / FEE_DENOMINATOR;\n        return dy - _fee;\n    }\n\n    function get_dy_underlying(\n        uint256 i,\n        uint256 j,\n        uint256 dx\n    ) external view returns (uint256) {\n        // dx and dy in underlying units\n        uint256[N_COINS] memory xp = _xp();\n        uint256[N_COINS] memory precisions = PRECISION_MUL;\n\n        uint256 x = xp[i] + dx * precisions[i];\n        uint256 y = get_y(i, j, x, xp);\n        uint256 dy = (xp[j] - y - 1) / precisions[j];\n        uint256 _fee = (fee * dy) / FEE_DENOMINATOR;\n        return dy - _fee;\n    }\n\n    function exchange_to_native(\n        uint256 amount_in,\n        uint256 native_min_amount_out\n    ) external payable nonReentrant returns (uint256) {\n        require(support_native, \"Cant exchange native without native support\");\n\n        if (coins[0] == NATIVE_ADDRESS) {\n            return exchange(1, 0, amount_in, native_min_amount_out);\n        } else {\n            return exchange(0, 1, amount_in, native_min_amount_out);\n        }\n    }\n\n    function exchange_from_native(\n        uint256 min_amount_out\n    ) external payable nonReentrant returns (uint256) {\n        require(support_native, \"Cant exchange native without native support\");\n\n        if (coins[0] == NATIVE_ADDRESS) {\n            return exchange(0, 1, msg.value, min_amount_out);\n        } else {\n            return exchange(1, 0, msg.value, min_amount_out);\n        }\n    }\n\n    function exchange(\n        uint256 source_token,\n        uint256 dest_token,\n        uint256 amount_in,\n        uint256 amount_out\n    ) internal returns (uint256) {\n        require(!is_killed, \"Killed\");\n        if (!support_native) {\n            require(msg.value == 0, \"Inconsistent quantity\"); // Avoid sending native by mistake.\n        }\n\n        uint256[N_COINS] memory old_balances = balances;\n        uint256[N_COINS] memory xp = _xp_mem(old_balances);\n\n        uint256 x = xp[source_token] +\n            (amount_in * RATES[source_token]) /\n            PRECISION;\n        uint256 y = get_y(source_token, dest_token, x, xp);\n\n        uint256 dy = xp[dest_token] - y - 1; //  -1 just in case there were some rounding errors\n        uint256 dy_fee = (dy * fee) / FEE_DENOMINATOR;\n\n        // Convert all to real units\n        dy = ((dy - dy_fee) * PRECISION) / RATES[dest_token];\n        require(\n            dy >= amount_out,\n            \"Exchange resulted in fewer coins than expected\"\n        );\n\n        uint256 dy_admin_fee = (dy_fee * admin_fee) / FEE_DENOMINATOR;\n        dy_admin_fee = (dy_admin_fee * PRECISION) / RATES[dest_token];\n\n        // Change balances exactly in same way as we change actual ERC20 coin amounts\n        balances[source_token] = old_balances[source_token] + amount_in;\n        // When rounding errors happen, we undercharge admin fee in favor of LP\n        balances[dest_token] = old_balances[dest_token] - dy - dy_admin_fee;\n\n        address iAddress = coins[source_token];\n        if (iAddress == NATIVE_ADDRESS) {\n            require(amount_in == msg.value, \"Inconsistent quantity\");\n        } else {\n            IERC20(iAddress).safeTransferFrom(\n                msg.sender,\n                address(this),\n                amount_in\n            );\n        }\n        address jAddress = coins[dest_token];\n        transfer_out(jAddress, dy);\n        return dy;\n    }\n\n    function remove_liquidity(\n        uint256 _amount,\n        uint256[N_COINS] memory min_amounts\n    ) external nonReentrant {\n        uint256 total_supply = token.totalSupply();\n        uint256[N_COINS] memory amounts;\n        uint256[N_COINS] memory fees; //Fees are unused but we've got them historically in event\n\n        for (uint256 i = 0; i < N_COINS; i++) {\n            uint256 value = (balances[i] * _amount) / total_supply;\n            require(\n                value >= min_amounts[i],\n                \"Withdrawal resulted in fewer coins than expected\"\n            );\n            balances[i] -= value;\n            amounts[i] = value;\n            transfer_out(coins[i], value);\n        }\n\n        token.burnFrom(msg.sender, _amount); // dev: insufficient funds\n\n        emit RemoveLiquidity(msg.sender, amounts, fees, total_supply - _amount);\n    }\n\n    function remove_liquidity_imbalance(\n        uint256[N_COINS] memory amounts,\n        uint256 max_burn_amount\n    ) external nonReentrant {\n        require(!is_killed, \"Killed\");\n\n        uint256 token_supply = token.totalSupply();\n        require(token_supply > 0, \"dev: zero total supply\");\n        uint256 _fee = (fee * N_COINS) / (4 * (N_COINS - 1));\n        uint256 _admin_fee = admin_fee;\n        uint256 amp = get_amplification_coefficient();\n\n        uint256[N_COINS] memory old_balances = balances;\n        uint256[N_COINS] memory new_balances = [\n            old_balances[0],\n            old_balances[1]\n        ];\n        uint256 D0 = get_D_mem(old_balances, amp);\n        for (uint256 i = 0; i < N_COINS; i++) {\n            new_balances[i] -= amounts[i];\n        }\n        uint256 D1 = get_D_mem(new_balances, amp);\n        uint256[N_COINS] memory fees;\n        for (uint256 i = 0; i < N_COINS; i++) {\n            uint256 ideal_balance = (D1 * old_balances[i]) / D0;\n            uint256 difference;\n            if (ideal_balance > new_balances[i]) {\n                difference = ideal_balance - new_balances[i];\n            } else {\n                difference = new_balances[i] - ideal_balance;\n            }\n            fees[i] = (_fee * difference) / FEE_DENOMINATOR;\n            balances[i] =\n                new_balances[i] -\n                ((fees[i] * _admin_fee) / FEE_DENOMINATOR);\n            new_balances[i] -= fees[i];\n        }\n        uint256 D2 = get_D_mem(new_balances, amp);\n\n        uint256 token_amount = ((D0 - D2) * token_supply) / D0;\n        require(token_amount > 0, \"token_amount must be greater than 0\");\n        token_amount += 1; // In case of rounding errors - make it unfavorable for the \"attacker\"\n        require(token_amount <= max_burn_amount, \"Slippage screwed you\");\n\n        token.burnFrom(msg.sender, token_amount); // dev: insufficient funds\n\n        for (uint256 i = 0; i < N_COINS; i++) {\n            if (amounts[i] > 0) {\n                transfer_out(coins[i], amounts[i]);\n            }\n        }\n        token_supply -= token_amount;\n        emit RemoveLiquidityImbalance(\n            msg.sender,\n            amounts,\n            fees,\n            D1,\n            token_supply\n        );\n    }\n\n    function get_y_D(\n        uint256 A_,\n        uint256 i,\n        uint256[N_COINS] memory xp,\n        uint256 D\n    ) internal pure returns (uint256) {\n        /**\n        Calculate x[i] if one reduces D from being calculated for xp to D\n\n        Done by solving quadratic equation iteratively.\n        x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\n        x_1**2 + b*x_1 = c\n\n        x_1 = (x_1**2 + c) / (2*x_1 + b)\n        */\n        // x in the input is converted to the same price/precision\n        require(i < N_COINS, \"dev: i above N_COINS\");\n        uint256 c = D;\n        uint256 S_;\n        uint256 Ann = A_ * N_COINS;\n\n        uint256 _x;\n        for (uint256 k = 0; k < N_COINS; k++) {\n            if (k != i) {\n                _x = xp[k];\n            } else {\n                continue;\n            }\n            S_ += _x;\n            c = (c * D) / (_x * N_COINS);\n        }\n        c = (c * D) / (Ann * N_COINS);\n        uint256 b = S_ + D / Ann;\n        uint256 y_prev;\n        uint256 y = D;\n\n        for (uint256 k = 0; k < 255; k++) {\n            y_prev = y;\n            y = (y * y + c) / (2 * y + b - D);\n            // Equality with the precision of 1\n            if (y > y_prev) {\n                if (y - y_prev <= 1) {\n                    break;\n                }\n            } else {\n                if (y_prev - y <= 1) {\n                    break;\n                }\n            }\n        }\n        return y;\n    }\n\n    function _calc_withdraw_one_coin(\n        uint256 _token_amount,\n        uint256 i\n    ) internal view returns (uint256, uint256) {\n        // First, need to calculate\n        // * Get current D\n        // * Solve Eqn against y_i for D - _token_amount\n        uint256 amp = get_amplification_coefficient();\n        uint256 _fee = (fee * N_COINS) / (4 * (N_COINS - 1));\n        uint256[N_COINS] memory precisions = PRECISION_MUL;\n        uint256 total_supply = token.totalSupply();\n\n        uint256[N_COINS] memory xp = _xp();\n\n        uint256 D0 = get_D(xp, amp);\n        uint256 D1 = D0 - (_token_amount * D0) / total_supply;\n        uint256[N_COINS] memory xp_reduced = xp;\n\n        uint256 new_y = get_y_D(amp, i, xp, D1);\n        uint256 dy_0 = (xp[i] - new_y) / precisions[i]; // w/o fees\n\n        for (uint256 k = 0; k < N_COINS; k++) {\n            uint256 dx_expected;\n            if (k == i) {\n                dx_expected = (xp[k] * D1) / D0 - new_y;\n            } else {\n                dx_expected = xp[k] - (xp[k] * D1) / D0;\n            }\n            xp_reduced[k] -= (_fee * dx_expected) / FEE_DENOMINATOR;\n        }\n        uint256 dy = xp_reduced[i] - get_y_D(amp, i, xp_reduced, D1);\n        dy = (dy - 1) / precisions[i]; // Withdraw less to account for rounding errors\n\n        return (dy, dy_0 - dy);\n    }\n\n    function calc_withdraw_one_coin(\n        uint256 _token_amount,\n        uint256 i\n    ) external view returns (uint256) {\n        (uint256 dy, ) = _calc_withdraw_one_coin(_token_amount, i);\n        return dy;\n    }\n\n    function remove_liquidity_one_coin(\n        uint256 _token_amount,\n        uint256 i,\n        uint256 min_amount\n    ) external nonReentrant {\n        // Remove _amount of liquidity all in a form of coin i\n        require(!is_killed, \"Killed\");\n        (uint256 dy, uint256 dy_fee) = _calc_withdraw_one_coin(\n            _token_amount,\n            i\n        );\n        require(dy >= min_amount, \"Not enough coins removed\");\n\n        balances[i] -= (dy + (dy_fee * admin_fee) / FEE_DENOMINATOR);\n        token.burnFrom(msg.sender, _token_amount); // dev: insufficient funds\n        transfer_out(coins[i], dy);\n\n        emit RemoveLiquidityOne(msg.sender, i, _token_amount, dy);\n    }\n\n    function transfer_out(address coin_address, uint256 value) internal {\n        if (coin_address == NATIVE_ADDRESS) {\n            _safeTransferNative(msg.sender, value);\n        } else {\n            IERC20(coin_address).safeTransfer(msg.sender, value);\n        }\n    }\n\n    function transfer_in(address coin_address, uint256 value) internal {\n        if (coin_address == NATIVE_ADDRESS) {\n            require(value == msg.value, \"Inconsistent quantity\");\n        } else {\n            IERC20(coin_address).safeTransferFrom(\n                msg.sender,\n                address(this),\n                value\n            );\n        }\n    }\n\n    function _safeTransferNative(address to, uint256 value) internal {\n        (bool success, ) = to.call{gas: native_gas, value: value}(\"\");\n        require(success, \"native transfer failed\");\n    }\n\n    // Admin functions\n\n    function set_native_gas(uint256 _native_gas) external onlyOwner {\n        require(\n            _native_gas >= MIN_NATIVE_GAS && _native_gas <= MAX_NATIVE_GAS,\n            \"Illegal gas\"\n        );\n        native_gas = _native_gas;\n        emit SetNativeGas(_native_gas);\n    }\n\n    function ramp_amplification_coefficient(\n        uint256 _future_amplification_coefficient,\n        uint256 _future_time\n    ) external onlyOwner {\n        require(\n            block.timestamp >=\n                initial_amplification_coefficient_time + MIN_RAMP_TIME,\n            \"dev : too early\"\n        );\n        require(\n            _future_time >= block.timestamp + MIN_RAMP_TIME,\n            \"dev: insufficient time\"\n        );\n\n        uint256 _initial_amplification_coefficient = get_amplification_coefficient();\n        require(\n            _future_amplification_coefficient > 0 &&\n                _future_amplification_coefficient <\n                MAX_AMPLIFICATION_COEFFICIENT,\n            \"_future_amplification_coefficient must be between 0 and MAX_AMPLIFICATION_COEFFICIENT\"\n        );\n        require(\n            (_future_amplification_coefficient >=\n                _initial_amplification_coefficient &&\n                _future_amplification_coefficient <=\n                _initial_amplification_coefficient *\n                    MAX_AMPLIFICATION_COEFFICIENT_CHANGE) ||\n                (_future_amplification_coefficient <\n                    _initial_amplification_coefficient &&\n                    _future_amplification_coefficient *\n                        MAX_AMPLIFICATION_COEFFICIENT_CHANGE >=\n                    _initial_amplification_coefficient),\n            \"Illegal parameter _future_amplification_coefficient\"\n        );\n        initial_amplification_coefficient = _initial_amplification_coefficient;\n        future_amplification_coefficient = _future_amplification_coefficient;\n        initial_amplification_coefficient_time = block.timestamp;\n        future_amplification_coefficient_time = _future_time;\n\n        emit RampA(\n            _initial_amplification_coefficient,\n            _future_amplification_coefficient,\n            block.timestamp,\n            _future_time\n        );\n    }\n\n    function stop_rampget_amplification_coefficient() external onlyOwner {\n        uint256 current_amplification_coefficient = get_amplification_coefficient();\n        initial_amplification_coefficient = current_amplification_coefficient;\n        future_amplification_coefficient = current_amplification_coefficient;\n        initial_amplification_coefficient_time = block.timestamp;\n        future_amplification_coefficient_time = block.timestamp;\n        // now (block.timestamp < t1) is always False, so we return saved A\n\n        emit StopRampA(current_amplification_coefficient, block.timestamp);\n    }\n\n    function commit_new_fee(\n        uint256 new_fee,\n        uint256 new_admin_fee\n    ) external onlyOwner {\n        require(\n            admin_actions_deadline == 0,\n            \"admin_actions_deadline must be 0\"\n        ); // dev: active action\n        require(new_fee <= MAX_FEE, \"dev: fee exceeds maximum\");\n        require(\n            new_admin_fee <= MAX_ADMIN_FEE,\n            \"dev: admin fee exceeds maximum\"\n        );\n\n        admin_actions_deadline = block.timestamp + ADMIN_ACTIONS_DELAY;\n        future_fee = new_fee;\n        future_admin_fee = new_admin_fee;\n\n        emit CommitNewFee(admin_actions_deadline, new_fee, new_admin_fee);\n    }\n\n    function apply_new_fee() external onlyOwner {\n        require(\n            block.timestamp >= admin_actions_deadline,\n            \"dev: insufficient time\"\n        );\n        require(\n            admin_actions_deadline != 0,\n            \"admin_actions_deadline should not be 0\"\n        );\n\n        admin_actions_deadline = 0;\n        fee = future_fee;\n        admin_fee = future_admin_fee;\n\n        emit NewFee(fee, admin_fee);\n    }\n\n    function revert_new_parameters() external onlyOwner {\n        admin_actions_deadline = 0;\n        emit RevertParameters();\n    }\n\n    function admin_balances(uint256 i) external view returns (uint256) {\n        if (coins[i] == NATIVE_ADDRESS) {\n            return address(this).balance - balances[i];\n        } else {\n            return IERC20(coins[i]).balanceOf(address(this)) - balances[i];\n        }\n    }\n\n    function withdraw_admin_fees() external onlyOwner {\n        for (uint256 i = 0; i < N_COINS; i++) {\n            uint256 value;\n            if (coins[i] == NATIVE_ADDRESS) {\n                value = address(this).balance - balances[i];\n            } else {\n                value = IERC20(coins[i]).balanceOf(address(this)) - balances[i];\n            }\n            if (value > 0) {\n                transfer_out(coins[i], value);\n            }\n        }\n    }\n\n    function donate_admin_fees() external onlyOwner {\n        for (uint256 i = 0; i < N_COINS; i++) {\n            if (coins[i] == NATIVE_ADDRESS) {\n                balances[i] = address(this).balance;\n            } else {\n                balances[i] = IERC20(coins[i]).balanceOf(address(this));\n            }\n        }\n        emit DonateAdminFees();\n    }\n\n    function kill_me() external onlyOwner {\n        require(kill_deadline > block.timestamp, \"Exceeded deadline\");\n        is_killed = true;\n        emit Kill();\n    }\n\n    function unkill_me() external onlyOwner {\n        is_killed = false;\n        emit Unkill();\n    }\n}\n"
    },
    "contracts/Token.sol": {
      "content": "// Basic ERC20 token\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract Token is ERC20 {\n    uint8 private _decimals;\n\n    constructor(\n        uint256 _totalSupply,\n        uint8 __decimals,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol) {\n        _decimals = __decimals;\n        _mint(msg.sender, _totalSupply);\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n}\n"
    },
    "contracts/TransferLimit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {Ownable2StepUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\nimport {AggregatorV3Interface} from \"@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {ITransferLimit} from \"./ITransferLimit.sol\";\n\n/// @title TransferLimit\n/// @author Cardinal Cryptography\n/// @notice Implements a transfer limit based on pricing data from Chainlink oracles\ncontract TransferLimit is\n    ITransferLimit,\n    UUPSUpgradeable,\n    Ownable2StepUpgradeable\n{\n    mapping(address => uint256) public defaultMinima;\n\n    struct USDMinimum {\n        AggregatorV3Interface oracle;\n        uint256 limit;\n    }\n\n    mapping(address => USDMinimum) public usdMinima;\n\n    function initialize(address owner) public initializer {\n        __Ownable_init(owner);\n    }\n\n    function _authorizeUpgrade(\n        address newImplementation\n    ) internal override onlyOwner {}\n\n    /// @notice Set the default minimum transfer amount for a token - this is used if no USD oracle is set\n    /// @param _token The token address\n    /// @param _limit The minimum transfer amount\n    function setDefaultLimit(address _token, uint256 _limit) public onlyOwner {\n        defaultMinima[_token] = _limit;\n    }\n\n    /// @notice Set the USD oracle params for a token\n    /// @param _token The token address\n    /// @param _tokenDecimals The number of decimals the token has\n    /// @param _oracle The Chainlink oracle address\n    /// @param _limit The minimum transfer amount in USD with no decimals\n    function setUSDOracle(\n        address _token,\n        uint256 _tokenDecimals,\n        AggregatorV3Interface _oracle,\n        uint256 _limit\n    ) public onlyOwner {\n        usdMinima[_token] = USDMinimum({\n            oracle: _oracle,\n            limit: _limit * 10 ** (_tokenDecimals + _oracle.decimals())\n        });\n    }\n\n    /// @notice Get the minimum transfer amount for a given token based on the current configuration\n    /// @param _token The token address\n    function minimumTransferAmount(\n        address _token\n    ) public view returns (uint256) {\n        uint256 minimum = defaultMinima[_token];\n\n        USDMinimum memory config = usdMinima[_token];\n        if (config.limit > 0) {\n            (, int usdPrice, , , ) = config.oracle.latestRoundData();\n            uint256 usdBasedMinimum = config.limit / uint256(usdPrice);\n\n            minimum = Math.min(minimum, usdBasedMinimum);\n        }\n\n        return minimum;\n    }\n\n    /// @notice Check if a transfer of a given amount of a token is allowed - currently only checks if the minimum is met\n    /// @param _token The token address\n    /// @param _amount The amount of the token\n    function isRequestAllowed(\n        address _token,\n        uint256 _amount\n    ) public view returns (bool) {\n        return _amount >= minimumTransferAmount(_token);\n    }\n}\n"
    },
    "contracts/WrappedToken.sol": {
      "content": "// Wrapped representation of a remote PSP22 token that can be minted and burned\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {Ownable2Step} from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract WrappedToken is ERC20, Ownable2Step {\n    uint8 private _decimals;\n    address public minterBurner;\n\n    error NotMinter();\n    error NotBurner();\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 __decimals,\n        address _minter_burner\n    ) ERC20(_name, _symbol) Ownable(msg.sender) {\n        minterBurner = _minter_burner;\n        _decimals = __decimals;\n    }\n\n    modifier onlyMinter() {\n        if (msg.sender != minterBurner) {\n            revert NotMinter();\n        }\n        _;\n    }\n\n    modifier onlyBurner() {\n        if (msg.sender != minterBurner) {\n            revert NotBurner();\n        }\n        _;\n    }\n\n    function mint(address _to, uint256 _amount) external onlyMinter {\n        _mint(_to, _amount);\n    }\n\n    function burn(uint256 _amount) external onlyBurner {\n        _burn(msg.sender, _amount);\n    }\n\n    function setMinterBurner(address _minter_burner) external onlyOwner {\n        minterBurner = _minter_burner;\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  }
}}