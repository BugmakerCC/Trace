{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "paris",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface that must be implemented by smart contracts in order to receive\n * ERC-1155 token transfers.\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/utils/ERC1155Holder.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165, ERC165} from \"../../../utils/introspection/ERC165.sol\";\nimport {IERC1155Receiver} from \"../IERC1155Receiver.sol\";\n\n/**\n * @dev Simple implementation of `IERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\n *\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\n * stuck.\n */\nabstract contract ERC1155Holder is ERC165, IERC1155Receiver {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "src/Interfaces.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\ninterface IERC20 {\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function balanceOf(address owner) external returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n}\n\n// https://github.com/RealityETH/reality-eth-monorepo/blob/main/packages/contracts/flat/RealityETH-3.0.sol\ninterface IRealityETH_v3_0 {\n    function askQuestionWithMinBond(\n        uint256 template_id,\n        string memory question,\n        address arbitrator,\n        uint32 timeout,\n        uint32 opening_ts,\n        uint256 nonce,\n        uint256 min_bond\n    ) external payable returns (bytes32);\n\n    function resultForOnceSettled(bytes32 question_id) external view returns (bytes32);\n\n    function getContentHash(bytes32 question_id) external view returns (bytes32);\n\n    function getTimeout(bytes32 question_id) external view returns (uint32);\n\n    function submitAnswer(bytes32 question_id, bytes32 answer, uint256 max_previous) external payable;\n}\n\ninterface IConditionalTokens {\n    function payoutNumerators(bytes32 conditionId, uint256 index) external view returns (uint256);\n\n    function payoutDenominator(bytes32 conditionId) external view returns (uint256);\n\n    function prepareCondition(address oracle, bytes32 questionId, uint256 outcomeSlotCount) external;\n\n    function reportPayouts(bytes32 questionId, uint256[] calldata payouts) external;\n\n    function splitPosition(\n        /*IERC20*/\n        address collateralToken,\n        bytes32 parentCollectionId,\n        bytes32 conditionId,\n        uint256[] calldata partition,\n        uint256 amount\n    ) external;\n\n    function mergePositions(\n        /*IERC20*/\n        address collateralToken,\n        bytes32 parentCollectionId,\n        bytes32 conditionId,\n        uint256[] calldata partition,\n        uint256 amount\n    ) external;\n\n    function redeemPositions(\n        /*IERC20*/\n        address collateralToken,\n        bytes32 parentCollectionId,\n        bytes32 conditionId,\n        uint256[] calldata indexSets\n    ) external;\n\n    function getConditionId(\n        address oracle,\n        bytes32 questionId,\n        uint256 outcomeSlotCount\n    ) external pure returns (bytes32);\n\n    function getCollectionId(\n        bytes32 parentCollectionId,\n        bytes32 conditionId,\n        uint256 indexSet\n    ) external view returns (bytes32);\n\n    function getPositionId(address collateralToken, bytes32 collectionId) external pure returns (uint256);\n\n    function getOutcomeSlotCount(bytes32 conditionId) external view returns (uint256);\n\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\n\n    function balanceOf(address owner, uint256 id) external view returns (uint256);\n}\n\ninterface IWrapped1155Factory {\n    function requireWrapped1155(\n        /*IERC1155*/\n        address multiToken,\n        uint256 tokenId,\n        bytes calldata data\n    ) external /*Wrapped1155*/ returns (IERC20);\n\n    function unwrap(\n        /*IERC1155*/\n        address multiToken,\n        uint256 tokenId,\n        uint256 amount,\n        address recipient,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "src/MainnetRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport \"./Router.sol\";\n\ninterface ISavingsDai is IERC20 {\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n\n/// @dev Router implementation with functions to interact with DAI on Ethereum Mainnet.\ncontract MainnetRouter is Router {\n    /// @dev DAI address.\n    IERC20 public constant DAI = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n    /// @dev SavingsDai address.\n    ISavingsDai public constant sDAI = ISavingsDai(0x83F20F44975D03b1b09e64809B757c47f942BEeA);\n\n    /// @dev Constructor.\n    /// @param _conditionalTokens Conditional Tokens contract.\n    /// @param _wrapped1155Factory Wrapped1155Factory contract.\n    constructor(\n        IConditionalTokens _conditionalTokens,\n        IWrapped1155Factory _wrapped1155Factory\n    ) Router(_conditionalTokens, _wrapped1155Factory) {}\n\n    /// @notice Splits a position using DAI and sends the ERC20 outcome tokens back to the user.\n    /// @dev The ERC20 associated to each outcome must be previously created on the wrapped1155Factory.\n    /// @param market The Market to split.\n    /// @param amount The amount of collateral to split.\n    function splitFromDai(Market market, uint256 amount) external {\n        DAI.transferFrom(msg.sender, address(this), amount);\n        DAI.approve(address(sDAI), amount);\n        uint256 shares = sDAI.deposit(amount, address(this));\n\n        _splitPosition(IERC20(address(sDAI)), market, shares);\n    }\n\n    /// @notice Merges positions and sends DAI to the user.\n    /// @dev The ERC20 associated to each outcome must be previously created on the wrapped1155Factory.\n    /// @param market The Market to merge.\n    /// @param amount The amount of outcome tokens to merge.\n    function mergeToDai(Market market, uint256 amount) external {\n        _mergePositions(IERC20(address(sDAI)), market, amount);\n        sDAI.redeem(amount, msg.sender, address(this));\n    }\n\n    /// @notice Redeems positions and sends DAI to the user.\n    /// @dev The ERC20 associated to each outcome must be previously created on the wrapped1155Factory.\n    /// @param market The Market to redeem.\n    /// @param outcomeIndexes The index of the outcomes to redeem.\n    /// @param amounts Amount to redeem of each outcome.\n    function redeemToDai(Market market, uint256[] calldata outcomeIndexes, uint256[] calldata amounts) external {\n        uint256 initialBalance = sDAI.balanceOf(address(this));\n\n        _redeemPositions(sDAI, market, outcomeIndexes, amounts);\n\n        uint256 finalBalance = sDAI.balanceOf(address(this));\n\n        if (finalBalance > initialBalance) {\n            sDAI.redeem(finalBalance - initialBalance, msg.sender, address(this));\n        }\n    }\n}\n"
    },
    "src/Market.sol": {
      "content": "/**\n *  @authors: [@xyzseer]\n *  @reviewers: [@nvm1410, @madhurMongia, @unknownunknown1, @mani99brar]\n *  @auditors: []\n *  @bounties: []\n *  @deployments: []\n */\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport {IERC20} from \"./Interfaces.sol\";\nimport \"./RealityProxy.sol\";\n\ncontract Market {\n    /// @dev Flag to initialize the market only once.\n    bool public initialized;\n\n    /// @dev Contains the information associated to Reality.\n    /// @param questionsIds Reality questions ids.\n    /// @param templateId Reality templateId.\n    /// @param encodedQuestions Encoded questions parameters, needed to create and reopen a question.\n    struct RealityParams {\n        bytes32[] questionsIds;\n        uint256 templateId;\n        string[] encodedQuestions;\n    }\n\n    /// @dev Contains the information associated to Conditional Tokens.\n    /// @param conditionId Conditional Tokens conditionId.\n    /// @param parentCollectionId Conditional Tokens parentCollectionId.\n    /// @param parentOutcome Conditional outcome to use (optional).\n    /// @param parentMarket Conditional market to use (optional).\n    /// @param questionId Conditional Tokens questionId.\n    /// @param wrapped1155 Outcome tokens Wrapped1155 address.\n    /// @param data Wrapped1155 token data.\n    struct ConditionalTokensParams {\n        bytes32 conditionId;\n        bytes32 parentCollectionId;\n        uint256 parentOutcome;\n        address parentMarket;\n        bytes32 questionId;\n        IERC20[] wrapped1155;\n        bytes[] data;\n    }\n\n    /// @dev The name of the market.\n    string public marketName;\n    /// @dev The market outcomes, doesn't include the INVALID_RESULT outcome.\n    string[] public outcomes;\n    /// @dev Lower bound, only used for scalar markets.\n    uint256 public lowerBound;\n    /// @dev Upper bound, only used for scalar markets.\n    uint256 public upperBound;\n    /// @dev Conditional Tokens parameters.\n    ConditionalTokensParams public conditionalTokensParams;\n    /// @dev Reality parameters.\n    RealityParams public realityParams;\n    /// @dev Oracle contract.\n    RealityProxy public realityProxy;\n\n    /// @dev Initializer.\n    /// @param _marketName The name of the market.\n    /// @param _outcomes The market outcomes, doesn't include the INVALID_RESULT outcome.\n    /// @param _lowerBound Lower bound, only used for scalar markets.\n    /// @param _upperBound Upper bound, only used for scalar markets.\n    /// @param _conditionalTokensParams Conditional Tokens params.\n    /// @param _realityParams Reality params.\n    /// @param _realityProxy Oracle contract.\n    function initialize(\n        string memory _marketName,\n        string[] memory _outcomes,\n        uint256 _lowerBound,\n        uint256 _upperBound,\n        ConditionalTokensParams memory _conditionalTokensParams,\n        RealityParams memory _realityParams,\n        RealityProxy _realityProxy\n    ) external {\n        require(!initialized, \"Already initialized.\");\n\n        marketName = _marketName;\n        outcomes = _outcomes;\n        lowerBound = _lowerBound;\n        upperBound = _upperBound;\n        conditionalTokensParams = _conditionalTokensParams;\n        realityParams = _realityParams;\n        realityProxy = _realityProxy;\n\n        initialized = true;\n    }\n\n    /// @dev The templateId associated to the Reality question.\n    /// @return The template id.\n    function templateId() external view returns (uint256) {\n        return realityParams.templateId;\n    }\n\n    /// @dev Returns the Reality questions ids. Multi Scalar markets have one question for each outcome, while any other market has only one question.\n    /// @return The Reality questions ids.\n    function questionsIds() external view returns (bytes32[] memory) {\n        return realityParams.questionsIds;\n    }\n\n    /// @dev Encoded questions parameters, needed to create and reopen a question.\n    /// @param index The question index.\n    /// @return The encoded question.\n    function encodedQuestions(uint256 index) external view returns (string memory) {\n        return realityParams.encodedQuestions[index];\n    }\n\n    /// @dev Conditional Tokens questionId.\n    /// @return the question ID.\n    function questionId() external view returns (bytes32) {\n        return conditionalTokensParams.questionId;\n    }\n\n    /// @dev Conditional Tokens conditionId.\n    /// @return The condition ID.\n    function conditionId() external view returns (bytes32) {\n        return conditionalTokensParams.conditionId;\n    }\n\n    /// @dev Conditional Tokens parentCollectionId.\n    /// @return The parent collection ID.\n    function parentCollectionId() external view returns (bytes32) {\n        return conditionalTokensParams.parentCollectionId;\n    }\n\n    /// @dev The parent market (optional). This market redeems to an outcome token of the parent market.\n    /// @return The parent market address.\n    function parentMarket() external view returns (address) {\n        return conditionalTokensParams.parentMarket;\n    }\n\n    /// @dev The parent outcome (optional). The parent market's outcome token this market redeems for.\n    /// @return The parent outcome index.\n    function parentOutcome() external view returns (uint256) {\n        return conditionalTokensParams.parentOutcome;\n    }\n\n    /// @dev Returns the wrapped1155 and the data corresponding to an outcome token.\n    /// @param index The outcome index.\n    /// @return wrapped1155 The wrapped token.\n    /// @return data The token data.\n    function wrappedOutcome(uint256 index) external view returns (IERC20 wrapped1155, bytes memory data) {\n        return (conditionalTokensParams.wrapped1155[index], conditionalTokensParams.data[index]);\n    }\n\n    /// @dev Returns the wrapped1155 and the data corresponding to the parent market.\n    /// @return wrapped1155 The wrapped token.\n    /// @return data The token data.\n    function parentWrappedOutcome() external view returns (IERC20 wrapped1155, bytes memory data) {\n        if (conditionalTokensParams.parentMarket != address(0)) {\n            (wrapped1155, data) =\n                Market(conditionalTokensParams.parentMarket).wrappedOutcome(conditionalTokensParams.parentOutcome);\n        }\n    }\n\n    /// @dev Returns the number of outcomes.\n    /// Doesn't include the INVALID_RESULT outcome.\n    /// @return numOutcomes The number of outcomes.\n    function numOutcomes() external view returns (uint256) {\n        return outcomes.length;\n    }\n\n    /// @dev Helper function to resolve the market.\n    function resolve() external {\n        realityProxy.resolve(this);\n    }\n}\n"
    },
    "src/RealityProxy.sol": {
      "content": "/**\n *  @authors: [@xyzseer]\n *  @reviewers: [@nvm1410, @madhurMongia, @unknownunknown1, @mani99brar]\n *  @auditors: []\n *  @bounties: []\n *  @deployments: []\n */\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport {IConditionalTokens, IRealityETH_v3_0} from \"./Interfaces.sol\";\nimport \"./Market.sol\";\n\ncontract RealityProxy {\n    /// @dev Conditional Tokens contract.\n    IConditionalTokens public immutable conditionalTokens;\n    /// @dev Reality.eth contract.\n    IRealityETH_v3_0 public immutable realitio;\n\n    /// @dev INVALID_RESULT reserved value.\n    bytes32 internal constant INVALID_RESULT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @dev Template for scalar and multi scalar markets.\n    uint256 internal constant REALITY_UINT_TEMPLATE = 1;\n    /// @dev Template for categorical markets.\n    uint256 internal constant REALITY_SINGLE_SELECT_TEMPLATE = 2;\n    /// @dev Template for multi categorical markets.\n    uint256 internal constant REALITY_MULTI_SELECT_TEMPLATE = 3;\n\n    /// @dev Constructor.\n    /// @param _conditionalTokens Conditional Tokens contract address.\n    /// @param _realitio Reality.eth contract address.\n    constructor(IConditionalTokens _conditionalTokens, IRealityETH_v3_0 _realitio) {\n        conditionalTokens = _conditionalTokens;\n        realitio = _realitio;\n    }\n\n    /// @dev Resolves the specified market.\n    /// @param market Market to resolve. UNTRUSTED.\n    function resolve(Market market) external {\n        bytes32[] memory questionsIds = market.questionsIds();\n        uint256 numOutcomes = market.numOutcomes();\n        uint256 templateId = market.templateId();\n        uint256 low = market.lowerBound();\n        uint256 high = market.upperBound();\n\n        // questionId must be a hash of all the values used to resolve a market, this way if an attacker tries to resolve a fake market by changing some value its questionId will not match the id of a valid market.\n        bytes32 questionId = keccak256(abi.encode(questionsIds, numOutcomes, templateId, low, high));\n\n        if (templateId == REALITY_SINGLE_SELECT_TEMPLATE) {\n            resolveCategoricalMarket(questionId, questionsIds, numOutcomes);\n            return;\n        }\n\n        if (templateId == REALITY_MULTI_SELECT_TEMPLATE) {\n            resolveMultiCategoricalMarket(questionId, questionsIds, numOutcomes);\n            return;\n        }\n\n        if (questionsIds.length > 1) {\n            resolveMultiScalarMarket(questionId, questionsIds, numOutcomes);\n            return;\n        }\n\n        resolveScalarMarket(questionId, questionsIds, low, high);\n    }\n\n    /// @dev Resolves to invalid if the answer is invalid or the result is greater than the amount of outcomes.\n    /// @param questionId Conditional Tokens questionId.\n    /// @param questionsIds Reality questions ids.\n    /// @param numOutcomes The number of outcomes, excluding the INVALID_RESULT outcome.\n    function resolveCategoricalMarket(\n        bytes32 questionId,\n        bytes32[] memory questionsIds,\n        uint256 numOutcomes\n    ) internal {\n        uint256 answer = uint256(realitio.resultForOnceSettled(questionsIds[0]));\n        uint256[] memory payouts = new uint256[](numOutcomes + 1);\n\n        if (answer == uint256(INVALID_RESULT) || answer >= numOutcomes) {\n            // the last outcome is INVALID_RESULT.\n            payouts[numOutcomes] = 1;\n        } else {\n            payouts[answer] = 1;\n        }\n\n        conditionalTokens.reportPayouts(questionId, payouts);\n    }\n\n    /// @dev Resolves to invalid if the answer is invalid or all the results are zero.\n    /// @param questionId Conditional Tokens questionId.\n    /// @param questionsIds Reality questions ids.\n    /// @param numOutcomes The number of outcomes, excluding the INVALID_RESULT outcome.\n    function resolveMultiCategoricalMarket(\n        bytes32 questionId,\n        bytes32[] memory questionsIds,\n        uint256 numOutcomes\n    ) internal {\n        uint256 answer = uint256(realitio.resultForOnceSettled(questionsIds[0]));\n        uint256[] memory payouts = new uint256[](numOutcomes + 1);\n\n        if (answer == uint256(INVALID_RESULT)) {\n            // the last outcome is INVALID_RESULT.\n            payouts[numOutcomes] = 1;\n        } else {\n            bool allZeroes = true;\n\n            for (uint256 i = 0; i < numOutcomes; i++) {\n                payouts[i] = (answer >> i) & 1;\n                allZeroes = allZeroes && payouts[i] == 0;\n            }\n\n            if (allZeroes) {\n                // invalid result.\n                payouts[numOutcomes] = 1;\n            }\n        }\n\n        conditionalTokens.reportPayouts(questionId, payouts);\n    }\n\n    /// @dev Resolves to invalid if the answer is invalid.\n    /// @param questionId Conditional Tokens questionId.\n    /// @param questionsIds Reality questions ids.\n    /// @param low Lower bound.\n    /// @param high Upper bound.\n    function resolveScalarMarket(\n        bytes32 questionId,\n        bytes32[] memory questionsIds,\n        uint256 low,\n        uint256 high\n    ) internal {\n        uint256 answer = uint256(realitio.resultForOnceSettled(questionsIds[0]));\n        uint256[] memory payouts = new uint256[](3);\n\n        if (answer == uint256(INVALID_RESULT)) {\n            // the last outcome is INVALID_RESULT.\n            payouts[2] = 1;\n        } else if (answer <= low) {\n            payouts[0] = 1;\n        } else if (answer >= high) {\n            payouts[1] = 1;\n        } else {\n            payouts[0] = high - answer;\n            payouts[1] = answer - low;\n        }\n\n        conditionalTokens.reportPayouts(questionId, payouts);\n    }\n\n    /// @dev If any individual result is invalid then the corresponding payout element is set to 0.\n    /// @dev If all the elements of the payout vector are 0 or all are invalid, the market resolves to invalid.\n    /// @param questionId Conditional Tokens questionId.\n    /// @param questionsIds Reality questions ids.\n    /// @param numOutcomes The number of outcomes, excluding the INVALID_RESULT outcome.\n    function resolveMultiScalarMarket(\n        bytes32 questionId,\n        bytes32[] memory questionsIds,\n        uint256 numOutcomes\n    ) internal {\n        uint256[] memory payouts = new uint256[](numOutcomes + 1);\n        bool allZeroesOrInvalid = true;\n\n        /*\n         * We set maxPayout to a sufficiently large number for most possible outcomes that also avoids overflows in the following places:\n         * https://github.com/gnosis/conditional-tokens-contracts/blob/master/contracts/ConditionalTokens.sol#L89\n         * https://github.com/gnosis/conditional-tokens-contracts/blob/master/contracts/ConditionalTokens.sol#L242\n         */\n        uint256 maxPayout = 2 ** (256 / 2) - 1;\n\n        for (uint256 i = 0; i < numOutcomes; i++) {\n            payouts[i] = uint256(realitio.resultForOnceSettled(questionsIds[i]));\n\n            if (payouts[i] == uint256(INVALID_RESULT)) {\n                payouts[i] = 0;\n            } else if (payouts[i] > maxPayout) {\n                payouts[i] = maxPayout;\n            }\n\n            allZeroesOrInvalid = allZeroesOrInvalid && payouts[i] == 0;\n        }\n\n        if (allZeroesOrInvalid) {\n            // invalid result.\n            payouts[numOutcomes] = 1;\n        }\n\n        conditionalTokens.reportPayouts(questionId, payouts);\n    }\n}\n"
    },
    "src/Router.sol": {
      "content": "/**\n *  @authors: [@xyzseer]\n *  @reviewers: [@nvm1410, @madhurMongia, @unknownunknown1, @mani99brar]\n *  @auditors: []\n *  @bounties: []\n *  @deployments: []\n */\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport {IConditionalTokens, IERC20, IWrapped1155Factory} from \"./Interfaces.sol\";\nimport \"./Market.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\n\n/// @dev The Router contract replicates the main Conditional Tokens functions, but allowing to work with ERC20 outcomes instead of the ERC1155.\ncontract Router is ERC1155Holder {\n    /// @dev Conditional Tokens contract.\n    IConditionalTokens public immutable conditionalTokens;\n    /// @dev Wrapped1155Factory contract.\n    IWrapped1155Factory public immutable wrapped1155Factory;\n\n    /// @dev Constructor.\n    /// @param _conditionalTokens Conditional Tokens contract.\n    /// @param _wrapped1155Factory Wrapped1155Factory contract.\n    constructor(IConditionalTokens _conditionalTokens, IWrapped1155Factory _wrapped1155Factory) {\n        conditionalTokens = _conditionalTokens;\n        wrapped1155Factory = _wrapped1155Factory;\n    }\n\n    /// @notice Transfers the collateral to the Router, splits the position and sends the ERC20 outcome tokens back to the user.\n    /// @dev The ERC20 associated to each outcome must be previously created on the wrapped1155Factory.\n    /// @dev Collateral tokens are deposited only if we are not splitting a deep position (parentCollectionId is bytes32(0)).\n    /// @param collateralToken The address of the ERC20 used as collateral.\n    /// @param market The Market to split.\n    /// @param amount The amount of collateral to split.\n    function splitPosition(IERC20 collateralToken, Market market, uint256 amount) public {\n        if (market.parentCollectionId() == bytes32(0)) {\n            // transfer the collateral tokens to the Router.\n            collateralToken.transferFrom(msg.sender, address(this), amount);\n        }\n        _splitPosition(collateralToken, market, amount);\n    }\n\n    /// @notice Splits a position and sends the ERC20 outcome tokens to the user.\n    /// @dev The ERC20 associated to each outcome must be previously created on the wrapped1155Factory.\n    /// @param collateralToken The address of the ERC20 used as collateral.\n    /// @param market The Market to split.\n    /// @param amount The amount of collateral to split.\n    function _splitPosition(IERC20 collateralToken, Market market, uint256 amount) internal {\n        bytes32 parentCollectionId = market.parentCollectionId();\n        bytes32 conditionId = market.conditionId();\n\n        uint256[] memory partition = getPartition(conditionalTokens.getOutcomeSlotCount(conditionId));\n\n        if (parentCollectionId != bytes32(0)) {\n            // it's splitting from a parent position, so we need to unwrap these tokens first because they will be burnt to mint the child outcome tokens.\n            (IERC20 wrapped1155, bytes memory data) = market.parentWrappedOutcome();\n\n            uint256 tokenId = conditionalTokens.getPositionId(address(collateralToken), parentCollectionId);\n\n            wrapped1155.transferFrom(msg.sender, address(this), amount);\n            wrapped1155Factory.unwrap(address(conditionalTokens), tokenId, amount, address(this), data);\n        } else {\n            collateralToken.approve(address(conditionalTokens), amount);\n        }\n\n        conditionalTokens.splitPosition(address(collateralToken), parentCollectionId, conditionId, partition, amount);\n\n        // wrap & transfer the minted outcome tokens.\n        for (uint256 j = 0; j < partition.length; j++) {\n            uint256 tokenId = getTokenId(collateralToken, parentCollectionId, conditionId, partition[j]);\n\n            (IERC20 wrapped1155, bytes memory data) = market.wrappedOutcome(j);\n\n            // wrap to erc20.\n            conditionalTokens.safeTransferFrom(address(this), address(wrapped1155Factory), tokenId, amount, data);\n\n            // transfer the ERC20 back to the user.\n            require(wrapped1155.transfer(msg.sender, amount), \"Wrapped token transfer failed\");\n        }\n    }\n\n    /// @notice Merges positions and sends the collateral tokens to the user.\n    /// @dev The ERC20 associated to each outcome must be previously created on the wrapped1155Factory.\n    /// @dev Collateral tokens are withdrawn only if we are not merging a deep position (parentCollectionId is bytes32(0)).\n    /// @param collateralToken The address of the ERC20 used as collateral.\n    /// @param market The Market to merge.\n    /// @param amount The amount of outcome tokens to merge.\n    function mergePositions(IERC20 collateralToken, Market market, uint256 amount) public {\n        _mergePositions(collateralToken, market, amount);\n\n        if (market.parentCollectionId() == bytes32(0)) {\n            // send collateral tokens back to the user.\n            require(collateralToken.transfer(msg.sender, amount), \"Collateral transfer failed\");\n        }\n    }\n\n    /// @notice Merges positions and receives the collateral tokens.\n    /// @dev Callers to this function must send the collateral to the user.\n    /// @param collateralToken The address of the ERC20 used as collateral.\n    /// @param market The Market to merge.\n    /// @param amount The amount of outcome tokens to merge.\n    function _mergePositions(IERC20 collateralToken, Market market, uint256 amount) internal {\n        bytes32 parentCollectionId = market.parentCollectionId();\n        bytes32 conditionId = market.conditionId();\n\n        uint256[] memory partition = getPartition(conditionalTokens.getOutcomeSlotCount(conditionId));\n\n        // we need to unwrap the outcome tokens because they will be burnt during the merge.\n\n        for (uint256 j = 0; j < partition.length; j++) {\n            uint256 tokenId = getTokenId(collateralToken, parentCollectionId, conditionId, partition[j]);\n\n            (IERC20 wrapped1155, bytes memory data) = market.wrappedOutcome(j);\n\n            wrapped1155.transferFrom(msg.sender, address(this), amount);\n            wrapped1155Factory.unwrap(address(conditionalTokens), tokenId, amount, address(this), data);\n        }\n\n        conditionalTokens.mergePositions(address(collateralToken), parentCollectionId, conditionId, partition, amount);\n\n        if (parentCollectionId != bytes32(0)) {\n            // it's merging from a parent position, so we need to wrap these tokens and send them back to the user.\n            uint256 tokenId = conditionalTokens.getPositionId(address(collateralToken), parentCollectionId);\n\n            (IERC20 wrapped1155, bytes memory data) = market.parentWrappedOutcome();\n\n            // wrap to erc20.\n            conditionalTokens.safeTransferFrom(address(this), address(wrapped1155Factory), tokenId, amount, data);\n\n            // transfer the ERC20 back to the user.\n            require(wrapped1155.transfer(msg.sender, amount), \"Wrapped token transfer failed\");\n        }\n    }\n\n    /// @notice Redeems positions and sends the collateral tokens to the user.\n    /// @dev The ERC20 associated to each outcome must be previously created on the wrapped1155Factory.\n    /// @dev Collateral tokens are withdrawn only if we are not redeeming a deep position (parentCollectionId is bytes32(0)).\n    /// @param collateralToken The address of the ERC20 used as collateral.\n    /// @param market The Market to redeem.\n    /// @param outcomeIndexes The index of the outcomes to redeem.\n    /// @param amounts Amount to redeem of each outcome.\n    function redeemPositions(\n        IERC20 collateralToken,\n        Market market,\n        uint256[] calldata outcomeIndexes,\n        uint256[] calldata amounts\n    ) public {\n        bytes32 parentCollectionId = market.parentCollectionId();\n        uint256 initialBalance;\n\n        if (parentCollectionId == bytes32(0)) {\n            initialBalance = collateralToken.balanceOf(address(this));\n        }\n\n        _redeemPositions(collateralToken, market, outcomeIndexes, amounts);\n\n        if (parentCollectionId == bytes32(0)) {\n            uint256 finalBalance = collateralToken.balanceOf(address(this));\n\n            if (finalBalance > initialBalance) {\n                // send collateral tokens back to the user.\n                require(collateralToken.transfer(msg.sender, finalBalance - initialBalance), \"Collateral transfer failed\");\n            }\n        }\n    }\n\n    /// @notice Redeems positions and receives the collateral tokens.\n    /// @dev Callers to this function must send the collateral to the user.\n    /// @param collateralToken The address of the ERC20 used as collateral.\n    /// @param market The Market to redeem.\n    /// @param outcomeIndexes The index of the outcomes to redeem.\n    /// @param amounts Amount to redeem of each outcome.\n    function _redeemPositions(\n        IERC20 collateralToken,\n        Market market,\n        uint256[] calldata outcomeIndexes,\n        uint256[] calldata amounts\n    ) internal {\n        bytes32 parentCollectionId = market.parentCollectionId();\n        bytes32 conditionId = market.conditionId();\n        uint256 tokenId = 0;\n\n        uint256[] memory indexSets = new uint256[](outcomeIndexes.length);\n\n        for (uint256 j = 0; j < outcomeIndexes.length; j++) {\n            indexSets[j] = 1 << outcomeIndexes[j];\n            tokenId = getTokenId(collateralToken, parentCollectionId, conditionId, indexSets[j]);\n\n            // first we need to unwrap the outcome tokens that will be redeemed.\n            (IERC20 wrapped1155, bytes memory data) = market.wrappedOutcome(outcomeIndexes[j]);\n\n            wrapped1155.transferFrom(msg.sender, address(this), amounts[j]);\n\n            wrapped1155Factory.unwrap(address(conditionalTokens), tokenId, amounts[j], address(this), data);\n        }\n\n        uint256 initialBalance = 0;\n\n        if (parentCollectionId != bytes32(0)) {\n            // if we are redeeming from a child market, the user may already have parent tokens so we need to track the balance change.\n            tokenId = conditionalTokens.getPositionId(address(collateralToken), parentCollectionId);\n            initialBalance = conditionalTokens.balanceOf(address(this), tokenId);\n        }\n\n        conditionalTokens.redeemPositions(address(collateralToken), parentCollectionId, conditionId, indexSets);\n\n        if (parentCollectionId != bytes32(0)) {\n            // if we are redeeming from a child market, redeemPositions() returned outcome tokens of the parent market. We need to wrap and send them to the user.\n            uint256 finalBalance = conditionalTokens.balanceOf(address(this), tokenId);\n\n            if (finalBalance > initialBalance) {\n                // wrap to erc20.\n                (IERC20 parentWrapped1155, bytes memory parentData) = market.parentWrappedOutcome();\n\n                conditionalTokens.safeTransferFrom(\n                    address(this), address(wrapped1155Factory), tokenId, finalBalance - initialBalance, parentData\n                );\n\n                // transfer the ERC20 back to the user.\n                require(parentWrapped1155.transfer(msg.sender, finalBalance - initialBalance), \"Parent wrapped token transfer failed\");\n            }\n        }\n    }\n\n    /// @dev Returns a partition containing the full set of outcomes.\n    /// @param size Number of outcome slots.\n    /// @return The partition containing the full set of outcomes.\n    function getPartition(uint256 size) internal pure returns (uint256[] memory) {\n        uint256[] memory partition = new uint256[](size);\n\n        for (uint256 i = 0; i < size; i++) {\n            partition[i] = 1 << i;\n        }\n\n        return partition;\n    }\n\n    /// @notice Constructs a tokenId from a collateral token and an outcome collection.\n    /// @param collateralToken The address of the ERC20 used as collateral.\n    /// @param parentCollectionId The Conditional Tokens parent collection id.\n    /// @param conditionId The id of the condition used to redeem.\n    /// @param indexSet Index set of the outcome collection to combine with the parent outcome collection.\n    /// @return The token id.\n    function getTokenId(\n        IERC20 collateralToken,\n        bytes32 parentCollectionId,\n        bytes32 conditionId,\n        uint256 indexSet\n    ) public view returns (uint256) {\n        bytes32 collectionId = conditionalTokens.getCollectionId(parentCollectionId, conditionId, indexSet);\n        return conditionalTokens.getPositionId(address(collateralToken), collectionId);\n    }\n\n    /// @notice Helper function used to know the redeemable outcomes associated to a conditionId.\n    /// @param conditionId The id of the condition.\n    /// @return An array of outcomes where a true value indicates that the outcome is redeemable.\n    function getWinningOutcomes(bytes32 conditionId) external view returns (bool[] memory) {\n        bool[] memory result = new bool[](conditionalTokens.getOutcomeSlotCount(conditionId));\n\n        for (uint256 i = 0; i < result.length; i++) {\n            result[i] = conditionalTokens.payoutNumerators(conditionId, i) == 0 ? false : true;\n        }\n\n        return result;\n    }\n}\n"
    }
  }
}}