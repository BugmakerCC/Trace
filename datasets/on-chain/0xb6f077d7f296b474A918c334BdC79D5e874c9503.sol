{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "london",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 10
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/access/access_control/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IAccessControl } from './IAccessControl.sol';\nimport { AccessControlInternal } from './AccessControlInternal.sol';\n\n/**\n * @title Role-based access control system\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nabstract contract AccessControl is IAccessControl, AccessControlInternal {\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function grantRole(\n        bytes32 role,\n        address account\n    ) external onlyRole(_getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function hasRole(\n        bytes32 role,\n        address account\n    ) external view returns (bool) {\n        return _hasRole(role, account);\n    }\n\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32) {\n        return _getRoleAdmin(role);\n    }\n\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function revokeRole(\n        bytes32 role,\n        address account\n    ) external onlyRole(_getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function renounceRole(bytes32 role) external {\n        _renounceRole(role);\n    }\n\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function getRoleMember(\n        bytes32 role,\n        uint256 index\n    ) external view returns (address) {\n        return _getRoleMember(role, index);\n    }\n\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256) {\n        return _getRoleMemberCount(role);\n    }\n}\n"
    },
    "@solidstate/contracts/access/access_control/AccessControlInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { EnumerableSet } from '../../data/EnumerableSet.sol';\nimport { AddressUtils } from '../../utils/AddressUtils.sol';\nimport { UintUtils } from '../../utils/UintUtils.sol';\nimport { IAccessControlInternal } from './IAccessControlInternal.sol';\nimport { AccessControlStorage } from './AccessControlStorage.sol';\n\n/**\n * @title Role-based access control system\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nabstract contract AccessControlInternal is IAccessControlInternal {\n    using AddressUtils for address;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using UintUtils for uint256;\n\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /*\n     * @notice query whether role is assigned to account\n     * @param role role to query\n     * @param account account to query\n     * @return whether role is assigned to account\n     */\n    function _hasRole(\n        bytes32 role,\n        address account\n    ) internal view virtual returns (bool) {\n        return\n            AccessControlStorage.layout().roles[role].members.contains(account);\n    }\n\n    /**\n     * @notice revert if sender does not have given role\n     * @param role role to query\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, msg.sender);\n    }\n\n    /**\n     * @notice revert if given account does not have given role\n     * @param role role to query\n     * @param account to query\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!_hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        'AccessControl: account ',\n                        account.toString(),\n                        ' is missing role ',\n                        uint256(role).toHexString(32)\n                    )\n                )\n            );\n        }\n    }\n\n    /*\n     * @notice query admin role for given role\n     * @param role role to query\n     * @return admin role\n     */\n    function _getRoleAdmin(\n        bytes32 role\n    ) internal view virtual returns (bytes32) {\n        return AccessControlStorage.layout().roles[role].adminRole;\n    }\n\n    /**\n     * @notice set role as admin role\n     * @param role role to set\n     * @param adminRole admin role to set\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = _getRoleAdmin(role);\n        AccessControlStorage.layout().roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /*\n     * @notice assign role to given account\n     * @param role role to assign\n     * @param account recipient of role assignment\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        AccessControlStorage.layout().roles[role].members.add(account);\n        emit RoleGranted(role, account, msg.sender);\n    }\n\n    /*\n     * @notice unassign role from given account\n     * @param role role to unassign\n     * @parm account\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        AccessControlStorage.layout().roles[role].members.remove(account);\n        emit RoleRevoked(role, account, msg.sender);\n    }\n\n    /**\n     * @notice relinquish role\n     * @param role role to relinquish\n     */\n    function _renounceRole(bytes32 role) internal virtual {\n        _revokeRole(role, msg.sender);\n    }\n\n    /**\n     * @notice query role for member at given index\n     * @param role role to query\n     * @param index index to query\n     */\n    function _getRoleMember(\n        bytes32 role,\n        uint256 index\n    ) internal view virtual returns (address) {\n        return AccessControlStorage.layout().roles[role].members.at(index);\n    }\n\n    /**\n     * @notice query role for member count\n     * @param role role to query\n     */\n    function _getRoleMemberCount(\n        bytes32 role\n    ) internal view virtual returns (uint256) {\n        return AccessControlStorage.layout().roles[role].members.length();\n    }\n}\n"
    },
    "@solidstate/contracts/access/access_control/AccessControlStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { EnumerableSet } from '../../data/EnumerableSet.sol';\n\nlibrary AccessControlStorage {\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    struct Layout {\n        mapping(bytes32 => RoleData) roles;\n    }\n\n    bytes32 internal constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.AccessControl');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/access/access_control/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IAccessControlInternal } from './IAccessControlInternal.sol';\n\n/**\n * @title AccessControl interface\n */\ninterface IAccessControl is IAccessControlInternal {\n    /*\n     * @notice query whether role is assigned to account\n     * @param role role to query\n     * @param account account to query\n     * @return whether role is assigned to account\n     */\n    function hasRole(\n        bytes32 role,\n        address account\n    ) external view returns (bool);\n\n    /*\n     * @notice query admin role for given role\n     * @param role role to query\n     * @return admin role\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /*\n     * @notice assign role to given account\n     * @param role role to assign\n     * @param account recipient of role assignment\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /*\n     * @notice unassign role from given account\n     * @param role role to unassign\n     * @parm account\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @notice relinquish role\n     * @param role role to relinquish\n     */\n    function renounceRole(bytes32 role) external;\n\n    /**\n     * @notice Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(\n        bytes32 role,\n        uint256 index\n    ) external view returns (address);\n\n    /**\n     * @notice Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@solidstate/contracts/access/access_control/IAccessControlInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Partial AccessControl interface needed by internal functions\n */\ninterface IAccessControlInternal {\n    event RoleAdminChanged(\n        bytes32 indexed role,\n        bytes32 indexed previousAdminRole,\n        bytes32 indexed newAdminRole\n    );\n\n    event RoleGranted(\n        bytes32 indexed role,\n        address indexed account,\n        address indexed sender\n    );\n\n    event RoleRevoked(\n        bytes32 indexed role,\n        address indexed account,\n        address indexed sender\n    );\n}\n"
    },
    "@solidstate/contracts/data/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Set implementation with enumeration functions\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nlibrary EnumerableSet {\n    error EnumerableSet__IndexOutOfBounds();\n\n    struct Set {\n        bytes32[] _values;\n        // 1-indexed to allow 0 to signify nonexistence\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    function at(\n        Bytes32Set storage set,\n        uint256 index\n    ) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    function at(\n        AddressSet storage set,\n        uint256 index\n    ) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    function at(\n        UintSet storage set,\n        uint256 index\n    ) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    function contains(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    function contains(\n        AddressSet storage set,\n        address value\n    ) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function contains(\n        UintSet storage set,\n        uint256 value\n    ) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    function indexOf(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, value);\n    }\n\n    function indexOf(\n        AddressSet storage set,\n        address value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function indexOf(\n        UintSet storage set,\n        uint256 value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, bytes32(value));\n    }\n\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function add(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    function add(\n        AddressSet storage set,\n        address value\n    ) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    function remove(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    function remove(\n        AddressSet storage set,\n        address value\n    ) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function remove(\n        UintSet storage set,\n        uint256 value\n    ) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    function toArray(\n        Bytes32Set storage set\n    ) internal view returns (bytes32[] memory) {\n        return set._inner._values;\n    }\n\n    function toArray(\n        AddressSet storage set\n    ) internal view returns (address[] memory) {\n        bytes32[] storage values = set._inner._values;\n        address[] storage array;\n\n        assembly {\n            array.slot := values.slot\n        }\n\n        return array;\n    }\n\n    function toArray(\n        UintSet storage set\n    ) internal view returns (uint256[] memory) {\n        bytes32[] storage values = set._inner._values;\n        uint256[] storage array;\n\n        assembly {\n            array.slot := values.slot\n        }\n\n        return array;\n    }\n\n    function _at(\n        Set storage set,\n        uint256 index\n    ) private view returns (bytes32) {\n        if (index >= set._values.length)\n            revert EnumerableSet__IndexOutOfBounds();\n        return set._values[index];\n    }\n\n    function _contains(\n        Set storage set,\n        bytes32 value\n    ) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    function _indexOf(\n        Set storage set,\n        bytes32 value\n    ) private view returns (uint256) {\n        unchecked {\n            return set._indexes[value] - 1;\n        }\n    }\n\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    function _add(\n        Set storage set,\n        bytes32 value\n    ) private returns (bool status) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            set._indexes[value] = set._values.length;\n            status = true;\n        }\n    }\n\n    function _remove(\n        Set storage set,\n        bytes32 value\n    ) private returns (bool status) {\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            unchecked {\n                bytes32 last = set._values[set._values.length - 1];\n\n                // move last value to now-vacant index\n\n                set._values[valueIndex - 1] = last;\n                set._indexes[last] = valueIndex;\n            }\n            // clear last index\n\n            set._values.pop();\n            delete set._indexes[value];\n\n            status = true;\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/security/pausable/IPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IPausableInternal } from './IPausableInternal.sol';\n\ninterface IPausable is IPausableInternal {\n    /**\n     * @notice query whether contract is paused\n     * @return status whether contract is paused\n     */\n    function paused() external view returns (bool status);\n}\n"
    },
    "@solidstate/contracts/security/pausable/IPausableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\ninterface IPausableInternal {\n    error Pausable__Paused();\n    error Pausable__NotPaused();\n\n    event Paused(address account);\n    event Unpaused(address account);\n}\n"
    },
    "@solidstate/contracts/security/pausable/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IPausable } from './IPausable.sol';\nimport { PausableInternal } from './PausableInternal.sol';\n\n/**\n * @title Pausable security control module.\n */\nabstract contract Pausable is IPausable, PausableInternal {\n    /**\n     * @inheritdoc IPausable\n     */\n    function paused() external view virtual returns (bool status) {\n        status = _paused();\n    }\n}\n"
    },
    "@solidstate/contracts/security/pausable/PausableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IPausableInternal } from './IPausableInternal.sol';\nimport { PausableStorage } from './PausableStorage.sol';\n\n/**\n * @title Internal functions for Pausable security control module.\n */\nabstract contract PausableInternal is IPausableInternal {\n    modifier whenNotPaused() {\n        if (_paused()) revert Pausable__Paused();\n        _;\n    }\n\n    modifier whenPaused() {\n        if (!_paused()) revert Pausable__NotPaused();\n        _;\n    }\n\n    /**\n     * @notice query whether contract is paused\n     * @return status whether contract is paused\n     */\n    function _paused() internal view virtual returns (bool status) {\n        status = PausableStorage.layout().paused;\n    }\n\n    /**\n     * @notice Triggers paused state, when contract is unpaused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage.layout().paused = true;\n        emit Paused(msg.sender);\n    }\n\n    /**\n     * @notice Triggers unpaused state, when contract is paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        delete PausableStorage.layout().paused;\n        emit Unpaused(msg.sender);\n    }\n}\n"
    },
    "@solidstate/contracts/security/pausable/PausableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary PausableStorage {\n    struct Layout {\n        bool paused;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.Pausable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/utils/AddressUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { UintUtils } from './UintUtils.sol';\n\nlibrary AddressUtils {\n    using UintUtils for uint256;\n\n    error AddressUtils__InsufficientBalance();\n    error AddressUtils__NotContract();\n    error AddressUtils__SendValueFailed();\n\n    function toString(address account) internal pure returns (string memory) {\n        return uint256(uint160(account)).toHexString(20);\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function sendValue(address payable account, uint256 amount) internal {\n        (bool success, ) = account.call{ value: amount }('');\n        if (!success) revert AddressUtils__SendValueFailed();\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data\n    ) internal returns (bytes memory) {\n        return\n            functionCall(target, data, 'AddressUtils: failed low-level call');\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory error\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, error);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                'AddressUtils: failed low-level call with value'\n            );\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) internal returns (bytes memory) {\n        if (value > address(this).balance)\n            revert AddressUtils__InsufficientBalance();\n        return _functionCallWithValue(target, data, value, error);\n    }\n\n    /**\n     * @notice execute arbitrary external call with limited gas usage and amount of copied return data\n     * @dev derived from https://github.com/nomad-xyz/ExcessivelySafeCall (MIT License)\n     * @param target recipient of call\n     * @param gasAmount gas allowance for call\n     * @param value native token value to include in call\n     * @param maxCopy maximum number of bytes to copy from return data\n     * @param data encoded call data\n     * @return success whether call is successful\n     * @return returnData copied return data\n     */\n    function excessivelySafeCall(\n        address target,\n        uint256 gasAmount,\n        uint256 value,\n        uint16 maxCopy,\n        bytes memory data\n    ) internal returns (bool success, bytes memory returnData) {\n        returnData = new bytes(maxCopy);\n\n        assembly {\n            // execute external call via assembly to avoid automatic copying of return data\n            success := call(\n                gasAmount,\n                target,\n                value,\n                add(data, 0x20),\n                mload(data),\n                0,\n                0\n            )\n\n            // determine whether to limit amount of data to copy\n            let toCopy := returndatasize()\n\n            if gt(toCopy, maxCopy) {\n                toCopy := maxCopy\n            }\n\n            // store the length of the copied bytes\n            mstore(returnData, toCopy)\n\n            // copy the bytes from returndata[0:toCopy]\n            returndatacopy(add(returnData, 0x20), 0, toCopy)\n        }\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) private returns (bytes memory) {\n        if (!isContract(target)) revert AddressUtils__NotContract();\n\n        (bool success, bytes memory returnData) = target.call{ value: value }(\n            data\n        );\n\n        if (success) {\n            return returnData;\n        } else if (returnData.length > 0) {\n            assembly {\n                let returnData_size := mload(returnData)\n                revert(add(32, returnData), returnData_size)\n            }\n        } else {\n            revert(error);\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/utils/UintUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title utility functions for uint256 operations\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nlibrary UintUtils {\n    error UintUtils__InsufficientHexLength();\n\n    bytes16 private constant HEX_SYMBOLS = '0123456789abcdef';\n\n    function add(uint256 a, int256 b) internal pure returns (uint256) {\n        return b < 0 ? sub(a, -b) : a + uint256(b);\n    }\n\n    function sub(uint256 a, int256 b) internal pure returns (uint256) {\n        return b < 0 ? add(a, -b) : a - uint256(b);\n    }\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0';\n        }\n\n        uint256 temp = value;\n        uint256 digits;\n\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n\n        bytes memory buffer = new bytes(digits);\n\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n\n        return string(buffer);\n    }\n\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0x00';\n        }\n\n        uint256 length = 0;\n\n        for (uint256 temp = value; temp != 0; temp >>= 8) {\n            unchecked {\n                length++;\n            }\n        }\n\n        return toHexString(value, length);\n    }\n\n    function toHexString(\n        uint256 value,\n        uint256 length\n    ) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n\n        unchecked {\n            for (uint256 i = 2 * length + 1; i > 1; --i) {\n                buffer[i] = HEX_SYMBOLS[value & 0xf];\n                value >>= 4;\n            }\n        }\n\n        if (value != 0) revert UintUtils__InsufficientHexLength();\n\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/common/admin/interfaces/ICrossPaymentModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { IPaymentModule } from \"./IPaymentModule.sol\";\n\ninterface ICrossPaymentModule {\n    struct CrossPaymentSignatureInput {\n        address payer;\n        uint256 sourceChainId;\n        uint256 paymentIndex;\n        bytes signature;\n    }\n\n    struct ProcessCrossPaymentOutput {\n        bytes32 platformId;\n        uint32[] services;\n        uint32[] serviceAmounts;\n        address spender;\n        uint256 destinationChainId;\n        address payer;\n        uint256 sourceChainId;\n        uint256 paymentIndex;\n    }\n\n    function updateCrossPaymentSignerAddress(address newSignerAddress) external;\n    function processCrossPayment(\n        IPaymentModule.ProcessPaymentInput memory paymentInput,\n        address spender,\n        uint256 destinationChainId\n    ) external payable returns (uint256);\n    function processCrossPaymentForDelegator(\n        IPaymentModule.ProcessPaymentInput memory paymentInput,\n        address delegator,\n        uint256 destinationChainId,\n        uint256 gasFee,\n        bytes memory signature\n    ) external payable returns (uint256);\n    function processCrossPaymentBuyTokenForDelegator(\n        IPaymentModule.ProcessPaymentInput memory paymentInput,\n        address delegator,\n        uint256 gasFee,\n        bytes memory signature\n    ) external payable returns (uint256);\n    function spendCrossPaymentSignature(address spender, ProcessCrossPaymentOutput memory output, bytes memory signature) external;\n    function getCrossPaymentSignerAddress() external view returns (address);\n    function getCrossPaymentOutputByIndex(uint256 paymentIndex) external view returns (ProcessCrossPaymentOutput memory);\n    function prefixedMessage(bytes32 hash) external pure returns (bytes32);\n    function getHashedMessage(ProcessCrossPaymentOutput memory output) external pure returns (bytes32);\n    function recoverSigner(bytes32 message, bytes memory signature) external pure returns (address);\n    function checkSignature(ProcessCrossPaymentOutput memory output, bytes memory signature) external view;\n    function getDelegatorHashedMessage(address delegator, uint256 destinationChainId, uint256 gasFee) external pure returns (bytes32);\n    function checkDelegatorSignature(address delegator, uint256 destinationChainId, uint256 gasFee, bytes memory signature) external pure;\n    function getDelegatorBuyTokenHashedMessage(\n        address delegator,\n        address destinationAddress,\n        uint32 destinationChainId,\n        uint256 gasFee\n    ) external pure returns (bytes32);\n    function checkDelegatorBuyTokenSignature(\n        address delegator,\n        address destinationAddress,\n        uint32 destinationChainId,\n        uint256 gasFee,\n        bytes memory signature\n    ) external pure;\n    function getChainID() external view returns (uint256);\n\n    /** EVENTS */\n    event CrossPaymentProcessed(uint256 indexed previousBlock, uint256 indexed paymentIndex);\n    event CrossPaymentSignatureSpent(uint256 indexed previousBlock, uint256 indexed sourceChainId, uint256 indexed paymentIndex);\n    event CrossPaymentSignerAddressUpdated(address indexed oldSigner, address indexed newSigner);\n    event CrossPaymentProcessedBuyToken(\n        uint256 indexed paymentIndex,\n        address delegator,\n        uint256 indexed destinationChainId,\n        address indexed destinationAddress\n    );\n\n    /** ERRORS */\n    error ProcessCrossPaymentError(string errorMessage);\n    error CheckSignatureError(string errorMessage);\n    error ProcessCrossPaymentSignatureError(string errorMessage);\n}\n"
    },
    "contracts/common/admin/interfaces/IPaymentModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\ninterface IPaymentModule {\n    enum PaymentMethod {\n        NATIVE,\n        USD,\n        ALTCOIN\n    }\n\n    enum PaymentType {\n        NATIVE,\n        GIFT,\n        CROSSCHAIN\n    }\n\n    struct AcceptedToken {\n        string name;\n        PaymentMethod tokenType;\n        address token;\n        address router;\n        bool isV2Router;\n        uint256 slippageTolerance;\n    }\n\n    struct ProcessPaymentInput {\n        bytes32 platformId;\n        uint32[] services;\n        uint32[] serviceAmounts;\n        address referrer;\n        address user;\n        address tokenAddress;\n    }\n\n    struct ProcessPaymentOutput {\n        ProcessPaymentInput processPaymentInput;\n        uint256 usdPrice;\n        uint256 paymentAmount;\n        uint256 burnedAmount;\n        uint256 treasuryShare;\n        uint256 referrerShare;\n    }\n\n    struct ProcessCrossPaymentOutput {\n        bytes32 platformId;\n        uint32[] services;\n        uint32[] serviceAmounts;\n        address payer;\n        address spender;\n        uint256 sourceChainId;\n        uint256 destinationChainId;\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function PAYMENT_PROCESSOR_ROLE() external pure returns (bytes32);\n    function adminWithdraw(address tokenAddress, uint256 amount, address treasury) external;\n    function setUsdToken(address newUsdToken) external;\n    function setRouterAddress(address newRouter, bool _isV2Router) external;\n    function addAcceptedToken(AcceptedToken memory acceptedToken) external;\n    function removeAcceptedToken(address tokenAddress) external;\n    function updateAcceptedToken(AcceptedToken memory acceptedToken) external;\n    function setV3PoolFeeForTokenNative(address token, uint24 poolFee) external;\n    function getUsdToken() external view returns (address);\n    function processPayment(ProcessPaymentInput memory params) external payable returns (uint256);\n    function getPaymentByIndex(uint256 paymentIndex) external view returns (ProcessPaymentOutput memory);\n    function getQuoteTokenPrice(address token0, address token1) external view returns (uint256 price);\n    function getV3PoolFeeForTokenWithNative(address token) external view returns (uint24);\n    function isV2Router() external view returns (bool);\n    function getRouterAddress() external view returns (address);\n    function getAcceptedTokenByAddress(address tokenAddress) external view returns (AcceptedToken memory);\n    function getAcceptedTokens() external view returns (address[] memory);\n\n    /** EVENTS */\n    event TokenBurned(uint256 indexed tokenBurnedLastBlock, address indexed tokenAddress, uint256 amount);\n    event PaymentProcessed(uint256 indexed previousBlock, uint256 indexed paymentIndex);\n    event TreasuryAddressUpdated(address indexed oldTreasury, address indexed newTreasury);\n\n    /** ERRORS */\n    error ProcessPaymentError(string errorMessage);\n}\n"
    },
    "contracts/common/admin/internal/WhitelistInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { AccessControlInternal } from \"@solidstate/contracts/access/access_control/AccessControlInternal.sol\";\n\nimport { LibAccessControl } from \"../libraries/LibAccessControl.sol\";\nimport { LibWhitelabel } from \"../libraries/LibWhitelabel.sol\";\n\nabstract contract WhitelistInternal is AccessControlInternal {\n    modifier onlyWhitelisted(address account, bytes32 productId) {\n        LibWhitelabel.DiamondStorage storage ds = LibWhitelabel.diamondStorage();\n        require(!ds.isWhitelistEnabled[productId] || _hasRole(LibAccessControl.WHITELISTED_ROLE, account), \"Whitelist: caller is not whitelisted\");\n        _;\n    }\n}\n"
    },
    "contracts/common/admin/libraries/LibAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nlibrary LibAccessControl {\n    bytes32 internal constant DEFAULT_ADMIN_ROLE = 0x00;\n    bytes32 internal constant WHITELIST_ADMIN_ROLE = keccak256(\"WHITELIST_ADMIN_ROLE\");\n    bytes32 internal constant WHITELISTED_ROLE = keccak256(\"WHITELISTED_ROLE\");\n    bytes32 internal constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 internal constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n}\n"
    },
    "contracts/common/admin/libraries/LibWhitelabel.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nlibrary LibWhitelabel {\n    bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(\"floki.whitelabel.diamond.storage\");\n\n    struct DiamondStorage {\n        mapping(bytes32 => bool) isWhitelistEnabled; // bytes32 is productIdentifier generated using keccak256\n    }\n\n    event WhitelistedAdded(address indexed account);\n    event WhitelistedRemoved(address indexed account);\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            ds.slot := position\n        }\n    }\n}\n"
    },
    "contracts/common/diamonds/Diamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n*\n* Implementation of a diamond.\n/******************************************************************************/\n\nimport { LibDiamond } from \"./libraries/LibDiamond.sol\";\nimport { IDiamondCut } from \"./interfaces/IDiamondCut.sol\";\n\ncontract Diamond {\n    constructor(address _contractOwner, address _diamondCutFacet) payable {\n        LibDiamond.setContractOwner(_contractOwner);\n\n        // Add the diamondCut external function from the diamondCutFacet\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);\n        bytes4[] memory functionSelectors = new bytes4[](1);\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\n        cut[0] = IDiamondCut.FacetCut({ facetAddress: _diamondCutFacet, action: IDiamondCut.FacetCutAction.Add, functionSelectors: functionSelectors });\n        LibDiamond.diamondCut(cut, address(0), \"\");\n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    // solhint-disable-next-line no-complex-fallback\n    fallback() external payable {\n        LibDiamond.DiamondStorage storage ds;\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\n        // get diamond storage\n        assembly {\n            ds.slot := position\n        }\n        // get facet from function selector\n        address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;\n        require(facet != address(0), \"Diamond: Function does not exist\");\n        // Execute external function from facet using delegatecall and return any value.\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/common/diamonds/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n    enum FacetCutAction {\n        Add,\n        Replace,\n        Remove\n    }\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external;\n}\n"
    },
    "contracts/common/diamonds/interfaces/IDiamondCutWithApproval.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { IDiamondCut } from \"./IDiamondCut.sol\";\n\ninterface IDiamondCutWithApproval is IDiamondCut {\n    function contractOwner() external view returns (address);\n\n    function setContractOwner(address _newContractOwner) external;\n}\n"
    },
    "contracts/common/diamonds/interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\n// A loupe is a small magnifying glass used to look at diamonds.\n// These functions look at diamonds\ninterface IDiamondLoupe {\n    /// These functions are expected to be called frequently\n    /// by tools.\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ Facet\n    function facets() external view returns (Facet[] memory facets_);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\n}\n"
    },
    "contracts/common/diamonds/interfaces/IDiamondProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondProxy {\n    function implementation() external view returns (address);\n\n    function setImplementation(address _implementation) external;\n}\n"
    },
    "contracts/common/diamonds/interfaces/IPausableFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport { IPausable } from \"@solidstate/contracts/security/pausable/Pausable.sol\";\n\ninterface IPausableFacet is IPausable {\n    function pause() external;\n\n    function unpause() external;\n}\n"
    },
    "contracts/common/diamonds/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\n\nlibrary LibDiamond {\n    bytes32 public constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\n    }\n\n    struct DiamondStorage {\n        // maps function selector to the facet address and\n        // the position of the selector in the facetFunctionSelectors.selectors array\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n        // maps facet addresses to function selectors\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n        // facet addresses\n        address[] facetAddresses;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n    }\n\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    // Internal function version of diamondCut\n    function diamondCut(IDiamondCut.FacetCut[] memory _diamondCut, address _init, bytes memory _calldata) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n            removeFunction(ds, oldFacetAddress, selector);\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        // if function does not exist then do nothing and return\n        require(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            removeFunction(ds, oldFacetAddress, selector);\n        }\n    }\n\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\n        enforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\n        ds.facetAddresses.push(_facetAddress);\n    }\n\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {\n        require(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n        // an immutable function is a function defined directly in a diamond\n        require(_facetAddress != address(this), \"LibDiamondCut: Can't remove immutable function\");\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete ds.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            ds.facetAddresses.pop();\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n        }\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            return;\n        }\n        enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                // bubble up error\n                /// @solidity memory-safe-assembly\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(error)\n                    revert(add(32, error), returndata_size)\n                }\n            } else {\n                revert InitializationFunctionReverted(_init, _calldata);\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "contracts/common/diamonds/libraries/LibDiamondHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { IAccessControl } from \"@solidstate/contracts/access/access_control/AccessControl.sol\";\n\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\nimport { IDiamondProxy } from \"../interfaces/IDiamondProxy.sol\";\nimport { IDiamondCutWithApproval } from \"../interfaces/IDiamondCutWithApproval.sol\";\nimport { IPausableFacet, IPausable } from \"../interfaces/IPausableFacet.sol\";\n\nlibrary LibDiamondHelpers {\n    function getAccessControlSelectors() internal pure returns (bytes4[] memory functionSelectors) {\n        functionSelectors = new bytes4[](7);\n        functionSelectors[0] = IAccessControl.hasRole.selector;\n        functionSelectors[1] = IAccessControl.getRoleAdmin.selector;\n        functionSelectors[2] = IAccessControl.grantRole.selector;\n        functionSelectors[3] = IAccessControl.revokeRole.selector;\n        functionSelectors[4] = IAccessControl.renounceRole.selector;\n        functionSelectors[5] = IAccessControl.getRoleMember.selector;\n        functionSelectors[6] = IAccessControl.getRoleMemberCount.selector;\n    }\n\n    function getPausableSelectors() internal pure returns (bytes4[] memory functionSelectors) {\n        functionSelectors = new bytes4[](3);\n        functionSelectors[0] = IPausable.paused.selector;\n        functionSelectors[1] = IPausableFacet.pause.selector;\n        functionSelectors[2] = IPausableFacet.unpause.selector;\n    }\n\n    function getDiamondLoupeSelectors() internal pure returns (bytes4[] memory functionSelectors) {\n        functionSelectors = new bytes4[](4);\n        functionSelectors[0] = IDiamondLoupe.facetFunctionSelectors.selector;\n        functionSelectors[1] = IDiamondLoupe.facetAddress.selector;\n        functionSelectors[2] = IDiamondLoupe.facetAddresses.selector;\n        functionSelectors[3] = IDiamondLoupe.facets.selector;\n    }\n\n    function getDiamondProxySelectors() internal pure returns (bytes4[] memory functionSelectors) {\n        functionSelectors = new bytes4[](2);\n        functionSelectors[0] = IDiamondProxy.implementation.selector;\n        functionSelectors[1] = IDiamondProxy.setImplementation.selector;\n    }\n\n    function getDiamondCutWithApprovalSelectors() internal pure returns (bytes4[] memory functionSelectors) {\n        functionSelectors = new bytes4[](2);\n        functionSelectors[0] = IDiamondCutWithApproval.contractOwner.selector;\n        functionSelectors[1] = IDiamondCutWithApproval.setContractOwner.selector;\n        // we don't need to add the diamondCut function selector here because it is added in the Diamond constructor\n    }\n\n    function getReentrancyGuardSelectors() internal pure returns (bytes4[] memory functionSelectors) {\n        functionSelectors = new bytes4[](0);\n    }\n}\n"
    },
    "contracts/launchpad/facets/LaunchPadFactoryFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { ILaunchPadFactory, ILaunchPadCommon } from \"../interfaces/ILaunchPadFactory.sol\";\nimport { ILaunchPadProjectInit } from \"../interfaces/ILaunchPadProjectInit.sol\";\nimport { LibDiamond } from \"../../common/diamonds/libraries/LibDiamond.sol\";\nimport { LibLaunchPadFactoryStorage } from \"../libraries/LibLaunchPadFactoryStorage.sol\";\nimport { LibLaunchPadConsts } from \"../libraries/LibLaunchPadConsts.sol\";\nimport { IPaymentModule } from \"../../common/admin/interfaces/IPaymentModule.sol\";\nimport { ICrossPaymentModule } from \"../../common/admin/interfaces/ICrossPaymentModule.sol\";\nimport { IDiamondCutWithApproval, IDiamondCut } from \"../../common/diamonds/interfaces/IDiamondCutWithApproval.sol\";\nimport { LibDiamondHelpers } from \"../../common/diamonds/libraries/LibDiamondHelpers.sol\";\nimport { Diamond } from \"../../common/diamonds/Diamond.sol\";\nimport { ITokenLauncherFactory } from \"../../token-launcher/interfaces/ITokenLauncherFactory.sol\";\nimport { ITokenFiErc20 } from \"../../token-launcher/interfaces/ITokenFiErc20.sol\";\nimport { WhitelistInternal } from \"../../common/admin/internal/WhitelistInternal.sol\";\nimport { IDiamondProxy } from \"../../common/diamonds/interfaces/IDiamondProxy.sol\";\n\ncontract LaunchPadFactoryFacet is ILaunchPadFactory, WhitelistInternal {\n    using SafeERC20 for IERC20;\n\n    function addInvestorToLaunchPad(address investor) external override {\n        LibLaunchPadFactoryStorage.DiamondStorage storage ds = LibLaunchPadFactoryStorage.diamondStorage();\n        // Can only be called by a launchpad contract\n        require(ds.isLaunchPad[msg.sender], \"LaunchPadFactoryFacet:addInvestorToLaunchPad: LaunchPad does not exist\");\n        ds.launchPadsByInvestor[investor].push(msg.sender);\n    }\n\n    // solhint-disable-next-line function-max-lines\n    function _createLaunchPad(ILaunchPadCommon.CreateLaunchPadInput memory storeInput) private {\n        if (storeInput.launchPadType == ILaunchPadCommon.LaunchPadType.FlokiPadCreatedBefore) {\n            // create a TokenFiErc20 token by using TokenLauncherFactory\n            // payment would be ignored because launchpad factory has a discount NFT\n\n            address tokenAddress = ITokenLauncherFactory(address(this)).createErc20(\n                ITokenLauncherFactory.CreateErc20Input({\n                    tokenInfo: ITokenFiErc20.TokenInfo({\n                        name: storeInput.createErc20Input.name,\n                        symbol: storeInput.createErc20Input.symbol,\n                        logo: storeInput.createErc20Input.logo,\n                        decimals: storeInput.createErc20Input.decimals,\n                        initialSupply: storeInput.launchPadInfo.fundTarget.hardCap + storeInput.createErc20Input.treasuryReserved,\n                        maxSupply: storeInput.createErc20Input.maxSupply,\n                        treasury: address(this),\n                        owner: storeInput.createErc20Input.owner,\n                        fees: ITokenFiErc20.Fees({\n                            transferFee: ITokenFiErc20.FeeDetails({ percentage: 0, onlyOnSwaps: false }),\n                            burn: ITokenFiErc20.FeeDetails({ percentage: 0, onlyOnSwaps: false }),\n                            reflection: ITokenFiErc20.FeeDetails({ percentage: 0, onlyOnSwaps: false }),\n                            buyback: ITokenFiErc20.FeeDetails({ percentage: 0, onlyOnSwaps: false })\n                        }),\n                        buybackDetails: ITokenFiErc20.BuybackDetails({\n                            pairToken: address(0),\n                            router: address(0),\n                            liquidityBasisPoints: 0,\n                            priceImpactBasisPoints: 0\n                        })\n                    }),\n                    referrer: storeInput.referrer,\n                    paymentToken: address(0)\n                })\n            );\n\n            storeInput.launchPadInfo.tokenAddress = tokenAddress;\n        } else if (storeInput.launchPadType == ILaunchPadCommon.LaunchPadType.FlokiPadCreatedAfter) {\n            // create a TokenFiErc20 token by using TokenLauncherFactory after ICO by the launchpad owner\n            // payment would be ignored because launchpad factory has a discount NFT\n            require(storeInput.createErc20Input.owner != address(0), \"LaunchPadFactory::createLaunchPad(): owner cannot be Address Zero \");\n            require(\n                storeInput.createErc20Input.maxSupply >= storeInput.launchPadInfo.fundTarget.hardCap,\n                \"LaunchPadFactory::createLaunchPad(): maxSupply cannot be smaller than launchPad hardCap\"\n            );\n            storeInput.launchPadInfo.tokenAddress = address(0);\n        } else {\n            revert(\"LaunchPadFactory: Invalid launchPadType\");\n        }\n\n        // Create the new LaunchPad\n        LibLaunchPadFactoryStorage.DiamondStorage storage ds = LibLaunchPadFactoryStorage.diamondStorage();\n        LibDiamond.DiamondStorage storage diamondStorage = LibDiamond.diamondStorage();\n        LibDiamond.FacetAddressAndPosition memory diamondCutFacet = diamondStorage.selectorToFacetAndPosition[IDiamondCut.diamondCut.selector];\n        address launchPad = address(new Diamond(address(this), diamondCutFacet.facetAddress));\n\n        _prepareLaunchPadDiamond(launchPad, storeInput, ds);\n\n        // set LaunchpadImplementation for etherscan\n        IDiamondProxy(launchPad).setImplementation(ds.launchPadImplementation);\n\n        // Transfer token to the launchpad and treasury address\n        if (storeInput.launchPadType == ILaunchPadCommon.LaunchPadType.FlokiPadCreatedBefore) {\n            IERC20(storeInput.launchPadInfo.tokenAddress).safeTransfer(address(launchPad), storeInput.launchPadInfo.fundTarget.hardCap);\n            if (storeInput.createErc20Input.treasuryReserved > 0) {\n                IERC20(storeInput.launchPadInfo.tokenAddress).safeTransfer(storeInput.createErc20Input.owner, storeInput.createErc20Input.treasuryReserved);\n            }\n        }\n\n        // Log new launchPad into store\n        _addLaunchPad(storeInput, launchPad);\n\n        // Transfer ownership\n        IDiamondCutWithApproval(launchPad).setContractOwner(storeInput.launchPadInfo.owner);\n    }\n\n    function createLaunchPad(\n        ILaunchPadCommon.CreateLaunchPadInput memory storeInput\n    ) external payable override onlyWhitelisted(msg.sender, LibLaunchPadConsts.PRODUCT_ID) {\n        // Now let's process the payment\n        uint32[] memory services = new uint32[](1);\n        services[0] = uint32(storeInput.launchPadType);\n        uint32[] memory serviceAmounts = new uint32[](1);\n        serviceAmounts[0] = 1;\n        IPaymentModule.ProcessPaymentInput memory paymentInput = IPaymentModule.ProcessPaymentInput({\n            platformId: LibLaunchPadConsts.PRODUCT_ID,\n            services: services,\n            serviceAmounts: serviceAmounts,\n            referrer: storeInput.referrer,\n            user: msg.sender,\n            tokenAddress: storeInput.paymentTokenAddress\n        });\n        IPaymentModule(address(this)).processPayment{ value: msg.value }(paymentInput);\n\n        _createLaunchPad(storeInput);\n    }\n\n    function createLaunchPadWithPaymentSignature(\n        ILaunchPadCommon.CreateLaunchPadInput memory storeInput,\n        ICrossPaymentModule.CrossPaymentSignatureInput memory crossPaymentSignatureInput\n    ) external override onlyWhitelisted(msg.sender, LibLaunchPadConsts.PRODUCT_ID) {\n        // Now let's process the payment\n        uint32[] memory services = new uint32[](1);\n        services[0] = uint32(storeInput.launchPadType);\n        uint32[] memory serviceAmounts = new uint32[](1);\n        serviceAmounts[0] = 1;\n\n        ICrossPaymentModule.ProcessCrossPaymentOutput memory processCrossPaymentOutput = ICrossPaymentModule.ProcessCrossPaymentOutput({\n            platformId: LibLaunchPadConsts.PRODUCT_ID,\n            services: services,\n            serviceAmounts: serviceAmounts,\n            spender: msg.sender,\n            destinationChainId: ICrossPaymentModule(address(this)).getChainID(),\n            payer: crossPaymentSignatureInput.payer,\n            sourceChainId: crossPaymentSignatureInput.sourceChainId,\n            paymentIndex: crossPaymentSignatureInput.paymentIndex\n        });\n        ICrossPaymentModule(address(this)).spendCrossPaymentSignature(msg.sender, processCrossPaymentOutput, crossPaymentSignatureInput.signature);\n\n        _createLaunchPad(storeInput);\n    }\n\n    function _addLaunchPad(ILaunchPadCommon.CreateLaunchPadInput memory input, address launchPad) private {\n        require(input.launchPadInfo.owner != address(0), \"LaunchPadFactory: Owner cannot be 0\");\n        ILaunchPadFactory.StoreLaunchPadInput memory storeInput = ILaunchPadFactory.StoreLaunchPadInput({\n            launchPadType: input.launchPadType,\n            launchPadAddress: launchPad,\n            owner: input.launchPadInfo.owner,\n            referrer: input.referrer\n        });\n\n        LibLaunchPadFactoryStorage.DiamondStorage storage ds = LibLaunchPadFactoryStorage.diamondStorage();\n\n        ds.launchPadsByOwner[storeInput.owner].push(storeInput.launchPadAddress);\n        ds.launchPads.push(storeInput.launchPadAddress);\n        ds.isLaunchPad[storeInput.launchPadAddress] = true;\n        ds.launchPadOwner[storeInput.launchPadAddress] = storeInput.owner;\n        ds.tokenInfoByLaunchPadAddress[storeInput.launchPadAddress] = input.createErc20Input;\n        emit LibLaunchPadFactoryStorage.LaunchPadCreated(ds.currentBlockLaunchPadCreated, storeInput);\n        ds.currentBlockLaunchPadCreated = block.number;\n    }\n\n    function _prepareLaunchPadDiamond(\n        address launchPad,\n        ILaunchPadCommon.CreateLaunchPadInput memory input,\n        LibLaunchPadFactoryStorage.DiamondStorage storage ds\n    ) private {\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](7);\n\n        // Add LaunchPadProjectFacet\n        bytes4[] memory functionSelectors = LibLaunchPadFactoryStorage.getLaunchPadProjectSelectors();\n\n        cut[0] = IDiamondCut.FacetCut({ facetAddress: ds.launchPadProjectFacet, action: IDiamondCut.FacetCutAction.Add, functionSelectors: functionSelectors });\n\n        // Add LaunchPadProjectAdminFacet\n        functionSelectors = LibLaunchPadFactoryStorage.getLaunchPadProjectAdminSelectors();\n\n        cut[1] = IDiamondCut.FacetCut({\n            facetAddress: ds.launchPadProjectAdminFacet,\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: functionSelectors\n        });\n\n        // Add AccessControlFacet\n        functionSelectors = LibDiamondHelpers.getAccessControlSelectors();\n        cut[2] = IDiamondCut.FacetCut({ facetAddress: ds.accessControlFacet, action: IDiamondCut.FacetCutAction.Add, functionSelectors: functionSelectors });\n\n        // Add PausableFacet\n        functionSelectors = LibDiamondHelpers.getPausableSelectors();\n        cut[3] = IDiamondCut.FacetCut({ facetAddress: ds.pausableFacet, action: IDiamondCut.FacetCutAction.Add, functionSelectors: functionSelectors });\n\n        // Add DiamondLoupeFacet\n        functionSelectors = LibDiamondHelpers.getDiamondLoupeSelectors();\n        cut[4] = IDiamondCut.FacetCut({ facetAddress: ds.loupeFacet, action: IDiamondCut.FacetCutAction.Add, functionSelectors: functionSelectors });\n\n        // Add DiamondProxy\n        functionSelectors = LibDiamondHelpers.getDiamondProxySelectors();\n        cut[5] = IDiamondCut.FacetCut({ facetAddress: ds.proxyFacet, action: IDiamondCut.FacetCutAction.Add, functionSelectors: functionSelectors });\n\n        // Add DiamondCutWithApproval\n        functionSelectors = LibDiamondHelpers.getDiamondCutWithApprovalSelectors();\n        cut[6] = IDiamondCut.FacetCut({\n            facetAddress: ds.diamondCutWithApprovalFacet,\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: functionSelectors\n        });\n\n        // Add Facets to LaunchPad Diamond and initialize it\n        bytes memory _calldata = abi.encodeCall(ILaunchPadProjectInit.init, input);\n        IDiamondCut(launchPad).diamondCut(cut, ds.launchPadProjectDiamondInit, _calldata);\n    }\n}\n"
    },
    "contracts/launchpad/interfaces/ILaunchPadCommon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\ninterface ILaunchPadCommon {\n    enum LaunchPadType {\n        FlokiPadCreatedBefore,\n        FlokiPadCreatedAfter\n    }\n\n    struct IdoInfo {\n        bool enabled;\n        address dexRouter;\n        address pairToken;\n        uint256 price;\n        uint256 amountToList;\n    }\n\n    struct RefundInfo {\n        uint256 penaltyFeePercent;\n        uint256 expireDuration;\n    }\n\n    struct FundTarget {\n        uint256 softCap;\n        uint256 hardCap;\n    }\n\n    struct ReleaseSchedule {\n        uint256 timestamp;\n        uint256 percent;\n    }\n\n    struct ReleaseScheduleV2 {\n        uint256 timestamp;\n        uint256 percent;\n        bool isVesting;\n    }\n\n    struct CreateErc20Input {\n        string name;\n        string symbol;\n        string logo;\n        uint8 decimals;\n        uint256 maxSupply;\n        address owner;\n        uint256 treasuryReserved;\n    }\n\n    struct LaunchPadInfo {\n        address owner;\n        address tokenAddress;\n        address paymentTokenAddress;\n        uint256 price;\n        FundTarget fundTarget;\n        uint256 maxInvestPerWallet;\n        uint256 startTimestamp;\n        uint256 duration;\n        uint256 tokenCreationDeadline;\n        RefundInfo refundInfo;\n        IdoInfo idoInfo;\n    }\n\n    struct CreateLaunchPadInput {\n        LaunchPadType launchPadType;\n        LaunchPadInfo launchPadInfo;\n        ReleaseScheduleV2[] releaseSchedule;\n        CreateErc20Input createErc20Input;\n        address referrer;\n        bool isSuperchargerEnabled;\n        uint256 feePercentage;\n        address paymentTokenAddress;\n    }\n}\n"
    },
    "contracts/launchpad/interfaces/ILaunchPadFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ILaunchPadCommon } from \"./ILaunchPadCommon.sol\";\nimport { ICrossPaymentModule } from \"../../common/admin/interfaces/ICrossPaymentModule.sol\";\n\ninterface ILaunchPadFactory {\n    struct StoreLaunchPadInput {\n        ILaunchPadCommon.LaunchPadType launchPadType;\n        address launchPadAddress;\n        address owner;\n        address referrer;\n    }\n\n    function addInvestorToLaunchPad(address investor) external;\n    function createLaunchPad(ILaunchPadCommon.CreateLaunchPadInput memory input) external payable;\n    function createLaunchPadWithPaymentSignature(\n        ILaunchPadCommon.CreateLaunchPadInput memory storeInput,\n        ICrossPaymentModule.CrossPaymentSignatureInput memory crossPaymentSignatureInput\n    ) external;\n}\n"
    },
    "contracts/launchpad/interfaces/ILaunchPadProject.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ILaunchPadCommon } from \"./ILaunchPadCommon.sol\";\n\ninterface ILaunchPadProject {\n    struct PurchasedInfo {\n        uint256 purchasedTokenAmount;\n        uint256 claimedTokenAmount;\n        uint256 paidTokenAmount;\n    }\n\n    struct BuyTokenInput {\n        uint256 tokenAmount;\n        uint256 tier;\n        uint256 nonce;\n        uint256 deadline;\n        bytes signature;\n    }\n\n    struct ClaimTokenWithSuperchargerInput {\n        uint256 timestamp;\n        uint256 deadline;\n        bytes signature;\n    }\n\n    struct RefundWithSuperchargerInput {\n        uint256 timestamp;\n        uint256 deadline;\n        bytes signature;\n    }\n\n    function buyTokens(uint256 tokenAmount) external payable;\n\n    function buyTokensWithSupercharger(BuyTokenInput memory input) external payable;\n\n    function reserveTokens(address user, uint256 tokenAmount, uint256 sourceChainId, uint256 paymentIndex, bytes memory signature) external;\n\n    function processRefund(address user, uint256 tokenAmount, bytes memory signature) external;\n\n    function processRefundOnTokenCreationExpired(address user, uint256 tokenAmount, bytes memory signature) external;\n\n    function processRefundOnSoftCapFailure(address user, bytes memory signature) external;\n\n    function checkSignature(address wallet, uint256 tier, uint256 nonce, uint256 deadline, bytes memory signature) external view;\n\n    function checkSignatureForCrossPayment(address wallet, uint256 amount, uint256 sourceChainId, uint256 paymentIndex, bytes memory signature) external view;\n\n    function checkSignatureForRefund(address wallet, uint256 amount, bytes memory signature) external view;\n\n    function claimTokens() external;\n\n    function claimTokensWithSupercharger(ILaunchPadProject.ClaimTokenWithSuperchargerInput memory input) external;\n\n    function getAllInvestors() external view returns (address[] memory);\n\n    function getCurrentTier() external view returns (uint256);\n\n    function getFeeShare() external view returns (uint256);\n\n    function getHardCapPerTier(uint256 tier) external view returns (uint256);\n\n    function getInvestorAddressByIndex(uint256 index) external view returns (address);\n\n    function getInvestorsLength() external view returns (uint256);\n\n    function getLaunchPadAddress() external view returns (address);\n\n    function getLaunchPadInfo() external view returns (ILaunchPadCommon.LaunchPadInfo memory);\n\n    function getMaxInvestPerWalletPerTier(uint256 tier) external view returns (uint256);\n\n    function getNextNonce(address user) external view returns (uint256);\n\n    function getProjectOwnerRole() external view returns (bytes32);\n\n    function getPurchasedInfoByUser(address user) external view returns (PurchasedInfo memory);\n\n    function getReleasedTokensPercentage() external view returns (uint256);\n\n    function getReleaseSchedule() external view returns (ILaunchPadCommon.ReleaseScheduleV2[] memory);\n\n    function getTokensAvailableToBeClaimed(address user) external view returns (uint256);\n\n    function getTokenCreationDeadline() external view returns (uint256);\n\n    function getTotalRaised() external view returns (uint256);\n\n    function getInvestorsRefundedCount() external view returns (uint256);\n\n    function getMaxInvestorsToRefund() external view returns (uint256);\n\n    function getRemainingInvestorsToRefund() external view returns (uint256);\n\n    function setMaxInvestorsToRefund(uint256 maxInvestorsUpdate) external;\n\n    function isSuperchargerEnabled() external view returns (bool);\n\n    function recoverSigner(bytes32 message, bytes memory signature) external view returns (address);\n\n    function refund(uint256 tokenAmount) external;\n\n    function refundOnSoftCapFailure() external;\n\n    function refundOnTokenCreationExpired(uint256 tokenAmount) external;\n\n    function refundAllInvestors() external;\n\n    function refundOnUnstakedDuringSales(ILaunchPadProject.RefundWithSuperchargerInput memory input) external;\n\n    function tokenDecimals() external view returns (uint256);\n\n    function totalTokensClaimed() external view returns (uint256);\n\n    function totalTokensSold() external view returns (uint256);\n}\n"
    },
    "contracts/launchpad/interfaces/ILaunchPadProjectAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ILaunchPadCommon } from \"./ILaunchPadCommon.sol\";\n\ninterface ILaunchPadProjectAdmin {\n    function setSupercharger(bool isSuperchargerEnabled) external;\n\n    function updateStartTimestamp(uint256 newStartTimestamp) external;\n\n    function extendDuration(uint256 durationIncrease) external;\n\n    function updateReleaseSchedule(ILaunchPadCommon.ReleaseScheduleV2[] memory releaseSchedule) external;\n\n    function setTokenAddress(address tokenAddress) external;\n\n    function withdrawFees() external;\n\n    function withdrawTokens(address tokenAddress) external;\n\n    function withdrawTokensToRecipient(address tokenAddress, address recipient) external;\n\n    /** EVENTS */\n\n    event SuperchargerUpdated(bool isSuperchargerEnabled);\n    event StartTimestampUpdated(uint256 newStartTimestamp);\n    event DurationExtended(uint256 durationIncrease);\n    event ReleaseScheduleUpdated(ILaunchPadCommon.ReleaseScheduleV2[] releaseSchedule);\n    event TokenAddressUpdated(address tokenAddress);\n    event FeesWithdrawn(uint256 feeAmount);\n    event TokensWithdrawn(address tokenAddress);\n    event TokensWithdrawnToRecipient(address tokenAddress, address recipient);\n\n    /** ERRORS */\n    error UPDATE_RELEASE_SCHEDULE_ERROR(string errorMessage);\n    error UPDATE_START_TIMESTAMP_ERROR(string errorMessage);\n    error EXTEND_DURATION_ERROR(string errorMessage);\n}\n"
    },
    "contracts/launchpad/interfaces/ILaunchPadProjectInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ILaunchPadCommon } from \"./ILaunchPadCommon.sol\";\n\ninterface ILaunchPadProjectInit {\n    function init(ILaunchPadCommon.CreateLaunchPadInput memory input) external;\n}\n"
    },
    "contracts/launchpad/libraries/LibLaunchPadConsts.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nlibrary LibLaunchPadConsts {\n    bytes32 internal constant PRODUCT_ID = keccak256(\"tokenfi.launchpad\");\n    uint256 internal constant BURN_BASIS_POINTS = 5_000;\n    uint256 internal constant MAX_INVESTORS_TO_REFUND = 100;\n}\n"
    },
    "contracts/launchpad/libraries/LibLaunchPadFactoryStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ILaunchPadCommon } from \"../interfaces/ILaunchPadCommon.sol\";\nimport { ILaunchPadFactory } from \"../interfaces/ILaunchPadFactory.sol\";\nimport { ILaunchPadProject } from \"../interfaces/ILaunchPadProject.sol\";\nimport { ILaunchPadProjectAdmin } from \"../interfaces/ILaunchPadProjectAdmin.sol\";\n\nlibrary LibLaunchPadFactoryStorage {\n    bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(\"tokenfi.launchpad.factory.diamond.storage\");\n\n    struct DiamondStorage {\n        address[] launchPads;\n        mapping(address => address[]) launchPadsByOwner;\n        mapping(address => address[]) launchPadsByInvestor;\n        mapping(address => address) launchPadOwner;\n        mapping(address => bool) isLaunchPad;\n        mapping(address => ILaunchPadCommon.CreateErc20Input) tokenInfoByLaunchPadAddress;\n        uint256 currentBlockLaunchPadCreated;\n        uint256 currentBlockLaunchPadOwnerUpdated;\n        address _tokenLauncherERC20; // deprecated (available on Diamond itself)\n        address _tokenLauncherStore; // deprecated (available on Diamond itself)\n        address _tokenLauncherBuybackHandler; // deprecated (available on Diamond itself)\n        address launchPadProjectFacet;\n        address accessControlFacet;\n        address pausableFacet;\n        address loupeFacet;\n        address proxyFacet;\n        address launchPadProjectDiamondInit;\n        address _tokenfiToken; // deprecated (available on LaunchPadPaymentStorage)\n        address _usdToken; // deprecated (available on LaunchPadPaymentStorage)\n        address _router; // deprecated (available on LaunchPadPaymentStorage)\n        address _treasury; // deprecated (available on LaunchPadPaymentStorage)\n        address signerAddress;\n        uint256 maxTokenCreationDeadline;\n        uint256[] _superChargerMultiplierByTier; // deprecated (cause of wrong updates by v1)\n        uint256[] _superChargerHeadstartByTier; // deprecated (cause of wrong updates by v1)\n        uint256[] _superChargerTokensPercByTier; // deprecated (cause of wrong updates by v1)\n        uint256 maxDurationIncrement;\n        address launchPadProjectAdminFacet;\n        address launchPadImplementation;\n        uint256[] superChargerMultiplierByTier;\n        uint256[] superChargerHeadstartByTier;\n        uint256[] superChargerTokensPercByTier;\n        address diamondCutWithApprovalFacet;\n    }\n\n    event LaunchPadCreated(uint256 indexed previousBlock, ILaunchPadFactory.StoreLaunchPadInput launchPad);\n    event LaunchPadOwnerUpdated(uint256 indexed previousBlock, address owner, address newOwner);\n    event MaxTokenCreationDeadlineUpdated(uint256 indexed previousMaxTokenCreationDeadline, uint256 newMaxTokenCreationDeadline);\n    event LaunchpadRemoved(address indexed launchPadAddress, address indexed owner);\n    event SignerAddressUpdated(address indexed previousSignerAddress, address indexed newSignerAddress);\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    function getLaunchPadProjectSelectors() internal pure returns (bytes4[] memory) {\n        bytes4[] memory functionSelectors = new bytes4[](38);\n        functionSelectors[0] = ILaunchPadProject.buyTokens.selector;\n        functionSelectors[1] = ILaunchPadProject.buyTokensWithSupercharger.selector;\n        functionSelectors[2] = ILaunchPadProject.checkSignature.selector;\n        functionSelectors[3] = ILaunchPadProject.claimTokens.selector;\n        functionSelectors[4] = ILaunchPadProject.getAllInvestors.selector;\n        functionSelectors[5] = ILaunchPadProject.getCurrentTier.selector;\n        functionSelectors[6] = ILaunchPadProject.getFeeShare.selector;\n        functionSelectors[7] = ILaunchPadProject.getHardCapPerTier.selector;\n        functionSelectors[8] = ILaunchPadProject.getInvestorAddressByIndex.selector;\n        functionSelectors[9] = ILaunchPadProject.getInvestorsLength.selector;\n        functionSelectors[10] = ILaunchPadProject.getLaunchPadAddress.selector;\n        functionSelectors[11] = ILaunchPadProject.getLaunchPadInfo.selector;\n        functionSelectors[12] = ILaunchPadProject.getMaxInvestPerWalletPerTier.selector;\n        functionSelectors[13] = ILaunchPadProject.getNextNonce.selector;\n        functionSelectors[14] = ILaunchPadProject.getProjectOwnerRole.selector;\n        functionSelectors[15] = ILaunchPadProject.getPurchasedInfoByUser.selector;\n        functionSelectors[16] = ILaunchPadProject.getReleasedTokensPercentage.selector;\n        functionSelectors[17] = ILaunchPadProject.getReleaseSchedule.selector;\n        functionSelectors[18] = ILaunchPadProject.getTokensAvailableToBeClaimed.selector;\n        functionSelectors[19] = ILaunchPadProject.getTokenCreationDeadline.selector;\n        functionSelectors[20] = ILaunchPadProject.getTotalRaised.selector;\n        functionSelectors[21] = ILaunchPadProject.isSuperchargerEnabled.selector;\n        functionSelectors[22] = ILaunchPadProject.recoverSigner.selector;\n        functionSelectors[23] = ILaunchPadProject.refund.selector;\n        functionSelectors[24] = ILaunchPadProject.refundOnSoftCapFailure.selector;\n        functionSelectors[25] = ILaunchPadProject.refundOnTokenCreationExpired.selector;\n        functionSelectors[26] = ILaunchPadProject.tokenDecimals.selector;\n        functionSelectors[27] = ILaunchPadProject.totalTokensClaimed.selector;\n        functionSelectors[28] = ILaunchPadProject.totalTokensSold.selector;\n        functionSelectors[29] = ILaunchPadProject.reserveTokens.selector;\n        functionSelectors[30] = ILaunchPadProject.processRefund.selector;\n        functionSelectors[31] = ILaunchPadProject.processRefundOnTokenCreationExpired.selector;\n        functionSelectors[32] = ILaunchPadProject.processRefundOnSoftCapFailure.selector;\n        functionSelectors[33] = ILaunchPadProject.refundAllInvestors.selector;\n        functionSelectors[34] = ILaunchPadProject.getInvestorsRefundedCount.selector;\n        functionSelectors[35] = ILaunchPadProject.getMaxInvestorsToRefund.selector;\n        functionSelectors[36] = ILaunchPadProject.setMaxInvestorsToRefund.selector;\n        functionSelectors[37] = ILaunchPadProject.getRemainingInvestorsToRefund.selector;\n\n        return functionSelectors;\n    }\n\n    function getLaunchPadProjectAdminSelectors() internal pure returns (bytes4[] memory) {\n        bytes4[] memory functionSelectors = new bytes4[](9);\n        functionSelectors[0] = ILaunchPadProjectAdmin.setSupercharger.selector;\n        functionSelectors[1] = ILaunchPadProjectAdmin.setTokenAddress.selector;\n        functionSelectors[2] = ILaunchPadProjectAdmin.withdrawFees.selector;\n        functionSelectors[3] = ILaunchPadProjectAdmin.withdrawTokens.selector;\n        functionSelectors[4] = ILaunchPadProjectAdmin.withdrawTokensToRecipient.selector;\n        functionSelectors[5] = ILaunchPadProjectAdmin.updateStartTimestamp.selector;\n        functionSelectors[6] = ILaunchPadProjectAdmin.extendDuration.selector;\n        functionSelectors[7] = ILaunchPadProjectAdmin.updateReleaseSchedule.selector;\n\n        return functionSelectors;\n    }\n}\n"
    },
    "contracts/token-launcher/interfaces/ITokenFiErc1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ICrossPaymentModule } from \"../../common/admin/interfaces/ICrossPaymentModule.sol\";\n\ninterface ITokenFiErc1155 {\n    struct TokenInfo {\n        string name;\n        string symbol;\n        string collectionLogo;\n        string baseURI;\n        bool isPublicMintEnabled;\n        bool isAdminMintEnabled;\n        address owner;\n    }\n\n    struct CreateTokenInput {\n        uint256 tokenId;\n        uint256 maxSupply;\n        uint256 publicMintUsdPrice;\n        uint8 decimals;\n        string uri;\n    }\n\n    function adminMint(address account, uint256 id, uint256 amount) external;\n    function setTokenInfo(TokenInfo memory _newTokenInfo) external;\n    function createToken(CreateTokenInput memory input) external;\n    function setTokenPublicMintPrice(uint256 _tokenId, uint256 _price) external;\n    function setTokenUri(uint256 _tokenId, string memory _uri) external;\n    function mint(address account, uint256 id, uint256 amount, address paymentToken, address referrer) external payable;\n    function mintWithPaymentSignature(\n        address account,\n        uint256 id,\n        uint256 amount,\n        ICrossPaymentModule.CrossPaymentSignatureInput memory crossPaymentSignatureInput\n    ) external;\n    function tokenInfo() external view returns (TokenInfo memory);\n    function maxSupply(uint256 tokenId) external view returns (uint256);\n    function decimals(uint256 tokenId) external view returns (uint256);\n    function paymentServiceIndexByTokenId(uint256 tokenId) external view returns (uint256);\n    function exists(uint256 id) external view returns (bool);\n    function getExistingTokenIds() external view returns (uint256[] memory);\n    function paymentModule() external view returns (address);\n\n    event TokenInfoUpdated(TokenInfo indexed oldTokenInfo, TokenInfo indexed newTokenInfo);\n    event MintPaymentProccessed(address indexed user, uint256 indexed paymentId);\n}\n"
    },
    "contracts/token-launcher/interfaces/ITokenFiErc20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\ninterface ITokenFiErc20 {\n    struct FeeDetails {\n        uint256 percentage;\n        bool onlyOnSwaps;\n    }\n\n    struct Fees {\n        FeeDetails transferFee;\n        FeeDetails burn;\n        FeeDetails reflection;\n        FeeDetails buyback;\n    }\n\n    struct BuybackDetails {\n        address pairToken;\n        address router;\n        uint256 liquidityBasisPoints;\n        uint256 priceImpactBasisPoints;\n    }\n\n    struct TokenInfo {\n        string name;\n        string symbol;\n        string logo;\n        uint8 decimals;\n        uint256 initialSupply;\n        uint256 maxSupply;\n        address treasury;\n        address owner;\n        Fees fees;\n        BuybackDetails buybackDetails;\n    }\n\n    struct TotalReflection {\n        uint256 tTotal;\n        uint256 rTotal;\n        uint256 tFeeTotal;\n    }\n\n    struct ReflectionInfo {\n        TotalReflection totalReflection;\n        mapping(address => uint256) rOwned;\n        mapping(address => uint256) tOwned;\n        mapping(address => bool) isExcludedFromReflectionRewards;\n        address[] excluded;\n    }\n\n    /** ONLY ROLES */\n    function mint(address to, uint256 amount) external;\n    function updateTokenLauncher(address _newTokenLauncher) external;\n    function updateTreasury(address _newTreasury) external;\n    function setName(string memory name) external;\n    function setSymbol(string memory symbol) external;\n    function setDecimals(uint8 decimals) external;\n    function updateFees(Fees memory _fees) external;\n    function setBuybackDetails(BuybackDetails memory _buybackDetails) external;\n    function setBuybackHandler(address _newBuybackHandler) external;\n    function addExchangePool(address pool) external;\n    function removeExchangePool(address pool) external;\n    function addExemptAddress(address account) external;\n    function removeExemptAddress(address account) external;\n\n    /** VIEW */\n    function fees() external view returns (Fees memory);\n    function tokenInfo() external view returns (TokenInfo memory);\n    function buybackHandler() external view returns (address);\n    function isExchangePool(address pool) external view returns (bool);\n    function isExemptedFromTax(address account) external view returns (bool);\n    function isReflectionToken() external view returns (bool);\n\n    /** REFLECTION Implemetation */\n    function reflect(uint256 tAmount) external;\n    function excludeAccount(address account) external;\n    function includeAccount(address account) external;\n    function isExcludedFromReflectionRewards(address account) external view returns (bool);\n    function totalReflection() external view returns (TotalReflection memory);\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) external view returns (uint256);\n    function tokenFromReflection(uint256 rAmount) external view returns (uint256);\n    function totalFees() external view returns (uint256);\n\n    event ExemptedAdded(address indexed account);\n    event ExemptedRemoved(address indexed account);\n    event ExchangePoolAdded(address indexed pool);\n    event ExchangePoolRemoved(address indexed pool);\n    event TokenLauncherUpdated(address indexed oldTokenLauncher, address indexed newTokenLauncher);\n    event TransferTax(address indexed account, address indexed receiver, uint256 amount, string indexed taxType);\n    event BuybackHandlerUpdated(address indexed oldBuybackHandler, address indexed newBuybackHandler);\n    event BuybackDetailsUpdated(address indexed router, address indexed pairToken, uint256 liquidityBasisPoints, uint256 priceImpactBasisPoints);\n    event TreasuryUpdated(address indexed oldTreasury, address indexed newTreasury);\n}\n"
    },
    "contracts/token-launcher/interfaces/ITokenFiErc721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ICrossPaymentModule } from \"../../common/admin/interfaces/ICrossPaymentModule.sol\";\n\ninterface ITokenFiErc721 {\n    enum PaymentServices {\n        TOKEN_MINT\n    }\n\n    struct TokenInfo {\n        string name;\n        string symbol;\n        string collectionLogo;\n        string baseURI;\n        uint256 maxSupply;\n        bool isPublicMintEnabled;\n        bool isAdminMintEnabled;\n        address owner;\n    }\n\n    function adminMint(address _to) external;\n    function adminMintBatch(address _to, uint256 _amount) external;\n    function setTokenInfo(TokenInfo memory _newTokenInfo) external;\n    function setTokenUri(uint256 tokenId, string memory uri) external;\n    function mint(address _to, address paymentToken, address referrer) external payable;\n    function mintWithPaymentSignature(address _to, ICrossPaymentModule.CrossPaymentSignatureInput memory crossPaymentSignatureInput) external;\n    function mintBatch(address _to, uint256 _amount, address paymentToken, address referrer) external payable;\n    function mintBatchWithPaymentSignature(\n        address _to,\n        uint256 _amount,\n        ICrossPaymentModule.CrossPaymentSignatureInput memory crossPaymentSignatureInput\n    ) external;\n    function tokenInfo() external view returns (TokenInfo memory);\n    function paymentModule() external view returns (address);\n\n    event TokenInfoUpdated(TokenInfo indexed oldTokenInfo, TokenInfo indexed newTokenInfo);\n    event MintPaymentProccessed(address indexed user, uint256 indexed paymentId);\n}\n"
    },
    "contracts/token-launcher/interfaces/ITokenLauncherCommon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\ninterface ITokenLauncherCommon {\n    enum TokenType {\n        ERC20,\n        ERC721,\n        ERC1155\n    }\n}\n"
    },
    "contracts/token-launcher/interfaces/ITokenLauncherFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ITokenLauncherCommon } from \"./ITokenLauncherCommon.sol\";\nimport { ITokenFiErc20 } from \"./ITokenFiErc20.sol\";\nimport { ITokenFiErc721 } from \"./ITokenFiErc721.sol\";\nimport { ITokenFiErc1155 } from \"./ITokenFiErc1155.sol\";\nimport { ICrossPaymentModule } from \"../../common/admin/interfaces/ICrossPaymentModule.sol\";\n\ninterface ITokenLauncherFactory is ITokenLauncherCommon {\n    struct CreateErc20Input {\n        ITokenFiErc20.TokenInfo tokenInfo;\n        address referrer;\n        address paymentToken;\n    }\n\n    struct PublicErc721MintPaymentInfo {\n        uint256 usdPrice;\n        address treasury;\n        uint256 burnBasisPoints;\n        uint256 referrerBasisPoints;\n    }\n\n    struct CreateErc721Input {\n        ITokenFiErc721.TokenInfo tokenInfo;\n        PublicErc721MintPaymentInfo publicMintPaymentInfo;\n        address referrer;\n        address paymentToken;\n    }\n\n    struct PublicErc1155MintPaymentInfo {\n        address treasury;\n        uint256 burnBasisPoints;\n        uint256 referrerBasisPoints;\n    }\n\n    struct CreateErc1155Input {\n        ITokenFiErc1155.TokenInfo tokenInfo;\n        PublicErc1155MintPaymentInfo publicMintPaymentInfo;\n        ITokenFiErc1155.CreateTokenInput[] initialTokens;\n        address referrer;\n        address paymentToken;\n    }\n\n    struct StoreTokenInput {\n        address tokenAddress;\n        address owner;\n        address referrer;\n        uint256 paymentIndex;\n        TokenType tokenType;\n    }\n\n    function createErc20(CreateErc20Input memory input) external payable returns (address tokenAddress);\n    function createErc20WithPaymentSignature(\n        CreateErc20Input memory input,\n        ICrossPaymentModule.CrossPaymentSignatureInput memory crossPaymentSignatureInput\n    ) external returns (address tokenAddress);\n    function createErc721(CreateErc721Input memory input) external payable returns (address tokenAddress);\n    function createErc721WithPaymentSignature(\n        CreateErc721Input memory input,\n        ICrossPaymentModule.CrossPaymentSignatureInput memory crossPaymentSignatureInput\n    ) external returns (address tokenAddress);\n    function createErc1155(CreateErc1155Input memory input) external payable returns (address tokenAddress);\n    function createErc1155WithPaymentSignature(\n        CreateErc1155Input memory input,\n        ICrossPaymentModule.CrossPaymentSignatureInput memory crossPaymentSignatureInput\n    ) external returns (address tokenAddress);\n\n    /** EVNETS */\n    event TokenCreated(uint256 indexed currentBlockTokenCreated, StoreTokenInput input);\n}\n"
    }
  }
}}