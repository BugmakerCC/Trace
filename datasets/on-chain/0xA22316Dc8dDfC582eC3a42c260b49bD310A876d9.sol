{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "paris",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@lazy-sol/access-control-upgradeable/contracts/InitializableAccessControlCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4; // custom errors (0.8.4)\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @title Initializable Role-based Access Control Core (I-RBAC-C)\n *\n * @notice Access control smart contract provides an API to check\n *      if a specific operation is permitted globally and/or\n *      if a particular user has a permission to execute it.\n *\n * @notice This contract is inherited by other contracts requiring the role-based access control (RBAC)\n *      protection for the restricted access functions\n *\n * @notice It deals with two main entities: features and roles.\n *\n * @notice Features are designed to be used to enable/disable public functions\n *      of the smart contract (used by a wide audience).\n * @notice User roles are designed to control the access to restricted functions\n *      of the smart contract (used by a limited set of maintainers).\n *\n * @notice Terms \"role\", \"permissions\" and \"set of permissions\" have equal meaning\n *      in the documentation text and may be used interchangeably.\n * @notice Terms \"permission\", \"single permission\" implies only one permission bit set.\n *\n * @notice Access manager is a special role which allows to grant/revoke other roles.\n *      Access managers can only grant/revoke permissions which they have themselves.\n *      As an example, access manager with no other roles set can only grant/revoke its own\n *      access manager permission and nothing else.\n *\n * @notice Access manager permission should be treated carefully, as a super admin permission:\n *      Access manager with even no other permission can interfere with another account by\n *      granting own access manager permission to it and effectively creating more powerful\n *      permission set than its own.\n *\n * @dev Both current and OpenZeppelin AccessControl implementations feature a similar API\n *      to check/know \"who is allowed to do this thing\".\n * @dev Zeppelin implementation is more flexible:\n *      - it allows setting unlimited number of roles, while current is limited to 256 different roles\n *      - it allows setting an admin for each role, while current allows having only one global admin\n * @dev Current implementation is more lightweight:\n *      - it uses only 1 bit per role, while Zeppelin uses 256 bits\n *      - it allows setting up to 256 roles at once, in a single transaction, while Zeppelin allows\n *        setting only one role in a single transaction\n *\n * @dev This smart contract is designed to be inherited by other\n *      smart contracts which require access control management capabilities.\n *\n * @dev Access manager permission has a bit 255 set.\n *      This bit must not be used by inheriting contracts for any other permissions/features.\n *\n * @dev This is an initializable version of the RBAC, based on Zeppelin implementation,\n *      it can be used for EIP-1167 minimal proxies, for ERC1967 proxies, etc.\n *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#Clones\n *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\n *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\n *      see https://forum.openzeppelin.com/t/uups-proxies-tutorial-solidity-javascript/7786\n *      see https://eips.ethereum.org/EIPS/eip-1167\n *\n * @dev The 'core' version of the RBAC contract hides three rarely used external functions from the public ABI,\n *      making them internal and thus reducing the overall compiled implementation size.\n *      isFeatureEnabled() public -> _isFeatureEnabled() internal\n *      isSenderInRole() public -> _isSenderInRole() internal\n *      isOperatorInRole() public -> _isOperatorInRole() internal\n *\n * @custom:since 1.1.0\n *\n * @author Basil Gorin\n */\nabstract contract InitializableAccessControlCore is Initializable {\n\t/**\n\t * @dev Privileged addresses with defined roles/permissions\n\t * @dev In the context of ERC20/ERC721 tokens these can be permissions to\n\t *      allow minting or burning tokens, transferring on behalf and so on\n\t *\n\t * @dev Maps user address to the permissions bitmask (role), where each bit\n\t *      represents a permission\n\t * @dev Bitmask 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n\t *      represents all possible permissions\n\t * @dev 'This' address mapping represents global features of the smart contract\n\t *\n\t * @dev We keep the mapping private to prevent direct writes to it from the inheriting\n\t *      contracts, `getRole()` and `updateRole()` functions should be used instead\n\t */\n\tmapping(address => uint256) private userRoles;\n\n\t/**\n\t * @dev Empty reserved space in storage. The size of the __gap array is calculated so that\n\t *      the amount of storage used by a contract always adds up to the 50.\n\t *      See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n\t */\n\tuint256[49] private __gap;\n\n\t/**\n\t * @notice Access manager is responsible for assigning the roles to users,\n\t *      enabling/disabling global features of the smart contract\n\t * @notice Access manager can add, remove and update user roles,\n\t *      remove and update global features\n\t *\n\t * @dev Role ROLE_ACCESS_MANAGER allows modifying user roles and global features\n\t * @dev Role ROLE_ACCESS_MANAGER has single bit at position 255 enabled\n\t */\n\tuint256 public constant ROLE_ACCESS_MANAGER = 0x8000000000000000000000000000000000000000000000000000000000000000;\n\n\t/**\n\t * @notice Upgrade manager is responsible for smart contract upgrades,\n\t *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\n\t *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\n\t *\n\t * @dev Role ROLE_UPGRADE_MANAGER allows passing the _authorizeUpgrade() check\n\t * @dev Role ROLE_UPGRADE_MANAGER has single bit at position 254 enabled\n\t */\n\tuint256 public constant ROLE_UPGRADE_MANAGER = 0x4000000000000000000000000000000000000000000000000000000000000000;\n\n\t/**\n\t * @dev Bitmask representing all the possible permissions (super admin role)\n\t * @dev Has all the bits are enabled (2^256 - 1 value)\n\t */\n\tuint256 internal constant FULL_PRIVILEGES_MASK = type(uint256).max; // before 0.8.0: uint256(-1) overflows to 0xFFFF...\n\n\t/**\n\t * @notice Thrown when a function is executed by an account that does not have\n\t *      the required access permission(s) (role)\n\t *\n\t * @dev This error is used to enforce role-based access control (RBAC) restrictions\n\t */\n\terror AccessDenied();\n\n\t/**\n\t * @dev Fired in updateRole() and updateFeatures()\n\t *\n\t * @param operator address which was granted/revoked permissions\n\t * @param requested permissions requested\n\t * @param assigned permissions effectively set\n\t */\n\tevent RoleUpdated(address indexed operator, uint256 requested, uint256 assigned);\n\n\t/**\n\t * @notice Function modifier making a function defined as public behave as restricted\n\t *      (so that only a pre-configured set of accounts can execute it)\n\t *\n\t * @param role the role transaction executor is required to have;\n\t *      the function throws an \"access denied\" exception if this condition is not met\n\t */\n\tmodifier restrictedTo(uint256 role) {\n\t\t// verify the access permission\n\t\t_requireSenderInRole(role);\n\n\t\t// execute the rest of the function\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Creates/deploys the RBAC implementation to be used in a proxy\n\t *\n\t * @dev Note:\n\t *      the implementation is already initialized and\n\t *      `_postConstruct` is not executable on the implementation\n\t *      `_postConstruct` is still available in the context of a proxy\n\t *      and should be executed on the proxy deployment (in the same tx)\n\t */\n\tconstructor() initializer {}\n\n\t/**\n\t * @dev Contract initializer, sets the contract owner to have full privileges\n\t *\n\t * @dev Can be executed only once, reverts when executed second time\n\t *\n\t * @dev IMPORTANT:\n\t *      this function SHOULD be executed during proxy deployment (in the same transaction)\n\t *\n\t * @param _owner smart contract owner having full privileges, can be zero\n\t * @param _features initial features mask of the contract, can be zero\n\t */\n\tfunction _postConstruct(address _owner, uint256 _features) internal virtual onlyInitializing {\n\t\t// grant owner full privileges\n\t\t__setRole(_owner, FULL_PRIVILEGES_MASK, FULL_PRIVILEGES_MASK);\n\t\t// update initial features bitmask\n\t\t__setRole(address(this), _features, _features);\n\t}\n\n\t/**\n\t * @dev Highest version that has been initialized.\n\t *      Non-zero value means contract was already initialized.\n\t * @dev see {Initializable}, {reinitializer}.\n\t *\n\t * @return highest version that has been initialized\n\t */\n\tfunction getInitializedVersion() public view returns(uint64) {\n\t\t// delegate to `_getInitializedVersion`\n\t\treturn _getInitializedVersion();\n\t}\n\n\t/**\n\t * @notice Retrieves globally set of features enabled\n\t *\n\t * @dev Effectively reads userRoles role for the contract itself\n\t *\n\t * @return 256-bit bitmask of the features enabled\n\t */\n\tfunction features() public view returns (uint256) {\n\t\t// features are stored in 'this' address mapping of `userRoles`\n\t\treturn getRole(address(this));\n\t}\n\n\t/**\n\t * @notice Updates set of the globally enabled features (`features`),\n\t *      taking into account sender's permissions\n\t *\n\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n\t * @dev Function is left for backward compatibility with older versions\n\t *\n\t * @param _mask bitmask representing a set of features to enable/disable\n\t */\n\tfunction updateFeatures(uint256 _mask) public {\n\t\t// delegate call to `updateRole`\n\t\tupdateRole(address(this), _mask);\n\t}\n\n\t/**\n\t * @notice Reads the permissions (role) for a given user from the `userRoles` mapping\n\t *      (privileged addresses with defined roles/permissions)\n\t * @notice In the context of ERC20/ERC721 tokens these can be permissions to\n\t *      allow minting or burning tokens, transferring on behalf and so on\n\t *\n\t * @dev Having a simple getter instead of making the mapping public\n\t *      allows enforcing the encapsulation of the mapping and protects from\n\t *      writing to it directly in the inheriting smart contracts\n\t *\n\t * @param operator address of a user to read permissions for,\n\t *      or self address to read global features of the smart contract\n\t */\n\tfunction getRole(address operator) public view returns(uint256) {\n\t\t// read the value from `userRoles` and return\n\t\treturn userRoles[operator];\n\t}\n\n\t/**\n\t * @notice Updates set of permissions (role) for a given user,\n\t *      taking into account sender's permissions.\n\t *\n\t * @dev Setting role to zero is equivalent to removing an all permissions\n\t * @dev Setting role to `FULL_PRIVILEGES_MASK` is equivalent to\n\t *      copying senders' permissions (role) to the user\n\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n\t *\n\t * @param operator address of a user to alter permissions for,\n\t *       or self address to alter global features of the smart contract\n\t * @param role bitmask representing a set of permissions to\n\t *      enable/disable for a user specified\n\t */\n\tfunction updateRole(address operator, uint256 role) public {\n\t\t// caller must have a permission to update user roles\n\t\t_requireSenderInRole(ROLE_ACCESS_MANAGER);\n\n\t\t// evaluate the role and reassign it\n\t\t__setRole(operator, role, _evaluateBy(msg.sender, getRole(operator), role));\n\t}\n\n\t/**\n\t * @notice Determines the permission bitmask an operator can set on the\n\t *      target permission set\n\t * @notice Used to calculate the permission bitmask to be set when requested\n\t *     in `updateRole` and `updateFeatures` functions\n\t *\n\t * @dev Calculated based on:\n\t *      1) operator's own permission set read from userRoles[operator]\n\t *      2) target permission set - what is already set on the target\n\t *      3) desired permission set - what do we want set target to\n\t *\n\t * @dev Corner cases:\n\t *      1) Operator is super admin and its permission set is `FULL_PRIVILEGES_MASK`:\n\t *        `desired` bitset is returned regardless of the `target` permission set value\n\t *        (what operator sets is what they get)\n\t *      2) Operator with no permissions (zero bitset):\n\t *        `target` bitset is returned regardless of the `desired` value\n\t *        (operator has no authority and cannot modify anything)\n\t *\n\t * @dev Example:\n\t *      Consider an operator with the permissions bitmask     00001111\n\t *      is about to modify the target permission set          01010101\n\t *      Operator wants to set that permission set to          00110011\n\t *      Based on their role, an operator has the permissions\n\t *      to update only lowest 4 bits on the target, meaning that\n\t *      high 4 bits of the target set in this example is left\n\t *      unchanged and low 4 bits get changed as desired:      01010011\n\t *\n\t * @param operator address of the contract operator which is about to set the permissions\n\t * @param target input set of permissions to operator is going to modify\n\t * @param desired desired set of permissions operator would like to set\n\t * @return resulting set of permissions given operator will set\n\t */\n\tfunction _evaluateBy(address operator, uint256 target, uint256 desired) internal view returns (uint256) {\n\t\t// read operator's permissions\n\t\tuint256 p = getRole(operator);\n\n\t\t// taking into account operator's permissions,\n\t\t// 1) enable the permissions desired on the `target`\n\t\ttarget |= p & desired;\n\t\t// 2) disable the permissions desired on the `target`\n\t\ttarget &= FULL_PRIVILEGES_MASK ^ (p & (FULL_PRIVILEGES_MASK ^ desired));\n\n\t\t// return calculated result\n\t\treturn target;\n\t}\n\n\t/**\n\t * @notice Ensures that the transaction sender has the required access permission(s) (role)\n\t *\n\t * @dev Reverts with an `AccessDenied` error if the sender does not have the required role\n\t *\n\t * @param required the set of permissions (role) that the transaction sender is required to have\n\t */\n\tfunction _requireSenderInRole(uint256 required) internal view {\n\t\t// check if the transaction has the required permission(s),\n\t\t// reverting with the \"access denied\" error if not\n\t\t_requireAccessCondition(_isSenderInRole(required));\n\t}\n\n\t/**\n\t * @notice Ensures that a specific condition is met\n\t *\n\t * @dev Reverts with an `AccessDenied` error if the condition is not met\n\t *\n\t * @param condition the condition that needs to be true for the function to proceed\n\t */\n\tfunction _requireAccessCondition(bool condition) internal pure {\n\t\t// check if the condition holds\n\t\tif(!condition) {\n\t\t\t// revert with the \"access denied\" error if not\n\t\t\trevert AccessDenied();\n\t\t}\n\t}\n\n\t/**\n\t * @notice Checks if requested set of features is enabled globally on the contract\n\t *\n\t * @param required set of features to check against\n\t * @return true if all the features requested are enabled, false otherwise\n\t */\n\tfunction _isFeatureEnabled(uint256 required) internal view returns (bool) {\n\t\t// delegate call to `__hasRole`, passing `features` property\n\t\treturn __hasRole(features(), required);\n\t}\n\n\t/**\n\t * @notice Checks if transaction sender `msg.sender` has all the permissions required\n\t *\n\t * @param required set of permissions (role) to check against\n\t * @return true if all the permissions requested are enabled, false otherwise\n\t */\n\tfunction _isSenderInRole(uint256 required) internal view returns (bool) {\n\t\t// delegate call to `isOperatorInRole`, passing transaction sender\n\t\treturn _isOperatorInRole(msg.sender, required);\n\t}\n\n\t/**\n\t * @notice Checks if operator has all the permissions (role) required\n\t *\n\t * @param operator address of the user to check role for\n\t * @param required set of permissions (role) to check\n\t * @return true if all the permissions requested are enabled, false otherwise\n\t */\n\tfunction _isOperatorInRole(address operator, uint256 required) internal view returns (bool) {\n\t\t// delegate call to `__hasRole`, passing operator's permissions (role)\n\t\treturn __hasRole(getRole(operator), required);\n\t}\n\n\t/**\n\t * @dev Sets the `assignedRole` role to the operator, logs both `requestedRole` and `actualRole`\n\t *\n\t * @dev Unsafe:\n\t *      provides direct write access to `userRoles` mapping without any security checks,\n\t *      doesn't verify the executor (msg.sender) permissions,\n\t *      must be kept private at all times\n\t *\n\t * @param operator address of a user to alter permissions for,\n\t *       or self address to alter global features of the smart contract\n\t * @param requestedRole bitmask representing a set of permissions requested\n\t *      to be enabled/disabled for a user specified, used only to be logged into event\n\t * @param assignedRole bitmask representing a set of permissions to\n\t *      enable/disable for a user specified, used to update the mapping and to be logged into event\n\t */\n\tfunction __setRole(address operator, uint256 requestedRole, uint256 assignedRole) private {\n\t\t// assign the role to the operator\n\t\tuserRoles[operator] = assignedRole;\n\n\t\t// fire an event\n\t\temit RoleUpdated(operator, requestedRole, assignedRole);\n\t}\n\n\t/**\n\t * @dev Checks if role `actual` contains all the permissions required `required`\n\t *\n\t * @param actual existent role\n\t * @param required required role\n\t * @return true if actual has required role (all permissions), false otherwise\n\t */\n\tfunction __hasRole(uint256 actual, uint256 required) private pure returns (bool) {\n\t\t// check the bitmask for the role required and return the result\n\t\treturn actual & required == required;\n\t}\n}\n"
    },
    "@lazy-sol/advanced-erc20/contracts/interfaces/ERC1363Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./ERC20Spec.sol\";\nimport \"./ERC165Spec.sol\";\n\n/**\n * @title ERC1363 Interface\n *\n * @dev Interface defining a ERC1363 Payable Token contract.\n *      Implementing contracts MUST implement the ERC1363 interface as well as the ERC20 and ERC165 interfaces.\n */\ninterface ERC1363 is ERC20, ERC165  {\n\t/*\n\t * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n\t * 0xb0202a11 ===\n\t *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n\t *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n\t *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n\t *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n\t *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n\t *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n\t */\n\n\t/**\n\t * @notice Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver\n\t * @param to address The address which you want to transfer to\n\t * @param value uint256 The amount of tokens to be transferred\n\t * @return true unless throwing\n\t */\n\tfunction transferAndCall(address to, uint256 value) external returns (bool);\n\n\t/**\n\t * @notice Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver\n\t * @param to address The address which you want to transfer to\n\t * @param value uint256 The amount of tokens to be transferred\n\t * @param data bytes Additional data with no specified format, sent in call to `to`\n\t * @return true unless throwing\n\t */\n\tfunction transferAndCall(address to, uint256 value, bytes memory data) external returns (bool);\n\n\t/**\n\t * @notice Transfer tokens from one address to another and then call `onTransferReceived` on receiver\n\t * @param from address The address which you want to send tokens from\n\t * @param to address The address which you want to transfer to\n\t * @param value uint256 The amount of tokens to be transferred\n\t * @return true unless throwing\n\t */\n\tfunction transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n\t/**\n\t * @notice Transfer tokens from one address to another and then call `onTransferReceived` on receiver\n\t * @param from address The address which you want to send tokens from\n\t * @param to address The address which you want to transfer to\n\t * @param value uint256 The amount of tokens to be transferred\n\t * @param data bytes Additional data with no specified format, sent in call to `to`\n\t * @return true unless throwing\n\t */\n\tfunction transferFromAndCall(address from, address to, uint256 value, bytes memory data) external returns (bool);\n\n\t/**\n\t * @notice Approve the passed address to spend the specified amount of tokens on behalf of msg.sender\n\t * and then call `onApprovalReceived` on spender.\n\t * @param spender address The address which will spend the funds\n\t * @param value uint256 The amount of tokens to be spent\n\t */\n\tfunction approveAndCall(address spender, uint256 value) external returns (bool);\n\n\t/**\n\t * @notice Approve the passed address to spend the specified amount of tokens on behalf of msg.sender\n\t * and then call `onApprovalReceived` on spender.\n\t * @param spender address The address which will spend the funds\n\t * @param value uint256 The amount of tokens to be spent\n\t * @param data bytes Additional data with no specified format, sent in call to `spender`\n\t */\n\tfunction approveAndCall(address spender, uint256 value, bytes memory data) external returns (bool);\n}\n\n/**\n * @title ERC1363Receiver Interface\n *\n * @dev Interface for any contract that wants to support `transferAndCall` or `transferFromAndCall`\n *      from ERC1363 token contracts.\n */\ninterface ERC1363Receiver {\n\t/*\n\t * Note: the ERC-165 identifier for this interface is 0x88a7ca5c.\n\t * 0x88a7ca5c === bytes4(keccak256(\"onTransferReceived(address,address,uint256,bytes)\"))\n\t */\n\n\t/**\n\t * @notice Handle the receipt of ERC1363 tokens\n\t *\n\t * @dev Any ERC1363 smart contract calls this function on the recipient\n\t *      after a `transfer` or a `transferFrom`. This function MAY throw to revert and reject the\n\t *      transfer. Return of other than the magic value MUST result in the\n\t *      transaction being reverted.\n\t *      Note: the token contract address is always the message sender.\n\t *\n\t * @param operator address The address which called `transferAndCall` or `transferFromAndCall` function\n\t * @param from address The address which are token transferred from\n\t * @param value uint256 The amount of tokens transferred\n\t * @param data bytes Additional data with no specified format\n\t * @return `bytes4(keccak256(\"onTransferReceived(address,address,uint256,bytes)\"))`\n\t *      unless throwing\n\t */\n\tfunction onTransferReceived(address operator, address from, uint256 value, bytes memory data) external returns (bytes4);\n}\n\n/**\n * @title ERC1363Spender Interface\n *\n * @dev Interface for any contract that wants to support `approveAndCall`\n *      from ERC1363 token contracts.\n */\ninterface ERC1363Spender {\n\t/*\n\t * Note: the ERC-165 identifier for this interface is 0x7b04a2d0.\n\t * 0x7b04a2d0 === bytes4(keccak256(\"onApprovalReceived(address,uint256,bytes)\"))\n\t */\n\n\t/**\n\t * @notice Handle the approval of ERC1363 tokens\n\t *\n\t * @dev Any ERC1363 smart contract calls this function on the recipient\n\t *      after an `approve`. This function MAY throw to revert and reject the\n\t *      approval. Return of other than the magic value MUST result in the\n\t *      transaction being reverted.\n\t *      Note: the token contract address is always the message sender.\n\t *\n\t * @param owner address The address which called `approveAndCall` function\n\t * @param value uint256 The amount of tokens to be spent\n\t * @param data bytes Additional data with no specified format\n\t * @return `bytes4(keccak256(\"onApprovalReceived(address,uint256,bytes)\"))`\n\t *      unless throwing\n\t */\n\tfunction onApprovalReceived(address owner, uint256 value, bytes memory data) external returns (bytes4);\n}\n\n/**\n * @title Mintable ERC1363 Extension\n *\n * @notice Adds mint functions to the ERC1363 interface, these functions\n *      follow the same idea and logic as ERC1363 transferAndCall functions,\n *      allowing to notify the recipient ERC1363Receiver contract about the tokens received\n */\ninterface MintableERC1363 is ERC1363 {\n\t/**\n\t * @notice Mint tokens to the receiver and then call `onTransferReceived` on the receiver\n\t * @param to address The address which you want to mint to\n\t * @param value uint256 The amount of tokens to be minted\n\t * @return true unless throwing\n\t */\n\tfunction mintAndCall(address to, uint256 value) external returns (bool);\n\n\t/**\n\t * @notice Mint tokens to the receiver and then call `onTransferReceived` on the receiver\n\t * @param to address The address which you want to mint to\n\t * @param value uint256 The amount of tokens to be minted\n\t * @param data bytes Additional data with no specified format, sent in call to `to`\n\t * @return true unless throwing\n\t */\n\tfunction mintAndCall(address to, uint256 value, bytes memory data) external returns (bool);\n}\n"
    },
    "@lazy-sol/advanced-erc20/contracts/interfaces/ERC165Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title ERC-165 Standard Interface Detection\n *\n * @dev Interface of the ERC165 standard, as defined in the\n *       https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * @dev Implementers can declare support of contract interfaces,\n *      which can then be queried by others.\n *\n * @author Christian Reitwie√üner, Nick Johnson, Fabian Vogelsteller, Jordi Baylina, Konrad Feldmeier, William Entriken\n */\ninterface ERC165 {\n\t/**\n\t * @notice Query if a contract implements an interface\n\t *\n\t * @dev Interface identification is specified in ERC-165.\n\t *      This function uses less than 30,000 gas.\n\t *\n\t * @param interfaceID The interface identifier, as specified in ERC-165\n\t * @return `true` if the contract implements `interfaceID` and\n\t *      `interfaceID` is not 0xffffffff, `false` otherwise\n\t */\n\tfunction supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "@lazy-sol/advanced-erc20/contracts/interfaces/ERC20Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title EIP-20: ERC-20 Token Standard\n *\n * @notice The ERC-20 (Ethereum Request for Comments 20), proposed by Fabian Vogelsteller in November 2015,\n *      is a Token Standard that implements an API for tokens within Smart Contracts.\n *\n * @notice It provides functionalities like to transfer tokens from one account to another,\n *      to get the current token balance of an account and also the total supply of the token available on the network.\n *      Besides these it also has some other functionalities like to approve that an amount of\n *      token from an account can be spent by a third party account.\n *\n * @notice If a Smart Contract implements the following methods and events it can be called an ERC-20 Token\n *      Contract and, once deployed, it will be responsible to keep track of the created tokens on Ethereum.\n *\n * @notice See https://ethereum.org/en/developers/docs/standards/tokens/erc-20/\n * @notice See https://eips.ethereum.org/EIPS/eip-20\n */\ninterface ERC20 {\n\t/**\n\t * @dev Fired in transfer(), transferFrom() to indicate that token transfer happened\n\t *\n\t * @param from an address tokens were consumed from\n\t * @param to an address tokens were sent to\n\t * @param value number of tokens transferred\n\t */\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\n\t/**\n\t * @dev Fired in approve() to indicate an approval event happened\n\t *\n\t * @param owner an address which granted a permission to transfer\n\t *      tokens on its behalf\n\t * @param spender an address which received a permission to transfer\n\t *      tokens on behalf of the owner `owner`\n\t * @param value amount of tokens granted to transfer on behalf\n\t */\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n\n\t/**\n\t * @return name of the token (ex.: USD Coin)\n\t */\n\t// OPTIONAL - This method can be used to improve usability,\n\t// but interfaces and other contracts MUST NOT expect these values to be present.\n\t// function name() external view returns (string memory);\n\n\t/**\n\t * @return symbol of the token (ex.: USDC)\n\t */\n\t// OPTIONAL - This method can be used to improve usability,\n\t// but interfaces and other contracts MUST NOT expect these values to be present.\n\t// function symbol() external view returns (string memory);\n\n\t/**\n\t * @dev Returns the number of decimals used to get its user representation.\n\t *      For example, if `decimals` equals `2`, a balance of `505` tokens should\n\t *      be displayed to a user as `5,05` (`505 / 10 ** 2`).\n\t *\n\t * @dev Tokens usually opt for a value of 18, imitating the relationship between\n\t *      Ether and Wei. This is the value {ERC20} uses, unless this function is\n\t *      overridden;\n\t *\n\t * @dev NOTE: This information is only used for _display_ purposes: it in\n\t *      no way affects any of the arithmetic of the contract, including\n\t *      {IERC20-balanceOf} and {IERC20-transfer}.\n\t *\n\t * @return token decimals\n\t */\n\t// OPTIONAL - This method can be used to improve usability,\n\t// but interfaces and other contracts MUST NOT expect these values to be present.\n\t// function decimals() external view returns (uint8);\n\n\t/**\n\t * @return the amount of tokens in existence\n\t */\n\tfunction totalSupply() external view returns (uint256);\n\n\t/**\n\t * @notice Gets the balance of a particular address\n\t *\n\t * @param owner the address to query the the balance for\n\t * @return balance an amount of tokens owned by the address specified\n\t */\n\tfunction balanceOf(address owner) external view returns (uint256 balance);\n\n\t/**\n\t * @notice Transfers some tokens to an external address or a smart contract\n\t *\n\t * @dev Called by token owner (an address which has a\n\t *      positive token balance tracked by this smart contract)\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `to` address:\n\t *          * zero address or\n\t *          * self address or\n\t *          * smart contract which doesn't support ERC20\n\t *\n\t * @param to an address to transfer tokens to,\n\t *      must be either an external address or a smart contract,\n\t *      compliant with the ERC20 standard\n\t * @param value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction transfer(address to, uint256 value) external returns (bool success);\n\n\t/**\n\t * @notice Transfers some tokens on behalf of address `from' (token owner)\n\t *      to some other address `to`\n\t *\n\t * @dev Called by token owner on his own or approved address,\n\t *      an address approved earlier by token owner to\n\t *      transfer some amount of tokens on its behalf\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `to` address:\n\t *          * zero address or\n\t *          * same as `from` address (self transfer)\n\t *          * smart contract which doesn't support ERC20\n\t *\n\t * @param from token owner which approved caller (transaction sender)\n\t *      to transfer `value` of tokens on its behalf\n\t * @param to an address to transfer tokens to,\n\t *      must be either an external address or a smart contract,\n\t *      compliant with the ERC20 standard\n\t * @param value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction transferFrom(address from, address to, uint256 value) external returns (bool success);\n\n\t/**\n\t * @notice Approves address called `spender` to transfer some amount\n\t *      of tokens on behalf of the owner (transaction sender)\n\t *\n\t * @dev Transaction sender must not necessarily own any tokens to grant the permission\n\t *\n\t * @param spender an address approved by the caller (token owner)\n\t *      to spend some tokens on its behalf\n\t * @param value an amount of tokens spender `spender` is allowed to\n\t *      transfer on behalf of the token owner\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction approve(address spender, uint256 value) external returns (bool success);\n\n\t/**\n\t * @notice Returns the amount which `spender` is still allowed to withdraw from `owner`.\n\t *\n\t * @dev A function to check an amount of tokens owner approved\n\t *      to transfer on its behalf by some other address called \"spender\"\n\t *\n\t * @param owner an address which approves transferring some tokens on its behalf\n\t * @param spender an address approved to transfer some tokens on behalf\n\t * @return remaining an amount of tokens approved address `spender` can transfer on behalf\n\t *      of token owner `owner`\n\t */\n\tfunction allowance(address owner, address spender) external view returns (uint256 remaining);\n}\n\n/**\n * @title Mintable/burnable ERC20 Extension\n *\n * @notice Adds mint/burn functions to the ERC20 interface;\n *      these functions are usually present in ERC20 implementations;\n *      they become a must for the bridged tokens since the bridge usually\n *      needs to have a way to mint tokens deposited from L1 to L2\n *      and to burn tokens to be withdrawn from L2 to L1\n */\ninterface MintableBurnableERC20 is ERC20 {\n\t/**\n\t * @dev Mints (creates) some tokens to address specified\n\t * @dev The value specified is treated as is without taking\n\t *      into account what `decimals` value is\n\t *\n\t * @param to an address to mint tokens to\n\t * @param value an amount of tokens to mint (create)\n\t * @return success true on success, false otherwise\n\t */\n\tfunction mint(address to, uint256 value) external returns (bool success);\n\n\t/**\n\t * @dev Burns (destroys) some tokens from the address specified\n\t *\n\t * @dev The value specified is treated as is without taking\n\t *      into account what `decimals` value is\n\t *\n\t * @param from an address to burn some tokens from\n\t * @param value an amount of tokens to burn (destroy)\n\t * @return success true on success, false otherwise\n\t */\n\tfunction burn(address from, uint256 value) external returns (bool success);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "contracts/protocol/es/AbstractEmissionSchedule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@lazy-sol/access-control-upgradeable/contracts/InitializableAccessControlCore.sol\";\n\nimport \"./EmissionSchedule.sol\";\n\n/**\n * @title Abstract Emission Schedule\n *\n * @notice Implements some EmissionSchedule functionality, common for most of the implementations\n *\n * @author Lizard Labs Core Contributors\n */\nabstract contract AbstractEmissionSchedule is EmissionSchedule, InitializableAccessControlCore {\n\t/**\n\t * @dev Empty reserved space in storage. The size of the __gap array is calculated so that\n\t *      the amount of storage used by a contract always adds up to the 50.\n\t *      See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n\t */\n\tuint256[50] private __gap;\n\n\t/**\n\t * @notice Token releaser is responsible for releasing tokens from the schedule\n\t *\n\t * @dev Role ROLE_TOKEN_RELEASER allows releasing (minting, or transferring)\n\t *      the tokens from the schedule using the release functions:\n\t *      release(), releaseCapped(), and releaseAll()\n\t */\n\tuint32 public constant ROLE_TOKEN_RELEASER = 0x0001_0000;\n\n\t/// @inheritdoc EmissionSchedule\n\tfunction emissionVolume(uint256 t) public view virtual returns(uint256);\n\n\t/// @inheritdoc EmissionSchedule\n\tfunction emissionVolumeDelta(uint256 t0, uint256 t1) public view virtual returns(uint256) {\n\t\trequire(t0 <= t1, \"bad interval\");\n\t\treturn emissionVolume(t1) - emissionVolume(t0);\n\t}\n\n\t/// @inheritdoc EmissionSchedule\n\tfunction emissionRate(uint256 t, uint256 dt) public view virtual returns(uint256) {\n\t\trequire(t >= dt, \"bad interval\");\n\t\treturn emissionVolumeDelta(t - dt, t);\n\t}\n\n\t/// @inheritdoc EmissionSchedule\n\tfunction initialEmissionVolume() public view virtual returns(uint256) {\n\t\treturn 0;\n\t}\n\n\t/// @inheritdoc EmissionSchedule\n\tfunction totalEmissionVolume() public view virtual returns(uint256);\n\n\t/// @inheritdoc EmissionSchedule\n\tfunction alreadyReleasedAmount() public view virtual returns(uint256);\n\n\t/// @inheritdoc EmissionSchedule\n\tfunction toBeReleasedAmount() public view virtual returns(uint256) {\n\t\treturn totalEmissionVolume() - alreadyReleasedAmount();\n\t}\n\n\t/// @inheritdoc EmissionSchedule\n\tfunction canReleaseNowAmount() public view virtual returns(uint256) {\n\t\treturn emissionVolume(now32()) - alreadyReleasedAmount();\n\t}\n\n\t/// @inheritdoc EmissionSchedule\n\tfunction release(address to, uint256 amount) public virtual {\n\t\t// delegate to `__release` with the ERC1363 payload switch disabled\n\t\t__release(to, amount, false, \"\");\n\t}\n\n\t/// @inheritdoc EmissionSchedule\n\tfunction releaseCapped(address to, uint256 cap) public virtual returns(uint256) {\n\t\t// delegate to `__releaseCapped` with the ERC1363 payload switch disabled\n\t\treturn __releaseCapped(to, cap, false, \"\");\n\t}\n\n\t/// @inheritdoc EmissionSchedule\n\tfunction releaseAll(address to) public virtual returns(uint256 amount) {\n\t\t// delegate to `releaseCapped` with no cap\n\t\treturn releaseCapped(to, 0);\n\t}\n\n\t/// @inheritdoc EmissionSchedule\n\tfunction releaseAndCall(address target, uint256 amount, bytes calldata data) public virtual {\n\t\t// delegate to `__release` with the ERC1363 payload switch enabled\n\t\t__release(target, amount, true, data);\n\t}\n\n\t/// @inheritdoc EmissionSchedule\n\tfunction releaseAndCallCapped(address target, uint256 cap, bytes calldata data) public virtual returns(uint256) {\n\t\t// delegate to `__releaseCapped` with the ERC1363 payload switch enabled\n\t\treturn __releaseCapped(target, cap, true, data);\n\t}\n\n\t/// @inheritdoc EmissionSchedule\n\tfunction releaseAllAndCall(address target, bytes calldata data) public virtual returns(uint256 amount) {\n\t\t// delegate to `releaseCapped` with no cap\n\t\treturn releaseAndCallCapped(target, 0, data);\n\t}\n\n\t/**\n\t * @dev Release release() and releaseAndCall() logic implementation\n\t *\n\t * @param target an address to release tokens to, or\n\t *       ERC1363Receiver smart contract to send released tokens to,\n\t *       and trigger the `onTransferReceived` callback function on\n\t * @param amount the amount of tokens to release\n\t * @param withPayload either treat the `releaseTo` as ERC1363Receiver and trigger the\n\t *       `onTransferReceived` callback on it (true) or not (false)\n\t * @param data ERC1363 payload to be passed to the target contract's `onTransferReceived` callback\n\t */\n\tfunction __release(address target, uint256 amount, bool withPayload, bytes memory data) private {\n\t\t// verify the access permission\n\t\t_requireSenderInRole(ROLE_TOKEN_RELEASER);\n\n\t\t// explicit ask to release zero amount makes no sense\n\t\trequire(amount > 0, \"zero amount\");\n\n\t\t// make sure we can release the required amount\n\t\trequire(amount <= canReleaseNowAmount(), \"rate exceeded\");\n\n\t\t// if the ERC1363 release with callback is requested\n\t\tif(withPayload) {\n\t\t\t// ERC1363 release: delegate to `__releaseAndCall()`\n\t\t\t__releaseAndCall(target, amount, data);\n\t\t\t// emit an event with the ERC1363 payload\n\t\t\temit Released(target, amount, true, data);\n\t\t}\n\t\t// otherwise execute simple ERC20 release\n\t\telse {\n\t\t\t// release: delegate to `__release()`\n\t\t\t__release(target, amount);\n\t\t\t// emit an event without the ERC1363 payload\n\t\t\temit Released(target, amount, false, \"\");\n\t\t}\n\t}\n\n\t/**\n\t * @dev Release releaseCapped() and releaseAndCallCapped() logic implementation\n\t *\n\t * @param target an address to release tokens to, or\n\t *       ERC1363Receiver smart contract to send released tokens to,\n\t *       and trigger the `onTransferReceived` callback function on\n\t * @param cap maximum amount of tokens to release (amount cap); zero means no cap\n\t * @param withPayload either treat the `releaseTo` as ERC1363Receiver and trigger the\n\t *       `onTransferReceived` callback on it (true) or not (false)\n\t * @param data ERC1363 payload to be passed to the target contract's `onTransferReceived` callback\n\t */\n\tfunction __releaseCapped(address target, uint256 cap, bool withPayload, bytes memory data) private returns(uint256) {\n\t\t// verify the access permission\n\t\t_requireSenderInRole(ROLE_TOKEN_RELEASER);\n\n\t\t// determine how much we can release\n\t\tuint256 amount = canReleaseNowAmount();\n\n\t\t// if cap is set (non-zero) and amount exceeds the cap\n\t\tif(cap > 0 && amount > cap) {\n\t\t\t// cap the amount to be released\n\t\t\tamount = cap;\n\t\t}\n\n\t\t// if there is anything to release\n\t\tif(amount > 0) {\n\t\t\t// if the ERC1363 release with callback is requested\n\t\t\tif(withPayload) {\n\t\t\t\t// ERC1363 release: delegate to `__releaseAndCall()`\n\t\t\t\t__releaseAndCall(target, amount, data);\n\t\t\t}\n\t\t\t// otherwise execute simple ERC20 release\n\t\t\telse {\n\t\t\t\t// release: delegate to `__release()`\n\t\t\t\t__release(target, amount);\n\t\t\t}\n\n\t\t\t// emit an event with the ERC1363 payload\n\t\t\temit Released(target, amount, withPayload, data);\n\t\t}\n\t\t\t// otherwise, if there is nothing to release\n\t\telse {\n\t\t\t// emit an event without the ERC1363 payload\n\t\t\temit Released(target, 0, false, \"\");\n\t\t}\n\n\t\t// return the amount released\n\t\treturn amount;\n\t}\n\n\t/**\n\t * @dev Releases `amount` of tokens to the destination address `to`.\n\t *\n\t * @dev Unsafe. Doesn't verify the `canReleaseNowAmount()`.\n\t *      Must be kept private/internal at all times.\n\t *\n\t * @param to address to release tokens to\n\t * @param amount amount of tokens to release\n\t */\n\tfunction __release(address to, uint256 amount) internal virtual;\n\n\t/**\n\t * @dev Releases `amount` of tokens to the destination ERC1361Receiver contract `target`\n\t *      and executes the `onTransferReceived` callback on it.\n\t *\n\t * @dev Unsafe. Doesn't verify the `canReleaseNowAmount()`.\n\t *      Must be kept private/internal at all times.\n\t *\n\t * @param target address of the contract to release tokens to, and execute the callback on\n\t * @param amount amount of tokens to release\n\t * @param data ERC1363 payload data sent as is to the target contract's `onTransferReceived` function\n\t */\n\tfunction __releaseAndCall(address target, uint256 amount, bytes memory data) internal virtual;\n\n\t/**\n\t * @dev Testing time-dependent functionality may be difficult;\n\t *      we override time in the helper test smart contract (mock)\n\t *\n\t * @return `block.timestamp` in mainnet, custom values in testnets (if overridden)\n\t */\n\tfunction now32() public view virtual returns(uint32) {\n\t\t// return current block timestamp\n\t\treturn uint32(block.timestamp);\n\t}\n}\n"
    },
    "contracts/protocol/es/EmissionSchedule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title Emission Schedule\n *\n * @notice Emission schedule defines the rate at which new tokens are released into circulation over time.\n *      It's a function that outlines the number of tokens released per unit of time,\n *      such as during a month or year. \n *\n * @notice Emission schedule defines the emission volume of the new tokens released over time.\n *      It's a function that outlines the number of tokens released so far, by the given time.\n *      See emissionVolume(t) function\n *\n * @notice Emission rate is the derivative of the emission volume with respect to time,\n *      and emission volume is an integral of the emission rate over time.\n *      See emissionRate(t, dt) function\n * \n * @notice Emission schedule is defined on the time interval [start time, start time + duration],\n *      when token emission happens; also called an `emission period`.\n *      See emissionPeriod() function\n *\n * @notice Emission schedule defines initial (often zero) and final emission volumes.\n *      See initialEmissionVolume() and totalEmissionVolume() functions\n *\n * @notice The source of the new tokens released into circulation can be anything:\n *      tokens may get created (minted), transferred from the treasury wallet, etc.\n *      The source of the tokens is implementation dependent.\n *\n * @dev This interface aims to be generic and allow various types of implementations with\n *      various shapes of the emission curves;\n *      still the interface is specific enough for the clients app to integrate with.\n *\n * @dev Implementations MUST guarantee the following invariants ALWAYS hold TRUE:\n *      emissionVolume(t = start time) = initialEmissionVolume()\n *      emissionVolume(t < start time) = 0\n *      emissionVolume(t = start time + duration) = totalEmissionVolume()\n *      emissionVolume(t > start time + duration) = totalEmissionVolume()\n *      emissionVolume(t) - emissionVolume(t - dt) = emissionRate(t, dt)\n *      emissionVolume(t1) - emissionVolume(t0) = emissionVolumeDelta(t0, t1)\n *      emissionVolumeDelta(t1, t2) = 0, if t1 = t2\n *      alreadyReleasedAmount() <= emissionVolume(t = now)\n *      toBeReleasedAmount() = totalEmissionVolume() - alreadyReleasedAmount()\n *      canReleaseNowAmount() = emissionVolume(t = now) - alreadyReleasedAmount()\n *\n * @dev Implementation may not support any `dt` value in emissionRate(t, dt),\n *      but it must support at least dt = 1\n *\n * @author Lizard Labs Core Contributors\n */\ninterface EmissionSchedule {\n\t/**\n\t * @dev Fired in release(), releaseCapped(), releaseAll() functions, as well as\n\t *      in releaseAndCall(), releaseAndCallCapped(), releaseAllAndCall() functions\n\t *\n\t * @param target an account where tokens were released to, or ERC1363Receiver smart contract\n\t *       where tokens were sent to and the `onTransferReceived` callback function was triggered on\n\t * @param amount amount of the tokens released\n\t * @param withCallback true if `target` was treated as the ERC1363Receiver smart contract and\n\t *      `onTransferReceived` callback was executed on it; false otherwise\n\t * @param callbackPayload ERC1363 payload passed to the target contract's `onTransferReceived` callback\n\t */\n\tevent Released(address indexed target, uint256 amount, bool withCallback, bytes callbackPayload);\n\n\t/**\n\t * @notice Emission token is an address of the token this schedule releases into\n\t *      circulation, or zero address if schedule releases native currency like ETH\n\t *\n\t * @return Emission token address or zero address\n\t */\n\tfunction emissionToken() external view returns(address);\n\n\t/**\n\t * @notice Emission volume as a function of time `t` (unix timestamp)\n\t *\n\t * @param t current time or just the time of interest, unix timestamp\n\t * @return emission volume, number of tokens which could be released so far (by time `t`)\n\t */\n\tfunction emissionVolume(uint256 t) external view returns(uint256);\n\n\t/**\n\t * @notice Emission volume on the [t0, t1) time interval\n\t *\n\t * @param t0 lower time interval bound, inclusive, unix timestamp\n\t * @param t1 upper time interval bound, exclusive, unix timestamp\n\t * @return emission volume on the [t0, t1) time interval\n\t */\n\tfunction emissionVolumeDelta(uint256 t0, uint256 t1) external view returns(uint256);\n\n\t/**\n\t * @notice Emission rate as a function of time `t` (unix timestamp) and time change `dt` (seconds)\n\t *\n\t * @param t current time or just the time of interest, unix timestamp\n\t * @param dt time change, seconds, can't be zero (default value: 1)\n\t * @return emission rate, which is an emission volume on the [t - dt, t) time interval\n\t */\n\tfunction emissionRate(uint256 t, uint256 dt) external view returns(uint256);\n\n\t/**\n\t * @notice Emission period is the time interval when emission happens, it is defined\n\t *      by the start time, and duration\n\t *\n\t * @notice Implementations MUST use zero duration value for empty schedules, not releasing any tokens;\n\t *      implementations SHOULD return (0, 0) (start, duration) for empty schedules\n\t *\n\t * @return start emission start time, unix timestamp\n\t * @return duration emission duration, seconds\n\t */\n\tfunction emissionPeriod() external view returns(uint256 start, uint256 duration);\n\n\t/**\n\t * @notice Initial emission volume, amount of tokens which can be released immediately\n\t *      when the schedule starts\n\t *\n\t * @return initial emission volume, emissionVolume(0)\n\t */\n\tfunction initialEmissionVolume() external view returns(uint256);\n\n\t/**\n\t * @notice Total / final emission volume, amount of tokens which will be released eventually;\n\t *      amount of tokens which can be released after the schedule ends\n\t *\n\t * @return total (final) emission volume, emissionVolume(start time + duration)\n\t */\n\tfunction totalEmissionVolume() external view returns(uint256);\n\n\t/**\n\t * @notice Amount of tokens already released\n\t *\n\t * @notice Note: this can be lower than the value returned by `emissionVolume(now)`\n\t *      as not all the tokens which could be released, may be released\n\t *\n\t * @return amount of tokens already released\n\t */\n\tfunction alreadyReleasedAmount() external view returns(uint256);\n\n\t/**\n\t * @notice Amount of tokens that can be (will be) released in the future\n\t *\n\t * @return amount of tokens yet to be released\n\t */\n\tfunction toBeReleasedAmount() external view returns(uint256);\n\n\t/**\n\t * @notice Amount of tokes that can be released right now\n\t *\n\t * @dev Implementation MUST guarantee that this is the amount which:\n\t *      - can be safely passed to release(to, amount) function and it won't throw\n\t *      - is released and returned by the releaseCapped(to, cap) when releasing with no cap, or\n\t *            with the higher cap than the canReleaseNowAmount()\n\t *      - is released and returned by the releaseAll(to)\n\t *\n\t * @return amount of tokens that can be released right now\n\t */\n\tfunction canReleaseNowAmount() external view returns(uint256);\n\n\t/**\n\t * @notice Releases specified amount of tokens to the specified destination address `to`,\n\t *      throwing if the amount is either zero or exceeds canReleaseNowAmount()\n\t *\n\t * @dev Implementation MUST throw if the specified amount exceeds canReleaseNowAmount()\n\t *\n\t * @param to an address to release tokens to\n\t * @param amount the amount of tokens to release\n\t */\n\tfunction release(address to, uint256 amount) external;\n\n\t/**\n\t * @notice Releases tokens available for releasing, but no more than the specified cap\n\t *\n\t * @param to an address to release (send) tokens to\n\t * @param cap maximum amount of tokens to release (amount cap); zero means no cap\n\t * @return releasedAmount the actual released amount, not exceeding neither `cap`, nor canReleaseNowAmount()\n\t */\n\tfunction releaseCapped(address to, uint256 cap) external returns(uint256 releasedAmount);\n\n\t/**\n\t * @notice Releases all the tokens available for releasing\n\t *\n\t * @param to an address to release (send) tokens to\n\t * @return releasedAmount the actual released amount, not exceeding canReleaseNowAmount()\n\t */\n\tfunction releaseAll(address to) external returns(uint256 releasedAmount);\n\n\t/**\n\t * @notice Releases specified amount of tokens to the specified ERC1361Receiver contract,\n\t *      throwing if the amount specified is either zero or exceeds canReleaseNowAmount()\n\t *\n\t * @notice Executes the ERC1361 `onTransferReceived` callback function on the target contract\n\t *\n\t * @dev Implementation MUST throw if the amount specified exceeds canReleaseNowAmount()\n\t *\n\t * @param target ERC1363Receiver smart contract to send released tokens to,\n\t *       and trigger the `onTransferReceived` callback function on\n\t * @param amount the amount of tokens to release\n\t * @param data ERC1363 payload to be passed to the target contract's `onTransferReceived` callback\n\t */\n\tfunction releaseAndCall(address target, uint256 amount, bytes calldata data) external;\n\n\t/**\n\t * @notice Releases tokens available for releasing, but no more than the cap specified\n\t *\n\t * @notice Executes the ERC1361 `onTransferReceived` callback function on the target contract\n\t *\n\t * @param target ERC1363Receiver smart contract to send released tokens to,\n\t *       and trigger the `onTransferReceived` callback function on\n\t * @param cap maximum amount of tokens to release (amount cap); zero means no cap\n\t * @param data ERC1363 payload to be passed to the target contract's `onTransferReceived` callback\n\t * @return releasedAmount the actual released amount, not exceeding neither `cap`, nor canReleaseNowAmount()\n\t */\n\tfunction releaseAndCallCapped(address target, uint256 cap, bytes calldata data) external returns(uint256 releasedAmount);\n\n\t/**\n\t * @notice Releases all the tokens available for releasing\n\t *\n\t * @notice Executes the ERC1361 callback `onTransferReceived` on the target contract\n\t *\n\t * @param target ERC1363Receiver smart contract to send released tokens to,\n\t *       and trigger the `onTransferReceived` callback function on\n\t * @param data ERC1363 payload to be passed to the target contract's `onTransferReceived` callback\n\t * @return releasedAmount the actual released amount, not exceeding canReleaseNowAmount()\n\t */\n\tfunction releaseAllAndCall(address target, bytes calldata data) external returns(uint256 releasedAmount);\n}\n"
    },
    "contracts/protocol/es/MintingEmissionSchedule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@lazy-sol/advanced-erc20/contracts/interfaces/ERC20Spec.sol\";\nimport \"@lazy-sol/advanced-erc20/contracts/interfaces/ERC1363Spec.sol\";\n\nimport \"./AbstractEmissionSchedule.sol\";\n\n/**\n * @title Minting Emission Schedule\n *\n * @notice Releases the tokens into circulation by minting them\n *\n * @author Lizard Labs Core Contributors\n */\nabstract contract MintingEmissionSchedule is AbstractEmissionSchedule {\n\t/**\n\t * @dev Token address the schedule releases into circulation\n\t *\n\t * @dev Token smart contract is called to release the tokens; the function called\n\t *      on the token contract can be anything and is defined in the `releaseCallPrefix`\n\t */\n\taddress private token;\n\n\t/**\n\t * @dev Number of tokens already released by the schedule\n\t */\n\tuint96 private releasedAmount;\n\n\t/**\n\t * @dev Empty reserved space in storage. The size of the __gap array is calculated so that\n\t *      the amount of storage used by a contract always adds up to the 50.\n\t *      See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n\t */\n\tuint256[49] private __gap;\n\n\t/**\n\t * @dev \"Constructor replacement\" for a smart contract with a delayed initialization (post-deployment initialization)\n\t *\n\t * @dev Initializes an emission schedule with the token address\n\t *\n\t * @param _token address of the token contract to mint\n\t */\n\tfunction _postConstruct(address _token) internal virtual onlyInitializing {\n\t\t// verify the inputs\n\t\trequire(_token != address(0), \"zero address\");\n\t\trequire(_token.code.length > 0, \"EOA address\");\n\n\t\t// initialize contract storage\n\t\ttoken = _token;\n\t}\n\n\t/// @inheritdoc EmissionSchedule\n\tfunction emissionToken() public view returns(address) {\n\t\treturn token;\n\t}\n\n\t/// @inheritdoc EmissionSchedule\n\tfunction alreadyReleasedAmount() public view override returns(uint256) {\n\t\treturn releasedAmount;\n\t}\n\n\t/// @inheritdoc AbstractEmissionSchedule\n\tfunction __release(address to, uint256 amount) internal override {\n\t\t// update released amount counter\n\t\treleasedAmount += uint96(amount);\n\t\t// mint the tokens\n\t\trequire(MintableBurnableERC20(token).mint(to, amount), \"release failed\");\n\t}\n\n\t/// @inheritdoc AbstractEmissionSchedule\n\tfunction __releaseAndCall(address target, uint256 amount, bytes memory data) internal override {\n\t\t// update released amount counter\n\t\treleasedAmount += uint96(amount);\n\t\t// mint the tokens\n\t\trequire(MintableERC1363(token).mintAndCall(target, amount, data), \"release failed\");\n\t}\n}\n"
    },
    "contracts/protocol/es/UniformEpochEmissionSchedule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./AbstractEmissionSchedule.sol\";\n\n/**\n * @title Uniform Epoch Emission Schedule\n *\n * @notice Emission schedule which breaks the emission period into the epochs of the equal duration\n *      and has its emission rates defined for every epoch.\n *\n * @notice Emission volume is defined in the end of every epoch, and changes linearly within the epoch\n *      from the volume at the end of the previous epoch (zero for the very first epoch) to the volume\n *      at the end of the current epoch\n *\n * @author Lizard Labs Core Contributors\n */\nabstract contract UniformEpochEmissionSchedule is AbstractEmissionSchedule {\n\t/**\n\t * @dev Emission period start, unix timestamp\n\t */\n\tuint32 private emissionStart;\n\n\t/**\n\t * @dev Emission period duration\n\t */\n\tuint32 private emissionDuration;\n\n\t/**\n\t * @dev Emission volume at the end of every epoch;\n\t *      array length defines the number of epochs;\n\t *      epochs are of the equal length:\n\t *      epoch duration = emission period duration / number of epochs\n\t */\n\tuint96[] private emissionVolumeData;\n\n\t/**\n\t * @dev Empty reserved space in storage. The size of the __gap array is calculated so that\n\t *      the amount of storage used by a contract always adds up to the 50.\n\t *      See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n\t */\n\tuint256[48] private __gap;\n\n\t/**\n\t * @dev \"Constructor replacement\" for a smart contract with a delayed initialization (post-deployment initialization)\n\t *\n\t * @dev Initializes an emission schedule defined on the [_start, _start + _duration] interval,\n\t *      with the fixed emission rate in every sub-interval called epoch\n\t *\n\t * @dev Uses the mint(address,uint256) function signature to mint/release the tokens\n\t *\n\t * @param start emission period start\n\t * @param duration emission period duration\n\t * @param volume emission volume data presented as an array, each element\n\t *      represents emission volume at the end of corresponding epoch\n\t */\n\tfunction _postConstruct(uint32 start, uint32 duration, uint96[] memory volume) internal virtual onlyInitializing {\n\t\t// verify the inputs\n\t\trequire(start > 0 && duration > 0, \"invalid interval\");\n\t\trequire(volume.length > 0, \"no epochs defined\");\n\t\t// verify the emission volume array monotonically increases\n\t\tfor(uint256 i = 1; i < volume.length; i++) {\n\t\t\t// check the next element is not smaller tha the previous one\n\t\t\trequire(volume[i - 1] <= volume[i], \"emission volume decreases\");\n\t\t}\n\t\trequire(volume[volume.length - 1] > 0, \"empty schedule\");\n\n\t\t// initialize contract storage\n\t\temissionStart = start;\n\t\temissionDuration = duration;\n\t\temissionVolumeData = volume;\n\t}\n\n\t/// @dev volume array getter, for testing purposes\n\tfunction getVolumeArray() external view returns(uint96[] memory) {\n\t\t// since the volume array is initialized only once and in a single postConstruct() tx,\n\t\t// reading it entirely from the storage is always possible (and cheaper than writing)\n\t\t// read from storage into the memory and return\n\t\treturn emissionVolumeData;\n\t}\n\n\t/// @inheritdoc EmissionSchedule\n\tfunction emissionVolume(uint256 t) public view override returns(uint256) {\n\t\t// cache the required data on the stack\n\t\t(uint32 _start, uint32 _duration) = (emissionStart, emissionDuration);\n\n\t\t// if emission didn't yet start\n\t\tif(t <= _start) {\n\t\t\t// return zero volume\n\t\t\treturn 0;\n\t\t}\n\t\t// if emission already finished\n\t\tif(t >= _start + _duration) {\n\t\t\t// return total emission volume\n\t\t\treturn totalEmissionVolume();\n\t\t}\n\n\t\t// total number of epochs `n`\n\t\tuint256 n = emissionVolumeData.length;\n\t\t// current epoch number `k`\n\t\tuint256 k = (t - _start) * n / _duration;\n\t\t// determine emission volume at the beginning of the current epoch (end of the previous epoch)\n\t\tuint256 v0 = k == 0? 0: emissionVolumeData[k - 1];\n\t\t// determine emission volume at the end of the current epoch\n\t\tuint256 v1 = emissionVolumeData[k];\n\t\t// calculate the emission volume in the middle of the epoch\n\t\treturn v0 + (v1 - v0) * (t - _start - k * _duration / n) * n / _duration;\n\t}\n\n\t/// @inheritdoc EmissionSchedule\n\tfunction emissionPeriod() public view returns(uint256 start, uint256 duration) {\n\t\treturn (emissionStart, emissionDuration);\n\t}\n\n\t/// @inheritdoc EmissionSchedule\n\tfunction totalEmissionVolume() public view override returns(uint256) {\n\t\t// return the last epoch end volume\n\t\treturn emissionVolumeData[emissionVolumeData.length - 1];\n\t}\n}\n"
    },
    "contracts/protocol/es/UniformEpochEmissionScheduleV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./AbstractEmissionSchedule.sol\";\nimport \"./UniformEpochEmissionSchedule.sol\";\nimport \"./MintingEmissionSchedule.sol\";\n\n/**\n * @title Uniform Epoch Emission Schedule\n *\n * @notice Emission schedule which breaks the emission period into the epochs of the equal duration\n *      and has its emission rates defined for every epoch.\n *\n * @notice Emission volume is defined in the end of every epoch, and changes linearly within the epoch\n *      from the volume at the end of the previous epoch (zero for the very first epoch) to the volume\n *      at the end of the current epoch\n *\n * @author Lizard Labs Core Contributors\n */\ncontract UniformEpochEmissionScheduleV1 is UniformEpochEmissionSchedule, MintingEmissionSchedule {\n\t/**\n\t * @dev \"Constructor replacement\" for a smart contract with a delayed initialization (post-deployment initialization)\n\t *\n\t * @dev Initializes an emission schedule defined on the [_start, _start + _duration] interval,\n\t *      with the fixed emission rate in every sub-interval called epoch\n\t * @dev Initializes an emission schedule with the token address\n\t * @dev Initializes RBAC module with no features and full permissions given to msg.sender\n\t *\n\t * @param token address of the token contract to mint\n\t * @param start emission period start\n\t * @param duration emission period duration\n\t * @param volume emission volume data presented as an array, each element\n\t *      represents emission volume at the end of corresponding epoch\n\t */\n\tfunction postConstruct(address token, uint32 start, uint32 duration, uint96[] memory volume) public initializer {\n\t\t// initialize the UniformEpochEmissionSchedule\n\t\t_postConstruct(start, duration, volume);\n\t\t// initialize the MintingEmissionSchedule\n\t\t_postConstruct(token);\n\t\t// initialize the RBAC module\n\t\t_postConstruct(msg.sender, 0);\n\t}\n}\n"
    }
  }
}}