{{
  "language": "Solidity",
  "sources": {
    "contracts/interface/RocketStorageInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketStorageInterface {\n\n    // Deploy status\n    function getDeployedStatus() external view returns (bool);\n\n    // Guardian\n    function getGuardian() external view returns(address);\n    function setGuardian(address _newAddress) external;\n    function confirmGuardian() external;\n\n    // Getters\n    function getAddress(bytes32 _key) external view returns (address);\n    function getUint(bytes32 _key) external view returns (uint);\n    function getString(bytes32 _key) external view returns (string memory);\n    function getBytes(bytes32 _key) external view returns (bytes memory);\n    function getBool(bytes32 _key) external view returns (bool);\n    function getInt(bytes32 _key) external view returns (int);\n    function getBytes32(bytes32 _key) external view returns (bytes32);\n\n    // Setters\n    function setAddress(bytes32 _key, address _value) external;\n    function setUint(bytes32 _key, uint _value) external;\n    function setString(bytes32 _key, string calldata _value) external;\n    function setBytes(bytes32 _key, bytes calldata _value) external;\n    function setBool(bytes32 _key, bool _value) external;\n    function setInt(bytes32 _key, int _value) external;\n    function setBytes32(bytes32 _key, bytes32 _value) external;\n\n    // Deleters\n    function deleteAddress(bytes32 _key) external;\n    function deleteUint(bytes32 _key) external;\n    function deleteString(bytes32 _key) external;\n    function deleteBytes(bytes32 _key) external;\n    function deleteBool(bytes32 _key) external;\n    function deleteInt(bytes32 _key) external;\n    function deleteBytes32(bytes32 _key) external;\n\n    // Arithmetic\n    function addUint(bytes32 _key, uint256 _amount) external;\n    function subUint(bytes32 _key, uint256 _amount) external;\n\n    // Protected storage\n    function getNodeWithdrawalAddress(address _nodeAddress) external view returns (address);\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external view returns (address);\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external;\n    function confirmWithdrawalAddress(address _nodeAddress) external;\n}\n"
    },
    "contracts/contract/RocketBase.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"../interface/RocketStorageInterface.sol\";\n\n/// @title Base settings / modifiers for each contract in Rocket Pool\n/// @author David Rugendyke\n\nabstract contract RocketBase {\n\n    // Calculate using this as the base\n    uint256 constant calcBase = 1 ether;\n\n    // Version of the contract\n    uint8 public version;\n\n    // The main storage contract where primary persistant storage is maintained\n    RocketStorageInterface rocketStorage = RocketStorageInterface(address(0));\n\n\n    /*** Modifiers **********************************************************/\n\n    /**\n    * @dev Throws if called by any sender that doesn't match a Rocket Pool network contract\n    */\n    modifier onlyLatestNetworkContract() {\n        require(getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        _;\n    }\n\n    /**\n    * @dev Throws if called by any sender that doesn't match one of the supplied contract or is the latest version of that contract\n    */\n    modifier onlyLatestContract(string memory _contractName, address _contractAddress) {\n        require(_contractAddress == getAddress(keccak256(abi.encodePacked(\"contract.address\", _contractName))), \"Invalid or outdated contract\");\n        _;\n    }\n\n    /**\n    * @dev Throws if called by any sender that isn't a registered node\n    */\n    modifier onlyRegisteredNode(address _nodeAddress) {\n        require(getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress))), \"Invalid node\");\n        _;\n    }\n\n    /**\n    * @dev Throws if called by any sender that isn't a trusted node DAO member\n    */\n    modifier onlyTrustedNode(address _nodeAddress) {\n        require(getBool(keccak256(abi.encodePacked(\"dao.trustednodes.\", \"member\", _nodeAddress))), \"Invalid trusted node\");\n        _;\n    }\n\n    /**\n    * @dev Throws if called by any sender that isn't a registered minipool\n    */\n    modifier onlyRegisteredMinipool(address _minipoolAddress) {\n        require(getBool(keccak256(abi.encodePacked(\"minipool.exists\", _minipoolAddress))), \"Invalid minipool\");\n        _;\n    }\n    \n\n    /**\n    * @dev Throws if called by any account other than a guardian account (temporary account allowed access to settings before DAO is fully enabled)\n    */\n    modifier onlyGuardian() {\n        require(msg.sender == rocketStorage.getGuardian(), \"Account is not a temporary guardian\");\n        _;\n    }\n\n\n\n\n    /*** Methods **********************************************************/\n\n    /// @dev Set the main Rocket Storage address\n    constructor(RocketStorageInterface _rocketStorageAddress) {\n        // Update the contract address\n        rocketStorage = RocketStorageInterface(_rocketStorageAddress);\n    }\n\n\n    /// @dev Get the address of a network contract by name\n    function getContractAddress(string memory _contractName) internal view returns (address) {\n        // Get the current contract address\n        address contractAddress = getAddress(keccak256(abi.encodePacked(\"contract.address\", _contractName)));\n        // Check it\n        require(contractAddress != address(0x0), \"Contract not found\");\n        // Return\n        return contractAddress;\n    }\n\n\n    /// @dev Get the address of a network contract by name (returns address(0x0) instead of reverting if contract does not exist)\n    function getContractAddressUnsafe(string memory _contractName) internal view returns (address) {\n        // Get the current contract address\n        address contractAddress = getAddress(keccak256(abi.encodePacked(\"contract.address\", _contractName)));\n        // Return\n        return contractAddress;\n    }\n\n\n    /// @dev Get the name of a network contract by address\n    function getContractName(address _contractAddress) internal view returns (string memory) {\n        // Get the contract name\n        string memory contractName = getString(keccak256(abi.encodePacked(\"contract.name\", _contractAddress)));\n        // Check it\n        require(bytes(contractName).length > 0, \"Contract not found\");\n        // Return\n        return contractName;\n    }\n\n    /// @dev Get revert error message from a .call method\n    function getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return \"Transaction reverted silently\";\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n\n\n\n    /*** Rocket Storage Methods ****************************************/\n\n    // Note: Unused helpers have been removed to keep contract sizes down\n\n    /// @dev Storage get methods\n    function getAddress(bytes32 _key) internal view returns (address) { return rocketStorage.getAddress(_key); }\n    function getUint(bytes32 _key) internal view returns (uint) { return rocketStorage.getUint(_key); }\n    function getString(bytes32 _key) internal view returns (string memory) { return rocketStorage.getString(_key); }\n    function getBytes(bytes32 _key) internal view returns (bytes memory) { return rocketStorage.getBytes(_key); }\n    function getBool(bytes32 _key) internal view returns (bool) { return rocketStorage.getBool(_key); }\n    function getInt(bytes32 _key) internal view returns (int) { return rocketStorage.getInt(_key); }\n    function getBytes32(bytes32 _key) internal view returns (bytes32) { return rocketStorage.getBytes32(_key); }\n\n    /// @dev Storage set methods\n    function setAddress(bytes32 _key, address _value) internal { rocketStorage.setAddress(_key, _value); }\n    function setUint(bytes32 _key, uint _value) internal { rocketStorage.setUint(_key, _value); }\n    function setString(bytes32 _key, string memory _value) internal { rocketStorage.setString(_key, _value); }\n    function setBytes(bytes32 _key, bytes memory _value) internal { rocketStorage.setBytes(_key, _value); }\n    function setBool(bytes32 _key, bool _value) internal { rocketStorage.setBool(_key, _value); }\n    function setInt(bytes32 _key, int _value) internal { rocketStorage.setInt(_key, _value); }\n    function setBytes32(bytes32 _key, bytes32 _value) internal { rocketStorage.setBytes32(_key, _value); }\n\n    /// @dev Storage delete methods\n    function deleteAddress(bytes32 _key) internal { rocketStorage.deleteAddress(_key); }\n    function deleteUint(bytes32 _key) internal { rocketStorage.deleteUint(_key); }\n    function deleteString(bytes32 _key) internal { rocketStorage.deleteString(_key); }\n    function deleteBytes(bytes32 _key) internal { rocketStorage.deleteBytes(_key); }\n    function deleteBool(bytes32 _key) internal { rocketStorage.deleteBool(_key); }\n    function deleteInt(bytes32 _key) internal { rocketStorage.deleteInt(_key); }\n    function deleteBytes32(bytes32 _key) internal { rocketStorage.deleteBytes32(_key); }\n\n    /// @dev Storage arithmetic methods\n    function addUint(bytes32 _key, uint256 _amount) internal { rocketStorage.addUint(_key, _amount); }\n    function subUint(bytes32 _key, uint256 _amount) internal { rocketStorage.subUint(_key, _amount); }\n}\n"
    },
    "contracts/interface/dao/protocol/RocketDAOProtocolVerifierInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.5.0 <0.9.0;\npragma abicoder v2;\n\ninterface Types {\n    enum ChallengeState {\n        Unchallenged,\n        Challenged,\n        Responded,\n        Paid\n    }\n\n    struct Proposal {\n        address proposer;\n        uint32 blockNumber;\n        uint128 nodeCount;\n        bytes32 hash;\n        uint256 sum;\n    }\n\n    struct Node {\n        uint256 sum;\n        bytes32 hash;\n    }\n\n    struct Leaf {\n        address nodeAddress;\n        uint256 effectiveRpl;\n    }\n}\n\ninterface RocketDAOProtocolVerifierInterface {\n    function getDefeatIndex(uint256 _proposalID) external view returns (uint256);\n    function getProposalBond(uint256 _proposalID) external view returns (uint256);\n    function getChallengeBond(uint256 _proposalID) external view returns (uint256);\n    function getChallengePeriod(uint256 _proposalID) external view returns (uint256);\n    function getDepthPerRound() external pure returns (uint256);\n    function submitProposalRoot(uint256 _proposalId, address _proposer, uint32 _blockNumber, Types.Node[] memory _treeNodes) external;\n    function burnProposalBond(uint256 _proposalID) external;\n    function createChallenge(uint256 _proposalID, uint256 _index, Types.Node calldata _node, Types.Node[] calldata _witness) external;\n    function submitRoot(uint256 propId, uint256 index, Types.Node[] memory nodes) external;\n    function getChallengeState(uint256 _proposalID, uint256 _index) external view returns (Types.ChallengeState);\n    function verifyVote(address _voter, uint256 _nodeIndex, uint256 _proposalID, uint256 _votingPower, Types.Node[] calldata _witness) external view returns (bool);\n}\n"
    },
    "contracts/interface/network/RocketNetworkVotingInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.5.0 <0.9.0;\n\ninterface RocketNetworkVotingInterface {\n    function initialiseVotingFor(address _nodeAddress) external;\n    function initialiseVoting() external;\n    function initialiseVotingWithDelegate(address _delegate) external;\n    function getVotingInitialised(address _nodeAddress) external view returns (bool);\n    function getNodeCount(uint32 _block) external view returns (uint256);\n    function getVotingPower(address _nodeAddress, uint32 _block) external view returns (uint256);\n    function setDelegate(address _newDelegate) external;\n    function getDelegate(address _nodeAddress, uint32 _block) external view returns (address);\n    function getCurrentDelegate(address _nodeAddress) external view returns (address);\n}"
    },
    "contracts/types/NodeDetails.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\n// A struct containing all the information on-chain about a specific node\n\nstruct NodeDetails {\n    bool exists;\n    uint256 registrationTime;\n    string timezoneLocation;\n    bool feeDistributorInitialised;\n    address feeDistributorAddress;\n    uint256 rewardNetwork;\n    uint256 rplStake;\n    uint256 effectiveRPLStake;\n    uint256 minimumRPLStake;\n    uint256 maximumRPLStake;\n    uint256 ethMatched;\n    uint256 ethMatchedLimit;\n    uint256 minipoolCount;\n    uint256 balanceETH;\n    uint256 balanceRETH;\n    uint256 balanceRPL;\n    uint256 balanceOldRPL;\n    uint256 depositCreditBalance;\n    uint256 distributorBalanceUserETH;\n    uint256 distributorBalanceNodeETH;\n    address withdrawalAddress;\n    address pendingWithdrawalAddress;\n    bool smoothingPoolRegistrationState;\n    uint256 smoothingPoolRegistrationChanged;\n    address nodeAddress;\n}\n"
    },
    "contracts/interface/node/RocketNodeManagerInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.5.0 <0.9.0;\npragma abicoder v2;\n\nimport \"../../types/NodeDetails.sol\";\n\ninterface RocketNodeManagerInterface {\n\n    // Structs\n    struct TimezoneCount {\n        string timezone;\n        uint256 count;\n    }\n\n    function getNodeCount() external view returns (uint256);\n    function getNodeCountPerTimezone(uint256 offset, uint256 limit) external view returns (TimezoneCount[] memory);\n    function getNodeAt(uint256 _index) external view returns (address);\n    function getNodeExists(address _nodeAddress) external view returns (bool);\n    function getNodeWithdrawalAddress(address _nodeAddress) external view returns (address);\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external view returns (address);\n    function getNodeRPLWithdrawalAddress(address _nodeAddress) external view returns (address);\n    function getNodeRPLWithdrawalAddressIsSet(address _nodeAddress) external view returns (bool);\n    function unsetRPLWithdrawalAddress(address _nodeAddress) external;\n    function setRPLWithdrawalAddress(address _nodeAddress, address _newRPLWithdrawalAddress, bool _confirm) external;\n    function confirmRPLWithdrawalAddress(address _nodeAddress) external;\n    function getNodePendingRPLWithdrawalAddress(address _nodeAddress) external view returns (address);\n    function getNodeTimezoneLocation(address _nodeAddress) external view returns (string memory);\n    function registerNode(string calldata _timezoneLocation) external;\n    function getNodeRegistrationTime(address _nodeAddress) external view returns (uint256);\n    function setTimezoneLocation(string calldata _timezoneLocation) external;\n    function setRewardNetwork(address _nodeAddress, uint256 network) external;\n    function getRewardNetwork(address _nodeAddress) external view returns (uint256);\n    function getFeeDistributorInitialised(address _nodeAddress) external view returns (bool);\n    function initialiseFeeDistributor() external;\n    function getAverageNodeFee(address _nodeAddress) external view returns (uint256);\n    function setSmoothingPoolRegistrationState(bool _state) external;\n    function getSmoothingPoolRegistrationState(address _nodeAddress) external returns (bool);\n    function getSmoothingPoolRegistrationChanged(address _nodeAddress) external returns (uint256);\n    function getSmoothingPoolRegisteredNodeCount(uint256 _offset, uint256 _limit) external view returns (uint256);\n    function getNodeDetails(address _nodeAddress) external view returns (NodeDetails memory);\n    function getNodeAddresses(uint256 _offset, uint256 _limit) external view returns (address[] memory);\n}\n"
    },
    "@openzeppelin4/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "contracts/interface/util/IERC20.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\n// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity >0.5.0 <0.9.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "contracts/interface/token/RocketTokenRPLInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"../util/IERC20.sol\";\n\ninterface RocketTokenRPLInterface is IERC20 {\n    function getInflationCalcTime() external view returns(uint256);\n    function getInflationIntervalTime() external view returns(uint256);\n    function getInflationIntervalRate() external view returns(uint256);\n    function getInflationIntervalsPassed() external view returns(uint256);\n    function getInflationIntervalStartTime() external view returns(uint256);\n    function getInflationRewardsContractAddress() external view returns(address);\n    function inflationCalculate() external view returns (uint256);\n    function inflationMintTokens() external returns (uint256);\n    function swapTokens(uint256 _amount) external;\n}\n"
    },
    "contracts/types/SettingType.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nenum SettingType {\n  UINT256,\n  BOOL,\n  ADDRESS,\n  STRING,\n  BYTES,\n  BYTES32,\n  INT256\n}\n"
    },
    "contracts/interface/dao/protocol/RocketDAOProtocolProposalsInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.5.0 <0.9.0;\npragma abicoder v2;\n\nimport \"../../../types/SettingType.sol\";\n\ninterface RocketDAOProtocolProposalsInterface {\n    function proposalSettingMulti(string[] memory _settingContractNames, string[] memory _settingPaths, SettingType[] memory _types, bytes[] memory _data) external;\n    function proposalSettingUint(string memory _settingContractName, string memory _settingPath, uint256 _value) external;\n    function proposalSettingBool(string memory _settingContractName, string memory _settingPath, bool _value) external;\n    function proposalSettingAddress(string memory _settingContractName, string memory _settingPath, address _value) external;\n    function proposalSettingRewardsClaimers(uint256 _trustedNodePercent, uint256 _protocolPercent, uint256 _nodePercent) external;\n\n    function proposalTreasuryOneTimeSpend(string memory _invoiceID, address _recipientAddress, uint256 _amount) external;\n    function proposalTreasuryNewContract(string memory _contractName, address _recipientAddress, uint256 _amountPerPeriod, uint256 _periodLength, uint256 _startTime, uint256 _numPeriods) external;\n    function proposalTreasuryUpdateContract(string memory _contractName, address _recipientAddress, uint256 _amountPerPeriod, uint256 _periodLength, uint256 _numPeriods) external;\n\n    function proposalSecurityInvite(string memory _id, address _memberAddress) external;\n    function proposalSecurityKick(address _memberAddress) external;\n    function proposalSecurityKickMulti(address[] calldata _memberAddresses) external;\n    function proposalSecurityReplace(address _existingMemberAddress, string calldata _id, address _newMemberAddress) external;\n}\n"
    },
    "contracts/interface/dao/RocketDAOProposalInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketDAOProposalInterface {\n\n    // Possible states that a proposal may be in\n    enum ProposalState {\n        Pending,\n        Active,\n        Cancelled,\n        Defeated,\n        Succeeded,\n        Expired,\n        Executed\n    }\n\n    function getTotal() external view returns (uint256);\n    function getDAO(uint256 _proposalID) external view returns (string memory);\n    function getProposer(uint256 _proposalID) external view returns (address);\n    function getMessage(uint256 _proposalID) external view returns (string memory);\n    function getStart(uint256 _proposalID) external view returns (uint256);\n    function getEnd(uint256 _proposalID) external view returns (uint256);\n    function getExpires(uint256 _proposalID) external view returns (uint256);\n    function getCreated(uint256 _proposalID) external view returns (uint256);\n    function getVotesFor(uint256 _proposalID) external view returns (uint256);\n    function getVotesAgainst(uint256 _proposalID) external view returns (uint256);\n    function getVotesRequired(uint256 _proposalID) external view returns (uint256);\n    function getCancelled(uint256 _proposalID) external view returns (bool);\n    function getExecuted(uint256 _proposalID) external view returns (bool);\n    function getPayload(uint256 _proposalID) external view returns (bytes memory);\n    function getReceiptHasVoted(uint256 _proposalID, address _nodeAddress) external view returns (bool);\n    function getReceiptSupported(uint256 _proposalID, address _nodeAddress) external view returns (bool);\n    function getState(uint256 _proposalID) external view returns (ProposalState);\n    function add(address _member, string memory _dao, string memory _message, uint256 _startBlock, uint256 _durationBlocks, uint256 _expiresBlocks, uint256 _votesRequired, bytes memory _payload) external returns (uint256);\n    function vote(address _member, uint256 _votes, uint256 _proposalID, bool _support) external;\n    function cancel(address _member, uint256 _proposalID) external;\n    function execute(uint256 _proposalID) external;\n    \n}\n"
    },
    "contracts/interface/node/RocketNodeStakingInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.5.0 <0.9.0;\n\ninterface RocketNodeStakingInterface {\n    function getTotalRPLStake() external view returns (uint256);\n    function getNodeRPLStake(address _nodeAddress) external view returns (uint256);\n    function getNodeETHMatched(address _nodeAddress) external view returns (uint256);\n    function getNodeETHProvided(address _nodeAddress) external view returns (uint256);\n    function getNodeETHCollateralisationRatio(address _nodeAddress) external view returns (uint256);\n    function getNodeRPLStakedTime(address _nodeAddress) external view returns (uint256);\n    function getNodeEffectiveRPLStake(address _nodeAddress) external view returns (uint256);\n    function getNodeMinimumRPLStake(address _nodeAddress) external view returns (uint256);\n    function getNodeMaximumRPLStake(address _nodeAddress) external view returns (uint256);\n    function getNodeETHMatchedLimit(address _nodeAddress) external view returns (uint256);\n    function getRPLLockingAllowed(address _nodeAddress) external view returns (bool);\n    function stakeRPL(uint256 _amount) external;\n    function stakeRPLFor(address _nodeAddress, uint256 _amount) external;\n    function setRPLLockingAllowed(address _nodeAddress, bool _allowed) external;\n    function setStakeRPLForAllowed(address _caller, bool _allowed) external;\n    function setStakeRPLForAllowed(address _nodeAddress, address _caller, bool _allowed) external;\n    function getNodeRPLLocked(address _nodeAddress) external view returns (uint256);\n    function lockRPL(address _nodeAddress, uint256 _amount) external;\n    function unlockRPL(address _nodeAddress, uint256 _amount) external;\n    function transferRPL(address _from, address _to, uint256 _amount) external;\n    function burnRPL(address _from, uint256 _amount) external;\n    function withdrawRPL(uint256 _amount) external;\n    function withdrawRPL(address _nodeAddress, uint256 _amount) external;\n    function slashRPL(address _nodeAddress, uint256 _ethSlashAmount) external;\n}\n"
    },
    "contracts/interface/dao/protocol/settings/RocketDAOProtocolSettingsProposalsInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketDAOProtocolSettingsProposalsInterface {\n    function getVotePhase1Time() external view returns(uint256);\n    function getVotePhase2Time() external view returns(uint256);\n    function getVoteDelayTime() external view returns(uint256);\n    function getExecuteTime() external view returns(uint256);\n    function getProposalBond() external view returns(uint256);\n    function getChallengeBond() external view returns(uint256);\n    function getChallengePeriod() external view returns(uint256);\n    function getProposalQuorum() external view returns (uint256);\n    function getProposalVetoQuorum() external view returns (uint256);\n    function getProposalMaxBlockAge() external view returns (uint256);\n}\n"
    },
    "contracts/interface/dao/protocol/RocketDAOProtocolProposalInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.5.0 <0.9.0;\npragma abicoder v2;\n\nimport \"../../../types/SettingType.sol\";\nimport \"./RocketDAOProtocolVerifierInterface.sol\";\n\ninterface RocketDAOProtocolProposalInterface {\n    // Possible states that a proposal may be in\n    enum ProposalState {\n        Pending,\n        ActivePhase1,\n        ActivePhase2,\n        Destroyed,\n        Vetoed,\n        QuorumNotMet,\n        Defeated,\n        Succeeded,\n        Expired,\n        Executed\n    }\n\n    enum VoteDirection {\n        NoVote,\n        Abstain,\n        For,\n        Against,\n        AgainstWithVeto\n    }\n\n    function getTotal() external view returns (uint256);\n    function getProposer(uint256 _proposalID) external view returns (address);\n    function getMessage(uint256 _proposalID) external view returns (string memory);\n    function getStart(uint256 _proposalID) external view returns (uint256);\n    function getPhase1End(uint256 _proposalID) external view returns (uint256);\n    function getPhase2End(uint256 _proposalID) external view returns (uint256);\n    function getExpires(uint256 _proposalID) external view returns (uint256);\n    function getCreated(uint256 _proposalID) external view returns (uint256);\n    function getVotingPowerFor(uint256 _proposalID) external view returns (uint256);\n    function getVotingPowerAgainst(uint256 _proposalID) external view returns (uint256);\n    function getVotingPowerVeto(uint256 _proposalID) external view returns (uint256);\n    function getVotingPowerAbstained(uint256 _proposalID) external view returns (uint256);\n    function getVotingPowerRequired(uint256 _proposalID) external view returns (uint256);\n    function getDestroyed(uint256 _proposalID) external view returns (bool);\n    function getFinalised(uint256 _proposalID) external view returns (bool);\n    function getExecuted(uint256 _proposalID) external view returns (bool);\n    function getVetoQuorum(uint256 _proposalID) external view returns (uint256);\n    function getVetoed(uint256 _proposalID) external view returns (bool);\n    function getPayload(uint256 _proposalID) external view returns (bytes memory);\n    function getReceiptHasVoted(uint256 _proposalID, address _nodeAddress) external view returns (bool);\n    function getReceiptHasVotedPhase1(uint256 _proposalID, address _nodeAddress) external view returns (bool);\n    function getReceiptDirection(uint256 _proposalID, address _nodeAddress) external view returns (VoteDirection);\n    function getState(uint256 _proposalID) external view returns (ProposalState);\n\n    function getProposalBlock(uint256 _proposalID) external view returns (uint256);\n    function getProposalVetoQuorum(uint256 _proposalID) external view returns (uint256);\n\n    function propose(string memory _proposalMessage, bytes memory _payload, uint32 _blockNumber, Types.Node[] calldata _treeNodes) external returns (uint256);\n    function vote(uint256 _proposalID, VoteDirection _vote, uint256 _votingPower, uint256 _nodeIndex, Types.Node[] calldata _witness) external;\n    function overrideVote(uint256 _proposalID, VoteDirection _voteDirection) external;\n    function finalise(uint256 _proposalID) external;\n    function execute(uint256 _proposalID) external;\n    function destroy(uint256 _proposalID) external;\n}\n"
    },
    "contracts/contract/dao/protocol/RocketDAOProtocolVerifier.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.18;\n\nimport \"../../RocketBase.sol\";\nimport \"../../../interface/dao/protocol/RocketDAOProtocolVerifierInterface.sol\";\nimport \"../../../interface/network/RocketNetworkVotingInterface.sol\";\nimport \"../../../interface/node/RocketNodeManagerInterface.sol\";\n\nimport \"@openzeppelin4/contracts/utils/math/Math.sol\";\nimport \"../../../interface/token/RocketTokenRPLInterface.sol\";\nimport \"../../../interface/dao/protocol/RocketDAOProtocolProposalsInterface.sol\";\nimport \"../../../interface/dao/RocketDAOProposalInterface.sol\";\nimport \"../../../interface/node/RocketNodeStakingInterface.sol\";\nimport \"../../../interface/dao/protocol/settings/RocketDAOProtocolSettingsProposalsInterface.sol\";\nimport \"../../../interface/dao/protocol/RocketDAOProtocolProposalInterface.sol\";\n\n/// @notice Implements the protocol DAO optimistic fraud proof proposal system\ncontract RocketDAOProtocolVerifier is RocketBase, RocketDAOProtocolVerifierInterface {\n\n    uint256 constant internal depthPerRound = 5;\n\n    // Packing constants for packing challenge data into a single uint256\n    uint256 constant internal stateOffset = (256 - 8);\n    uint256 constant internal timestampOffset = (256 - 8 - 64);\n    uint256 constant internal addressOffset = (256 - 8 - 64 - 160);\n\n    // Offsets into storage for proposal details\n    uint256 constant internal proposerOffset = 0;\n    uint256 constant internal blockNumberOffset = 1;\n    uint256 constant internal nodeCountOffset = 2;\n    uint256 constant internal defeatIndexOffset = 3;\n    uint256 constant internal proposalBondOffset = 4;\n    uint256 constant internal challengeBondOffset = 5;\n    uint256 constant internal challengePeriodOffset = 6;\n\n    // Offsets into storage for challenge details\n    uint256 constant internal challengeStateOffset = 0;\n    uint256 constant internal sumOffset = 1;\n    uint256 constant internal hashOffset = 2;\n\n    // Burn rate\n    uint256 constant internal bondBurnPercent = 0.2 ether;\n\n    // Events\n    event RootSubmitted(uint256 indexed proposalID, address indexed proposer, uint32 blockNumber, uint256 index, Types.Node root, Types.Node[] treeNodes, uint256 timestamp);\n    event ChallengeSubmitted(uint256 indexed proposalID, address indexed challenger, uint256 index, uint256 timestamp);\n    event ProposalBondBurned(uint256 indexed proposalID, address indexed proposer, uint256 amount, uint256 timestamp);\n\n    // Construct\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketBase(_rocketStorageAddress) {\n        // Version\n        version = 2;\n    }\n\n    /// @notice Returns the depth per round\n    function getDepthPerRound() override external pure returns (uint256) {\n        return depthPerRound;\n    }\n\n    /// @notice Returns the defeat index for this proposal\n    /// @param _proposalID The proposal to fetch details\n    function getDefeatIndex(uint256 _proposalID) override external view returns (uint256) {\n        // Fetch the proposal key\n        uint256 proposalKey = uint256(keccak256(abi.encodePacked(\"dao.protocol.proposal\", _proposalID)));\n        return getUint(bytes32(proposalKey + defeatIndexOffset));\n    }\n\n    /// @notice Returns the proposal bond for this proposal\n    /// @param _proposalID The proposal to fetch details\n    function getProposalBond(uint256 _proposalID) override external view returns (uint256) {\n        // Fetch the proposal key\n        uint256 proposalKey = uint256(keccak256(abi.encodePacked(\"dao.protocol.proposal\", _proposalID)));\n        return getUint(bytes32(proposalKey + proposalBondOffset));\n    }\n\n    /// @notice Returns the challenge bond for this proposal\n    /// @param _proposalID The proposal to fetch details\n    function getChallengeBond(uint256 _proposalID) override external view returns (uint256) {\n        // Fetch the proposal key\n        uint256 proposalKey = uint256(keccak256(abi.encodePacked(\"dao.protocol.proposal\", _proposalID)));\n        return getUint(bytes32(proposalKey + challengeBondOffset));\n    }\n\n    /// @notice Returns the duration of the challenge period for this proposal\n    /// @param _proposalID The proposal to fetch details\n    function getChallengePeriod(uint256 _proposalID) override external view returns (uint256) {\n        // Fetch the proposal key\n        uint256 proposalKey = uint256(keccak256(abi.encodePacked(\"dao.protocol.proposal\", _proposalID)));\n        return getUint(bytes32(proposalKey + challengePeriodOffset));\n    }\n\n    /// @dev Called during a proposal submission to calculate and store the proposal root so it is available for challenging\n    /// @param _proposalID The ID of the proposal\n    /// @param _proposer The node raising the proposal\n    /// @param _blockNumber The block number used to generate the voting power tree\n    /// @param _treeNodes A pollard of the voting power tree\n    function submitProposalRoot(uint256 _proposalID, address _proposer, uint32 _blockNumber, Types.Node[] calldata _treeNodes) external onlyLatestContract(\"rocketDAOProtocolProposal\", msg.sender) onlyLatestContract(\"rocketDAOProtocolVerifier\", address(this)) {\n        // Retrieve the node count at _blockNumber\n        uint256 nodeCount;\n        {\n            RocketNetworkVotingInterface rocketNetworkVoting = RocketNetworkVotingInterface(getContractAddress(\"rocketNetworkVoting\"));\n            nodeCount = rocketNetworkVoting.getNodeCount(_blockNumber);\n        }\n\n        // Verify proposer supplied correct number of nodes for the pollard\n        {\n            uint256 maxDepth = getMaxDepth(nodeCount);\n\n            if (maxDepth < depthPerRound) {\n                uint256 leafCount = 2 ** maxDepth;\n                require(_treeNodes.length == leafCount, \"Invalid node count\");\n            } else {\n                require(_treeNodes.length == 2 ** depthPerRound, \"Invalid node count\");\n            }\n        }\n\n        // Compute the proposal root from the supplied nodes\n        Types.Node memory root = computeRootFromNodes(_treeNodes);\n\n        {\n            RocketDAOProtocolSettingsProposalsInterface rocketDAOProtocolSettingsProposals = RocketDAOProtocolSettingsProposalsInterface(getContractAddress(\"rocketDAOProtocolSettingsProposals\"));\n\n            // Get the current proposal bond amount\n            uint256 proposalBond = rocketDAOProtocolSettingsProposals.getProposalBond();\n\n            // Lock the proposal bond (will revert if proposer doesn't have enough effective RPL staked)\n            RocketNodeStakingInterface rocketNodeStaking = RocketNodeStakingInterface(getContractAddress(\"rocketNodeStaking\"));\n            rocketNodeStaking.lockRPL(_proposer, proposalBond);\n\n            // Store proposal details\n            uint256 proposalKey = uint256(keccak256(abi.encodePacked(\"dao.protocol.proposal\", _proposalID)));\n            setAddress(bytes32(proposalKey + proposerOffset), _proposer);\n            setUint(bytes32(proposalKey + blockNumberOffset), _blockNumber);\n            setUint(bytes32(proposalKey + nodeCountOffset), nodeCount);\n            setUint(bytes32(proposalKey + proposalBondOffset), proposalBond);\n            setUint(bytes32(proposalKey + challengeBondOffset), rocketDAOProtocolSettingsProposals.getChallengeBond());\n            setUint(bytes32(proposalKey + challengePeriodOffset), rocketDAOProtocolSettingsProposals.getChallengePeriod());\n        }\n\n        // The root was supplied so mark that index (1) as responded and store the node\n        setNode(_proposalID, 1, root);\n        uint256 state = uint256(Types.ChallengeState.Responded) << stateOffset;\n        state |= block.timestamp << timestampOffset;\n        setUint(keccak256(abi.encodePacked(\"dao.protocol.proposal.challenge\", _proposalID, uint256(1))), state);\n\n        // Emit event\n        emit RootSubmitted(_proposalID, _proposer, _blockNumber, 1, root, _treeNodes, block.timestamp);\n    }\n\n    /// @dev Called by proposal contract to burn the bond of the proposer after a successful veto\n    /// @param _proposalID the proposal ID that will have the bond burnt\n    function burnProposalBond(uint256 _proposalID) override external onlyLatestContract(\"rocketDAOProtocolProposal\", address(msg.sender)) onlyLatestContract(\"rocketDAOProtocolVerifier\", address(this)) {\n        // Retrieved required inputs from storage\n        uint256 proposalKey = uint256(keccak256(abi.encodePacked(\"dao.protocol.proposal\", _proposalID)));\n        address proposer = getAddress(bytes32(proposalKey + proposerOffset));\n        uint256 proposalBond = getUint(bytes32(proposalKey + proposalBondOffset));\n        // Unlock and burn\n        RocketNodeStakingInterface rocketNodeStaking = RocketNodeStakingInterface(getContractAddress(\"rocketNodeStaking\"));\n        rocketNodeStaking.unlockRPL(proposer, proposalBond);\n        rocketNodeStaking.burnRPL(proposer, proposalBond);\n        // Log it\n        emit ProposalBondBurned(_proposalID, proposer, proposalBond, block.timestamp);\n    }\n\n    /// @notice Used by a verifier to challenge a specific index of a proposal's voting power tree\n    /// @param _proposalID The ID of the proposal being challenged\n    /// @param _index The global index of the node being challenged\n    /// @param _node The node that is being challenged as submitted by the proposer\n    /// @param _witness A merkle proof of the challenged node (using the previously challenged index as a root)\n    function createChallenge(uint256 _proposalID, uint256 _index, Types.Node calldata _node, Types.Node[] calldata _witness) external onlyLatestContract(\"rocketDAOProtocolVerifier\", address(this)) onlyRegisteredNode(msg.sender) {\n        {  // Scope to prevent stack too deep\n            // Check whether the proposal is on the Pending state\n            RocketDAOProtocolProposalInterface daoProposal = RocketDAOProtocolProposalInterface(getContractAddress(\"rocketDAOProtocolProposal\"));\n            RocketDAOProtocolProposalInterface.ProposalState proposalState = daoProposal.getState(_proposalID);\n            require(proposalState == RocketDAOProtocolProposalInterface.ProposalState.Pending, \"Can only challenge while proposal is Pending\");\n        }\n        // Precompute the proposal key\n        uint256 proposalKey = uint256(keccak256(abi.encodePacked(\"dao.protocol.proposal\", _proposalID)));\n\n        // Retrieve the node count of this proposal\n        uint256 nodeCount = getUint(bytes32(proposalKey + nodeCountOffset));\n        uint256 maxDepth = getMaxDepth(nodeCount);\n        {\n            // Check depth doesn't exceed the extended tree\n            uint256 depth = getDepthFromIndex(_index);\n            require(depth < maxDepth * 2, \"Invalid index depth\");\n        }\n\n        // Check for existing challenge against this index\n        {\n            bytes32 challengeKey = keccak256(abi.encodePacked(\"dao.protocol.proposal.challenge\", _proposalID, _index));\n            uint256 challengeData = getUint(challengeKey);\n            require(challengeData == 0, \"Index already challenged\");\n            // Write challenge\n            challengeData = uint256(Types.ChallengeState.Challenged) << stateOffset;\n            challengeData |= block.timestamp << timestampOffset;\n            challengeData |= uint256(uint160(msg.sender)) << addressOffset;\n            setUint(challengeKey, challengeData);\n        }\n\n        // Check the proposal hasn't already been defeated\n        require(getUint(bytes32(proposalKey+defeatIndexOffset)) == 0, \"Proposal already defeated\");\n\n        // Verify the validity of the challenge proof\n        {\n            // Check depth is exactly one round deeper than a previous challenge (or the proposal root)\n            uint256 previousIndex = getPollardRootIndex(_index, nodeCount);\n            require(_getChallengeState(getUint(keccak256(abi.encodePacked(\"dao.protocol.proposal.challenge\", _proposalID, previousIndex)))) == Types.ChallengeState.Responded, \"Invalid challenge depth\");\n\n            // Check the proof contains the expected number of nodes\n            require(_witness.length == getDepthFromIndex(_index) - getDepthFromIndex(previousIndex), \"Invalid proof length\");\n\n            // Get expected node and compute provided root node then compare\n            Types.Node memory _expected = getNode(_proposalID, previousIndex);\n            Types.Node memory rootFromWitness = computeRootFromWitness(_index, _node, _witness);\n            require(rootFromWitness.hash == _expected.hash, \"Invalid hash\");\n            require(rootFromWitness.sum == _expected.sum, \"Invalid sum\");\n\n            // Store the node\n            setNode(_proposalID, _index, _node);\n        }\n\n        // Lock the challenger's bond (reverts if not enough effective RPL)\n        {\n            uint256 challengeBond = getUint(bytes32(proposalKey + challengeBondOffset));\n            RocketNodeStakingInterface rocketNodeStaking = RocketNodeStakingInterface(getContractAddress(\"rocketNodeStaking\"));\n            rocketNodeStaking.lockRPL(msg.sender, challengeBond);\n        }\n\n        // Emit event\n        emit ChallengeSubmitted(_proposalID, msg.sender, _index, block.timestamp);\n    }\n\n    /// @notice Can be called if proposer fails to respond to a challenge within the required time limit. Destroys the proposal if successful\n    /// @param _proposalID The ID of the challenged proposal\n    /// @param _index The index which was failed to respond to\n    function defeatProposal(uint256 _proposalID, uint256 _index) external onlyLatestContract(\"rocketDAOProtocolVerifier\", address(this)) onlyRegisteredNode(msg.sender) {\n        {  // Scope to prevent stack too deep\n            // Check whether the proposal is in the Pending state\n            RocketDAOProtocolProposalInterface daoProposal = RocketDAOProtocolProposalInterface(getContractAddress(\"rocketDAOProtocolProposal\"));\n            RocketDAOProtocolProposalInterface.ProposalState proposalState = daoProposal.getState(_proposalID);\n            require(proposalState == RocketDAOProtocolProposalInterface.ProposalState.Pending, \"Can not defeat a valid proposal\");\n        }\n\n        // Check the challenge at the given index has not been responded to\n        bytes32 challengeKey = keccak256(abi.encodePacked(\"dao.protocol.proposal.challenge\", _proposalID, _index));\n        uint256 data = getUint(challengeKey);\n        Types.ChallengeState state = _getChallengeState(data);\n        require(state == Types.ChallengeState.Challenged, \"Invalid challenge state\");\n\n        uint256 proposalKey = uint256(keccak256(abi.encodePacked(\"dao.protocol.proposal\", _proposalID)));\n\n        // Precompute defeat index key\n        bytes32 defeatIndexKey = bytes32(proposalKey+defeatIndexOffset);\n        uint256 challengePeriod = getUint(bytes32(proposalKey + challengePeriodOffset));\n\n        // Check the proposal hasn't already been defeated\n        uint256 defeatIndex = getUint(defeatIndexKey);\n        require(defeatIndex == 0, \"Proposal already defeated\");\n\n        // Check enough time has passed\n        uint256 timestamp = getChallengeTimestamp(data);\n        require(block.timestamp > timestamp + challengePeriod, \"Not enough time has passed\");\n\n        // Destroy the proposal\n        RocketDAOProtocolProposalInterface rocketDAOProtocolProposal = RocketDAOProtocolProposalInterface(getContractAddress(\"rocketDAOProtocolProposal\"));\n        rocketDAOProtocolProposal.destroy(_proposalID);\n\n        // Record the winning index for reward payments\n        setUint(defeatIndexKey, _index);\n    }\n\n    /// @notice Called by a challenger to claim bonds (both refunded bonds and any rewards paid minus the 20% bond burn)\n    /// @param _proposalID The ID of the proposal\n    /// @param _indices An array of indices which the challenger has a claim against\n    function claimBondChallenger(uint256 _proposalID, uint256[] calldata _indices) external onlyLatestContract(\"rocketDAOProtocolVerifier\", address(this)) onlyRegisteredNode(msg.sender) {\n        {  // Scope to prevent stack too deep\n            // Check whether the proposal is NOT on the Pending state\n            RocketDAOProtocolProposalInterface daoProposal = RocketDAOProtocolProposalInterface(getContractAddress(\"rocketDAOProtocolProposal\"));\n            RocketDAOProtocolProposalInterface.ProposalState proposalState = daoProposal.getState(_proposalID);\n            require(proposalState != RocketDAOProtocolProposalInterface.ProposalState.Pending, \"Can not claim bond while proposal is Pending\");\n        }\n        // Check whether the proposal was defeated\n        uint256 defeatIndex = getUint(bytes32(uint256(keccak256(abi.encodePacked(\"dao.protocol.proposal\", _proposalID)))+defeatIndexOffset));\n        bool defeated = defeatIndex != 0;\n\n        // Keep track of the number of indices the claimer had which were involved in defeating the proposal\n        uint256 rewardedIndices = 0;\n\n        for (uint256 i = 0; i < _indices.length; ++i) {\n            bytes32 challengeKey = keccak256(abi.encodePacked(\"dao.protocol.proposal.challenge\", _proposalID, _indices[i]));\n            uint256 challengeData = getUint(challengeKey);\n            Types.ChallengeState challengeState = _getChallengeState(challengeData);\n\n            if (defeated) {\n                // Refund all challenges if the proposal was defeated\n                require(challengeState == Types.ChallengeState.Responded || challengeState == Types.ChallengeState.Challenged, \"Invalid challenge state\");\n            } else {\n                // Only refund non-responded challenges if the proposal wasn't defeated\n                require(challengeState == Types.ChallengeState.Challenged, \"Invalid challenge state\");\n            }\n\n            // Check the challenger is the caller\n            address challenger = address(uint160(challengeData >> addressOffset));\n            require(msg.sender == challenger, \"Invalid challenger\");\n\n            // Increment reward indices if required\n            if (isRewardedIndex(defeatIndex, _indices[i])) {\n                rewardedIndices++;\n            }\n\n            // Mark index as paid\n            challengeData = setChallengeState(challengeData, Types.ChallengeState.Paid);\n            setUint(challengeKey, challengeData);\n        }\n\n        // Get staking contract\n        RocketNodeStakingInterface rocketNodeStaking = RocketNodeStakingInterface(getContractAddress(\"rocketNodeStaking\"));\n\n        // Unlock challenger bond\n        uint256 proposalKey = uint256(keccak256(abi.encodePacked(\"dao.protocol.proposal\", _proposalID)));\n        uint256 challengeBond = getUint(bytes32(proposalKey + challengeBondOffset));\n        uint256 totalBond = _indices.length * challengeBond;\n        rocketNodeStaking.unlockRPL(msg.sender, totalBond);\n\n        // Pay challenger their reward\n        if (rewardedIndices > 0) {\n            uint256 proposalBond = getUint(bytes32(proposalKey + proposalBondOffset));\n            // Calculate the number of challenges involved in defeating the proposal\n            uint256 nodeCount = getUint(bytes32(proposalKey + nodeCountOffset));\n            uint256 totalDefeatingIndices = getRoundsFromIndex(defeatIndex, nodeCount);\n            uint256 totalReward = proposalBond * rewardedIndices / totalDefeatingIndices;\n            uint256 burnAmount = totalReward * bondBurnPercent / calcBase;\n            // Unlock the reward amount from the proposer and transfer it to the challenger\n            address proposer = getAddress(bytes32(proposalKey + proposerOffset));\n            rocketNodeStaking.unlockRPL(proposer, totalReward);\n            rocketNodeStaking.burnRPL(proposer, burnAmount);\n            rocketNodeStaking.transferRPL(proposer, msg.sender, totalReward - burnAmount);\n        }\n    }\n\n    /// @notice Called by a proposer to claim bonds (both refunded bond and any rewards paid minus the 20% bond burn)\n    /// @param _proposalID The ID of the proposal\n    /// @param _indices An array of indices which the proposer has a claim against\n    function claimBondProposer(uint256 _proposalID, uint256[] calldata _indices) external onlyLatestContract(\"rocketDAOProtocolVerifier\", address(this)) onlyRegisteredNode(msg.sender) {\n        uint256 defeatIndex = getUint(bytes32(uint256(keccak256(abi.encodePacked(\"dao.protocol.proposal\", _proposalID)))+defeatIndexOffset));\n\n        // Proposer has nothing to claim if their proposal was defeated\n        require(defeatIndex == 0, \"Proposal defeated\");\n\n        // Check the proposal has passed the waiting period and the voting period and wasn't cancelled\n        {\n            RocketDAOProtocolProposalInterface daoProposal = RocketDAOProtocolProposalInterface(getContractAddress(\"rocketDAOProtocolProposal\"));\n            RocketDAOProtocolProposalInterface.ProposalState proposalState = daoProposal.getState(_proposalID);\n            require(proposalState >= RocketDAOProtocolProposalInterface.ProposalState.QuorumNotMet, \"Invalid proposal state\");\n        }\n\n        address proposer;\n        uint256 challengeBond;\n        uint256 proposalBond;\n        {\n            uint256 proposalKey = uint256(keccak256(abi.encodePacked(\"dao.protocol.proposal\", _proposalID)));\n            proposer = getAddress(bytes32(proposalKey + proposerOffset));\n            // Only the proposer can call\n            require(msg.sender == proposer, \"Not proposer\");\n            // Query proposal bond params\n            challengeBond = getUint(bytes32(proposalKey + challengeBondOffset));\n            proposalBond = getUint(bytes32(proposalKey + proposalBondOffset));\n        }\n\n        // Get staking contract\n        RocketNodeStakingInterface rocketNodeStaking = RocketNodeStakingInterface(getContractAddress(\"rocketNodeStaking\"));\n\n        uint256 burnPerChallenge = challengeBond * bondBurnPercent / calcBase;\n\n        for (uint256 i = 0; i < _indices.length; ++i) {\n            // Check the challenge of the given index was responded to\n            bytes32 challengeKey = keccak256(abi.encodePacked(\"dao.protocol.proposal.challenge\", _proposalID, _indices[i]));\n            uint256 state = getUint(challengeKey);\n\n            // Proposer can only claim the reward on indices they responded to\n            require(_getChallengeState(state) == Types.ChallengeState.Responded, \"Invalid challenge state\");\n\n            // Mark index as paid\n            state = setChallengeState(state, Types.ChallengeState.Paid);\n            setUint(challengeKey, state);\n\n            // If claiming the root at this stage, then we return the proposal bond\n            if (_indices[i] == 1) {\n                rocketNodeStaking.unlockRPL(proposer, proposalBond);\n            } else {\n                // Unlock the challenger bond and pay to proposer\n                address challenger = getChallengeAddress(state);\n                rocketNodeStaking.unlockRPL(challenger, challengeBond);\n                rocketNodeStaking.transferRPL(challenger, proposer, challengeBond - burnPerChallenge);\n                rocketNodeStaking.burnRPL(challenger, burnPerChallenge);\n            }\n        }\n    }\n\n    /// @notice Used by a proposer to defend a challenged index\n    /// @param _proposalID The ID of the proposal\n    /// @param _index The global index of the node for which the proposer is submitting a new pollard\n    /// @param _nodes A list of nodes making up the new pollard\n    function submitRoot(uint256 _proposalID, uint256 _index, Types.Node[] calldata _nodes) external onlyLatestContract(\"rocketDAOProtocolVerifier\", address(this)) onlyRegisteredNode(msg.sender) {\n        uint256 proposalKey = uint256(keccak256(abi.encodePacked(\"dao.protocol.proposal\", _proposalID)));\n\n        {  // Scope to prevent stack too deep\n            // Check whether the proposal is in the Pending state\n            RocketDAOProtocolProposalInterface daoProposal = RocketDAOProtocolProposalInterface(getContractAddress(\"rocketDAOProtocolProposal\"));\n            RocketDAOProtocolProposalInterface.ProposalState proposalState = daoProposal.getState(_proposalID);\n            require(proposalState == RocketDAOProtocolProposalInterface.ProposalState.Pending, \"Can not submit root for a valid proposal\");\n            address proposer = getAddress(bytes32(proposalKey + proposerOffset));\n            require(msg.sender == proposer, \"Not proposer\");\n        }\n        {  // Scope to prevent stack too deep\n            // Get challenge state\n            bytes32 challengeKey = keccak256(abi.encodePacked(\"dao.protocol.proposal.challenge\", _proposalID, _index));\n            uint256 state = getUint(challengeKey);\n\n            // Make sure this index was actually challenged\n            require(_getChallengeState(state) == Types.ChallengeState.Challenged, \"Challenge does not exist\");\n\n            // Mark the index as responded\n            state = setChallengeState(state, Types.ChallengeState.Responded);\n            setUint(challengeKey, state);\n        }\n        // Check the proposal hasn't already been defeated\n        require(getUint(bytes32(proposalKey + defeatIndexOffset)) == 0, \"Proposal already defeated\");\n\n        // Verify correct number of nodes in the pollard\n        uint256 nodeCount = getUint(bytes32(proposalKey + nodeCountOffset));\n        uint256 indexDepth = Math.log2(_index, Math.Rounding.Down);\n        require(_nodes.length == 2 ** (getNextDepth(_index, nodeCount) - indexDepth), \"Invalid node count\");\n\n        Types.Node memory expected = getNode(_proposalID, _index);\n        Types.Node memory actual = computeRootFromNodes(_nodes);\n\n        // Check that the supplied nodes sum to the expected value\n        require(expected.sum == actual.sum, \"Invalid sum\");\n\n        // Determine if this index is a leaf node of the primary tree or sub tree\n        {\n            uint256 treeDepth = Math.log2(nodeCount, Math.Rounding.Up);\n\n            // Verify sub-tree leaves with known values\n            if (indexDepth + depthPerRound >= treeDepth * 2) {\n                // Calculate the offset into the leaf nodes in the final tree that match the supplied nodes\n                uint256 offset = (_index * (2 ** (getNextDepth(_index, nodeCount) - indexDepth))) - (2 ** (treeDepth * 2));\n                // Verify the leaves match the values we know on chain\n                require(verifyLeaves(getUint(bytes32(proposalKey + blockNumberOffset)), nodeCount, offset, _nodes), \"Invalid leaves\");\n            }\n\n            if (indexDepth == treeDepth) {\n                // The leaf node of the primary tree is just a hash of the sum\n                bytes32 actualHash = keccak256(abi.encodePacked(actual.sum));\n                require(expected.hash == actualHash, \"Invalid hash\");\n\n                // Update the node to include the root hash of the sub tree\n                setNode(_proposalID, _index, actual);\n            } else {\n                require(expected.hash == actual.hash, \"Invalid hash\");\n            }\n        }\n\n        // Emit event\n        emit RootSubmitted(_proposalID, getAddress(bytes32(proposalKey + proposerOffset)), uint32(getUint(bytes32(proposalKey + blockNumberOffset))), _index, actual, _nodes, block.timestamp);\n    }\n\n    /// @dev Checks a slice of the final nodes in a tree with the correct known on-chain values\n    /// @param _blockNumber The block number used to generate the voting power tree\n    /// @param _nodeCount The number of nodes that existed at the proposal block\n    /// @param _offset The pollard's offset into the leaves\n    /// @param _leaves The pollard's leaves\n    /// @return True if the leaves match what is known on chain\n    function verifyLeaves(uint256 _blockNumber, uint256 _nodeCount, uint256 _offset, Types.Node[] calldata _leaves) internal view returns (bool) {\n        // Get contracts\n        RocketNetworkVotingInterface rocketNetworkVoting = RocketNetworkVotingInterface(getContractAddress(\"rocketNetworkVoting\"));\n        RocketNodeManagerInterface rocketNodeManager = RocketNodeManagerInterface(getContractAddress(\"rocketNodeManager\"));\n        // Calculate the closest power of 2 of the node count\n        uint256 nodeCount = 2 ** Math.log2(_nodeCount, Math.Rounding.Up);\n        uint32 blockNumber32 = uint32(_blockNumber);\n        // Iterate over the leaves\n        for (uint256 i = 0; i < _leaves.length; ++i) {\n            // The leaf nodes are a 2d array of voting power in the form of [delegateIndex][nodeIndex] where both\n            // arrays are padded out to the closest power of 2 with zeros\n            uint256 nodeIndex = (_offset + i) % nodeCount;\n            uint256 delegateIndex = (_offset + i) / nodeCount;\n            // Determine the correct voting power for this leaf (fill with zero if > node count)\n            uint256 actual = 0;\n            if (nodeIndex < _nodeCount && delegateIndex < _nodeCount) {\n                // Calculate the node and the delegate referred to by this leaf node\n                address nodeAddress = rocketNodeManager.getNodeAt(nodeIndex);\n                address actualDelegate = rocketNetworkVoting.getDelegate(nodeAddress, blockNumber32);\n                // If a delegation exists, retrieve the node's voting power\n                if (actualDelegate == rocketNodeManager.getNodeAt(delegateIndex)) {\n                    actual = rocketNetworkVoting.getVotingPower(nodeAddress, blockNumber32);\n                }\n            }\n            // Check provided leaves against actual sum\n            if (_leaves[i].sum != actual) {\n                return false;\n            }\n            // Check provided leaves against hash\n            if (_leaves[i].hash != keccak256(abi.encodePacked(actual))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @notice Check if a vote is valid using a provided proof\n    /// @param _voter address of the node operator casting the vote\n    /// @param _nodeIndex index of the voting node\n    /// @param _proposalID ID of the proposal being voted\n    /// @param _votingPower VP being used with this vote\n    /// @param _witness A merkle proof that will be verified\n    function verifyVote(address _voter, uint256 _nodeIndex, uint256 _proposalID, uint256 _votingPower, Types.Node[] calldata _witness) external view returns (bool) {\n        // Get contracts\n        RocketNodeManagerInterface rocketNodeManager = RocketNodeManagerInterface(getContractAddress(\"rocketNodeManager\"));\n        // Verify voter\n        if(rocketNodeManager.getNodeAt(_nodeIndex) != _voter) {\n            return false;\n        }\n        // Load the proposal\n        uint256 proposalKey = uint256(keccak256(abi.encodePacked(\"dao.protocol.proposal\", _proposalID)));\n        // Calculate the network tree index for this voter\n        uint256 nodeCount = getUint(bytes32(proposalKey + nodeCountOffset));\n        uint256 depth = getMaxDepth(nodeCount);\n        uint256 treeIndex = (2 ** depth) + _nodeIndex;\n        // Reconstruct leaf node\n        Types.Node memory leaf;\n        leaf.sum = _votingPower;\n        leaf.hash = keccak256(abi.encodePacked(_votingPower));\n        // Retrieve the expected root node\n        Types.Node memory expected = getNode(_proposalID, 1);\n        // Compute a root from the supplied proof\n        Types.Node memory actual = computeRootFromWitness(treeIndex, leaf, _witness);\n        // Equality check\n        return (actual.sum == expected.sum && actual.hash == expected.hash);\n    }\n\n    /// @dev Computes the root node given a witness\n    /// @param _index The global index the proof is for\n    /// @param _leaf The node at the global index `_index`\n    /// @param _witness A merkle proof starting at the global index `_index`\n    /// @return The computed root node for the given witness\n    function computeRootFromWitness(uint256 _index, Types.Node memory _leaf, Types.Node[] calldata _witness) internal pure returns (Types.Node memory) {\n        Types.Node memory root = _leaf;\n        for (uint256 i = 0; i < _witness.length; ++i) {\n            if (_index % 2 == 1) {\n                root.hash = keccak256(abi.encodePacked(\n                        _witness[i].hash, _witness[i].sum,\n                        root.hash, root.sum\n                    ));\n            } else {\n                root.hash = keccak256(abi.encodePacked(\n                        root.hash, root.sum,\n                        _witness[i].hash, _witness[i].sum\n                    ));\n            }\n\n            root.sum += _witness[i].sum;\n            _index = _index / 2;\n        }\n        return root;\n    }\n\n    /// @dev Computes the root node given a pollard\n    /// @param _nodes An array of nodes to compute a root node for\n    /// @return The computed root node\n    function computeRootFromNodes(Types.Node[] calldata _nodes) internal pure returns (Types.Node memory) {\n        uint256 len = _nodes.length / 2;\n        // Perform first step into a new temporary memory buffer to leave original intact\n        Types.Node[] memory temp = new Types.Node[](len);\n        for (uint256 i = 0; i < len; ++i) {\n            temp[i].hash = keccak256(abi.encodePacked(\n                    _nodes[i * 2].hash, _nodes[i * 2].sum,\n                    _nodes[i * 2 + 1].hash, _nodes[i * 2 + 1].sum\n                ));\n            temp[i].sum = _nodes[i * 2].sum + _nodes[i * 2 + 1].sum;\n        }\n        // Compute the remainder within the temporary buffer\n        while (len > 1) {\n            len /= 2;\n            for (uint256 i = 0; i < len; ++i) {\n                temp[i].hash = keccak256(abi.encodePacked(\n                        temp[i * 2].hash, temp[i * 2].sum,\n                        temp[i * 2 + 1].hash, temp[i * 2 + 1].sum\n                    ));\n                temp[i].sum = temp[i * 2].sum + temp[i * 2 + 1].sum;\n            }\n        }\n        return temp[0];\n    }\n\n    /// @dev Calculates the depth of a given index\n    /// @param _index The global index to calculate a depth for\n    /// @return The depth of the global index `_index`\n    function getDepthFromIndex(uint256 _index) internal pure returns (uint256) {\n        return Math.log2(_index, Math.Rounding.Down);\n    }\n\n    /// @dev Calculates the number of rounds required to get to given index\n    /// @param _index The global index to calculate number of rounds for\n    /// @return The number of rounds it takes to get to the global index `_index`\n    function getRoundsFromIndex(uint256 _index, uint256 _nodeCount) internal pure returns (uint256) {\n        uint256 subTreeDepth = Math.log2(_nodeCount, Math.Rounding.Up);\n        uint256 indexDepth = Math.log2(_index, Math.Rounding.Down);\n\n        if (indexDepth <= subTreeDepth) {\n            return (indexDepth - 1) / depthPerRound + 1;\n        } else {\n            uint256 phase2Depth = indexDepth - subTreeDepth;\n            uint256 phase1Rounds = (subTreeDepth - 1) / depthPerRound + 1;\n            uint256 phase2Rounds = (phase2Depth - 1) / depthPerRound + 1;\n            return phase1Rounds + phase2Rounds;\n        }\n    }\n\n    /// @dev Calculates the max depth of a tree containing specified number of nodes\n    /// @param _nodeCount The number of nodes\n    /// @return The max depth of a tree with `_nodeCount` many nodes\n    function getMaxDepth(uint256 _nodeCount) internal pure returns (uint256) {\n        return Math.log2(_nodeCount, Math.Rounding.Up);\n    }\n\n    /// @dev Calculates the depth of the next round taking into account the max depth\n    /// @param _currentIndex The index to calculate the next depth for\n    /// @param _nodeCount The number of nodes\n    /// @return The next depth for a challenge\n    function getNextDepth(uint256 _currentIndex, uint256 _nodeCount) internal pure returns (uint256) {\n        uint256 currentDepth = getDepthFromIndex(_currentIndex);\n        uint256 maxDepth = getMaxDepth(_nodeCount);\n        uint256 nextDepth = currentDepth + depthPerRound;\n        if (nextDepth > maxDepth * 2) {\n            return maxDepth * 2;\n        } else if (nextDepth > maxDepth) {\n            if (currentDepth < maxDepth) {\n                return maxDepth;\n            }\n        }\n        return nextDepth;\n    }\n\n    /// @dev Calculates the root index of a pollard given the index of of one of its nodes\n    /// @param _index The index to calculate a pollard root index from\n    /// @return The pollard root index for node with global index of `_index`\n    function getPollardRootIndex(uint256 _index, uint256 _nodeCount) internal pure returns (uint256) {\n        require(_index > 1, \"Invalid index\");\n\n        uint256 indexDepth = Math.log2(_index, Math.Rounding.Down);\n        uint256 maxDepth = Math.log2(_nodeCount, Math.Rounding.Up);\n\n        if (indexDepth < maxDepth) {\n            // Index is leaf of phase 1 tree\n            uint256 remainder = indexDepth % depthPerRound;\n            require(remainder == 0, \"Invalid index\");\n            return _index / (2 ** depthPerRound);\n        } else if (indexDepth == maxDepth) {\n            // Index is a network tree leaf\n            uint256 remainder = indexDepth % depthPerRound;\n            return _index / (2 ** (remainder == 0 ? depthPerRound : remainder));\n        } else if (indexDepth < maxDepth * 2) {\n            // Index is phase 2 pollard\n            uint256 subIndexDepth = indexDepth - maxDepth;\n            uint256 remainder = subIndexDepth % depthPerRound;\n            require(remainder == 0, \"Invalid index\");\n            return _index / (2 ** depthPerRound);\n        }\n        revert(\"Invalid index\");\n    }\n\n    /// @dev Returns true if the given `_index` is in the path from the proposal root down to `_defeatIndex`\n    /// @param _defeatIndex The index which resulted in the defeat of the proposal\n    /// @param _index The index to check if it's within the defeat path\n    /// @return True if `_index` was part of the path which defeated the proposal\n    function isRewardedIndex(uint256 _defeatIndex, uint256 _index) internal pure returns (bool) {\n        for (uint256 i = _defeatIndex; i > 1; i /= 2) {\n            if (_index == i) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /// @notice Returns the state of the given challenge\n    /// @param _proposalID The ID of the proposal the challenge is for\n    /// @param _index The global index of the node that is challenged\n    /// @return The state of the challenge for the given proposal and node\n    function getChallengeState(uint256 _proposalID, uint256 _index) override external view returns (Types.ChallengeState) {\n        bytes32 challengeKey = keccak256(abi.encodePacked(\"dao.protocol.proposal.challenge\", _proposalID, _index));\n        uint256 data = getUint(challengeKey);\n        return _getChallengeState(data);\n    }\n\n    /// @dev Extracts the packed challenge state from the given uint256\n    function _getChallengeState(uint256 _data) internal pure returns (Types.ChallengeState) {\n        return Types.ChallengeState(uint8(_data >> stateOffset));\n    }\n\n    /// @dev Extracts the packed timestamp from the given uint256\n    function getChallengeTimestamp(uint256 _data) internal pure returns (uint64) {\n        return uint64(_data >> timestampOffset);\n    }\n\n    /// @dev Extracts the packed address of the challenger from the given uint256\n    function getChallengeAddress(uint256 _data) internal pure returns (address) {\n        return address(uint160(_data >> addressOffset));\n    }\n\n    /// @dev Modifies the packed challenge state of a given uint256\n    function setChallengeState(uint256 _data, Types.ChallengeState _newState) internal pure returns (uint256) {\n        _data &= ~(uint256(~uint8(0)) << stateOffset);\n        _data |= uint256(_newState) << stateOffset;\n        return _data;\n    }\n\n    /// @notice Retrieves the sum and hash of the node at the given global index\n    function getNode(uint256 _proposalID, uint256 _index) public view returns (Types.Node memory) {\n        uint256 challengeKey = uint256(keccak256(abi.encodePacked(\"dao.protocol.proposal.challenge\", _proposalID, _index)));\n        Types.Node memory node;\n        node.sum = getUint(bytes32(challengeKey + sumOffset));\n        node.hash = getBytes32(bytes32(challengeKey + hashOffset));\n        return node;\n    }\n\n    /// @dev Sets the sum and hash of the node at the given global index\n    function setNode(uint256 _proposalID, uint256 _index, Types.Node memory _node) internal {\n        uint256 challengeKey = uint256(keccak256(abi.encodePacked(\"dao.protocol.proposal.challenge\", _proposalID, _index)));\n        setUint(bytes32(challengeKey + sumOffset), _node.sum);\n        setBytes32(bytes32(challengeKey + hashOffset), _node.hash);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 15000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}