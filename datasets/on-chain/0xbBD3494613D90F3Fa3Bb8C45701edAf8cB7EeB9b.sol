{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "istanbul",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMathUpgradeable {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "src/InterestRateModel/InterestRateSecondModelV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport \"../library/SafeRatioMath.sol\";\n\n/**\n * @title dForce's lending InterestRateSecondModelV2 Contract\n * @author dForce\n */\ncontract InterestRateSecondModelV2 {\n    using SafeMathUpgradeable for uint256;\n    using SafeRatioMath for uint256;\n\n    uint256 private constant ONE = 1e18;\n\n    /**\n     * @notice The approximate number of blocks produced each year for different blockchain.\n     */\n    uint256 public constant secsPerYear = 60 * 60 * 24 * 365;\n\n    uint256 public base;\n    uint256 public optimal;\n    uint256 public slope_1;\n    uint256 public slope_2;\n\n    constructor(\n        uint256 _base,\n        uint256 _optimal,\n        uint256 _slope_1,\n        uint256 _slope_2\n    ) public {\n        require(\n            _base <= ONE,\n            \"InterestRateSecondModelV2: Base can not exceed 1!\"\n        );\n        require(\n            _optimal > 0,\n            \"InterestRateSecondModelV2: Optimal can not be zero!\"\n        );\n        require(\n            _optimal < ONE,\n            \"InterestRateSecondModelV2: Optimal should be less than 1!\"\n        );\n        require(\n            _slope_1 <= ONE,\n            \"InterestRateSecondModelV2: Slope 1 can not exceed 1!\"\n        );\n        base = _base;\n        optimal = _optimal;\n        slope_1 = _slope_1;\n        slope_2 = _slope_2;\n    }\n\n    /*********************************/\n    /******** Security Check *********/\n    /*********************************/\n\n    /**\n     * @notice Ensure this is an interest rate model contract.\n     */\n    function isInterestRateSecondModel() external pure returns (bool) {\n        return true;\n    }\n\n    /**\n     * @notice Calculate the utilization rate: `_borrows / (_cash + _borrows - _reserves)`\n     * @param _cash Asset balance\n     * @param _borrows Asset borrows\n     * @param _reserves Asset reserves\n     * @return Asset utilization [0, 1e18]\n     */\n    function utilizationRate(\n        uint256 _cash,\n        uint256 _borrows,\n        uint256 _reserves\n    ) internal pure returns (uint256) {\n        // Utilization rate is 0 when there are no borrows\n        if (_borrows == 0) return 0;\n\n        // Utilization rate is 100% when _grossSupply is less than or equal to borrows\n        uint256 _grossSupply = _cash.add(_borrows);\n        if (_grossSupply <= _reserves) return ONE;\n\n        // Utilization rate is 100% when _borrows is greater than _supply\n        uint256 _supply = _grossSupply.sub(_reserves);\n        if (_borrows > _supply) return ONE;\n\n        return _borrows.rdiv(_supply);\n    }\n\n    /**\n     * @notice Get the current borrow rate per second, 18 decimal places\n     * @param _balance Asset balance\n     * @param _borrows Asset borrows\n     * @param _reserves Asset reserves\n     * @return _borrowRate Current borrow rate APR\n     */\n    function getBorrowRate(\n        uint256 _balance,\n        uint256 _borrows,\n        uint256 _reserves\n    ) external view returns (uint256 _borrowRate) {\n        uint256 _util = utilizationRate(_balance, _borrows, _reserves);\n        uint256 _annualBorrowRateScaled = 0;\n\n        // Borrow rate is:\n        // 1). when Ur < Uoptimal, Rate = R0 + R1 * Ur / Uoptimal\n        // 2). when Ur >= Uoptimal, Rate = R0 + R1 + R2 * (Ur-Uoptimal)/(1-Uoptimal)\n        // R0: Base, R1: Slope1, R2: Slope2\n        if (_util < optimal) {\n            _annualBorrowRateScaled = base.add(slope_1.mul(_util).div(optimal));\n        } else {\n            _annualBorrowRateScaled = base.add(slope_1).add(\n                slope_2.mul(_util.sub(optimal)).div(ONE.sub(optimal))\n            );\n        }\n\n        // And then divide down by seconds per year.\n        _borrowRate = _annualBorrowRateScaled.div(secsPerYear);\n    }\n}\n\ncontract StablePrimaryInterestSecondModel is InterestRateSecondModelV2 {\n    constructor()\n        public\n        InterestRateSecondModelV2(0, 0.9e18, 0.05e18, 0.6e18)\n    {}\n}\n\ncontract StablePrimaryInterestSecondModelV1 is InterestRateSecondModelV2 {\n    constructor()\n        public\n        InterestRateSecondModelV2(0, 0.9e18, 0.09e18, 0.71e18)\n    {}\n}\n\ncontract StableSecondaryInterestSecondModel is InterestRateSecondModelV2 {\n    constructor() public InterestRateSecondModelV2(0, 0.8e18, 0.07e18, 1e18) {}\n}\n\ncontract BNBLikeInterestSecondModel is InterestRateSecondModelV2 {\n    constructor() public InterestRateSecondModelV2(0, 0.9e18, 0.09e18, 1e18) {}\n}\n\ncontract MainPrimaryInterestSecondModel is InterestRateSecondModelV2 {\n    constructor() public InterestRateSecondModelV2(0, 0.7e18, 0.05e18, 1e18) {}\n}\n\ncontract MainSecondaryInterestSecondModel is InterestRateSecondModelV2 {\n    constructor()\n        public\n        InterestRateSecondModelV2(0, 0.65e18, 0.07e18, 0.8e18)\n    {}\n}\n\ncontract CakeLikeInterestSecondModel is InterestRateSecondModelV2 {\n    constructor()\n        public\n        InterestRateSecondModelV2(0, 0.65e18, 0.07e18, 1.2e18)\n    {}\n}\n\ncontract ETHLikeInterestSecondModel is InterestRateSecondModelV2 {\n    constructor()\n        public\n        InterestRateSecondModelV2(0, 0.7e18, 0.03e18, 0.25e18)\n    {}\n}\n\ncontract OffBoardingInterestSecondModel2 is InterestRateSecondModelV2 {\n    constructor() public InterestRateSecondModelV2(1e18, 0.01e18, 1e18, 3e18) {}\n}\n"
    },
    "src/library/SafeRatioMath.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\n\nlibrary SafeRatioMath {\n    using SafeMathUpgradeable for uint256;\n\n    uint256 private constant BASE = 10 ** 18;\n    uint256 private constant DOUBLE = 10 ** 36;\n\n    function divup(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x.add(y.sub(1)).div(y);\n    }\n\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x.mul(y).div(BASE);\n    }\n\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x.mul(BASE).div(y);\n    }\n\n    function rdivup(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x.mul(BASE).add(y.sub(1)).div(y);\n    }\n\n    function tmul(\n        uint256 x,\n        uint256 y,\n        uint256 z\n    ) internal pure returns (uint256 result) {\n        result = x.mul(y).mul(z).div(DOUBLE);\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 base\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    z := base\n                }\n                default {\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    z := base\n                }\n                default {\n                    z := x\n                }\n                let half := div(base, 2) // for rounding.\n\n                for {\n                    n := div(n, 2)\n                } n {\n                    n := div(n, 2)\n                } {\n                    let xx := mul(x, x)\n                    if iszero(eq(div(xx, x), x)) {\n                        revert(0, 0)\n                    }\n                    let xxRound := add(xx, half)\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n                    x := div(xxRound, base)\n                    if mod(n, 2) {\n                        let zx := mul(z, x)\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) {\n                            revert(0, 0)\n                        }\n                        let zxRound := add(zx, half)\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n                        z := div(zxRound, base)\n                    }\n                }\n            }\n        }\n    }\n}\n"
    }
  }
}}