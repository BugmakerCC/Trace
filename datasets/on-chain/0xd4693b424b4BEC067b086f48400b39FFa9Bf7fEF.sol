{{
  "language": "Vyper",
  "sources": {
    "venv/lib/python3.11/site-packages/snekmate/auth/ownable.vy": {
      "content": "# pragma version ~=0.4.0\n\"\"\"\n@title Owner-Based Access Control Functions\n@custom:contract-name ownable\n@license GNU Affero General Public License v3.0 only\n@author pcaversaccio\n@notice These functions can be used to implement a basic access\n        control mechanism, where there is an account (an owner)\n        that can be granted exclusive access to specific functions.\n        By default, the owner account will be the one that deploys\n        the contract. This can later be changed with `transfer_ownership`.\n        An exemplary integration can be found in the ERC-20 implementation here:\n        https://github.com/pcaversaccio/snekmate/blob/main/src/snekmate/tokens/erc20.vy.\n        The implementation is inspired by OpenZeppelin's implementation here:\n        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol.\n\"\"\"\n\n\n# @dev Returns the address of the current owner.\n# @notice If you declare a variable as `public`,\n# Vyper automatically generates an `external`\n# getter function for the variable.\nowner: public(address)\n\n\n# @dev Emitted when the ownership is transferred\n# from `previous_owner` to `new_owner`.\nevent OwnershipTransferred:\n    previous_owner: indexed(address)\n    new_owner: indexed(address)\n\n\n@deploy\n@payable\ndef __init__():\n    \"\"\"\n    @dev To omit the opcodes for checking the `msg.value`\n         in the creation-time EVM bytecode, the constructor\n         is declared as `payable`.\n    @notice The `owner` role will be assigned to\n            the `msg.sender`.\n    \"\"\"\n    self._transfer_ownership(msg.sender)\n\n\n@external\ndef transfer_ownership(new_owner: address):\n    \"\"\"\n    @dev Transfers the ownership of the contract\n         to a new account `new_owner`.\n    @notice Note that this function can only be\n            called by the current `owner`. Also,\n            the `new_owner` cannot be the zero address.\n    @param new_owner The 20-byte address of the new owner.\n    \"\"\"\n    self._check_owner()\n    assert new_owner != empty(address), \"ownable: new owner is the zero address\"\n    self._transfer_ownership(new_owner)\n\n\n@external\ndef renounce_ownership():\n    \"\"\"\n    @dev Leaves the contract without an owner.\n    @notice Renouncing ownership will leave the\n            contract without an owner, thereby\n            removing any functionality that is\n            only available to the owner.\n    \"\"\"\n    self._check_owner()\n    self._transfer_ownership(empty(address))\n\n\n@internal\ndef _check_owner():\n    \"\"\"\n    @dev Throws if the sender is not the owner.\n    \"\"\"\n    assert msg.sender == self.owner, \"ownable: caller is not the owner\"\n\n\n@internal\ndef _transfer_ownership(new_owner: address):\n    \"\"\"\n    @dev Transfers the ownership of the contract\n         to a new account `new_owner`.\n    @notice This is an `internal` function without\n            access restriction.\n    @param new_owner The 20-byte address of the new owner.\n    \"\"\"\n    old_owner: address = self.owner\n    self.owner = new_owner\n    log OwnershipTransferred(old_owner, new_owner)\n",
      "sha256sum": "88ae32cf8b3e4a332d6518256019193419150e7ff716dd006a8d471550c329fc"
    },
    "contracts/bridgers/IBridger.vyi": {
      "content": "# pragma version ~=0.4.0\n\"\"\"\n@title Curve Bridge Adapter\n@license MIT\n@author CurveFi\n@notice Interface mainly used for bridging Curve emissions to L2s and collected fees to Ethereum.\n\"\"\"\n\nfrom ethereum.ercs import IERC20\n\n\n@external\n@payable\ndef bridge(_token: IERC20, _to: address, _amount: uint256, _min_amount: uint256=0) -> uint256:\n    \"\"\"\n    @notice Bridge `_token`\n    @param _token The ERC20 asset to bridge\n    @param _to The receiver on `_chain_id`\n    @param _amount The amount of `_token` to deposit, 2^256-1 for the whole balance\n    @param _min_amount Minimum amount when to bridge\n    @return Bridged amount\n    \"\"\"\n    ...\n\n\n@view\n@external\ndef check(_account: address) -> bool:\n    \"\"\"\n    @notice Check if `_account` may bridge via `transmit_emissions`\n    @param _account The account to check\n    \"\"\"\n    ...\n\n\n@view\n@external\ndef cost() -> uint256:\n    \"\"\"\n    @notice Cost in ETH to bridge, not all chains are supported\n    \"\"\"\n    ...\n",
      "sha256sum": "6f706ae0fccd481df984cada3477305aa5cc727b755c74568316fe7fe3af9898"
    },
    "contracts/bridgers/TaikoBridger.vy": {
      "content": "# @version 0.4.0\n\"\"\"\n@title TaikoBridger\n@custom:version 0.0.1\n@author Curve.Fi\n@license Copyright (c) Curve.Fi, 2020-2024 - all rights reserved\n@notice Curve Taiko bridge wrapper\n\"\"\"\n\nversion: public(constant(String[8])) = \"0.0.1\"\n\nfrom ethereum.ercs import IERC20\nfrom snekmate.auth import ownable\nimport IBridger\n\ninitializes: ownable\nimplements: IBridger\n\n\ninterface ERC20Vault:\n    def sendToken(_op: BridgeTransferOp) -> Message: payable\n\nstruct BridgeTransferOp:\n    destChainId: uint64  # Destination chain ID.\n    destOwner: address  # The owner of the bridge message on the destination chain.\n    to: address  # Recipient address.\n    fee: uint64  # Processing fee for the relayer.\n    token: address  # Address of the token.\n    gasLimit: uint32  # Gas limit for the operation.\n    amount: uint256  # Amount to be bridged.\n\nstruct Message:\n    id: uint64  # Message ID whose value is automatically assigned.\n    fee: uint64  # The max processing fee for the relayer. This fee has 3 parts:\n                 # - the fee for message calldata.\n                 # - the minimal fee reserve for general processing, excluding function call.\n                 # - the invocation fee for the function call.\n                 # Any unpaid fee will be refunded to the destOwner on the destination chain.\n                 # Note that fee must be 0 if gasLimit is 0, or large enough to make the invocation fee\n                 # non-zero.\n    gasLimit: uint32  # gasLimit that the processMessage call must have.\n    _from: address  # The address, EOA or contract, that interacts with this bridge.\n                    # The value is automatically assigned.\n    srcChainId: uint64  # Source chain ID whose value is automatically assigned.\n    srcOwner: address  # The owner of the message on the source chain.\n    destChainId: uint64  # Destination chain ID where the `to` address lives.\n    destOwner: address  # The owner of the message on the destination chain.\n    to: address  # The destination address on the destination chain.\n    value: uint256  # value to invoke on the destination chain.\n    data: Bytes[1024]  # callData to invoke on the destination chain.\n\nstruct ManualParameters:\n    dest_owner: address\n\n\nCRV20: constant(address) = 0xD533a949740bb3306d119CC777fa900bA034cd52\nERC20_VAULT: public(constant(ERC20Vault)) = ERC20Vault(0x996282cA11E5DEb6B5D122CC3B9A1FcAAD4415Ab)\n\ngas_price: public(uint256)\ngas_limit: public(uint256)\ndest_owner: public(address)\n\nDESTINATION_CHAIN_ID: public(immutable(uint256))\n\nallow_manual_parameters: public(bool)\nmanual_parameters: transient(ManualParameters)\n\n\n@deploy\ndef __init__(_chain_id: uint256, _dest_owner: address):\n    \"\"\"\n    @param _chain_id Chain ID to bridge to\n    @param _dest_owner Destination default excess fee owner\n    \"\"\"\n    DESTINATION_CHAIN_ID = _chain_id\n\n    assert extcall IERC20(CRV20).approve(ERC20_VAULT.address, max_value(uint256))\n\n    self.gas_price = 5 * 10 ** 8  # 0.5 gwei\n    self.gas_limit = 1_315_360\n\n    self.dest_owner = _dest_owner\n\n    ownable.__init__()\n\n\nexports: ownable.transfer_ownership\n\n\n@external\n@payable\ndef bridge(_token: IERC20, _to: address, _amount: uint256, _min_amount: uint256=0) -> uint256:\n    \"\"\"\n    @notice Bridge `_token` through Taiko Bridge\n    @param _token The ERC20 asset to bridge\n    @param _to The receiver on `_chain_id`\n    @param _amount The amount of `_token` to deposit, 2^256-1 for the whole balance\n    @param _min_amount Minimum amount when to bridge\n    @return Bridged amount\n    \"\"\"\n    amount: uint256 = _amount\n    if amount == max_value(uint256):\n        amount = min(staticcall _token.balanceOf(msg.sender), staticcall _token.allowance(msg.sender, self))\n    assert amount >= _min_amount, \"Amount too small\"\n\n    assert extcall _token.transferFrom(msg.sender, self, amount)\n\n    dest_owner: address = self.manual_parameters.dest_owner\n    if not self.allow_manual_parameters or dest_owner == empty(address):\n        dest_owner = self.dest_owner\n    gas_limit: uint256 = self.gas_limit\n    fee: uint256 = self.gas_price * gas_limit\n    extcall ERC20_VAULT.sendToken(\n        BridgeTransferOp(\n            destChainId=convert(DESTINATION_CHAIN_ID, uint64),\n            destOwner=dest_owner,  # The owner of the bridge message on the destination chain.\n            to=_to,\n            fee=convert(fee, uint64),\n            token=_token.address,\n            gasLimit=convert(gas_limit, uint32),\n            amount=amount,\n        ),\n        value=fee,\n    )\n    return amount\n\n\n@view\n@external\ndef cost() -> uint256:\n    \"\"\"\n    @notice Cost in ETH to bridge\n    \"\"\"\n    return self.gas_price * self.gas_limit\n\n\n@view\n@external\ndef check(_account: address) -> bool:\n    \"\"\"\n    @notice Check if `_account` is allowed to bridge\n    @param _account The account to check\n    \"\"\"\n    return True\n\n\n@external\ndef set_manual_parameters(_manual_parameters: ManualParameters):\n    \"\"\"\n    @notice Set manual parameters that will be actual within current transaction\n    @param _manual_parameters ()\n    \"\"\"\n    self.manual_parameters = _manual_parameters\n\n\n@external\ndef set_fee(_new_gas_price: uint256, _new_gas_limit: uint256):\n    \"\"\"\n    @notice Set gas parameters\n    \"\"\"\n    ownable._check_owner()\n\n    self.gas_price = _new_gas_price\n    self.gas_limit = _new_gas_limit\n\n\n@external\ndef set_dest_owner(_new_dest_owner: address):\n    \"\"\"\n    @notice Set new destination bridge transaction owner\n    @param _new_dest_owner New transaction initiator (better be Curve Vault)\n    \"\"\"\n    ownable._check_owner()\n\n    self.dest_owner = _new_dest_owner\n\n\n@external\ndef set_allow_manual_parameters(_allow: bool):\n    \"\"\"\n    @notice Allow to set manual parameters(dest_owner)\n    @param _allow Whether to allow\n    \"\"\"\n    ownable._check_owner()\n\n    self.allow_manual_parameters = _allow\n",
      "sha256sum": "8a2c2a1aa46c5f2c6ed3f20f1fe64b586a78f7843c55e285e0cc7bb2ade21e67"
    }
  },
  "settings": {
    "outputSelection": {
      "contracts/bridgers/TaikoBridger.vy": [
        "evm.bytecode",
        "evm.deployedBytecode",
        "abi"
      ]
    },
    "search_paths": [
      "venv/lib/python3.11/site-packages",
      "."
    ]
  },
  "compiler_version": "v0.4.0+commit.e9db8d9",
  "integrity": "f5b9edcd77a0855f8ebab7ed25209a30fd103d23823c03fec06e2ea237895ff1"
}}