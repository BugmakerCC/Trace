{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "london",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "src/Interfaces/Errors.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nerror BaseStakingPool_addRewardDistributor__RewardDistributorIsZeroAddress();\nerror BaseStakingPool_addRewardDistributor__RewardDistributorAlreadyExist();\nerror BaseStakingPool_initialize__StakingTokenIsZeroAddress();\nerror BaseStakingPool_removeRewardDistributor__RewardDistributorDoesNotExist();\nerror BaseStakingPool_stake__StakeAmountIsZero();\nerror BaseStakingPool_withdraw__WithdrawAmountIsZero();\n\nerror BLPStakingPool_setRewardDistributorManager__InvalidRewardDistributorManager();\n\nerror BLPReward_initialize__StakingTokenIsZeroAddress();\nerror BLPReward_initialize__RewardTokenIsZeroAddress();\nerror BLPReward_initialize__TreasuryIsZeroAddress();\nerror BLPReward_setTreasury__TreasuryIsZeroAddress();\nerror BLPReward_setTreasury__SameTreasuryAddress();\n\nerror EligibilityManager_addBLPStakingPoolInternal__InvalidStakingPool(\n    address stakingPool\n);\nerror EligibilityManager_addBLPStakingPoolInternal__StakingPoolAlreadyExist(\n    address stakingPool\n);\nerror EligibilityManager_addValidSupplyInternal__InvalidSupply(address iToken);\nerror EligibilityManager_addValidSupplyInternal__ValidSupplyAlreadyExist(\n    address iToken\n);\nerror EligibilityManager_initialize__InvalidController();\nerror EligibilityManager_removeValidSupplyInternal__ValidSupplyDoesNotExist(\n    address iToken\n);\nerror EligibilityManager_removeBLPStakingPoolInternal__StakingPoolDoesNotExist(\n    address stakingPool\n);\n\n// Modifier error\nerror RewardDistributorManager__NotController();\n// Function errors\nerror RewardDistributorManager_addRewardDistributorInternal__InvalidRewardDistributor();\nerror RewardDistributorManager_addRewardDistributorInternal__RewardDistributorAlreadyExist(\n    address rewardDistributor\n);\nerror RewardDistributorManager_initialize__InvalidController();\nerror RewardDistributorManager_removeRewardDistributorInternal__RewardDistributorDoesNotExist(\n    address rewardDistributor\n);\nerror RewardDistributorManager_setEligibilityManager_InvalidEligibilityManager();\nerror RewardDistributorManager_updateEligibleBalance__InvalidEligibility();\n\nerror RewardDistributor__CallerIsNotRewardManager();\nerror RewardDistributor__ContractPaused();\nerror RewardDistributor_initialize__InvalidController();\nerror RewardDistributor_initialize__InvalidRewardDistributorManager();\nerror RewardDistributor_rescueTokens__CallerIsNotTreasury();\nerror RewardDistributor_setRewardToken__InvalidRewardToken();\nerror RewardDistributor_setTreasury__InvalidTreasury();\nerror RewardDistributor_setDistributionBorrowSpeedsInternal__ArrayLengthMismatch();\nerror RewardDistributor_setDistributionSupplySpeedsInternal__ArrayLengthMismatch();\nerror RewardDistributor_setDistributionBorrowSpeed__TokenHasNotBeenListed(\n    address iToken\n);\nerror RewardDistributor_setDistributionSupplySpeed__TokenHasNotBeenListed(\n    address iToken\n);\nerror RewardDistributor_updateDistributionState__TokenHasNotBeenListed(\n    address iToken\n);\nerror RewardDistributor_updateReward__TokenHasNotBeenListed(address iToken);\nerror RewardDistributor_updateReward__AccountIsZeroAddress();\nerror RewardDistributor_setBountyRatio__RatioTooHigh();\n"
    },
    "src/Interfaces/IController.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\npragma experimental ABIEncoderV2;\n\ninterface IController {\n    /**\n     * @notice Security checks when updating the comptroller of a market, always expect to return true.\n     */\n    function isController() external view returns (bool);\n\n    /**\n     * @notice Return all of the iTokens\n     * @return The list of iToken addresses\n     */\n    function getAlliTokens() external view returns (address[] memory);\n\n    /**\n     * @notice Check whether a iToken is listed in controller\n     * @param _iToken The iToken to check for\n     * @return true if the iToken is listed otherwise false\n     */\n    function hasiToken(address _iToken) external view returns (bool);\n\n    function priceOracle() external view returns (address);\n    function rewardDistributor() external view returns (address);\n\n    function owner() external view returns (address);\n    function _setRewardDistributor(address _rewardDistributor) external;\n}\n"
    },
    "src/Interfaces/IEligibilityManager.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IEligibilityManager {\n    function isEligibilityManager() external pure returns (bool);\n    function isEligible(address _account) external returns (bool, bool);\n    function hasBLPStakingPool(address _stakingPool) external view returns (bool);\n}\n"
    },
    "src/Interfaces/IRewardDistributor.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"./IController.sol\";\n\ninterface IRewardDistributor {\n    function isRewardDistributor() external view returns (bool);\n\n    function controller() external view returns (IController);\n\n    function rewardToken() external returns (address);\n\n    function _setRewardToken(address newRewardToken) external;\n\n    /// @notice Emitted reward token address is changed by admin\n    event NewRewardToken(address oldRewardToken, address newRewardToken);\n\n    function treasury() external returns (address);\n\n    function _setTreasury(address newTreasury) external;\n\n    /// @notice Emitted treasury address is changed by admin\n    event NewTreasury(address oldTreasury, address newTreasury);\n\n    function _addRecipient(\n        address _iToken,\n        uint256 _distributionFactor\n    ) external;\n\n    event NewRecipient(address iToken, uint256 distributionFactor);\n\n    /// @notice Emitted when mint is paused/unpaused by admin\n    event PausedChanged(bool paused, uint256 timestamp);\n\n    function _pause() external;\n\n    function _unpause(\n        address[] calldata _borrowiTokens,\n        uint256[] calldata _borrowSpeeds,\n        address[] calldata _supplyiTokens,\n        uint256[] calldata _supplySpeeds\n    ) external;\n\n    /// @notice Emitted when Global Distribution speed for both supply and borrow are updated\n    event GlobalDistributionSpeedsChanged(\n        uint256 borrowSpeed,\n        uint256 supplySpeed,\n        uint256 timestamp\n    );\n\n    /// @notice Emitted when iToken's Distribution borrow speed is updated\n    event DistributionBorrowSpeedChanged(\n        address iToken,\n        uint256 borrowSpeed,\n        uint256 timestamp\n    );\n\n    /// @notice Emitted when iToken's Distribution supply speed is updated\n    event DistributionSupplySpeedChanged(\n        address iToken,\n        uint256 supplySpeed,\n        uint256 timestamp\n    );\n\n    /// @notice Emitted when iToken's Distribution factor is changed by admin\n    event NewDistributionFactor(\n        address iToken,\n        uint256 oldDistributionFactorMantissa,\n        uint256 newDistributionFactorMantissa\n    );\n\n    /// @notice Emitted when bounty ratio is changed by admin\n    event NewBountyRatio(uint256 oldBountyRatio, uint256 newBountyRatio);\n\n    function updateDistributionState(address _iToken, bool _isBorrow) external;\n\n    function updateReward(\n        address _iToken,\n        address _account,\n        bool _isBorrow\n    ) external;\n\n    function updateRewardBatch(\n        address[] memory _holders,\n        address[] memory _iTokens\n    ) external;\n\n    function claimReward(\n        address[] memory _holders,\n        address[] memory _iTokens\n    ) external;\n\n    function claimAllReward(address[] memory _holders) external;\n\n    function claimRewards(\n        address[] memory _holders,\n        address[] memory _suppliediTokens,\n        address[] memory _borrowediTokens\n    ) external;\n\n    /// @notice Emitted when reward of amount is distributed into account\n    event RewardDistributed(\n        address iToken,\n        address account,\n        uint256 amount,\n        uint256 accountIndex\n    );\n\n    function claimBounty(address _account, address _hunter) external;\n\n    /// @notice Emitted when bounty is claimed by a hunter\n    event BountyClaimed(\n        address rewardToken,\n        address hunter,\n        address account,\n        uint256 bounty,\n        uint256 reward\n    );\n}\n"
    },
    "src/Interfaces/IRewardDistributorManager.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\nimport \"./IEligibilityManager.sol\";\ninterface IRewardDistributorManager {\n    function isRewardDistributorManager() external pure returns (bool);\n\n    function eligibilityManager() external view returns (IEligibilityManager);\n\n    function _addRecipient(\n        address _iToken,\n        uint256 _distributionFactor\n    ) external;\n\n    function _setEligibilityManager(address _newEligibilityManager) external;\n\n    function eligibleTotalSupply(\n        address iToken\n    ) external view returns (uint256);\n\n    function eligibleTotalBorrow(\n        address iToken\n    ) external view returns (uint256);\n\n    function eligibleSupply(\n        address iToken,\n        address account\n    ) external view returns (uint256);\n\n    function eligibleBorrow(\n        address iToken,\n        address account\n    ) external view returns (uint256);\n\n    function updateEligibleBalance(address _account) external;\n\n    function updateEligibleBalances(address[] memory _accounts) external;\n}\n"
    },
    "src/Libraries/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(\n            !_initialized,\n            \"Initializable: contract is already initialized\"\n        );\n\n        _;\n\n        _initialized = true;\n    }\n}\n"
    },
    "src/Libraries/Ownable.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {_setPendingOwner} and {_acceptOwner}.\n */\ncontract Ownable {\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    address payable public owner;\n\n    /**\n     * @dev Returns the address of the current pending owner.\n     */\n    address payable public pendingOwner;\n\n    event NewOwner(address indexed previousOwner, address indexed newOwner);\n    event NewPendingOwner(\n        address indexed oldPendingOwner,\n        address indexed newPendingOwner\n    );\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"onlyOwner: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal {\n        owner = payable(msg.sender);\n        emit NewOwner(address(0), msg.sender);\n    }\n\n    /**\n     * @notice Base on the inputing parameter `newPendingOwner` to check the exact error reason.\n     * @dev Transfer contract control to a new owner. The newPendingOwner must call `_acceptOwner` to finish the transfer.\n     * @param newPendingOwner New pending owner.\n     */\n    function _setPendingOwner(\n        address payable newPendingOwner\n    ) external onlyOwner {\n        require(\n            newPendingOwner != address(0) && newPendingOwner != pendingOwner,\n            \"_setPendingOwner: New owenr can not be zero address and owner has been set!\"\n        );\n\n        // Gets current owner.\n        address oldPendingOwner = pendingOwner;\n\n        // Sets new pending owner.\n        pendingOwner = newPendingOwner;\n\n        emit NewPendingOwner(oldPendingOwner, newPendingOwner);\n    }\n\n    /**\n     * @dev Accepts the admin rights, but only for pendingOwenr.\n     */\n    function _acceptOwner() external {\n        require(\n            msg.sender == pendingOwner,\n            \"_acceptOwner: Only for pending owner!\"\n        );\n\n        // Gets current values for events.\n        address oldOwner = owner;\n        address oldPendingOwner = pendingOwner;\n\n        // Set the new contract owner.\n        owner = pendingOwner;\n\n        // Clear the pendingOwner.\n        pendingOwner = payable(address(0));\n\n        emit NewOwner(oldOwner, owner);\n        emit NewPendingOwner(oldPendingOwner, pendingOwner);\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "src/Libraries/RatioMath.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nlibrary RatioMath {\n    uint256 private constant BASE = 10 ** 18;\n    uint256 private constant DOUBLE = 10 ** 36;\n\n    function divup(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = (x + (y - 1)) / y;\n    }\n\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = (x * y) / BASE;\n    }\n\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = (x * BASE) / y;\n    }\n\n    function rdivup(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = (x * (BASE) + (y - 1)) / y;\n    }\n}\n"
    },
    "src/RewardDistributor.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./Interfaces/IRewardDistributor.sol\";\nimport \"./Interfaces/IController.sol\";\nimport \"./Interfaces/IRewardDistributorManager.sol\";\nimport \"./Libraries/RatioMath.sol\";\nimport \"./Libraries/Ownable.sol\";\nimport \"./Libraries/Initializable.sol\";\nimport \"./Interfaces/Errors.sol\";\n\n/**\n * @title dForce's lending reward distributor Contract\n * @author dForce\n */\ncontract RewardDistributor is Initializable, Ownable, IRewardDistributor {\n    using RatioMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /// @notice the controller\n    IController public override controller;\n\n    /// @notice the global Reward distribution speed\n    uint256 public globalDistributionSpeed;\n\n    /// @notice the Reward distribution speed of each iToken\n    mapping(address => uint256) public distributionSpeed;\n\n    /// @notice the Reward distribution factor of each iToken, 1.0 by default. stored as a mantissa\n    mapping(address => uint256) public distributionFactorMantissa;\n\n    struct DistributionState {\n        // Token's last updated index, stored as a mantissa\n        uint256 index;\n        // The block number the index was last updated at\n        uint256 block;\n        // The block timestamp the index was last updated at\n        uint256 timestamp;\n    }\n\n    /// @notice the Reward distribution supply state of each iToken\n    mapping(address => DistributionState) public distributionSupplyState;\n    /// @notice the Reward distribution borrow state of each iToken\n    mapping(address => DistributionState) public distributionBorrowState;\n\n    /// @notice the Reward distribution state of each account of each iToken\n    mapping(address => mapping(address => uint256))\n        public distributionSupplierIndex;\n    /// @notice the Reward distribution state of each account of each iToken\n    mapping(address => mapping(address => uint256))\n        public distributionBorrowerIndex;\n\n    /// @notice the Reward distributed into each account\n    mapping(address => uint256) public reward;\n\n    /// @notice the Reward token address\n    address public override rewardToken;\n\n    /// @notice whether the reward distribution is paused\n    bool public paused;\n\n    /// @notice the Reward distribution speed supply side of each iToken\n    mapping(address => uint256) public distributionSupplySpeed;\n\n    /// @notice the global Reward distribution speed for supply\n    uint256 public globalDistributionSupplySpeed;\n\n    /// @notice the treasury address where the reward is stored\n    address public override treasury;\n\n    /// @notice the reward distributor manager address where eligible balances is stored\n    IRewardDistributorManager public manager;\n\n    /// @notice the ratio of bounty hunter to collect from reward\n    uint256 public bountyRatio;\n    uint256 public constant BOUNTY_RATIO_MAX = 3e17; // max 30%\n\n    constructor(IController _controller, IRewardDistributorManager _manager) {\n        initialize(_controller, _manager);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the controller.\n     */\n    modifier onlyManager() {\n        if (msg.sender != address(manager)) {\n            revert RewardDistributor__CallerIsNotRewardManager();\n        }\n        _;\n    }\n\n    modifier whenNotPaused() {\n        if (paused) {\n            revert RewardDistributor__ContractPaused();\n        }\n        _;\n    }\n\n    /**\n     * @notice Initializes the contract.\n     */\n    function initialize(\n        IController _controller,\n        IRewardDistributorManager _manager\n    ) public initializer {\n        if (!_controller.isController()) {\n            revert RewardDistributor_initialize__InvalidController();\n        }\n        if (!_manager.isRewardDistributorManager()) {\n            revert RewardDistributor_initialize__InvalidRewardDistributorManager();\n        }\n\n        __Ownable_init();\n        controller = _controller;\n        manager = _manager;\n        paused = true;\n    }\n\n    /*********************************/\n    /******** Security Check *********/\n    /*********************************/\n\n    /**\n     * @notice Ensure this is a RewardDistributor contract.\n     */\n    function isRewardDistributor() external pure override returns (bool) {\n        return true;\n    }\n\n    /**\n     * @notice set reward token address\n     * @dev Admin function, only owner can call this\n     * @param _newRewardToken the address of reward token\n     */\n    function _setRewardToken(\n        address _newRewardToken\n    ) external override onlyOwner {\n        address _oldRewardToken = rewardToken;\n        if (\n            _newRewardToken == address(0) || _newRewardToken == _oldRewardToken\n        ) {\n            revert RewardDistributor_setRewardToken__InvalidRewardToken();\n        }\n\n        rewardToken = _newRewardToken;\n        emit NewRewardToken(_oldRewardToken, _newRewardToken);\n    }\n\n    /**\n     * @notice set new treasury address\n     * @dev Admin function, only owner can call this\n     * @param _newTreasury the address of treasury\n     */\n    function _setTreasury(address _newTreasury) external override onlyOwner {\n        address _oldTreasury = treasury;\n        if (_newTreasury == address(0) || _newTreasury == _oldTreasury) {\n            revert RewardDistributor_setTreasury__InvalidTreasury();\n        }\n\n        treasury = _newTreasury;\n        emit NewTreasury(_oldTreasury, _newTreasury);\n    }\n\n    /**\n     * @notice Add the iToken as receipient\n     * @dev Admin function, only controller can call this\n     * @param _iToken the iToken to add as recipient\n     * @param _distributionFactor the distribution factor of the recipient\n     */\n    function _addRecipient(\n        address _iToken,\n        uint256 _distributionFactor\n    ) external override onlyManager {\n        distributionFactorMantissa[_iToken] = _distributionFactor;\n        distributionSupplyState[_iToken] = DistributionState({\n            index: 0,\n            block: block.number,\n            timestamp: block.timestamp\n        });\n        distributionBorrowState[_iToken] = DistributionState({\n            index: 0,\n            block: block.number,\n            timestamp: block.timestamp\n        });\n\n        emit NewRecipient(_iToken, _distributionFactor);\n    }\n\n    /**\n     * @notice Pause the reward distribution\n     * @dev Admin function, pause will set global speed to 0 to stop the accumulation\n     */\n    function _pause() external override onlyOwner {\n        // Set the global distribution speed to 0 to stop accumulation\n        address[] memory _iTokens = controller.getAlliTokens();\n        uint256 _len = _iTokens.length;\n        for (uint256 i = 0; i < _len; i++) {\n            _setDistributionBorrowSpeed(_iTokens[i], 0);\n            _setDistributionSupplySpeed(_iTokens[i], 0);\n        }\n\n        _refreshGlobalDistributionSpeeds();\n\n        _setPaused(true);\n    }\n\n    /**\n     * @notice Unpause and set distribution speeds\n     * @dev Admin function\n     * @param _borrowiTokens The borrow asset array\n     * @param _borrowSpeeds  The borrow speed array\n     * @param _supplyiTokens The supply asset array\n     * @param _supplySpeeds  The supply speed array\n     */\n    function _unpause(\n        address[] calldata _borrowiTokens,\n        uint256[] calldata _borrowSpeeds,\n        address[] calldata _supplyiTokens,\n        uint256[] calldata _supplySpeeds\n    ) external override onlyOwner {\n        _setPaused(false);\n\n        _setDistributionSpeedsInternal(\n            _borrowiTokens,\n            _borrowSpeeds,\n            _supplyiTokens,\n            _supplySpeeds\n        );\n\n        _refreshGlobalDistributionSpeeds();\n    }\n\n    /**\n     * @notice Pause/Unpause the reward distribution\n     * @dev Admin function\n     * @param _paused whether to pause/unpause the distribution\n     */\n    function _setPaused(bool _paused) internal {\n        paused = _paused;\n        emit PausedChanged(_paused, block.timestamp);\n    }\n\n    /**\n     * @notice Set distribution speeds\n     * @dev Admin function, will fail when paused\n     * @param _borrowiTokens The borrow asset array\n     * @param _borrowSpeeds  The borrow speed array\n     * @param _supplyiTokens The supply asset array\n     * @param _supplySpeeds  The supply speed array\n     */\n    function _setDistributionSpeeds(\n        address[] calldata _borrowiTokens,\n        uint256[] calldata _borrowSpeeds,\n        address[] calldata _supplyiTokens,\n        uint256[] calldata _supplySpeeds\n    ) external onlyOwner whenNotPaused {\n        _setDistributionSpeedsInternal(\n            _borrowiTokens,\n            _borrowSpeeds,\n            _supplyiTokens,\n            _supplySpeeds\n        );\n\n        _refreshGlobalDistributionSpeeds();\n    }\n\n    function _setDistributionSpeedsInternal(\n        address[] memory _borrowiTokens,\n        uint256[] memory _borrowSpeeds,\n        address[] memory _supplyiTokens,\n        uint256[] memory _supplySpeeds\n    ) internal {\n        _setDistributionBorrowSpeedsInternal(_borrowiTokens, _borrowSpeeds);\n        _setDistributionSupplySpeedsInternal(_supplyiTokens, _supplySpeeds);\n    }\n\n    /**\n     * @notice Set borrow distribution speeds\n     * @dev Admin function, will fail when paused\n     * @param _iTokens The borrow asset array\n     * @param _borrowSpeeds  The borrow speed array\n     */\n    function _setDistributionBorrowSpeeds(\n        address[] calldata _iTokens,\n        uint256[] calldata _borrowSpeeds\n    ) external onlyOwner whenNotPaused {\n        _setDistributionBorrowSpeedsInternal(_iTokens, _borrowSpeeds);\n\n        _refreshGlobalDistributionSpeeds();\n    }\n\n    /**\n     * @notice Set supply distribution speeds\n     * @dev Admin function, will fail when paused\n     * @param _iTokens The supply asset array\n     * @param _supplySpeeds The supply speed array\n     */\n    function _setDistributionSupplySpeeds(\n        address[] calldata _iTokens,\n        uint256[] calldata _supplySpeeds\n    ) external onlyOwner whenNotPaused {\n        _setDistributionSupplySpeedsInternal(_iTokens, _supplySpeeds);\n\n        _refreshGlobalDistributionSpeeds();\n    }\n\n    function _refreshGlobalDistributionSpeeds() internal {\n        address[] memory _iTokens = controller.getAlliTokens();\n        uint256 _len = _iTokens.length;\n        uint256 _borrowSpeed;\n        uint256 _supplySpeed;\n        for (uint256 i = 0; i < _len; i++) {\n            _borrowSpeed = _borrowSpeed + distributionSpeed[_iTokens[i]];\n            _supplySpeed = _supplySpeed + distributionSupplySpeed[_iTokens[i]];\n        }\n\n        globalDistributionSpeed = _borrowSpeed;\n        globalDistributionSupplySpeed = _supplySpeed;\n\n        emit GlobalDistributionSpeedsChanged(\n            _borrowSpeed,\n            _supplySpeed,\n            block.timestamp\n        );\n    }\n\n    function _setDistributionBorrowSpeedsInternal(\n        address[] memory _iTokens,\n        uint256[] memory _borrowSpeeds\n    ) internal {\n        if (_iTokens.length != _borrowSpeeds.length) {\n            revert RewardDistributor_setDistributionBorrowSpeedsInternal__ArrayLengthMismatch();\n        }\n\n        uint256 _len = _iTokens.length;\n        for (uint256 i = 0; i < _len; i++) {\n            _setDistributionBorrowSpeed(_iTokens[i], _borrowSpeeds[i]);\n        }\n    }\n\n    function _setDistributionSupplySpeedsInternal(\n        address[] memory _iTokens,\n        uint256[] memory _supplySpeeds\n    ) internal {\n        if (_iTokens.length != _supplySpeeds.length) {\n            revert RewardDistributor_setDistributionSupplySpeedsInternal__ArrayLengthMismatch();\n        }\n\n        uint256 _len = _iTokens.length;\n        for (uint256 i = 0; i < _len; i++) {\n            _setDistributionSupplySpeed(_iTokens[i], _supplySpeeds[i]);\n        }\n    }\n\n    function _setDistributionBorrowSpeed(\n        address _iToken,\n        uint256 _borrowSpeed\n    ) internal {\n        // iToken must have been listed\n        if (!controller.hasiToken(_iToken)) {\n            revert RewardDistributor_setDistributionBorrowSpeed__TokenHasNotBeenListed(\n                _iToken\n            );\n        }\n\n        // Update borrow state before updating new speed\n        _updateDistributionState(_iToken, true);\n\n        distributionSpeed[_iToken] = _borrowSpeed;\n        emit DistributionBorrowSpeedChanged(\n            _iToken,\n            _borrowSpeed,\n            block.timestamp\n        );\n    }\n\n    function _setDistributionSupplySpeed(\n        address _iToken,\n        uint256 _supplySpeed\n    ) internal {\n        // iToken must have been listed\n        if (!controller.hasiToken(_iToken)) {\n            revert RewardDistributor_setDistributionSupplySpeed__TokenHasNotBeenListed(\n                _iToken\n            );\n        }\n\n        // Update supply state before updating new speed\n        _updateDistributionState(_iToken, false);\n\n        distributionSupplySpeed[_iToken] = _supplySpeed;\n        emit DistributionSupplySpeedChanged(\n            _iToken,\n            _supplySpeed,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice Update the iToken's  Reward distribution state\n     * @dev Will be called every time when the iToken's supply/borrow changes\n     * @param _iToken The iToken to be updated\n     * @param _isBorrow whether to update the borrow state\n     */\n    function updateDistributionState(\n        address _iToken,\n        bool _isBorrow\n    ) external override {\n        // Skip all updates if it is paused\n        if (paused) {\n            return;\n        }\n\n        _updateDistributionState(_iToken, _isBorrow);\n    }\n\n    function _updateDistributionState(\n        address _iToken,\n        bool _isBorrow\n    ) internal {\n        if (!controller.hasiToken(_iToken)) {\n            revert RewardDistributor_updateDistributionState__TokenHasNotBeenListed(\n                _iToken\n            );\n        }\n\n        DistributionState storage state = _isBorrow\n            ? distributionBorrowState[_iToken]\n            : distributionSupplyState[_iToken];\n\n        uint256 _speed = _isBorrow\n            ? distributionSpeed[_iToken]\n            : distributionSupplySpeed[_iToken];\n\n        uint256 _blockTimestamp = block.timestamp;\n        uint256 _deltaSecs = _blockTimestamp - state.timestamp;\n\n        if (_deltaSecs > 0 && _speed > 0) {\n            uint256 _totalToken = _isBorrow\n                ? manager.eligibleTotalBorrow(_iToken)\n                : manager.eligibleTotalSupply(_iToken);\n            uint256 _totalDistributed = _speed * _deltaSecs;\n\n            // Reward distributed per token since last time\n            uint256 _distributedPerToken = _totalToken > 0\n                ? _totalDistributed.rdiv(_totalToken)\n                : 0;\n\n            state.index = state.index + _distributedPerToken;\n        }\n\n        state.timestamp = _blockTimestamp;\n    }\n\n    /**\n     * @notice Update the account's Reward distribution state\n     * @dev Will be called every time when the account's supply/borrow changes\n     * @param _iToken The iToken to be updated\n     * @param _account The account to be updated\n     * @param _isBorrow whether to update the borrow state\n     */\n    function updateReward(\n        address _iToken,\n        address _account,\n        bool _isBorrow\n    ) external override {\n        _updateReward(_iToken, _account, _isBorrow);\n    }\n\n    function _updateReward(\n        address _iToken,\n        address _account,\n        bool _isBorrow\n    ) internal {\n        if (_account == address(0)) {\n            revert RewardDistributor_updateReward__AccountIsZeroAddress();\n        }\n        if (!controller.hasiToken(_iToken)) {\n            revert RewardDistributor_updateReward__TokenHasNotBeenListed(\n                _iToken\n            );\n        }\n\n        uint256 _iTokenIndex;\n        uint256 _accountIndex;\n        uint256 _accountBalance;\n        if (_isBorrow) {\n            _iTokenIndex = distributionBorrowState[_iToken].index;\n            _accountIndex = distributionBorrowerIndex[_iToken][_account];\n            _accountBalance = manager.eligibleBorrow(_iToken, _account);\n\n            // Update the account state to date\n            distributionBorrowerIndex[_iToken][_account] = _iTokenIndex;\n        } else {\n            _iTokenIndex = distributionSupplyState[_iToken].index;\n            _accountIndex = distributionSupplierIndex[_iToken][_account];\n            _accountBalance = manager.eligibleSupply(_iToken, _account);\n\n            // Update the account state to date\n            distributionSupplierIndex[_iToken][_account] = _iTokenIndex;\n        }\n\n        uint256 _deltaIndex = _iTokenIndex - _accountIndex;\n        uint256 _amount = _accountBalance.rmul(_deltaIndex);\n\n        if (_amount > 0) {\n            reward[_account] = reward[_account] + _amount;\n\n            emit RewardDistributed(_iToken, _account, _amount, _accountIndex);\n        }\n    }\n\n    /**\n     * @notice Update reward accrued in iTokens by the holders regardless of paused or not\n     * @param _holders The account to update\n     * @param _iTokens The _iTokens to update\n     */\n    function updateRewardBatch(\n        address[] memory _holders,\n        address[] memory _iTokens\n    ) public override {\n        // Update rewards for all _iTokens for holders\n        for (uint256 i = 0; i < _iTokens.length; i++) {\n            address _iToken = _iTokens[i];\n            _updateDistributionState(_iToken, false);\n            _updateDistributionState(_iToken, true);\n            for (uint256 j = 0; j < _holders.length; j++) {\n                _updateReward(_iToken, _holders[j], false);\n                _updateReward(_iToken, _holders[j], true);\n            }\n        }\n    }\n\n    /**\n     * @notice Update reward accrued in iTokens by the holders regardless of paused or not\n     * @param _holders The account to update\n     * @param _iTokens The _iTokens to update\n     * @param _isBorrow whether to update the borrow state\n     */\n    function _updateRewards(\n        address[] memory _holders,\n        address[] memory _iTokens,\n        bool _isBorrow\n    ) internal {\n        // Update rewards for all _iTokens for holders\n        for (uint256 i = 0; i < _iTokens.length; i++) {\n            address _iToken = _iTokens[i];\n            _updateDistributionState(_iToken, _isBorrow);\n            for (uint256 j = 0; j < _holders.length; j++) {\n                _updateReward(_iToken, _holders[j], _isBorrow);\n            }\n        }\n    }\n\n    /**\n     * @notice Claim reward accrued in iTokens by the holders\n     * @param _holders The account to claim for\n     * @param _iTokens The _iTokens to claim from\n     */\n    function claimReward(\n        address[] memory _holders,\n        address[] memory _iTokens\n    ) public override onlyManager {\n        updateRewardBatch(_holders, _iTokens);\n\n        // Withdraw all reward for all holders\n        for (uint256 j = 0; j < _holders.length; j++) {\n            address _account = _holders[j];\n            uint256 _reward = reward[_account];\n            if (_reward > 0) {\n                reward[_account] = 0;\n                IERC20(rewardToken).safeTransferFrom(\n                    treasury,\n                    _account,\n                    _reward\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Claim reward accrued in iTokens by the holders\n     * @param _holders The account to claim for\n     * @param _suppliediTokens The _suppliediTokens to claim from\n     * @param _borrowediTokens The _borrowediTokens to claim from\n     */\n    function claimRewards(\n        address[] memory _holders,\n        address[] memory _suppliediTokens,\n        address[] memory _borrowediTokens\n    ) external override onlyManager {\n        _updateRewards(_holders, _suppliediTokens, false);\n        _updateRewards(_holders, _borrowediTokens, true);\n\n        // Withdraw all reward for all holders\n        for (uint256 j = 0; j < _holders.length; j++) {\n            address _account = _holders[j];\n            uint256 _reward = reward[_account];\n            if (_reward > 0) {\n                reward[_account] = 0;\n                IERC20(rewardToken).safeTransferFrom(\n                    treasury,\n                    _account,\n                    _reward\n                );\n            }\n        }\n    }\n\n    /**\n     * @notice Claim reward accrued in all iTokens by the holders\n     * @param _holders The account to claim for\n     */\n    function claimAllReward(\n        address[] memory _holders\n    ) external override onlyManager {\n        claimReward(_holders, controller.getAlliTokens());\n    }\n\n    /**\n     * @notice Rescue tokens, can only be called by treasury\n     * @param _token The token to rescue\n     * @param _amount The amount of token to rescue\n     * @param _to The token to send to\n     */\n    function rescueTokens(\n        address _token,\n        uint256 _amount,\n        address _to\n    ) external {\n        if (msg.sender != treasury) {\n            revert RewardDistributor_rescueTokens__CallerIsNotTreasury();\n        }\n\n        // transfer _to\n        IERC20(_token).safeTransfer(_to, _amount);\n    }\n\n    /**\n     * @notice Set bounty ratio by admin\n     * @param _bountyRatio the ratio in 1e18\n     */\n    function _setBountyRatio(uint256 _bountyRatio) external onlyOwner {\n        if (_bountyRatio > BOUNTY_RATIO_MAX) {\n            revert RewardDistributor_setBountyRatio__RatioTooHigh();\n        }\n\n        uint256 _oldBountyRatio = bountyRatio;\n        bountyRatio = _bountyRatio;\n        emit NewBountyRatio(_oldBountyRatio, _bountyRatio);\n    }\n\n    function claimBounty(\n        address _account,\n        address _hunter\n    ) external onlyManager {\n        uint256 _reward = reward[_account];\n\n        if (_reward > 0) {\n            reward[_account] = 0;\n            uint256 _bounty = _reward.rmul(bountyRatio);\n\n            IERC20(rewardToken).safeTransferFrom(treasury, _hunter, _bounty);\n            IERC20(rewardToken).safeTransferFrom(\n                treasury,\n                _account,\n                _reward - _bounty\n            );\n\n            emit BountyClaimed(\n                rewardToken,\n                _hunter,\n                _account,\n                _bounty,\n                _reward\n            );\n        }\n    }\n}\n"
    }
  }
}}