{{
  "language": "Solidity",
  "sources": {
    "src/base/DecodersAndSanitizers/PointFarmingDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\nimport {MantleStandardBridgeDecoderAndSanitizer} from\n    \"src/base/DecodersAndSanitizers/Protocols/MantleStandardBridgeDecoderAndSanitizer.sol\";\nimport {ScrollBridgeDecoderAndSanitizer} from\n    \"src/base/DecodersAndSanitizers/Protocols/ScrollBridgeDecoderAndSanitizer.sol\";\nimport {LineaBridgeDecoderAndSanitizer} from\n    \"src/base/DecodersAndSanitizers/Protocols/LineaBridgeDecoderAndSanitizer.sol\";\nimport {StandardBridgeDecoderAndSanitizer} from\n    \"src/base/DecodersAndSanitizers/Protocols/StandardBridgeDecoderAndSanitizer.sol\";\nimport {OFTDecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/Protocols/OFTDecoderAndSanitizer.sol\";\n\ncontract PointFarmingDecoderAndSanitizer is\n    StandardBridgeDecoderAndSanitizer,\n    LineaBridgeDecoderAndSanitizer,\n    MantleStandardBridgeDecoderAndSanitizer,\n    ScrollBridgeDecoderAndSanitizer,\n    OFTDecoderAndSanitizer\n{\n    constructor(address _boringVault) BaseDecoderAndSanitizer(_boringVault) {}\n\n    //============================== HANDLE FUNCTION COLLISIONS ===============================\n}\n"
    },
    "src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {DecoderCustomTypes} from \"src/interfaces/DecoderCustomTypes.sol\";\n\ncontract BaseDecoderAndSanitizer {\n    error BaseDecoderAndSanitizer__FunctionSelectorNotSupported();\n    //============================== IMMUTABLES ===============================\n\n    /**\n     * @notice The BoringVault contract address.\n     */\n    address internal immutable boringVault;\n\n    constructor(address _boringVault) {\n        boringVault = _boringVault;\n    }\n\n    function approve(address spender, uint256) external pure returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(spender);\n    }\n\n    function transfer(address _to, uint256) external pure returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(_to);\n    }\n\n    function claimFees(address feeAsset) external pure returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(feeAsset);\n    }\n\n    function withdrawNonBoringToken(address token, uint256 /*amount*/ )\n        external\n        pure\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(token);\n    }\n\n    function withdrawNativeFromDrone() external pure returns (bytes memory addressesFound) {\n        return addressesFound;\n    }\n\n    //============================== FALLBACK ===============================\n    /**\n     * @notice The purpose of this function is to revert with a known error,\n     *         so that during merkle tree creation we can verify that a\n     *         leafs decoder and sanitizer implments the required function\n     *         selector.\n     */\n    fallback() external {\n        revert BaseDecoderAndSanitizer__FunctionSelectorNotSupported();\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/MantleStandardBridgeDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract MantleStandardBridgeDecoderAndSanitizer is BaseDecoderAndSanitizer {\n    /// @notice The mantle bridge closely follows the standard bridge format, but has a couple of breaking changes\n    /// that are accounted for using the functions below.\n    //============================== MantleStandardBridge ===============================\n\n    function bridgeETHTo(uint256, /*amount*/ address _to, uint32, /*_minGasLimit*/ bytes calldata /*_extraData*/ )\n        external\n        pure\n        virtual\n        returns (bytes memory sensitiveArguments)\n    {\n        // Extract sensitive arguments.\n        sensitiveArguments = abi.encodePacked(_to);\n    }\n\n    // Example TX https://etherscan.io/tx/0xe1b6ba19b47dadf53f1c67ed0fe7109b0c78bb8c3abb8c9578a9fa789fe725d7\n    function proveWithdrawalTransaction(\n        DecoderCustomTypes.MantleWithdrawalTransaction calldata _tx,\n        uint256, /*_l2OutputIndex*/\n        DecoderCustomTypes.OutputRootProof calldata, /*_outputRootProof*/\n        bytes[] calldata /*_withdrawalProof*/\n    ) external pure virtual returns (bytes memory sensitiveArguments) {\n        sensitiveArguments = abi.encodePacked(_tx.sender, _tx.target);\n    }\n\n    /// @notice Eample TX https://etherscan.io/tx/0x258c80e4c282fc94ddbec05bf64c602a437a2f26b1d2c14b6d16802ab1de9a11\n    function finalizeWithdrawalTransaction(DecoderCustomTypes.MantleWithdrawalTransaction calldata _tx)\n        external\n        pure\n        virtual\n        returns (bytes memory sensitiveArguments)\n    {\n        sensitiveArguments = abi.encodePacked(_tx.sender, _tx.target);\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/ScrollBridgeDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract ScrollBridgeDecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== Scroll Native Bridge ===============================\n\n    /// @notice Example deposit TX https://etherscan.io/tx/0xadf2121b495a0f6222219095dd3e116cd7b550c1a1a98ec1a561c9bff323eef9\n    /// @notice Example withdraw TX https://scrollscan.com/tx/0xfc81ca5bcba7d43cace50765117ecf9cf9d4f177c2493475171c26a91343f801\n    function sendMessage(address _to, uint256, /*_value*/ bytes calldata, /*_message*/ uint256 /*_gasLimit*/ )\n        external\n        pure\n        virtual\n        returns (bytes memory sensitiveArguments)\n    {\n        // Extract sensitive arguments.\n        sensitiveArguments = abi.encodePacked(_to);\n    }\n\n    /// @notice Example TX ETH https://etherscan.io/tx/0xdb9f80b209b7e56b529c07d74d686eca7f0e5c3962d5bf5d8c554929f69b7016\n    /// @notice Example TX ERC20 https://etherscan.io/tx/0x17f8e5674384e70987d5f31b3f9609968117a131ab5d376fcd69f26e2a658b6e\n    function relayMessageWithProof(\n        address _from,\n        address _to,\n        uint256, /*_value*/\n        uint256, /*_nonce*/\n        bytes calldata, /*_message*/\n        DecoderCustomTypes.L2MessageProof calldata /*_proof*/\n    ) external pure virtual returns (bytes memory sensitiveArguments) {\n        // Extract sensitive arguments.\n        sensitiveArguments = abi.encodePacked(_from, _to);\n    }\n\n    /// @notice Example TX https://etherscan.io/tx/0xa25e6c5dc294f469fbb754f74aa262b61353a5df68671e41bfe48faecd100059\n    function depositERC20(address _token, address _to, uint256, /*_amount*/ uint256 /*_gasLimit*/ )\n        external\n        pure\n        virtual\n        returns (bytes memory sensitiveArguments)\n    {\n        // Extract sensitive arguments.\n        sensitiveArguments = abi.encodePacked(_token, _to);\n    }\n\n    /// @notice Example TX https://scrollscan.com/tx/0xfcc5bdc518524b7f92f0d38dc696662c9a145123211c894b69607368578cc15d\n    function withdrawERC20(address _token, address _to, uint256, /*_amount*/ uint256 /*_gasLimit*/ )\n        external\n        pure\n        virtual\n        returns (bytes memory sensitiveArguments)\n    {\n        // Extract sensitive arguments.\n        sensitiveArguments = abi.encodePacked(_token, _to);\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/LineaBridgeDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract LineaBridgeDecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== Linea Native Bridge ===============================\n\n    /// @notice Example TX https://etherscan.io/tx/0x6fe5dcbafb6620980ec571cde88e6e651075214a0b698543eb5589e8889d52bd\n    /// @notice Set _fee to zero in order to claim funds manually.\n    /// @notice When bridging from Linea to mainnet a fee is required, so I think it is best to just allow the strategist\n    /// to pick a good fee value and do no sanitation of it.\n    function sendMessage(address _to, uint256, /*_fee*/ bytes calldata /*_calldata*/ )\n        external\n        pure\n        virtual\n        returns (bytes memory sensitiveArguments)\n    {\n        // Extract sensitive arguments.\n        sensitiveArguments = abi.encodePacked(_to);\n    }\n\n    // Bridge ERC20\n    // Example TX https://etherscan.io/tx/0x9935e537c51807f4097444399f08b04798dfe2a0f96cbf0b186caa9e8ab9d111\n    // Example TX https://lineascan.build/tx/0xa1ed773719a0d17373b5ce2db7c2e8c924eff99865dd0d3cdb4b58f3e9ea5310\n    function bridgeToken(address _token, uint256, /*_amount*/ address _recipient)\n        external\n        pure\n        virtual\n        returns (bytes memory sensitiveArguments)\n    {\n        // Extract sensitive arguments.\n        sensitiveArguments = abi.encodePacked(_token, _recipient);\n    }\n\n    // https://lineascan.build/tx/0xc97c7d28163dc81c5dd5c735d607952959a06a3016bada86484712d4c6cdea3f\n    // Used to claim ETH or ERC20s on destination chain, if no fee is provided.\n    function claimMessage(\n        address _from,\n        address _to,\n        uint256, /*_fee*/\n        uint256, /*_value*/\n        address _feeRecipient,\n        bytes calldata, /*_calldata*/\n        uint256 /*_nonce*/\n    ) external pure virtual returns (bytes memory sensitiveArguments) {\n        sensitiveArguments = abi.encodePacked(_from, _to, _feeRecipient);\n    }\n\n    // Example TX https://etherscan.io/tx/0x9af51fdd89ac1658a480605fad1105f95290420acff3d978f8df847e9e3891b7\n    function claimMessageWithProof(DecoderCustomTypes.ClaimMessageWithProofParams calldata _claimMessageWithProof)\n        external\n        pure\n        virtual\n        returns (bytes memory sensitiveArguments)\n    {\n        sensitiveArguments = abi.encodePacked(\n            _claimMessageWithProof.from, _claimMessageWithProof.to, _claimMessageWithProof.feeRecipient\n        );\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/StandardBridgeDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract StandardBridgeDecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== StandardBridge ===============================\n\n    /// @notice Example TX https://etherscan.io/tx/0x0b1cc213286c328e3fb483cfef9342aee51409b67ee5af1dc409e37273710f9f\n    /// @notice Eample TX https://basescan.org/tx/0x7805ac08f38bec2d98edafc2e6f9571271a76b5ede3928f96d3edbc459d0ea4d\n    function bridgeETHTo(address _to, uint32, /*_minGasLimit*/ bytes calldata /*_extraData*/ )\n        external\n        pure\n        virtual\n        returns (bytes memory sensitiveArguments)\n    {\n        // Extract sensitive arguments.\n        sensitiveArguments = abi.encodePacked(_to);\n    }\n\n    function bridgeERC20To(\n        address _localToken,\n        address _remoteToken,\n        address _to,\n        uint256, /*_amount*/\n        uint32, /*_minGasLimit*/\n        bytes calldata /*_extraData*/\n    ) external pure virtual returns (bytes memory sensitiveArguments) {\n        // Extract sensitive arguments.\n        sensitiveArguments = abi.encodePacked(_localToken, _remoteToken, _to);\n    }\n\n    /// @notice Example TX https://etherscan.io/tx/0x774db0b2aac5123f7a67fe00d57fb6c1f731457df435097481e7c8c913630fe1\n    /// @notice This appears to be callable by anyone, so I would think that the sender and target values are constrained by the proofs\n    // Playing with tendely sims, this does seem to be the case, so I am not sure it is worth it to sanitize these arguments\n    function proveWithdrawalTransaction(\n        DecoderCustomTypes.WithdrawalTransaction calldata _tx,\n        uint256, /*_l2OutputIndex*/\n        DecoderCustomTypes.OutputRootProof calldata, /*_outputRootProof*/\n        bytes[] calldata /*_withdrawalProof*/\n    ) external pure virtual returns (bytes memory sensitiveArguments) {\n        sensitiveArguments = abi.encodePacked(_tx.sender, _tx.target);\n    }\n\n    /// @notice Eample TX https://etherscan.io/tx/0x5bb20258a0b151a6acb01f05ea42ee2f51123cba5d51e9be46a5033e675faefe\n    function finalizeWithdrawalTransaction(DecoderCustomTypes.WithdrawalTransaction calldata _tx)\n        external\n        pure\n        virtual\n        returns (bytes memory sensitiveArguments)\n    {\n        sensitiveArguments = abi.encodePacked(_tx.sender, _tx.target);\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/OFTDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract OFTDecoderAndSanitizer is BaseDecoderAndSanitizer {\n    error OFTDecoderAndSanitizer__NonZeroMessage();\n    error OFTDecoderAndSanitizer__NonZeroOFTCommand();\n\n    //============================== OFT ===============================\n\n    function send(\n        DecoderCustomTypes.SendParam calldata _sendParam,\n        DecoderCustomTypes.MessagingFee calldata, /*_fee*/\n        address _refundAddress\n    ) external pure virtual returns (bytes memory sensitiveArguments) {\n        // Sanitize Message.\n        if (_sendParam.composeMsg.length > 0) {\n            revert OFTDecoderAndSanitizer__NonZeroMessage();\n        }\n        if (_sendParam.oftCmd.length > 0) {\n            revert OFTDecoderAndSanitizer__NonZeroOFTCommand();\n        }\n\n        sensitiveArguments =\n            abi.encodePacked(address(uint160(_sendParam.dstEid)), address(bytes20(_sendParam.to << 96)), _refundAddress);\n    }\n}\n"
    },
    "src/interfaces/DecoderCustomTypes.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\ncontract DecoderCustomTypes {\n    // ========================================= BALANCER =========================================\n    struct JoinPoolRequest {\n        address[] assets;\n        uint256[] maxAmountsIn;\n        bytes userData;\n        bool fromInternalBalance;\n    }\n\n    struct ExitPoolRequest {\n        address[] assets;\n        uint256[] minAmountsOut;\n        bytes userData;\n        bool toInternalBalance;\n    }\n\n    enum SwapKind {\n        GIVEN_IN,\n        GIVEN_OUT\n    }\n\n    struct SingleSwap {\n        bytes32 poolId;\n        SwapKind kind;\n        address assetIn;\n        address assetOut;\n        uint256 amount;\n        bytes userData;\n    }\n\n    struct FundManagement {\n        address sender;\n        bool fromInternalBalance;\n        address recipient;\n        bool toInternalBalance;\n    }\n\n    // ========================================= UNISWAP V3 =========================================\n\n    struct MintParams {\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n    }\n\n    struct IncreaseLiquidityParams {\n        uint256 tokenId;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    struct DecreaseLiquidityParams {\n        uint256 tokenId;\n        uint128 liquidity;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    struct CollectParams {\n        uint256 tokenId;\n        address recipient;\n        uint128 amount0Max;\n        uint128 amount1Max;\n    }\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    struct PancakeSwapExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    // ========================================= MORPHO BLUE =========================================\n\n    struct MarketParams {\n        address loanToken;\n        address collateralToken;\n        address oracle;\n        address irm;\n        uint256 lltv;\n    }\n\n    // ========================================= 1INCH =========================================\n\n    struct SwapDescription {\n        address srcToken;\n        address dstToken;\n        address payable srcReceiver;\n        address payable dstReceiver;\n        uint256 amount;\n        uint256 minReturnAmount;\n        uint256 flags;\n    }\n\n    // ========================================= PENDLE =========================================\n    struct TokenInput {\n        // TOKEN DATA\n        address tokenIn;\n        uint256 netTokenIn;\n        address tokenMintSy;\n        // AGGREGATOR DATA\n        address pendleSwap;\n        SwapData swapData;\n    }\n\n    struct TokenOutput {\n        // TOKEN DATA\n        address tokenOut;\n        uint256 minTokenOut;\n        address tokenRedeemSy;\n        // AGGREGATOR DATA\n        address pendleSwap;\n        SwapData swapData;\n    }\n\n    struct ApproxParams {\n        uint256 guessMin;\n        uint256 guessMax;\n        uint256 guessOffchain; // pass 0 in to skip this variable\n        uint256 maxIteration; // every iteration, the diff between guessMin and guessMax will be divided by 2\n        uint256 eps; // the max eps between the returned result & the correct result, base 1e18. Normally this number will be set\n            // to 1e15 (1e18/1000 = 0.1%)\n    }\n\n    struct SwapData {\n        SwapType swapType;\n        address extRouter;\n        bytes extCalldata;\n        bool needScale;\n    }\n\n    enum SwapType {\n        NONE,\n        KYBERSWAP,\n        ONE_INCH,\n        // ETH_WETH not used in Aggregator\n        ETH_WETH\n    }\n\n    struct LimitOrderData {\n        address limitRouter;\n        uint256 epsSkipMarket; // only used for swap operations, will be ignored otherwise\n        FillOrderParams[] normalFills;\n        FillOrderParams[] flashFills;\n        bytes optData;\n    }\n\n    struct FillOrderParams {\n        Order order;\n        bytes signature;\n        uint256 makingAmount;\n    }\n\n    struct Order {\n        uint256 salt;\n        uint256 expiry;\n        uint256 nonce;\n        OrderType orderType;\n        address token;\n        address YT;\n        address maker;\n        address receiver;\n        uint256 makingAmount;\n        uint256 lnImpliedRate;\n        uint256 failSafeRate;\n        bytes permit;\n    }\n\n    enum OrderType {\n        SY_FOR_PT,\n        PT_FOR_SY,\n        SY_FOR_YT,\n        YT_FOR_SY\n    }\n\n    // ========================================= EIGEN LAYER =========================================\n\n    struct QueuedWithdrawalParams {\n        // Array of strategies that the QueuedWithdrawal contains\n        address[] strategies;\n        // Array containing the amount of shares in each Strategy in the `strategies` array\n        uint256[] shares;\n        // The address of the withdrawer\n        address withdrawer;\n    }\n\n    struct Withdrawal {\n        // The address that originated the Withdrawal\n        address staker;\n        // The address that the staker was delegated to at the time that the Withdrawal was created\n        address delegatedTo;\n        // The address that can complete the Withdrawal + will receive funds when completing the withdrawal\n        address withdrawer;\n        // Nonce used to guarantee that otherwise identical withdrawals have unique hashes\n        uint256 nonce;\n        // Block number when the Withdrawal was created\n        uint32 startBlock;\n        // Array of strategies that the Withdrawal contains\n        address[] strategies;\n        // Array containing the amount of shares in each Strategy in the `strategies` array\n        uint256[] shares;\n    }\n\n    struct SignatureWithExpiry {\n        // the signature itself, formatted as a single bytes object\n        bytes signature;\n        // the expiration timestamp (UTC) of the signature\n        uint256 expiry;\n    }\n\n    // ========================================= CCIP =========================================\n\n    // If extraArgs is empty bytes, the default is 200k gas limit.\n    struct EVM2AnyMessage {\n        bytes receiver; // abi.encode(receiver address) for dest EVM chains\n        bytes data; // Data payload\n        EVMTokenAmount[] tokenAmounts; // Token transfers\n        address feeToken; // Address of feeToken. address(0) means you will send msg.value.\n        bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV2)\n    }\n\n    /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n    struct EVMTokenAmount {\n        address token; // token address on the local chain.\n        uint256 amount; // Amount of tokens.\n    }\n\n    struct EVMExtraArgsV1 {\n        uint256 gasLimit;\n    }\n\n    // ========================================= OFT =========================================\n\n    struct SendParam {\n        uint32 dstEid; // Destination endpoint ID.\n        bytes32 to; // Recipient address.\n        uint256 amountLD; // Amount to send in local decimals.\n        uint256 minAmountLD; // Minimum amount to send in local decimals.\n        bytes extraOptions; // Additional options supplied by the caller to be used in the LayerZero message.\n        bytes composeMsg; // The composed message for the send() operation.\n        bytes oftCmd; // The OFT command to be executed, unused in default OFT implementations.\n    }\n\n    struct MessagingFee {\n        uint256 nativeFee;\n        uint256 lzTokenFee;\n    }\n    // ========================================= L1StandardBridge =========================================\n\n    struct WithdrawalTransaction {\n        uint256 nonce;\n        address sender;\n        address target;\n        uint256 value;\n        uint256 gasLimit;\n        bytes data;\n    }\n\n    struct OutputRootProof {\n        bytes32 version;\n        bytes32 stateRoot;\n        bytes32 messagePasserStorageRoot;\n        bytes32 latestBlockhash;\n    }\n\n    // ========================================= Mantle L1StandardBridge =========================================\n\n    struct MantleWithdrawalTransaction {\n        uint256 nonce;\n        address sender;\n        address target;\n        uint256 mntValue;\n        uint256 value;\n        uint256 gasLimit;\n        bytes data;\n    }\n\n    // ========================================= Linea Bridge =========================================\n\n    struct ClaimMessageWithProofParams {\n        bytes32[] proof;\n        uint256 messageNumber;\n        uint32 leafIndex;\n        address from;\n        address to;\n        uint256 fee;\n        uint256 value;\n        address payable feeRecipient;\n        bytes32 merkleRoot;\n        bytes data;\n    }\n\n    // ========================================= Scroll Bridge =========================================\n\n    struct L2MessageProof {\n        uint256 batchIndex;\n        bytes merkleProof;\n    }\n\n    // ========================================= Camelot V3 =========================================\n\n    struct CamelotMintParams {\n        address token0;\n        address token1;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n    }\n    // ========================================= Velodrome V3 =========================================\n\n    struct VelodromeMintParams {\n        address token0;\n        address token1;\n        int24 tickSpacing;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n        uint160 sqrtPriceX96;\n    }\n\n    // ========================================= Karak =========================================\n\n    struct QueuedWithdrawal {\n        address staker;\n        address delegatedTo;\n        uint256 nonce;\n        uint256 start;\n        WithdrawRequest request;\n    }\n\n    struct WithdrawRequest {\n        address[] vaults;\n        uint256[] shares;\n        address withdrawer;\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@solmate/=lib/solmate/src/",
      "@forge-std/=lib/forge-std/src/",
      "@ds-test/=lib/forge-std/lib/ds-test/src/",
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "@openzeppelin/=lib/openzeppelin-contracts/",
      "@ccip/=lib/ccip/",
      "@devtools-oapp-evm/=lib/OAppAuth/lib/devtools/packages/oapp-evm/contracts/oapp/",
      "@layerzerolabs/lz-evm-protocol-v2/=lib/OAppAuth/lib/layerzero-v2/packages/layerzero-v2/evm/protocol/",
      "@layerzerolabs/oapp-evm/=lib/OAppAuth/lib/devtools/packages/oapp-evm/",
      "@lz-oapp-evm/=lib/OAppAuth/lib/LayerZero-V2/packages/layerzero-v2/evm/oapp/contracts/oapp/",
      "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
      "LayerZero-V2/=lib/OAppAuth/lib/",
      "LayerZero-v2/=lib/LayerZero-v2/",
      "OAppAuth/=lib/OAppAuth/",
      "ccip/=lib/ccip/contracts/",
      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      "forge-std/=lib/forge-std/src/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/",
      "solmate/=lib/solmate/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "evmVersion": "shanghai",
    "viaIR": false,
    "libraries": {}
  }
}}