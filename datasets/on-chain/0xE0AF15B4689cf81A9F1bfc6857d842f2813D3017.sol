{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "london",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 5000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "contracts/access/Governable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../interfaces/core/IAddressProvider.sol\";\n\n/**\n * @notice Contract module which provides access control mechanism, where\n * the governor account is granted with exclusive access to specific functions.\n * @dev Uses the AddressProvider to get the governor\n */\nabstract contract Governable {\n    IAddressProvider public constant addressProvider = IAddressProvider(0xfbA0816A81bcAbBf3829bED28618177a2bf0e82A);\n\n    /// @dev Throws if called by any account other than the governor.\n    modifier onlyGovernor() {\n        require(msg.sender == addressProvider.governor(), \"not-governor\");\n        _;\n    }\n}\n"
    },
    "contracts/features/UsingStalePeriod.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../access/Governable.sol\";\n\n/**\n * @title Stale price check feature, useful when checking if prices are fresh enough\n */\nabstract contract UsingStalePeriod is Governable {\n    /// @notice The default stale period. It's used to determine if a price is invalid (i.e. outdated)\n    uint256 public defaultStalePeriod;\n\n    /// @notice Custom stale period, used for token that has different stale window (e.g. some stable coins have 24h window)\n    mapping(address => uint256) customStalePeriod;\n\n    /// @notice Emitted when custom stale period is updated\n    event CustomStalePeriodUpdated(address token, uint256 oldStalePeriod, uint256 newStalePeriod);\n\n    /// @notice Emitted when default stale period is updated\n    event DefaultStalePeriodUpdated(uint256 oldStalePeriod, uint256 newStalePeriod);\n\n    constructor(uint256 defaultStalePeriod_) {\n        defaultStalePeriod = defaultStalePeriod_;\n    }\n\n    /**\n     * @notice Get stale period of a token\n     */\n    function stalePeriodOf(address token_) public view returns (uint256 _stalePeriod) {\n        _stalePeriod = customStalePeriod[token_];\n        if (_stalePeriod == 0) {\n            _stalePeriod = defaultStalePeriod;\n        }\n    }\n\n    /**\n     * @notice Check if a price timestamp is outdated\n     * @dev Uses default stale period\n     * @param timeOfLastUpdate_ The price timestamp\n     * @return true if price is stale (outdated)\n     */\n    function _priceIsStale(address token_, uint256 timeOfLastUpdate_) internal view returns (bool) {\n        return _priceIsStale(timeOfLastUpdate_, stalePeriodOf(token_));\n    }\n\n    /**\n     * @notice Check if a price timestamp is outdated\n     * @param timeOfLastUpdate_ The price timestamp\n     * @param stalePeriod_ The maximum acceptable outdated period\n     * @return true if price is stale (outdated)\n     */\n    function _priceIsStale(uint256 timeOfLastUpdate_, uint256 stalePeriod_) internal view returns (bool) {\n        return block.timestamp - timeOfLastUpdate_ > stalePeriod_;\n    }\n\n    /**\n     * @notice Update custom stale period\n     * @dev Use `0` as `stalePeriod_` to remove custom stale period\n     */\n    function updateCustomStalePeriod(address token_, uint256 stalePeriod_) external onlyGovernor {\n        require(token_ != address(0), \"token-is-null\");\n        emit CustomStalePeriodUpdated(token_, customStalePeriod[token_], stalePeriod_);\n        if (stalePeriod_ > 0) {\n            customStalePeriod[token_] = stalePeriod_;\n        } else {\n            delete customStalePeriod[token_];\n        }\n    }\n\n    /**\n     * @notice Update default stale period\n     */\n    function updateDefaultStalePeriod(uint256 stalePeriod_) external onlyGovernor {\n        emit DefaultStalePeriodUpdated(defaultStalePeriod, stalePeriod_);\n        defaultStalePeriod = stalePeriod_;\n    }\n}\n"
    },
    "contracts/interfaces/core/IAddressProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"./IStableCoinProvider.sol\";\nimport \"./IPriceProvidersAggregator.sol\";\n\ninterface IAddressProvider {\n    function governor() external view returns (address);\n\n    function providersAggregator() external view returns (IPriceProvidersAggregator);\n\n    function stableCoinProvider() external view returns (IStableCoinProvider);\n\n    function updateProvidersAggregator(IPriceProvidersAggregator providersAggregator_) external;\n}\n"
    },
    "contracts/interfaces/core/IPriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IPriceProvider {\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param token_ The address of asset\n     * @return _priceInUsd The USD price\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function getPriceInUsd(address token_) external view returns (uint256 _priceInUsd, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _tokenInLastUpdatedAt Last updated timestamp of `tokenIn_`\n     * @return _tokenOutLastUpdatedAt Last updated timestamp of `tokenOut_`\n     */\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        external\n        view\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        );\n\n    /**\n     * @notice Get quote in USD (or equivalent) amount\n     * @param token_ The address of assetIn\n     * @param amountIn_ Amount of input token.\n     * @return amountOut_ Amount in USD\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteTokenToUsd(address token_, uint256 amountIn_)\n        external\n        view\n        returns (uint256 amountOut_, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote from USD (or equivalent) amount to amount of token\n     * @param token_ The address of assetOut\n     * @param amountIn_ Input amount in USD\n     * @return _amountOut Output amount of token\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteUsdToToken(address token_, uint256 amountIn_)\n        external\n        view\n        returns (uint256 _amountOut, uint256 _lastUpdatedAt);\n}\n"
    },
    "contracts/interfaces/core/IPriceProvidersAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"../../libraries/DataTypes.sol\";\nimport \"./IPriceProvider.sol\";\n\n/**\n * @notice PriceProvidersAggregator interface\n * @dev Worth noting that the `_lastUpdatedAt` logic depends on the underlying price provider. In summary:\n * ChainLink: returns the last updated date from the aggregator\n * UniswapV2: returns the date of the latest pair oracle update\n * UniswapV3: assumes that the price is always updated (returns block.timestamp)\n * Umbrella (FCD): returns the last updated date returned from their oracle contract\n * Umbrella (Passport): returns the date of the latest pallet submission\n * Anytime that a quote performs more than one query, it uses the oldest date as the `_lastUpdatedAt`.\n * See more: https://github.com/bloqpriv/one-oracle/issues/64\n */\ninterface IPriceProvidersAggregator {\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param provider_ The price provider to get quote from\n     * @param token_ The address of asset\n     * @return _priceInUsd The USD price\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function getPriceInUsd(\n        DataTypes.Provider provider_,\n        address token_\n    ) external view returns (uint256 _priceInUsd, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Provider Providers' mapping\n     */\n    function priceProviders(DataTypes.Provider provider_) external view returns (IPriceProvider _priceProvider);\n\n    /**\n     * @notice Get quote\n     * @param provider_ The price provider to get quote from\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _tokenInLastUpdatedAt Last updated timestamp of `tokenIn_`\n     * @return _tokenOutLastUpdatedAt Last updated timestamp of `tokenOut_`\n     */\n    function quote(\n        DataTypes.Provider provider_,\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) external view returns (uint256 _amountOut, uint256 _tokenInLastUpdatedAt, uint256 _tokenOutLastUpdatedAt);\n\n    /**\n     * @notice Get quote\n     * @dev If providers aren't the same, uses native token as \"bridge\"\n     * @param providerIn_ The price provider to get quote for the tokenIn\n     * @param tokenIn_ The address of assetIn\n     * @param providerOut_ The price provider to get quote for the tokenOut\n     * @param tokenOut_ The address of assetOut\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     * @return _tokenInLastUpdatedAt Last updated timestamp of `tokenIn_`\n     * @return _nativeTokenLastUpdatedAt Last updated timestamp of native token (i.e. WETH) used when providers aren't the same\n     * @return _tokenOutLastUpdatedAt Last updated timestamp of `tokenOut_`\n     */\n    function quote(\n        DataTypes.Provider providerIn_,\n        address tokenIn_,\n        DataTypes.Provider providerOut_,\n        address tokenOut_,\n        uint256 amountIn_\n    )\n        external\n        view\n        returns (\n            uint256 _amountOut,\n            uint256 _tokenInLastUpdatedAt,\n            uint256 _nativeTokenLastUpdatedAt,\n            uint256 _tokenOutLastUpdatedAt\n        );\n\n    /**\n     * @notice Get quote in USD (or equivalent) amount\n     * @param provider_ The price provider to get quote from\n     * @param token_ The address of assetIn\n     * @param amountIn_ Amount of input token.\n     * @return amountOut_ Amount in USD\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteTokenToUsd(\n        DataTypes.Provider provider_,\n        address token_,\n        uint256 amountIn_\n    ) external view returns (uint256 amountOut_, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Get quote from USD (or equivalent) amount to amount of token\n     * @param provider_ The price provider to get quote from\n     * @param token_ The address of assetOut\n     * @param amountIn_ Input amount in USD\n     * @return _amountOut Output amount of token\n     * @return _lastUpdatedAt Last updated timestamp\n     */\n    function quoteUsdToToken(\n        DataTypes.Provider provider_,\n        address token_,\n        uint256 amountIn_\n    ) external view returns (uint256 _amountOut, uint256 _lastUpdatedAt);\n\n    /**\n     * @notice Set a price provider\n     * @dev Administrative function\n     * @param provider_ The provider (from enum)\n     * @param priceProvider_ The price provider contract\n     */\n    function setPriceProvider(DataTypes.Provider provider_, IPriceProvider priceProvider_) external;\n}\n"
    },
    "contracts/interfaces/core/IStableCoinProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IStableCoinProvider {\n    /**\n     * @notice Return the stable coin if pegged\n     * @dev Check price relation between both stable coins and revert if peg is too loose\n     * @return _stableCoin The primary stable coin if pass all checks\n     */\n    function getStableCoinIfPegged() external view returns (address _stableCoin);\n\n    /**\n     * @notice Convert given amount of stable coin to USD representation (18 decimals)\n     */\n    function toUsdRepresentation(uint256 stableCoinAmount_) external view returns (uint256 _usdAmount);\n}\n"
    },
    "contracts/interfaces/periphery/IOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\ninterface IOracle {\n    /**\n     * @notice Get USD (or equivalent) price of an asset\n     * @param token_ The address of asset\n     * @return _priceInUsd The USD price\n     */\n    function getPriceInUsd(address token_) external view returns (uint256 _priceInUsd);\n\n    /**\n     * @notice Get quote\n     * @param tokenIn_ The address of assetIn\n     * @param tokenOut_ The address of assetOut\n     * @param amountIn_ Amount of input token\n     * @return _amountOut Amount out\n     */\n    function quote(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) external view returns (uint256 _amountOut);\n\n    /**\n     * @notice Get quote in USD (or equivalent) amount\n     * @param token_ The address of assetIn\n     * @param amountIn_ Amount of input token.\n     * @return amountOut_ Amount in USD\n     */\n    function quoteTokenToUsd(address token_, uint256 amountIn_) external view returns (uint256 amountOut_);\n\n    /**\n     * @notice Get quote from USD (or equivalent) amount to amount of token\n     * @param token_ The address of assetOut\n     * @param amountIn_ Input amount in USD\n     * @return _amountOut Output amount of token\n     */\n    function quoteUsdToToken(address token_, uint256 amountIn_) external view returns (uint256 _amountOut);\n}\n"
    },
    "contracts/libraries/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nlibrary DataTypes {\n    /**\n     * @notice Price providers enumeration\n     */\n    enum Provider {\n        NONE,\n        CHAINLINK,\n        UNISWAP_V3,\n        UNISWAP_V2,\n        SUSHISWAP,\n        TRADERJOE,\n        PANGOLIN,\n        QUICKSWAP,\n        UMBRELLA_FIRST_CLASS,\n        UMBRELLA_PASSPORT\n    }\n}\n"
    },
    "contracts/periphery/MainAndFallbackOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport {IOracle} from \"../interfaces/periphery/IOracle.sol\";\nimport {IPriceProvider} from \"../interfaces/core/IPriceProvider.sol\";\nimport {UsingStalePeriod} from \"../features/UsingStalePeriod.sol\";\n\n/**\n * @title Main and Fallback oracle\n * @dev Uses a primary oracle, if it doesn't support the asset, or price is staled, try getting price from the fallback.\n */\ncontract MainAndFallbackOracle is IOracle, UsingStalePeriod {\n    IPriceProvider public immutable mainProvider;\n    IPriceProvider public immutable fallbackProvider;\n\n    constructor(\n        IPriceProvider mainProvider_,\n        IPriceProvider fallbackProvider_,\n        uint256 stalePeriod_\n    ) UsingStalePeriod(stalePeriod_) {\n        require(address(mainProvider_) != address(0), \"main-is-null\");\n        require(address(fallbackProvider_) != address(0), \"fallback-is-null\");\n        mainProvider = mainProvider_;\n        fallbackProvider = fallbackProvider_;\n    }\n\n    /// @inheritdoc IOracle\n    function getPriceInUsd(address _asset) public view virtual returns (uint256) {\n        uint256 _stalePeriod = stalePeriodOf(_asset);\n\n        // 1. Check main provider\n        (uint256 _priceInUsd, uint256 _lastUpdatedAt) = mainProvider.getPriceInUsd(_asset);\n\n        if (_priceInUsd > 0 && !_priceIsStale(_lastUpdatedAt, _stalePeriod)) {\n            return _priceInUsd;\n        }\n\n        // 2. Check fallback provider\n        (_priceInUsd, _lastUpdatedAt) = fallbackProvider.getPriceInUsd(_asset);\n\n        if (_priceInUsd > 0 && !_priceIsStale(_lastUpdatedAt, _stalePeriod)) {\n            return _priceInUsd;\n        }\n\n        revert(\"both-providers-failed\");\n    }\n\n    /// @inheritdoc IOracle\n    function quote(address tokenIn_, address tokenOut_, uint256 amountIn_) public view virtual returns (uint256) {\n        uint256 _inStalePeriod = stalePeriodOf(tokenIn_);\n        uint256 _outStalePeriod = stalePeriodOf(tokenOut_);\n\n        // 1. Check main provider\n        (uint256 _amountOut, uint256 _inUpdatedAt, uint256 _outUpdatedAt) = mainProvider.quote(\n            tokenIn_,\n            tokenOut_,\n            amountIn_\n        );\n\n        if (\n            _amountOut > 0 &&\n            !_priceIsStale(_inUpdatedAt, _inStalePeriod) &&\n            !_priceIsStale(_outUpdatedAt, _outStalePeriod)\n        ) {\n            return _amountOut;\n        }\n\n        // 2. Check fallback provider\n        (_amountOut, _inUpdatedAt, _outUpdatedAt) = fallbackProvider.quote(tokenIn_, tokenOut_, amountIn_);\n\n        if (\n            _amountOut > 0 &&\n            !_priceIsStale(_inUpdatedAt, _inStalePeriod) &&\n            !_priceIsStale(_outUpdatedAt, _outStalePeriod)\n        ) {\n            return _amountOut;\n        }\n\n        revert(\"both-providers-failed\");\n    }\n\n    /// @inheritdoc IOracle\n    function quoteTokenToUsd(address token_, uint256 amountIn_) public view virtual returns (uint256) {\n        uint256 _stalePeriod = stalePeriodOf(token_);\n\n        // 1. Check main provider\n        (uint256 _amountOut, uint256 _lastUpdatedAt) = mainProvider.quoteTokenToUsd(token_, amountIn_);\n\n        if (_amountOut > 0 && !_priceIsStale(_lastUpdatedAt, _stalePeriod)) {\n            return _amountOut;\n        }\n\n        // 2. Check fallback provider\n        (_amountOut, _lastUpdatedAt) = fallbackProvider.quoteTokenToUsd(token_, amountIn_);\n\n        if (_amountOut > 0 && !_priceIsStale(_lastUpdatedAt, _stalePeriod)) {\n            return _amountOut;\n        }\n\n        revert(\"both-providers-failed\");\n    }\n\n    /// @inheritdoc IOracle\n    function quoteUsdToToken(address token_, uint256 amountIn_) public view virtual returns (uint256) {\n        uint256 _stalePeriod = stalePeriodOf(token_);\n\n        // 1. Check main provider\n        (uint256 _amountOut, uint256 _lastUpdatedAt) = mainProvider.quoteUsdToToken(token_, amountIn_);\n\n        if (_amountOut > 0 && !_priceIsStale(_lastUpdatedAt, _stalePeriod)) {\n            return _amountOut;\n        }\n\n        // 2. Check fallback provider\n        (_amountOut, _lastUpdatedAt) = fallbackProvider.quoteUsdToToken(token_, amountIn_);\n\n        if (_amountOut > 0 && !_priceIsStale(_lastUpdatedAt, _stalePeriod)) {\n            return _amountOut;\n        }\n\n        revert(\"both-providers-failed\");\n    }\n}\n"
    }
  }
}}