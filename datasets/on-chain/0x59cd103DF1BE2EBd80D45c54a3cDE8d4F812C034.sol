{{
  "language": "Solidity",
  "sources": {
    "contracts/interface/RocketStorageInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketStorageInterface {\n\n    // Deploy status\n    function getDeployedStatus() external view returns (bool);\n\n    // Guardian\n    function getGuardian() external view returns(address);\n    function setGuardian(address _newAddress) external;\n    function confirmGuardian() external;\n\n    // Getters\n    function getAddress(bytes32 _key) external view returns (address);\n    function getUint(bytes32 _key) external view returns (uint);\n    function getString(bytes32 _key) external view returns (string memory);\n    function getBytes(bytes32 _key) external view returns (bytes memory);\n    function getBool(bytes32 _key) external view returns (bool);\n    function getInt(bytes32 _key) external view returns (int);\n    function getBytes32(bytes32 _key) external view returns (bytes32);\n\n    // Setters\n    function setAddress(bytes32 _key, address _value) external;\n    function setUint(bytes32 _key, uint _value) external;\n    function setString(bytes32 _key, string calldata _value) external;\n    function setBytes(bytes32 _key, bytes calldata _value) external;\n    function setBool(bytes32 _key, bool _value) external;\n    function setInt(bytes32 _key, int _value) external;\n    function setBytes32(bytes32 _key, bytes32 _value) external;\n\n    // Deleters\n    function deleteAddress(bytes32 _key) external;\n    function deleteUint(bytes32 _key) external;\n    function deleteString(bytes32 _key) external;\n    function deleteBytes(bytes32 _key) external;\n    function deleteBool(bytes32 _key) external;\n    function deleteInt(bytes32 _key) external;\n    function deleteBytes32(bytes32 _key) external;\n\n    // Arithmetic\n    function addUint(bytes32 _key, uint256 _amount) external;\n    function subUint(bytes32 _key, uint256 _amount) external;\n\n    // Protected storage\n    function getNodeWithdrawalAddress(address _nodeAddress) external view returns (address);\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external view returns (address);\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external;\n    function confirmWithdrawalAddress(address _nodeAddress) external;\n}\n"
    },
    "contracts/contract/RocketBase.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"../interface/RocketStorageInterface.sol\";\n\n/// @title Base settings / modifiers for each contract in Rocket Pool\n/// @author David Rugendyke\n\nabstract contract RocketBase {\n\n    // Calculate using this as the base\n    uint256 constant calcBase = 1 ether;\n\n    // Version of the contract\n    uint8 public version;\n\n    // The main storage contract where primary persistant storage is maintained\n    RocketStorageInterface rocketStorage = RocketStorageInterface(address(0));\n\n\n    /*** Modifiers **********************************************************/\n\n    /**\n    * @dev Throws if called by any sender that doesn't match a Rocket Pool network contract\n    */\n    modifier onlyLatestNetworkContract() {\n        require(getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        _;\n    }\n\n    /**\n    * @dev Throws if called by any sender that doesn't match one of the supplied contract or is the latest version of that contract\n    */\n    modifier onlyLatestContract(string memory _contractName, address _contractAddress) {\n        require(_contractAddress == getAddress(keccak256(abi.encodePacked(\"contract.address\", _contractName))), \"Invalid or outdated contract\");\n        _;\n    }\n\n    /**\n    * @dev Throws if called by any sender that isn't a registered node\n    */\n    modifier onlyRegisteredNode(address _nodeAddress) {\n        require(getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress))), \"Invalid node\");\n        _;\n    }\n\n    /**\n    * @dev Throws if called by any sender that isn't a trusted node DAO member\n    */\n    modifier onlyTrustedNode(address _nodeAddress) {\n        require(getBool(keccak256(abi.encodePacked(\"dao.trustednodes.\", \"member\", _nodeAddress))), \"Invalid trusted node\");\n        _;\n    }\n\n    /**\n    * @dev Throws if called by any sender that isn't a registered minipool\n    */\n    modifier onlyRegisteredMinipool(address _minipoolAddress) {\n        require(getBool(keccak256(abi.encodePacked(\"minipool.exists\", _minipoolAddress))), \"Invalid minipool\");\n        _;\n    }\n    \n\n    /**\n    * @dev Throws if called by any account other than a guardian account (temporary account allowed access to settings before DAO is fully enabled)\n    */\n    modifier onlyGuardian() {\n        require(msg.sender == rocketStorage.getGuardian(), \"Account is not a temporary guardian\");\n        _;\n    }\n\n\n\n\n    /*** Methods **********************************************************/\n\n    /// @dev Set the main Rocket Storage address\n    constructor(RocketStorageInterface _rocketStorageAddress) {\n        // Update the contract address\n        rocketStorage = RocketStorageInterface(_rocketStorageAddress);\n    }\n\n\n    /// @dev Get the address of a network contract by name\n    function getContractAddress(string memory _contractName) internal view returns (address) {\n        // Get the current contract address\n        address contractAddress = getAddress(keccak256(abi.encodePacked(\"contract.address\", _contractName)));\n        // Check it\n        require(contractAddress != address(0x0), \"Contract not found\");\n        // Return\n        return contractAddress;\n    }\n\n\n    /// @dev Get the address of a network contract by name (returns address(0x0) instead of reverting if contract does not exist)\n    function getContractAddressUnsafe(string memory _contractName) internal view returns (address) {\n        // Get the current contract address\n        address contractAddress = getAddress(keccak256(abi.encodePacked(\"contract.address\", _contractName)));\n        // Return\n        return contractAddress;\n    }\n\n\n    /// @dev Get the name of a network contract by address\n    function getContractName(address _contractAddress) internal view returns (string memory) {\n        // Get the contract name\n        string memory contractName = getString(keccak256(abi.encodePacked(\"contract.name\", _contractAddress)));\n        // Check it\n        require(bytes(contractName).length > 0, \"Contract not found\");\n        // Return\n        return contractName;\n    }\n\n    /// @dev Get revert error message from a .call method\n    function getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return \"Transaction reverted silently\";\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n\n\n\n    /*** Rocket Storage Methods ****************************************/\n\n    // Note: Unused helpers have been removed to keep contract sizes down\n\n    /// @dev Storage get methods\n    function getAddress(bytes32 _key) internal view returns (address) { return rocketStorage.getAddress(_key); }\n    function getUint(bytes32 _key) internal view returns (uint) { return rocketStorage.getUint(_key); }\n    function getString(bytes32 _key) internal view returns (string memory) { return rocketStorage.getString(_key); }\n    function getBytes(bytes32 _key) internal view returns (bytes memory) { return rocketStorage.getBytes(_key); }\n    function getBool(bytes32 _key) internal view returns (bool) { return rocketStorage.getBool(_key); }\n    function getInt(bytes32 _key) internal view returns (int) { return rocketStorage.getInt(_key); }\n    function getBytes32(bytes32 _key) internal view returns (bytes32) { return rocketStorage.getBytes32(_key); }\n\n    /// @dev Storage set methods\n    function setAddress(bytes32 _key, address _value) internal { rocketStorage.setAddress(_key, _value); }\n    function setUint(bytes32 _key, uint _value) internal { rocketStorage.setUint(_key, _value); }\n    function setString(bytes32 _key, string memory _value) internal { rocketStorage.setString(_key, _value); }\n    function setBytes(bytes32 _key, bytes memory _value) internal { rocketStorage.setBytes(_key, _value); }\n    function setBool(bytes32 _key, bool _value) internal { rocketStorage.setBool(_key, _value); }\n    function setInt(bytes32 _key, int _value) internal { rocketStorage.setInt(_key, _value); }\n    function setBytes32(bytes32 _key, bytes32 _value) internal { rocketStorage.setBytes32(_key, _value); }\n\n    /// @dev Storage delete methods\n    function deleteAddress(bytes32 _key) internal { rocketStorage.deleteAddress(_key); }\n    function deleteUint(bytes32 _key) internal { rocketStorage.deleteUint(_key); }\n    function deleteString(bytes32 _key) internal { rocketStorage.deleteString(_key); }\n    function deleteBytes(bytes32 _key) internal { rocketStorage.deleteBytes(_key); }\n    function deleteBool(bytes32 _key) internal { rocketStorage.deleteBool(_key); }\n    function deleteInt(bytes32 _key) internal { rocketStorage.deleteInt(_key); }\n    function deleteBytes32(bytes32 _key) internal { rocketStorage.deleteBytes32(_key); }\n\n    /// @dev Storage arithmetic methods\n    function addUint(bytes32 _key, uint256 _amount) internal { rocketStorage.addUint(_key, _amount); }\n    function subUint(bytes32 _key, uint256 _amount) internal { rocketStorage.subUint(_key, _amount); }\n}\n"
    },
    "contracts/interface/dao/protocol/settings/RocketDAOProtocolSettingsInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketDAOProtocolSettingsInterface {\n    function getSettingUint(string memory _settingPath) external view returns (uint256);\n    function setSettingUint(string memory _settingPath, uint256 _value) external;\n    function getSettingBool(string memory _settingPath) external view returns (bool);\n    function setSettingBool(string memory _settingPath, bool _value) external;\n    function getSettingAddress(string memory _settingPath) external view returns (address);\n    function setSettingAddress(string memory _settingPath, address _value) external;\n}\n"
    },
    "contracts/contract/dao/protocol/settings/RocketDAOProtocolSettings.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.5.0 <0.9.0;\n\nimport \"../../../RocketBase.sol\";\nimport \"../../../../interface/dao/protocol/settings/RocketDAOProtocolSettingsInterface.sol\";\n\n// Settings in RP which the DAO will have full control over\n// This settings contract enables storage using setting paths with namespaces, rather than explicit set methods\nabstract contract RocketDAOProtocolSettings is RocketBase, RocketDAOProtocolSettingsInterface {\n\n\n    // The namespace for a particular group of settings\n    bytes32 settingNameSpace;\n\n\n    // Only allow updating from the DAO proposals contract\n    modifier onlyDAOProtocolProposal() {\n        // If this contract has been initialised, only allow access from the proposals contract\n        if(getBool(keccak256(abi.encodePacked(settingNameSpace, \"deployed\")))) require(getContractAddress(\"rocketDAOProtocolProposals\") == msg.sender, \"Only DAO Protocol Proposals contract can update a setting\");\n        _;\n    }\n\n\n    // Construct\n    constructor(RocketStorageInterface _rocketStorageAddress, string memory _settingNameSpace) RocketBase(_rocketStorageAddress) {\n        // Apply the setting namespace\n        settingNameSpace = keccak256(abi.encodePacked(\"dao.protocol.setting.\", _settingNameSpace));\n    }\n\n\n    /*** Uints  ****************/\n\n    // A general method to return any setting given the setting path is correct, only accepts uints\n    function getSettingUint(string memory _settingPath) public view override returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(settingNameSpace, _settingPath)));\n    } \n\n    // Update a Uint setting, can only be executed by the DAO contract when a majority on a setting proposal has passed and been executed\n    function setSettingUint(string memory _settingPath, uint256 _value) virtual public override onlyDAOProtocolProposal {\n        // Update setting now\n        setUint(keccak256(abi.encodePacked(settingNameSpace, _settingPath)), _value);\n    } \n   \n\n    /*** Bools  ****************/\n\n    // A general method to return any setting given the setting path is correct, only accepts bools\n    function getSettingBool(string memory _settingPath) public view override returns (bool) {\n        return getBool(keccak256(abi.encodePacked(settingNameSpace, _settingPath)));\n    } \n\n    // Update a setting, can only be executed by the DAO contract when a majority on a setting proposal has passed and been executed\n    function setSettingBool(string memory _settingPath, bool _value) virtual public override onlyDAOProtocolProposal {\n        // Update setting now\n        setBool(keccak256(abi.encodePacked(settingNameSpace, _settingPath)), _value);\n    }\n\n    \n    /*** Addresses  ****************/\n\n    // A general method to return any setting given the setting path is correct, only accepts addresses\n    function getSettingAddress(string memory _settingPath) external view override returns (address) {\n        return getAddress(keccak256(abi.encodePacked(settingNameSpace, _settingPath)));\n    } \n\n    // Update a setting, can only be executed by the DAO contract when a majority on a setting proposal has passed and been executed\n    function setSettingAddress(string memory _settingPath, address _value) virtual external override onlyDAOProtocolProposal {\n        // Update setting now\n        setAddress(keccak256(abi.encodePacked(settingNameSpace, _settingPath)), _value);\n    }\n\n}\n"
    },
    "contracts/interface/dao/protocol/settings/RocketDAOProtocolSettingsProposalsInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketDAOProtocolSettingsProposalsInterface {\n    function getVotePhase1Time() external view returns(uint256);\n    function getVotePhase2Time() external view returns(uint256);\n    function getVoteDelayTime() external view returns(uint256);\n    function getExecuteTime() external view returns(uint256);\n    function getProposalBond() external view returns(uint256);\n    function getChallengeBond() external view returns(uint256);\n    function getChallengePeriod() external view returns(uint256);\n    function getProposalQuorum() external view returns (uint256);\n    function getProposalVetoQuorum() external view returns (uint256);\n    function getProposalMaxBlockAge() external view returns (uint256);\n}\n"
    },
    "contracts/contract/dao/protocol/settings/RocketDAOProtocolSettingsProposals.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.18;\n\nimport \"./RocketDAOProtocolSettings.sol\";\nimport \"../../../../interface/dao/protocol/settings/RocketDAOProtocolSettingsProposalsInterface.sol\";\n\n/// @notice Settings related to proposals in the protocol DAO\ncontract RocketDAOProtocolSettingsProposals is RocketDAOProtocolSettings, RocketDAOProtocolSettingsProposalsInterface {\n\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketDAOProtocolSettings(_rocketStorageAddress, \"proposals\") {\n        version = 2;\n        // Initialize settings on deployment\n        if(!getBool(keccak256(abi.encodePacked(settingNameSpace, \"deployed\")))) {\n            // Init settings\n            setSettingUint(\"proposal.vote.phase1.time\", 1 weeks);           // How long a proposal can be voted on in phase 1\n            setSettingUint(\"proposal.vote.phase2.time\", 1 weeks);           // How long a proposal can be voted on in phase 2\n            setSettingUint(\"proposal.vote.delay.time\", 1 weeks);            // How long before a proposal can be voted on after it is created\n            setSettingUint(\"proposal.execute.time\", 4 weeks);               // How long a proposal can be executed after its voting period is finished\n            setSettingUint(\"proposal.bond\", 100 ether);                     // The amount of RPL a proposer has to put up as a bond for creating a new proposal\n            setSettingUint(\"proposal.challenge.bond\", 10 ether);            // The amount of RPL a challenger has to put up as a bond for challenging a proposal\n            setSettingUint(\"proposal.challenge.period\", 30 minutes);        // The amount of time a proposer has to respond to a challenge before a proposal is defeated\n            setSettingUint(\"proposal.quorum\", 0.51 ether);                  // The quorum required to pass a proposal\n            setSettingUint(\"proposal.veto.quorum\", 0.51 ether);             // The quorum required to veto a proposal\n            setSettingUint(\"proposal.max.block.age\", 1024);                 // The maximum age of a block a proposal can be raised at\n            // Settings initialised\n            setBool(keccak256(abi.encodePacked(settingNameSpace, \"deployed\")), true);\n        }\n    }\n\n    /// @notice Update a setting, overrides inherited setting method with extra checks for this contract\n    function setSettingUint(string memory _settingPath, uint256 _value) override public onlyDAOProtocolProposal {\n        // Some safety guards for certain settings\n        bytes32 settingKey = keccak256(bytes(_settingPath));\n        if(settingKey == keccak256(bytes(\"proposal.vote.phase1.time\"))) {\n            // Must be at least 1 day (RPIP-33)\n            require(_value >= 1 days, \"Value must be at least 1 day\");\n        } else if(settingKey == keccak256(bytes(\"proposal.vote.phase2.time\"))) {\n            // Must be at least 1 day (RPIP-33)\n            require(_value >= 1 days, \"Value must be at least 1 day\");\n        } else if(settingKey == keccak256(bytes(\"proposal.vote.delay.time\"))) {\n            // Must be at least 1 week (RPIP-33)\n            require(_value >= 1 weeks, \"Value must be at least 1 week\");\n        } else if(settingKey == keccak256(bytes(\"proposal.execute.time\"))) {\n            // Must be at least 1 week (RPIP-33)\n            require(_value >= 1 weeks, \"Value must be at least 1 week\");\n        } else if(settingKey == keccak256(bytes(\"proposal.bond\"))) {\n            // Must be higher than 20 RPL(RPIP-33)\n            require(_value > 20 ether, \"Value must be higher than 20 RPL\");\n        } else if(settingKey == keccak256(bytes(\"proposal.challenge.bond\"))) {\n            // Must be higher than 2 RPL(RPIP-33)\n            require(_value > 2 ether, \"Value must be higher than 2 RPL\");\n        } else if(settingKey == keccak256(bytes(\"proposal.challenge.period\"))) {\n            // Must be at least 30 minutes (RPIP-33)\n            require(_value >= 30 minutes, \"Value must be at least 30 minutes\");\n        } else if(settingKey == keccak256(bytes(\"proposal.quorum\"))) {\n            // Must be >= 15% & < 75% (RPIP-63)\n            require(_value >= 0.15 ether && _value < 0.75 ether, \"Value must be >= 15% & < 75%\");\n        } else if(settingKey == keccak256(bytes(\"proposal.veto.quorum\"))) {\n            // Must be >= 51% & < 75% (RPIP-33)\n            require(_value >= 0.51 ether && _value < 0.75 ether, \"Value must be >= 51% & < 75%\");\n        } else if(settingKey == keccak256(bytes(\"proposal.max.block.age\"))) {\n            // Must be > 128 blocks & < 7200 blocks (RPIP-33)\n            require(_value > 128 && _value < 7200, \"Value must be > 128 blocks & < 7200 blocks\");\n        } \n        // Update setting now\n        setUint(keccak256(abi.encodePacked(settingNameSpace, _settingPath)), _value);\n    }\n\n    /// @notice How long a proposal can be voted on in phase 1\n    function getVotePhase1Time() override external view returns (uint256) {\n        return getSettingUint(\"proposal.vote.phase1.time\");\n    }\n\n    /// @notice How long a proposal can be voted on in phase 2\n    function getVotePhase2Time() override external view returns (uint256) {\n        return getSettingUint(\"proposal.vote.phase2.time\");\n    }\n\n    /// @notice How long before a proposal can be voted on after it is created\n    function getVoteDelayTime() override external view returns (uint256) {\n        return getSettingUint(\"proposal.vote.delay.time\");\n    }\n\n    /// @notice How long a proposal can be executed after its voting period is finished\n    function getExecuteTime() override external view returns (uint256) {\n        return getSettingUint(\"proposal.execute.time\");\n    }\n\n    /// @notice The amount of RPL that is locked when raising a proposal\n    function getProposalBond() override external view returns (uint256) {\n        return getSettingUint(\"proposal.bond\");\n    }\n\n    /// @notice The amount of RPL that is locked when challenging a proposal\n    function getChallengeBond() override external view returns (uint256) {\n        return getSettingUint(\"proposal.challenge.bond\");\n    }\n\n    /// @notice How long (in seconds) a proposer has to respond to a challenge\n    function getChallengePeriod() override external view returns (uint256) {\n        return getSettingUint(\"proposal.challenge.period\");\n    }\n\n    /// @notice The quorum required for a proposal to be successful (as a fraction of 1e18)\n    function getProposalQuorum() override external view returns (uint256) {\n        return getSettingUint(\"proposal.quorum\");\n    }\n\n    /// @notice The quorum required for a proposal veto to be successful (as a fraction of 1e18)\n    function getProposalVetoQuorum() override external view returns (uint256) {\n        return getSettingUint(\"proposal.veto.quorum\");\n    }\n\n    /// @notice The maximum time in the past (in blocks) a proposal can be submitted for\n    function getProposalMaxBlockAge() override external view returns (uint256) {\n        return getSettingUint(\"proposal.max.block.age\");\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 15000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}