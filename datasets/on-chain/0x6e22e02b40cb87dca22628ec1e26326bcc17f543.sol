{{
  "language": "Solidity",
  "sources": {
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/express/AxelarExpressExecutable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IAxelarGateway } from '../interfaces/IAxelarGateway.sol';\nimport { ExpressExecutorTracker } from './ExpressExecutorTracker.sol';\n\nimport { SafeTokenTransferFrom, SafeTokenTransfer } from '../libs/SafeTransfer.sol';\nimport { IERC20 } from '../interfaces/IERC20.sol';\n\ncontract AxelarExpressExecutable is ExpressExecutorTracker {\n    using SafeTokenTransfer for IERC20;\n    using SafeTokenTransferFrom for IERC20;\n\n    IAxelarGateway public immutable gateway;\n\n    constructor(address gateway_) {\n        if (gateway_ == address(0)) revert InvalidAddress();\n\n        gateway = IAxelarGateway(gateway_);\n    }\n\n    function execute(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) external {\n        bytes32 payloadHash = keccak256(payload);\n\n        if (!gateway.validateContractCall(commandId, sourceChain, sourceAddress, payloadHash))\n            revert NotApprovedByGateway();\n\n        address expressExecutor = _popExpressExecutor(commandId, sourceChain, sourceAddress, payloadHash);\n\n        if (expressExecutor != address(0)) {\n            // slither-disable-next-line reentrancy-events\n            emit ExpressExecutionFulfilled(commandId, sourceChain, sourceAddress, payloadHash, expressExecutor);\n        } else {\n            _execute(sourceChain, sourceAddress, payload);\n        }\n    }\n\n    function executeWithToken(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload,\n        string calldata tokenSymbol,\n        uint256 amount\n    ) external {\n        bytes32 payloadHash = keccak256(payload);\n        if (\n            !gateway.validateContractCallAndMint(\n                commandId,\n                sourceChain,\n                sourceAddress,\n                payloadHash,\n                tokenSymbol,\n                amount\n            )\n        ) revert NotApprovedByGateway();\n\n        address expressExecutor = _popExpressExecutorWithToken(\n            commandId,\n            sourceChain,\n            sourceAddress,\n            payloadHash,\n            tokenSymbol,\n            amount\n        );\n\n        if (expressExecutor != address(0)) {\n            // slither-disable-next-line reentrancy-events\n            emit ExpressExecutionWithTokenFulfilled(\n                commandId,\n                sourceChain,\n                sourceAddress,\n                payloadHash,\n                tokenSymbol,\n                amount,\n                expressExecutor\n            );\n\n            address gatewayToken = gateway.tokenAddresses(tokenSymbol);\n            IERC20(gatewayToken).safeTransfer(expressExecutor, amount);\n        } else {\n            _executeWithToken(sourceChain, sourceAddress, payload, tokenSymbol, amount);\n        }\n    }\n\n    function expressExecute(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) external payable virtual {\n        if (gateway.isCommandExecuted(commandId)) revert AlreadyExecuted();\n\n        address expressExecutor = msg.sender;\n        bytes32 payloadHash = keccak256(payload);\n\n        emit ExpressExecuted(commandId, sourceChain, sourceAddress, payloadHash, expressExecutor);\n\n        _setExpressExecutor(commandId, sourceChain, sourceAddress, payloadHash, expressExecutor);\n\n        _execute(sourceChain, sourceAddress, payload);\n    }\n\n    function expressExecuteWithToken(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount\n    ) external payable virtual {\n        if (gateway.isCommandExecuted(commandId)) revert AlreadyExecuted();\n\n        address expressExecutor = msg.sender;\n        address gatewayToken = gateway.tokenAddresses(symbol);\n        bytes32 payloadHash = keccak256(payload);\n\n        emit ExpressExecutedWithToken(\n            commandId,\n            sourceChain,\n            sourceAddress,\n            payloadHash,\n            symbol,\n            amount,\n            expressExecutor\n        );\n\n        _setExpressExecutorWithToken(\n            commandId,\n            sourceChain,\n            sourceAddress,\n            payloadHash,\n            symbol,\n            amount,\n            expressExecutor\n        );\n\n        IERC20(gatewayToken).safeTransferFrom(expressExecutor, address(this), amount);\n\n        _executeWithToken(sourceChain, sourceAddress, payload, symbol, amount);\n    }\n\n    function _execute(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) internal virtual {}\n\n    function _executeWithToken(\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload,\n        string calldata tokenSymbol,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/express/ExpressExecutorTracker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IAxelarExpressExecutable } from '../interfaces/IAxelarExpressExecutable.sol';\n\nabstract contract ExpressExecutorTracker is IAxelarExpressExecutable {\n    bytes32 internal constant PREFIX_EXPRESS_EXECUTE = keccak256('express-execute');\n    bytes32 internal constant PREFIX_EXPRESS_EXECUTE_WITH_TOKEN = keccak256('express-execute-with-token');\n\n    function _expressExecuteSlot(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash\n    ) internal pure returns (bytes32 slot) {\n        slot = keccak256(abi.encode(PREFIX_EXPRESS_EXECUTE, commandId, sourceChain, sourceAddress, payloadHash));\n    }\n\n    function _expressExecuteWithTokenSlot(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash,\n        string calldata symbol,\n        uint256 amount\n    ) internal pure returns (bytes32 slot) {\n        slot = keccak256(\n            abi.encode(\n                PREFIX_EXPRESS_EXECUTE_WITH_TOKEN,\n                commandId,\n                sourceChain,\n                sourceAddress,\n                payloadHash,\n                symbol,\n                amount\n            )\n        );\n    }\n\n    function getExpressExecutor(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash\n    ) external view returns (address expressExecutor) {\n        bytes32 slot = _expressExecuteSlot(commandId, sourceChain, sourceAddress, payloadHash);\n\n        assembly {\n            expressExecutor := sload(slot)\n        }\n    }\n\n    function getExpressExecutorWithToken(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash,\n        string calldata symbol,\n        uint256 amount\n    ) external view returns (address expressExecutor) {\n        bytes32 slot = _expressExecuteWithTokenSlot(commandId, sourceChain, sourceAddress, payloadHash, symbol, amount);\n\n        assembly {\n            expressExecutor := sload(slot)\n        }\n    }\n\n    function _setExpressExecutor(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash,\n        address expressExecutor\n    ) internal {\n        bytes32 slot = _expressExecuteSlot(commandId, sourceChain, sourceAddress, payloadHash);\n        address currentExecutor;\n\n        assembly {\n            currentExecutor := sload(slot)\n        }\n\n        if (currentExecutor != address(0)) revert ExpressExecutorAlreadySet();\n\n        assembly {\n            sstore(slot, expressExecutor)\n        }\n    }\n\n    function _setExpressExecutorWithToken(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash,\n        string calldata symbol,\n        uint256 amount,\n        address expressExecutor\n    ) internal {\n        bytes32 slot = _expressExecuteWithTokenSlot(commandId, sourceChain, sourceAddress, payloadHash, symbol, amount);\n        address currentExecutor;\n\n        assembly {\n            currentExecutor := sload(slot)\n        }\n\n        if (currentExecutor != address(0)) revert ExpressExecutorAlreadySet();\n\n        assembly {\n            sstore(slot, expressExecutor)\n        }\n    }\n\n    function _popExpressExecutor(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash\n    ) internal returns (address expressExecutor) {\n        bytes32 slot = _expressExecuteSlot(commandId, sourceChain, sourceAddress, payloadHash);\n\n        assembly {\n            expressExecutor := sload(slot)\n            if expressExecutor {\n                sstore(slot, 0)\n            }\n        }\n    }\n\n    function _popExpressExecutorWithToken(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash,\n        string calldata symbol,\n        uint256 amount\n    ) internal returns (address expressExecutor) {\n        bytes32 slot = _expressExecuteWithTokenSlot(commandId, sourceChain, sourceAddress, payloadHash, symbol, amount);\n\n        assembly {\n            expressExecutor := sload(slot)\n            if expressExecutor {\n                sstore(slot, 0)\n            }\n        }\n    }\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarExecutable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IAxelarGateway } from './IAxelarGateway.sol';\n\ninterface IAxelarExecutable {\n    error InvalidAddress();\n    error NotApprovedByGateway();\n\n    function gateway() external view returns (IAxelarGateway);\n\n    function execute(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) external;\n\n    function executeWithToken(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload,\n        string calldata tokenSymbol,\n        uint256 amount\n    ) external;\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarExpressExecutable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IAxelarExecutable } from './IAxelarExecutable.sol';\n\n/**\n * @title IAxelarExpressExecutable\n * @notice Interface for the Axelar Express Executable contract.\n */\ninterface IAxelarExpressExecutable is IAxelarExecutable {\n    // Custom errors\n    error AlreadyExecuted();\n    error InsufficientValue();\n    error ExpressExecutorAlreadySet();\n\n    /**\n     * @notice Emitted when an express execution is successfully performed.\n     * @param commandId The unique identifier for the command.\n     * @param sourceChain The source chain.\n     * @param sourceAddress The source address.\n     * @param payloadHash The hash of the payload.\n     * @param expressExecutor The address of the express executor.\n     */\n    event ExpressExecuted(\n        bytes32 indexed commandId,\n        string sourceChain,\n        string sourceAddress,\n        bytes32 payloadHash,\n        address indexed expressExecutor\n    );\n\n    /**\n     * @notice Emitted when an express execution with a token is successfully performed.\n     * @param commandId The unique identifier for the command.\n     * @param sourceChain The source chain.\n     * @param sourceAddress The source address.\n     * @param payloadHash The hash of the payload.\n     * @param symbol The token symbol.\n     * @param amount The amount of tokens.\n     * @param expressExecutor The address of the express executor.\n     */\n    event ExpressExecutedWithToken(\n        bytes32 indexed commandId,\n        string sourceChain,\n        string sourceAddress,\n        bytes32 payloadHash,\n        string symbol,\n        uint256 indexed amount,\n        address indexed expressExecutor\n    );\n\n    /**\n     * @notice Emitted when an express execution is fulfilled.\n     * @param commandId The commandId for the contractCall.\n     * @param sourceChain The source chain.\n     * @param sourceAddress The source address.\n     * @param payloadHash The hash of the payload.\n     * @param expressExecutor The address of the express executor.\n     */\n    event ExpressExecutionFulfilled(\n        bytes32 indexed commandId,\n        string sourceChain,\n        string sourceAddress,\n        bytes32 payloadHash,\n        address indexed expressExecutor\n    );\n\n    /**\n     * @notice Emitted when an express execution with a token is fulfilled.\n     * @param commandId The commandId for the contractCallWithToken.\n     * @param sourceChain The source chain.\n     * @param sourceAddress The source address.\n     * @param payloadHash The hash of the payload.\n     * @param symbol The token symbol.\n     * @param amount The amount of tokens.\n     * @param expressExecutor The address of the express executor.\n     */\n    event ExpressExecutionWithTokenFulfilled(\n        bytes32 indexed commandId,\n        string sourceChain,\n        string sourceAddress,\n        bytes32 payloadHash,\n        string symbol,\n        uint256 indexed amount,\n        address indexed expressExecutor\n    );\n\n    /**\n     * @notice Returns the express executor for a given command.\n     * @param commandId The commandId for the contractCall.\n     * @param sourceChain The source chain.\n     * @param sourceAddress The source address.\n     * @param payloadHash The hash of the payload.\n     * @return expressExecutor The address of the express executor.\n     */\n    function getExpressExecutor(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash\n    ) external view returns (address expressExecutor);\n\n    /**\n     * @notice Returns the express executor with token for a given command.\n     * @param commandId The commandId for the contractCallWithToken.\n     * @param sourceChain The source chain.\n     * @param sourceAddress The source address.\n     * @param payloadHash The hash of the payload.\n     * @param symbol The token symbol.\n     * @param amount The amount of tokens.\n     * @return expressExecutor The address of the express executor.\n     */\n    function getExpressExecutorWithToken(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash,\n        string calldata symbol,\n        uint256 amount\n    ) external view returns (address expressExecutor);\n\n    /**\n     * @notice Express executes a contract call.\n     * @param commandId The commandId for the contractCall.\n     * @param sourceChain The source chain.\n     * @param sourceAddress The source address.\n     * @param payload The payload data.\n     */\n    function expressExecute(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload\n    ) external payable;\n\n    /**\n     * @notice Express executes a contract call with token.\n     * @param commandId The commandId for the contractCallWithToken.\n     * @param sourceChain The source chain.\n     * @param sourceAddress The source address.\n     * @param payload The payload data.\n     * @param symbol The token symbol.\n     * @param amount The amount of token.\n     */\n    function expressExecuteWithToken(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount\n    ) external payable;\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGasService.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IUpgradable } from '../interfaces/IUpgradable.sol';\n\n/**\n * @title IAxelarGasService Interface\n * @notice This is an interface for the AxelarGasService contract which manages gas payments\n * and refunds for cross-chain communication on the Axelar network.\n * @dev This interface inherits IUpgradable\n */\ninterface IAxelarGasService is IUpgradable {\n    error NothingReceived();\n    error InvalidAddress();\n    error NotCollector();\n    error InvalidAmounts();\n\n    event GasPaidForContractCall(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event GasPaidForContractCallWithToken(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        string symbol,\n        uint256 amount,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event NativeGasPaidForContractCall(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event NativeGasPaidForContractCallWithToken(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        string symbol,\n        uint256 amount,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event GasPaidForExpressCall(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event GasPaidForExpressCallWithToken(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        string symbol,\n        uint256 amount,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event NativeGasPaidForExpressCall(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event NativeGasPaidForExpressCallWithToken(\n        address indexed sourceAddress,\n        string destinationChain,\n        string destinationAddress,\n        bytes32 indexed payloadHash,\n        string symbol,\n        uint256 amount,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event GasAdded(\n        bytes32 indexed txHash,\n        uint256 indexed logIndex,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event NativeGasAdded(bytes32 indexed txHash, uint256 indexed logIndex, uint256 gasFeeAmount, address refundAddress);\n\n    event ExpressGasAdded(\n        bytes32 indexed txHash,\n        uint256 indexed logIndex,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event NativeExpressGasAdded(\n        bytes32 indexed txHash,\n        uint256 indexed logIndex,\n        uint256 gasFeeAmount,\n        address refundAddress\n    );\n\n    event Refunded(\n        bytes32 indexed txHash,\n        uint256 indexed logIndex,\n        address payable receiver,\n        address token,\n        uint256 amount\n    );\n\n    /**\n     * @notice Pay for gas using ERC20 tokens for a contract call on a destination chain.\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\n     * @param sender The address making the payment\n     * @param destinationChain The target chain where the contract call will be made\n     * @param destinationAddress The target address on the destination chain\n     * @param payload Data payload for the contract call\n     * @param gasToken The address of the ERC20 token used to pay for gas\n     * @param gasFeeAmount The amount of tokens to pay for gas\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function payGasForContractCall(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external;\n\n    /**\n     * @notice Pay for gas using ERC20 tokens for a contract call with tokens on a destination chain.\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\n     * @param sender The address making the payment\n     * @param destinationChain The target chain where the contract call with tokens will be made\n     * @param destinationAddress The target address on the destination chain\n     * @param payload Data payload for the contract call with tokens\n     * @param symbol The symbol of the token to be sent with the call\n     * @param amount The amount of tokens to be sent with the call\n     * @param gasToken The address of the ERC20 token used to pay for gas\n     * @param gasFeeAmount The amount of tokens to pay for gas\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function payGasForContractCallWithToken(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external;\n\n    /**\n     * @notice Pay for gas using native currency for a contract call on a destination chain.\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\n     * @param sender The address making the payment\n     * @param destinationChain The target chain where the contract call will be made\n     * @param destinationAddress The target address on the destination chain\n     * @param payload Data payload for the contract call\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function payNativeGasForContractCall(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        address refundAddress\n    ) external payable;\n\n    /**\n     * @notice Pay for gas using native currency for a contract call with tokens on a destination chain.\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\n     * @param sender The address making the payment\n     * @param destinationChain The target chain where the contract call with tokens will be made\n     * @param destinationAddress The target address on the destination chain\n     * @param payload Data payload for the contract call with tokens\n     * @param symbol The symbol of the token to be sent with the call\n     * @param amount The amount of tokens to be sent with the call\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function payNativeGasForContractCallWithToken(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount,\n        address refundAddress\n    ) external payable;\n\n    /**\n     * @notice Pay for gas using ERC20 tokens for an express contract call on a destination chain.\n     * @dev This function is called on the source chain before calling the gateway to express execute a remote contract.\n     * @param sender The address making the payment\n     * @param destinationChain The target chain where the contract call will be made\n     * @param destinationAddress The target address on the destination chain\n     * @param payload Data payload for the contract call\n     * @param gasToken The address of the ERC20 token used to pay for gas\n     * @param gasFeeAmount The amount of tokens to pay for gas\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function payGasForExpressCall(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external;\n\n    /**\n     * @notice Pay for gas using ERC20 tokens for an express contract call with tokens on a destination chain.\n     * @dev This function is called on the source chain before calling the gateway to express execute a remote contract.\n     * @param sender The address making the payment\n     * @param destinationChain The target chain where the contract call with tokens will be made\n     * @param destinationAddress The target address on the destination chain\n     * @param payload Data payload for the contract call with tokens\n     * @param symbol The symbol of the token to be sent with the call\n     * @param amount The amount of tokens to be sent with the call\n     * @param gasToken The address of the ERC20 token used to pay for gas\n     * @param gasFeeAmount The amount of tokens to pay for gas\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function payGasForExpressCallWithToken(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external;\n\n    /**\n     * @notice Pay for gas using native currency for an express contract call on a destination chain.\n     * @dev This function is called on the source chain before calling the gateway to express execute a remote contract.\n     * @param sender The address making the payment\n     * @param destinationChain The target chain where the contract call will be made\n     * @param destinationAddress The target address on the destination chain\n     * @param payload Data payload for the contract call\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function payNativeGasForExpressCall(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        address refundAddress\n    ) external payable;\n\n    /**\n     * @notice Pay for gas using native currency for an express contract call with tokens on a destination chain.\n     * @dev This function is called on the source chain before calling the gateway to express execute a remote contract.\n     * @param sender The address making the payment\n     * @param destinationChain The target chain where the contract call with tokens will be made\n     * @param destinationAddress The target address on the destination chain\n     * @param payload Data payload for the contract call with tokens\n     * @param symbol The symbol of the token to be sent with the call\n     * @param amount The amount of tokens to be sent with the call\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function payNativeGasForExpressCallWithToken(\n        address sender,\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount,\n        address refundAddress\n    ) external payable;\n\n    /**\n     * @notice Add additional gas payment using ERC20 tokens after initiating a cross-chain call.\n     * @dev This function can be called on the source chain after calling the gateway to execute a remote contract.\n     * @param txHash The transaction hash of the cross-chain call\n     * @param logIndex The log index for the cross-chain call\n     * @param gasToken The ERC20 token address used to add gas\n     * @param gasFeeAmount The amount of tokens to add as gas\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function addGas(\n        bytes32 txHash,\n        uint256 logIndex,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external;\n\n    /**\n     * @notice Add additional gas payment using native currency after initiating a cross-chain call.\n     * @dev This function can be called on the source chain after calling the gateway to execute a remote contract.\n     * @param txHash The transaction hash of the cross-chain call\n     * @param logIndex The log index for the cross-chain call\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function addNativeGas(\n        bytes32 txHash,\n        uint256 logIndex,\n        address refundAddress\n    ) external payable;\n\n    /**\n     * @notice Add additional gas payment using ERC20 tokens after initiating an express cross-chain call.\n     * @dev This function can be called on the source chain after calling the gateway to express execute a remote contract.\n     * @param txHash The transaction hash of the cross-chain call\n     * @param logIndex The log index for the cross-chain call\n     * @param gasToken The ERC20 token address used to add gas\n     * @param gasFeeAmount The amount of tokens to add as gas\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function addExpressGas(\n        bytes32 txHash,\n        uint256 logIndex,\n        address gasToken,\n        uint256 gasFeeAmount,\n        address refundAddress\n    ) external;\n\n    /**\n     * @notice Add additional gas payment using native currency after initiating an express cross-chain call.\n     * @dev This function can be called on the source chain after calling the gateway to express execute a remote contract.\n     * @param txHash The transaction hash of the cross-chain call\n     * @param logIndex The log index for the cross-chain call\n     * @param refundAddress The address where refunds, if any, should be sent\n     */\n    function addNativeExpressGas(\n        bytes32 txHash,\n        uint256 logIndex,\n        address refundAddress\n    ) external payable;\n\n    /**\n     * @notice Allows the gasCollector to collect accumulated fees from the contract.\n     * @dev Use address(0) as the token address for native currency.\n     * @param receiver The address to receive the collected fees\n     * @param tokens Array of token addresses to be collected\n     * @param amounts Array of amounts to be collected for each respective token address\n     */\n    function collectFees(\n        address payable receiver,\n        address[] calldata tokens,\n        uint256[] calldata amounts\n    ) external;\n\n    /**\n     * @notice Refunds gas payment to the receiver in relation to a specific cross-chain transaction.\n     * @dev Only callable by the gasCollector.\n     * @dev Use address(0) as the token address to refund native currency.\n     * @param txHash The transaction hash of the cross-chain call\n     * @param logIndex The log index for the cross-chain call\n     * @param receiver The address to receive the refund\n     * @param token The token address to be refunded\n     * @param amount The amount to refund\n     */\n    function refund(\n        bytes32 txHash,\n        uint256 logIndex,\n        address payable receiver,\n        address token,\n        uint256 amount\n    ) external;\n\n    /**\n     * @notice Returns the address of the designated gas collector.\n     * @return address of the gas collector\n     */\n    function gasCollector() external returns (address);\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGateway.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IGovernable } from './IGovernable.sol';\nimport { IImplementation } from './IImplementation.sol';\n\ninterface IAxelarGateway is IImplementation, IGovernable {\n    /**********\\\n    |* Errors *|\n    \\**********/\n\n    error NotSelf();\n    error InvalidCodeHash();\n    error SetupFailed();\n    error InvalidAuthModule();\n    error InvalidTokenDeployer();\n    error InvalidAmount();\n    error InvalidChainId();\n    error InvalidCommands();\n    error TokenDoesNotExist(string symbol);\n    error TokenAlreadyExists(string symbol);\n    error TokenDeployFailed(string symbol);\n    error TokenContractDoesNotExist(address token);\n    error BurnFailed(string symbol);\n    error MintFailed(string symbol);\n    error InvalidSetMintLimitsParams();\n    error ExceedMintLimit(string symbol);\n\n    /**********\\\n    |* Events *|\n    \\**********/\n\n    event TokenSent(\n        address indexed sender,\n        string destinationChain,\n        string destinationAddress,\n        string symbol,\n        uint256 amount\n    );\n\n    event ContractCall(\n        address indexed sender,\n        string destinationChain,\n        string destinationContractAddress,\n        bytes32 indexed payloadHash,\n        bytes payload\n    );\n\n    event ContractCallWithToken(\n        address indexed sender,\n        string destinationChain,\n        string destinationContractAddress,\n        bytes32 indexed payloadHash,\n        bytes payload,\n        string symbol,\n        uint256 amount\n    );\n\n    event Executed(bytes32 indexed commandId);\n\n    event TokenDeployed(string symbol, address tokenAddresses);\n\n    event ContractCallApproved(\n        bytes32 indexed commandId,\n        string sourceChain,\n        string sourceAddress,\n        address indexed contractAddress,\n        bytes32 indexed payloadHash,\n        bytes32 sourceTxHash,\n        uint256 sourceEventIndex\n    );\n\n    event ContractCallApprovedWithMint(\n        bytes32 indexed commandId,\n        string sourceChain,\n        string sourceAddress,\n        address indexed contractAddress,\n        bytes32 indexed payloadHash,\n        string symbol,\n        uint256 amount,\n        bytes32 sourceTxHash,\n        uint256 sourceEventIndex\n    );\n\n    event ContractCallExecuted(bytes32 indexed commandId);\n\n    event TokenMintLimitUpdated(string symbol, uint256 limit);\n\n    event OperatorshipTransferred(bytes newOperatorsData);\n\n    event Upgraded(address indexed implementation);\n\n    /********************\\\n    |* Public Functions *|\n    \\********************/\n\n    function sendToken(\n        string calldata destinationChain,\n        string calldata destinationAddress,\n        string calldata symbol,\n        uint256 amount\n    ) external;\n\n    function callContract(\n        string calldata destinationChain,\n        string calldata contractAddress,\n        bytes calldata payload\n    ) external;\n\n    function callContractWithToken(\n        string calldata destinationChain,\n        string calldata contractAddress,\n        bytes calldata payload,\n        string calldata symbol,\n        uint256 amount\n    ) external;\n\n    function isContractCallApproved(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash\n    ) external view returns (bool);\n\n    function isContractCallAndMintApproved(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        address contractAddress,\n        bytes32 payloadHash,\n        string calldata symbol,\n        uint256 amount\n    ) external view returns (bool);\n\n    function validateContractCall(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash\n    ) external returns (bool);\n\n    function validateContractCallAndMint(\n        bytes32 commandId,\n        string calldata sourceChain,\n        string calldata sourceAddress,\n        bytes32 payloadHash,\n        string calldata symbol,\n        uint256 amount\n    ) external returns (bool);\n\n    /***********\\\n    |* Getters *|\n    \\***********/\n\n    function authModule() external view returns (address);\n\n    function tokenDeployer() external view returns (address);\n\n    function tokenMintLimit(string memory symbol) external view returns (uint256);\n\n    function tokenMintAmount(string memory symbol) external view returns (uint256);\n\n    function allTokensFrozen() external view returns (bool);\n\n    function implementation() external view returns (address);\n\n    function tokenAddresses(string memory symbol) external view returns (address);\n\n    function tokenFrozen(string memory symbol) external view returns (bool);\n\n    function isCommandExecuted(bytes32 commandId) external view returns (bool);\n\n    /************************\\\n    |* Governance Functions *|\n    \\************************/\n\n    function setTokenMintLimits(string[] calldata symbols, uint256[] calldata limits) external;\n\n    function upgrade(\n        address newImplementation,\n        bytes32 newImplementationCodeHash,\n        bytes calldata setupParams\n    ) external;\n\n    /**********************\\\n    |* External Functions *|\n    \\**********************/\n\n    function execute(bytes calldata input) external;\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IContractIdentifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// General interface for upgradable contracts\ninterface IContractIdentifier {\n    /**\n     * @notice Returns the contract ID. It can be used as a check during upgrades.\n     * @dev Meant to be overridden in derived contracts.\n     * @return bytes32 The contract ID\n     */\n    function contractId() external pure returns (bytes32);\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    error InvalidAccount();\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IGovernable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title IGovernable Interface\n * @notice This is an interface used by the AxelarGateway contract to manage governance and mint limiter roles.\n */\ninterface IGovernable {\n    error NotGovernance();\n    error NotMintLimiter();\n    error InvalidGovernance();\n    error InvalidMintLimiter();\n\n    event GovernanceTransferred(address indexed previousGovernance, address indexed newGovernance);\n    event MintLimiterTransferred(address indexed previousGovernance, address indexed newGovernance);\n\n    /**\n     * @notice Returns the governance address.\n     * @return address of the governance\n     */\n    function governance() external view returns (address);\n\n    /**\n     * @notice Returns the mint limiter address.\n     * @return address of the mint limiter\n     */\n    function mintLimiter() external view returns (address);\n\n    /**\n     * @notice Transfer the governance role to another address.\n     * @param newGovernance The new governance address\n     */\n    function transferGovernance(address newGovernance) external;\n\n    /**\n     * @notice Transfer the mint limiter role to another address.\n     * @param newGovernance The new mint limiter address\n     */\n    function transferMintLimiter(address newGovernance) external;\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IImplementation.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IContractIdentifier } from './IContractIdentifier.sol';\n\ninterface IImplementation is IContractIdentifier {\n    error NotProxy();\n\n    function setup(bytes calldata data) external;\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title IOwnable Interface\n * @notice IOwnable is an interface that abstracts the implementation of a\n * contract with ownership control features. It's commonly used in upgradable\n * contracts and includes the functionality to get current owner, transfer\n * ownership, and propose and accept ownership.\n */\ninterface IOwnable {\n    error NotOwner();\n    error InvalidOwner();\n    error InvalidOwnerAddress();\n\n    event OwnershipTransferStarted(address indexed newOwner);\n    event OwnershipTransferred(address indexed newOwner);\n\n    /**\n     * @notice Returns the current owner of the contract.\n     * @return address The address of the current owner\n     */\n    function owner() external view returns (address);\n\n    /**\n     * @notice Returns the address of the pending owner of the contract.\n     * @return address The address of the pending owner\n     */\n    function pendingOwner() external view returns (address);\n\n    /**\n     * @notice Transfers ownership of the contract to a new address\n     * @param newOwner The address to transfer ownership to\n     */\n    function transferOwnership(address newOwner) external;\n\n    /**\n     * @notice Proposes to transfer the contract's ownership to a new address.\n     * The new owner needs to accept the ownership explicitly.\n     * @param newOwner The address to transfer ownership to\n     */\n    function proposeOwnership(address newOwner) external;\n\n    /**\n     * @notice Transfers ownership to the pending owner.\n     * @dev Can only be called by the pending owner\n     */\n    function acceptOwnership() external;\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IUpgradable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IOwnable } from './IOwnable.sol';\nimport { IImplementation } from './IImplementation.sol';\n\n// General interface for upgradable contracts\ninterface IUpgradable is IOwnable, IImplementation {\n    error InvalidCodeHash();\n    error InvalidImplementation();\n    error SetupFailed();\n\n    event Upgraded(address indexed newImplementation);\n\n    function implementation() external view returns (address);\n\n    function upgrade(\n        address newImplementation,\n        bytes32 newImplementationCodeHash,\n        bytes calldata params\n    ) external;\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/libs/SafeTransfer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IERC20 } from '../interfaces/IERC20.sol';\n\nerror TokenTransferFailed();\n\n/*\n * @title SafeTokenCall\n * @dev This library is used for performing safe token transfers.\n */\nlibrary SafeTokenCall {\n    /*\n     * @notice Make a safe call to a token contract.\n     * @param token The token contract to interact with.\n     * @param callData The function call data.\n     * @throws TokenTransferFailed error if transfer of token is not successful.\n     */\n    function safeCall(IERC20 token, bytes memory callData) internal {\n        (bool success, bytes memory returnData) = address(token).call(callData);\n        bool transferred = success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\n\n        if (!transferred || address(token).code.length == 0) revert TokenTransferFailed();\n    }\n}\n\n/*\n * @title SafeTokenTransfer\n * @dev This library safely transfers tokens from the contract to a recipient.\n */\nlibrary SafeTokenTransfer {\n    /*\n     * @notice Transfer tokens to a recipient.\n     * @param token The token contract.\n     * @param receiver The recipient of the tokens.\n     * @param amount The amount of tokens to transfer.\n     */\n    function safeTransfer(\n        IERC20 token,\n        address receiver,\n        uint256 amount\n    ) internal {\n        SafeTokenCall.safeCall(token, abi.encodeWithSelector(IERC20.transfer.selector, receiver, amount));\n    }\n}\n\n/*\n * @title SafeTokenTransferFrom\n * @dev This library helps to safely transfer tokens on behalf of a token holder.\n */\nlibrary SafeTokenTransferFrom {\n    /*\n     * @notice Transfer tokens on behalf of a token holder.\n     * @param token The token contract.\n     * @param from The address of the token holder.\n     * @param to The address the tokens are to be sent to.\n     * @param amount The amount of tokens to be transferred.\n     */\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        SafeTokenCall.safeCall(token, abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, amount));\n    }\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/upgradable/Implementation.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IImplementation } from '../interfaces/IImplementation.sol';\n\n/**\n * @title Implementation\n * @notice This contract serves as a base for other contracts and enforces a proxy-first access restriction.\n * @dev Derived contracts must implement the setup function.\n */\nabstract contract Implementation is IImplementation {\n    address private immutable implementationAddress;\n\n    /**\n     * @dev Contract constructor that sets the implementation address to the address of this contract.\n     */\n    constructor() {\n        implementationAddress = address(this);\n    }\n\n    /**\n     * @dev Modifier to require the caller to be the proxy contract.\n     * Reverts if the caller is the current contract (i.e., the implementation contract itself).\n     */\n    modifier onlyProxy() {\n        if (implementationAddress == address(this)) revert NotProxy();\n        _;\n    }\n\n    /**\n     * @notice Initializes contract parameters.\n     * This function is intended to be overridden by derived contracts.\n     * The overriding function must have the onlyProxy modifier.\n     * @param params The parameters to be used for initialization\n     */\n    function setup(bytes calldata params) external virtual;\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/upgradable/Upgradable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IImplementation } from '../interfaces/IImplementation.sol';\nimport { IUpgradable } from '../interfaces/IUpgradable.sol';\nimport { Ownable } from '../utils/Ownable.sol';\nimport { Implementation } from './Implementation.sol';\n\n/**\n * @title Upgradable Contract\n * @notice This contract provides an interface for upgradable smart contracts and includes the functionality to perform upgrades.\n */\nabstract contract Upgradable is Ownable, Implementation, IUpgradable {\n    // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @notice Constructor sets the implementation address to the address of the contract itself\n     * @dev This is used in the onlyProxy modifier to prevent certain functions from being called directly\n     * on the implementation contract itself.\n     * @dev The owner is initially set as address(1) because the actual owner is set within the proxy. It is not\n     * set as the zero address because Ownable is designed to throw an error for ownership transfers to the zero address.\n     */\n    constructor() Ownable(address(1)) {}\n\n    /**\n     * @notice Returns the address of the current implementation\n     * @return implementation_ Address of the current implementation\n     */\n    function implementation() public view returns (address implementation_) {\n        assembly {\n            implementation_ := sload(_IMPLEMENTATION_SLOT)\n        }\n    }\n\n    /**\n     * @notice Upgrades the contract to a new implementation\n     * @param newImplementation The address of the new implementation contract\n     * @param newImplementationCodeHash The codehash of the new implementation contract\n     * @param params Optional setup parameters for the new implementation contract\n     * @dev This function is only callable by the owner.\n     */\n    function upgrade(\n        address newImplementation,\n        bytes32 newImplementationCodeHash,\n        bytes calldata params\n    ) external override onlyOwner {\n        if (IUpgradable(newImplementation).contractId() != IUpgradable(implementation()).contractId())\n            revert InvalidImplementation();\n\n        if (newImplementationCodeHash != newImplementation.codehash) revert InvalidCodeHash();\n\n        emit Upgraded(newImplementation);\n\n        if (params.length > 0) {\n            // slither-disable-next-line controlled-delegatecall\n            (bool success, ) = newImplementation.delegatecall(abi.encodeWithSelector(this.setup.selector, params));\n\n            if (!success) revert SetupFailed();\n        }\n\n        assembly {\n            sstore(_IMPLEMENTATION_SLOT, newImplementation)\n        }\n    }\n\n    /**\n     * @notice Sets up the contract with initial data\n     * @param data Initialization data for the contract\n     * @dev This function is only callable by the proxy contract.\n     */\n    function setup(bytes calldata data) external override(IImplementation, Implementation) onlyProxy {\n        _setup(data);\n    }\n\n    /**\n     * @notice Internal function to set up the contract with initial data\n     * @param data Initialization data for the contract\n     * @dev This function should be implemented in derived contracts.\n     */\n    function _setup(bytes calldata data) internal virtual {}\n}\n"
    },
    "@axelar-network/axelar-gmp-sdk-solidity/contracts/utils/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IOwnable } from '../interfaces/IOwnable.sol';\n\n/**\n * @title Ownable\n * @notice A contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The owner account is set through ownership transfer. This module makes\n * it possible to transfer the ownership of the contract to a new account in one\n * step, as well as to an interim pending owner. In the second flow the ownership does not\n * change until the pending owner accepts the ownership transfer.\n */\nabstract contract Ownable is IOwnable {\n    // keccak256('owner')\n    bytes32 internal constant _OWNER_SLOT = 0x02016836a56b71f0d02689e69e326f4f4c1b9057164ef592671cf0d37c8040c0;\n    // keccak256('ownership-transfer')\n    bytes32 internal constant _OWNERSHIP_TRANSFER_SLOT =\n        0x9855384122b55936fbfb8ca5120e63c6537a1ac40caf6ae33502b3c5da8c87d1;\n\n    /**\n     * @notice Initializes the contract by transferring ownership to the owner parameter.\n     * @param _owner Address to set as the initial owner of the contract\n     */\n    constructor(address _owner) {\n        _transferOwnership(_owner);\n    }\n\n    /**\n     * @notice Modifier that throws an error if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        if (owner() != msg.sender) revert NotOwner();\n\n        _;\n    }\n\n    /**\n     * @notice Returns the current owner of the contract.\n     * @return owner_ The current owner of the contract\n     */\n    function owner() public view returns (address owner_) {\n        assembly {\n            owner_ := sload(_OWNER_SLOT)\n        }\n    }\n\n    /**\n     * @notice Returns the pending owner of the contract.\n     * @return owner_ The pending owner of the contract\n     */\n    function pendingOwner() public view returns (address owner_) {\n        assembly {\n            owner_ := sload(_OWNERSHIP_TRANSFER_SLOT)\n        }\n    }\n\n    /**\n     * @notice Transfers ownership of the contract to a new account `newOwner`.\n     * @dev Can only be called by the current owner.\n     * @param newOwner The address to transfer ownership to\n     */\n    function transferOwnership(address newOwner) external virtual onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @notice Propose to transfer ownership of the contract to a new account `newOwner`.\n     * @dev Can only be called by the current owner. The ownership does not change\n     * until the new owner accepts the ownership transfer.\n     * @param newOwner The address to transfer ownership to\n     */\n    function proposeOwnership(address newOwner) external virtual onlyOwner {\n        if (newOwner == address(0)) revert InvalidOwnerAddress();\n\n        emit OwnershipTransferStarted(newOwner);\n\n        assembly {\n            sstore(_OWNERSHIP_TRANSFER_SLOT, newOwner)\n        }\n    }\n\n    /**\n     * @notice Accepts ownership of the contract.\n     * @dev Can only be called by the pending owner\n     */\n    function acceptOwnership() external virtual {\n        address newOwner = pendingOwner();\n        if (newOwner != msg.sender) revert InvalidOwner();\n\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @notice Internal function to transfer ownership of the contract to a new account `newOwner`.\n     * @dev Called in the constructor to set the initial owner.\n     * @param newOwner The address to transfer ownership to\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        if (newOwner == address(0)) revert InvalidOwnerAddress();\n\n        emit OwnershipTransferred(newOwner);\n\n        assembly {\n            sstore(_OWNER_SLOT, newOwner)\n            sstore(_OWNERSHIP_TRANSFER_SLOT, 0)\n        }\n    }\n}\n"
    },
    "contracts/IOjo.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./OjoTypes.sol\";\n\n/// @title Call a contract method using price data relayed from the Ojo Network.\n/// @author Ojo Network (https://docs.ojo.network/)\n/// @notice Prices are relayed from the Ojo Network to the Ojo contract using Axelar's General Message Passing.\n/// @dev See ./MockOjoContract.sol for an example of implenting this interface to call a contract method using price\n/// data fetched from an Ojo contract.\ninterface IOjo {\n    /// @dev Emmited when new prices are posted to the Ojo Contract (can only be triggered by Axelar's General Message\n    /// Passer).\n    /// @param timestamp Time of price data being posted.\n    event PriceDataPosted(uint256 indexed timestamp);\n\n    /// @notice Triggers the relaying of price data from the Ojo Network to the Ojo contract and uses said price data\n    /// when calling the specified contract method at the specified contract address.\n    /// @dev Reverts if contract method call does not succeed.\n    /// @param assetNames List of assets to be relayed from the Ojo Network and used by the contract method.\n    /// @param contractAddress Address of contract containing the contract method to be called.\n    /// @param commandSelector First four bytes of the Keccak-256 hash of the contract method to be called.\n    /// @param commandParams Abi encoded parameters to be used when calling the contract method (excluding assetNames\n    /// parameter).\n    function callContractMethodWithOjoPriceData(\n        bytes32[] calldata assetNames,\n        address contractAddress,\n        bytes4 commandSelector,\n        bytes calldata commandParams\n    ) external payable;\n\n    /// @notice Triggers the relaying of price data from the Ojo Network to the Ojo contract with an ERC-20 token for\n    /// and uses said price data when calling the specified contract method at the specified contract address.\n    /// @dev Reverts if contract method call does not succeed.\n    /// @param assetNames List of assets to be relayed from the Ojo Network and used by the contract method.\n    /// @param contractAddress Address of contract containing the contract method to be called.\n    /// @param commandSelector First four bytes of the Keccak-256 hash of the contract method to be called.\n    /// @param commandParams Abi encoded parameters to be used when calling the contract method (excluding assetNames\n    /// parameter).\n    /// @param symbol The symbol of the token to be sent with the call.\n    /// @param amount The amount of tokens to be sent with the call.\n    function callContractMethodWithOjoPriceDataAndToken(\n        bytes32[] calldata assetNames,\n        address contractAddress,\n        bytes4 commandSelector,\n        bytes calldata commandParams,\n        string memory symbol,\n        uint256 amount\n    ) external payable;\n\n    /// @notice Returns the price data of a specified asset.\n    /// @dev Price data is stored in a mapping, so requesting the price data of a non existent asset will return the\n    /// zero byte representation of OjoTypes.PriceData.\n    /// @return _priceData See ./OjoTypes.sol for a description of the PriceData object.\n    function getPriceData(\n        bytes32 assetName\n    ) external view returns (OjoTypes.PriceData memory _priceData);\n\n    /// @notice Returns a list of price data of specified assets.\n    /// @dev Price data is stored in a mapping, so requesting the price data of non existent asset will return the\n    /// zero byte representation of OjoTypes.PriceData.\n    /// @return _priceData See ./OjoTypes.sol for a description of the PriceData object.\n    function getPriceDataBulk(\n        bytes32[] calldata assetNames\n    ) external view returns (OjoTypes.PriceData[] memory _priceData);\n\n    /// @notice Returns the price of a specified base and quote asset pair.\n    /// @dev Reverts if quoteAssetName is not an existent asset pair to avoid a divide by 0 error.\n    /// @dev USD is used with a price of 1 when calculating price of an asset pair with USD.\n    /// @return _priceData OjoTypes.Price See ./OjoTypes.sol for a description of the Price object.\n    function getPrice(\n        bytes32 baseAssetName,\n        bytes32 quoteAssetName\n    ) external view returns (OjoTypes.Price memory _priceData);\n}\n"
    },
    "contracts/Ojo.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@axelar-network/axelar-gmp-sdk-solidity/contracts/express/AxelarExpressExecutable.sol\";\nimport \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGateway.sol\";\nimport \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGasService.sol\";\nimport \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IERC20.sol\";\nimport \"@axelar-network/axelar-gmp-sdk-solidity/contracts/upgradable/Upgradable.sol\";\nimport \"./IOjo.sol\";\nimport \"./OjoTypes.sol\";\n\ncontract Ojo is IOjo, AxelarExpressExecutable, Upgradable {\n    IAxelarGasService public immutable gasReceiver;\n\n    string public ojoChain;\n\n    string public ojoAddress;\n\n    uint256 public resolveWindow;\n\n    uint16 public assetLimit;\n\n    mapping(bytes32 => OjoTypes.PriceData) public priceData;\n\n    error AlreadyInitialized();\n\n    constructor(address gateway_, address gasReceiver_) AxelarExpressExecutable(gateway_) {\n        gasReceiver = IAxelarGasService(gasReceiver_);\n    }\n\n    function callContractMethodWithOjoPriceData(\n        bytes32[] calldata assetNames,\n        address contractAddress,\n        bytes4 commandSelector,\n        bytes calldata commandParams\n    ) external payable {\n        require(assetNames.length <= assetLimit, \"Number of assets requested is over limit\");\n\n        bytes memory payloadWithVersion = abi.encodePacked(\n            bytes4(uint32(0)), // version number\n            abi.encode(assetNames, contractAddress, commandSelector, commandParams, block.timestamp) // payload\n        );\n\n        gasReceiver.payNativeGasForContractCall{value: msg.value}(\n            address(this),\n            ojoChain,\n            ojoAddress,\n            payloadWithVersion,\n            msg.sender\n        );\n\n        gateway.callContract(ojoChain, ojoAddress, payloadWithVersion);\n    }\n\n    function callContractMethodWithOjoPriceDataAndToken(\n        bytes32[] calldata assetNames,\n        address contractAddress,\n        bytes4 commandSelector,\n        bytes calldata commandParams,\n        string memory symbol,\n        uint256 amount\n    ) external payable {\n        require(assetNames.length <= assetLimit, \"Number of assets requested is over limit\");\n\n        address tokenAddress = gateway.tokenAddresses(symbol);\n        IERC20(tokenAddress).transferFrom(msg.sender, address(this), amount);\n        IERC20(tokenAddress).approve(address(gateway), amount);\n\n        bytes memory payloadWithVersion = abi.encodePacked(\n            bytes4(uint32(0)), // version number\n            abi.encode(assetNames, contractAddress, commandSelector, commandParams, block.timestamp) // payload\n        );\n\n        gasReceiver.payNativeGasForContractCallWithToken{value: msg.value}(\n            address(this),\n            ojoChain,\n            ojoAddress,\n            payloadWithVersion,\n            symbol,\n            amount,\n            msg.sender\n        );\n\n        gateway.callContractWithToken(ojoChain, ojoAddress, payloadWithVersion, symbol, amount);\n    }\n\n    function _setup(bytes calldata data) internal override {\n        (string memory ojoChain_, string memory ojoAddress_, uint256 resolveWindow_, uint16 assetLimit_) = abi.decode(\n            data,\n            (string, string, uint256, uint16)\n        );\n        if (bytes(ojoChain).length != 0) revert AlreadyInitialized();\n        if (bytes(ojoAddress).length != 0) revert AlreadyInitialized();\n        if (resolveWindow != 0) revert AlreadyInitialized();\n        if (assetLimit != 0) revert AlreadyInitialized();\n        ojoChain = ojoChain_;\n        ojoAddress = ojoAddress_;\n        resolveWindow = resolveWindow_;\n        assetLimit = assetLimit_;\n    }\n\n    function _execute(\n        string calldata,\n        string calldata,\n        bytes calldata payload\n    ) internal override {\n        (\n            OjoTypes.PriceData[] memory _priceData,\n            bytes32[] memory assetNames,\n            address contractAddress,\n            bytes4 commandSelector,\n            bytes memory commandParams\n        ) = abi.decode(\n            payload,\n            (OjoTypes.PriceData[], bytes32[], address, bytes4, bytes)\n        );\n\n        postPriceData(_priceData);\n\n        // Call contract only if command selector is non empty\n        if (commandSelector != OjoTypes.EMPTY_COMMAND_SELECTOR) {\n            (bool success, bytes memory result) = contractAddress.call(\n                abi.encodeWithSelector(commandSelector, assetNames, commandParams)\n            );\n\n            if (!success) {\n                if (result.length == 0) {\n                    require(success, 'Failed with no reason');\n                } else {\n                    // rethrow same error\n                    assembly {\n                        let start := add(result, 0x20)\n                        let end := add(result, mload(result))\n                        revert(start, end)\n                    }\n                }\n            }\n        }\n    }\n\n    function postPriceData(OjoTypes.PriceData[] memory _priceData) internal {\n        for(uint256 i = 0; i < _priceData.length; i++){\n            if (_priceData[i].resolveTime + resolveWindow > block.timestamp) {\n                priceData[_priceData[i].assetName] = _priceData[i];\n            }\n        }\n\n        emit PriceDataPosted(block.timestamp);\n    }\n\n    function getPriceData(\n        bytes32 assetName\n    ) external view returns (OjoTypes.PriceData memory) {\n        return priceData[assetName];\n    }\n\n    function getPriceDataBulk(\n        bytes32[] calldata assetNames\n    ) external view returns (OjoTypes.PriceData[] memory _priceData) {\n        _priceData = new OjoTypes.PriceData[](assetNames.length);\n        for (uint256 i = 0; i < assetNames.length; i++) {\n            _priceData[i] = priceData[assetNames[i]];\n        }\n\n        return _priceData;\n    }\n\n    function getPrice(\n        bytes32 baseAssetName,\n        bytes32 quoteAssetName\n    ) external view returns (OjoTypes.Price memory) {\n        (uint256 basePrice, uint256 baseResolveTime)\n            = getPriceValueAndResolveTime(baseAssetName);\n        (uint256 quotePrice, uint256 quoteResolveTime)\n            = getPriceValueAndResolveTime(quoteAssetName);\n\n        require(quotePrice > 0, \"Quote price is 0\");\n\n        uint256 price = (basePrice * 10**18) / quotePrice;\n\n        return OjoTypes.Price({\n            price: price,\n            baseResolveTime: baseResolveTime,\n            quoteResolveTime: quoteResolveTime\n        });\n    }\n\n    function getPriceValueAndResolveTime(\n        bytes32 assetName\n    ) internal view returns (uint256, uint256) {\n        if (assetName == OjoTypes.USD) {\n            return (OjoTypes.USD_PRICE, 0);\n        }\n\n        return (priceData[assetName].price, priceData[assetName].resolveTime);\n    }\n\n    function updateOjoChain(string calldata ojoChain_) external onlyOwner {\n        ojoChain = ojoChain_;\n    }\n\n    function updateOjoAddress(string calldata ojoAddress_) external onlyOwner {\n        ojoAddress = ojoAddress_;\n    }\n\n    function updateResolveWindow(uint256 resolveWindow_) external onlyOwner {\n        resolveWindow = resolveWindow_;\n    }\n\n    function updateAssetLimit(uint8 assetLimit_) external onlyOwner {\n        assetLimit = assetLimit_;\n    }\n\n    function contractId() external pure returns (bytes32) {\n        return keccak256('ojo-v1');\n    }\n}\n"
    },
    "contracts/OjoTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nlibrary OjoTypes {\n    bytes32 constant USD = bytes32(\"USD\");\n    uint256 constant USD_PRICE= 10**9;\n\n    bytes4 constant EMPTY_COMMAND_SELECTOR = bytes4(keccak256(bytes(\"\")));\n\n    struct PriceData {\n        // Name of asset ex: ATOM\n        bytes32 assetName;\n        // Price in of asset in USD\n        uint256 price;\n        // Time request was sent to ojo for price data\n        uint256 resolveTime;\n        // Median data of asset\n        MedianData medianData;\n    }\n\n    struct MedianData {\n        // Ojo block numbers medians were stamped on\n        uint256[] blockNums;\n        // Median prices\n        uint256[] medians;\n        // Standard deviatoins of median prices\n        uint256[] deviations;\n    }\n\n    struct Price {\n        // Price of asset pair\n        uint256 price;\n        // Base asset resolve time of asset pair\n        uint256 baseResolveTime;\n        // Quote asset resolve time of asset pair\n        uint256 quoteResolveTime;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  }
}}