{"Airdrop.sol":{"content":"// SPDX-License-Identifier: MIT\n// By 0xAA\npragma solidity ^0.8.21;\n\nimport \"./IERC20.sol\"; //import IERC20\n\n/// @notice 向多个地址转账ERC20代币\ncontract Airdrop {\n    mapping(address =\u003e uint) failTransferList;\n\n    /// @notice 向多个地址转账ERC20代币，使用前需要先授权\n    ///\n    /// @param _token 转账的ERC20代币地址\n    /// @param _addresses 空投地址数组\n    /// @param _amounts 代币数量数组（每个地址的空投数量）\n    function multiTransferToken(\n        address _token,\n        address[] calldata _addresses,\n        uint256[] calldata _amounts\n    ) external {\n        // 检查：_addresses和_amounts数组的长度相等\n        require(\n            _addresses.length == _amounts.length,\n            \"Lengths of Addresses and Amounts NOT EQUAL\"\n        );\n        IERC20 token = IERC20(_token); // 声明IERC合约变量\n        uint _amountSum = getSum(_amounts); // 计算空投代币总量\n        // 检查：授权代币数量 \u003e 空投代币总量\n        require(\n            token.allowance(msg.sender, address(this)) \u003e _amountSum,\n            \"Need Approve ERC20 token\"\n        );\n\n        // for循环，利用transferFrom函数发送空投\n        for (uint256 i; i \u003c _addresses.length; i++) {\n            token.transferFrom(msg.sender, _addresses[i], _amounts[i]);\n        }\n    }\n\n    /// 向多个地址转账ETH\n    function multiTransferETH(\n        address payable[] calldata _addresses,\n        uint256[] calldata _amounts\n    ) public payable {\n        // 检查：_addresses和_amounts数组的长度相等\n        require(\n            _addresses.length == _amounts.length,\n            \"Lengths of Addresses and Amounts NOT EQUAL\"\n        );\n        uint _amountSum = getSum(_amounts); // 计算空投ETH总量\n        // 检查转入ETH等于空投总量\n        require(msg.value == _amountSum, \"Transfer amount error\");\n        // for循环，利用transfer函数发送ETH\n        for (uint256 i = 0; i \u003c _addresses.length; i++) {\n            // 注释代码有Dos攻击风险, 并且transfer 也是不推荐写法\n            // Dos攻击 具体参考 https://github.com/AmazingAng/WTF-Solidity/blob/main/S09_DoS/readme.md\n            // _addresses[i].transfer(_amounts[i]);\n            (bool success, ) = _addresses[i].call{value: _amounts[i]}(\"\");\n            if (!success) {\n                failTransferList[_addresses[i]] = _amounts[i];\n            }\n        }\n    }\n\n    // 给空投失败提供主动操作机会\n    function withdrawFromFailList(address _to) public {\n        uint failAmount = failTransferList[msg.sender];\n        require(failAmount \u003e 0, \"You are not in failed list\");\n        failTransferList[msg.sender] = 0;\n        (bool success, ) = _to.call{value: failAmount}(\"\");\n        require(success, \"Fail withdraw\");\n    }\n\n    // 数组求和函数\n    function getSum(uint256[] calldata _arr) public pure returns (uint sum) {\n        for (uint i = 0; i \u003c _arr.length; i++) sum = sum + _arr[i];\n    }\n}\n\n// ERC20代币合约\ncontract ERC20 is IERC20 {\n    mapping(address =\u003e uint256) public override balanceOf;\n\n    mapping(address =\u003e mapping(address =\u003e uint256)) public override allowance;\n\n    uint256 public override totalSupply; // 代币总供给\n\n    string public name; // 名称\n    string public symbol; // 符号\n\n    uint8 public decimals = 18; // 小数位数\n\n    constructor(string memory name_, string memory symbol_) {\n        name = name_;\n        symbol = symbol_;\n    }\n\n    // @dev 实现`transfer`函数，代币转账逻辑\n    function transfer(\n        address recipient,\n        uint amount\n    ) public override returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    // @dev 实现 `approve` 函数, 代币授权逻辑\n    function approve(\n        address spender,\n        uint amount\n    ) public override returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    // @dev 实现`transferFrom`函数，代币授权转账逻辑\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint amount\n    ) public override returns (bool) {\n        allowance[sender][msg.sender] -= amount;\n        balanceOf[sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    // @dev 铸造代币，从 `0` 地址转账给 调用者地址\n    function mint(uint amount) external {\n        balanceOf[msg.sender] += amount;\n        totalSupply += amount;\n        emit Transfer(address(0), msg.sender, amount);\n    }\n\n    // @dev 销毁代币，从 调用者地址 转账给  `0` 地址\n    function burn(uint amount) external {\n        balanceOf[msg.sender] -= amount;\n        totalSupply -= amount;\n        emit Transfer(msg.sender, address(0), amount);\n    }\n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// WTF Solidity by 0xAA\n\npragma solidity ^0.8.21;\n\n/**\n * @dev ERC20 接口合约.\n */\ninterface IERC20 {\n    /**\n     * @dev 释放条件：当 `value` 单位的货币从账户 (`from`) 转账到另一账户 (`to`)时.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev 释放条件：当 `value` 单位的货币从账户 (`owner`) 授权给另一账户 (`spender`)时.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev 返回代币总供给.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev 返回账户`account`所持有的代币数.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev 转账 `amount` 单位代币，从调用者账户到另一账户 `to`.\n     *\n     * 如果成功，返回 `true`.\n     *\n     * 释放 {Transfer} 事件.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev 返回`owner`账户授权给`spender`账户的额度，默认为0。\n     *\n     * 当{approve} 或 {transferFrom} 被调用时，`allowance`会改变.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev 调用者账户给`spender`账户授权 `amount`数量代币。\n     *\n     * 如果成功，返回 `true`.\n     *\n     * 释放 {Approval} 事件.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev 通过授权机制，从`from`账户向`to`账户转账`amount`数量代币。转账的部分会从调用者的`allowance`中扣除。\n     *\n     * 如果成功，返回 `true`.\n     *\n     * 释放 {Transfer} 事件.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}"}}