{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "istanbul",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "src/helper/UpgradeHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../library/Ownable.sol\";\n\ninterface IProxyAdmin {\n    function upgrade(address proxy, address implementation) external;\n}\n\ninterface IiToken {\n    function isiToken() external view returns (bool);\n\n    function underlying() external view returns (address);\n\n    function _upgrade() external;\n\n    function updateInterest() external;\n\n    function _setInterestRateModel(address _newInterestRateModel) external;\n}\n\ninterface IController {\n    function getAlliTokens() external view returns (address[] memory);\n\n    function _upgrade(\n        address _controllerExtraImp,\n        address _controllerExtraExp\n    ) external;\n}\n\ninterface ITimelock {\n    function executeTransactions(\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas\n    ) external payable;\n}\n\ncontract UpgradeHelper is Ownable {\n    address immutable proxyAdmin;\n    address immutable timelock;\n\n    address immutable controller;\n    address immutable controllerImpl;\n    address immutable controllerExtraImp;\n    address immutable controllerExtraExp;\n\n    address immutable rewardDistributor;\n    address immutable rewardDistributorImpl;\n\n    address immutable iTokenImpl;\n    address immutable iETHImpl;\n    address immutable iMSDImpl;\n\n    mapping(address => address) newInterestRateModels;\n\n    constructor(\n        address _proxyAdmin,\n        address _timelock,\n        address _controller,\n        address _rewardDistributor,\n        address _controllerImpl,\n        address _controllerExtraImp,\n        address _controllerExtraExp,\n        address _rewardDistributorImpl,\n        address _iTokenImpl,\n        address _iETHImpl,\n        address _iMSDImpl\n    ) public {\n        __Ownable_init();\n\n        proxyAdmin = _proxyAdmin;\n        timelock = _timelock;\n\n        controller = _controller;\n        rewardDistributor = _rewardDistributor;\n\n        controllerImpl = _controllerImpl;\n        controllerExtraImp = _controllerExtraImp;\n        controllerExtraExp = _controllerExtraExp;\n        rewardDistributorImpl = _rewardDistributorImpl;\n        iTokenImpl = _iTokenImpl;\n        iETHImpl = _iETHImpl;\n        iMSDImpl = _iMSDImpl;\n    }\n\n    function _upgradeiTokens() internal {\n        address[] memory _iTokens = IController(controller).getAlliTokens();\n\n        uint256 _len = _iTokens.length;\n        for (uint256 i = 0; i < _len; i++) {\n            address _iTokenAddr = _iTokens[i];\n            IiToken _iToken = IiToken(_iTokens[i]);\n\n            uint size = 4;\n            address[] memory targets = new address[](size);\n            uint256[] memory values = new uint256[](size);\n            string[] memory signatures = new string[](size);\n            bytes[] memory calldatas = new bytes[](size);\n\n            // _iToken.updateInterest();\n            targets[0] = _iTokenAddr;\n            values[0] = 0;\n            signatures[0] = \"updateInterest()\";\n            calldatas[0] = \"\";\n\n            address implemetation = iTokenImpl;\n            if (!_iToken.isiToken()) {\n                implemetation = iMSDImpl;\n            }\n            if (address(_iToken.underlying()) == address(0)) {\n                implemetation = iETHImpl;\n            }\n\n            // IProxyAdmin(proxyAdmin).upgrade(address(_iToken), implemetation);\n            targets[1] = proxyAdmin;\n            values[1] = 0;\n            signatures[1] = \"upgrade(address,address)\";\n            calldatas[1] = abi.encode(_iTokenAddr, implemetation);\n\n            // _iToken._upgrade();\n            targets[2] = _iTokenAddr;\n            values[2] = 0;\n            signatures[2] = \"_upgrade()\";\n            calldatas[2] = \"\";\n\n            // _iToken._setInterestRateModel(\n            //     newInterestRateModels[address(_iToken)]\n            // );\n            targets[3] = _iTokenAddr;\n            values[3] = 0;\n            signatures[3] = \"_setInterestRateModel(address)\";\n            calldatas[3] = abi.encode(newInterestRateModels[_iTokenAddr]);\n\n            ITimelock(timelock).executeTransactions(\n                targets,\n                values,\n                signatures,\n                calldatas\n            );\n        }\n    }\n\n    function _upgradeController() internal {\n        uint256 size = 4;\n        address[] memory targets = new address[](size);\n        uint256[] memory values = new uint256[](size);\n        string[] memory signatures = new string[](size);\n        bytes[] memory calldatas = new bytes[](size);\n        uint256 i = 0;\n\n        // Pause the reward distribution and explicit unpause is needed\n        // IRewardDistributor(rewardDistributor).pause();\n        targets[i] = rewardDistributor;\n        values[i] = 0;\n        signatures[i] = \"_pause()\";\n        calldatas[i++] = \"\";\n\n        // IProxyAdmin(proxyAdmin).upgrade(controller, controllerImpl);\n        targets[i] = proxyAdmin;\n        values[i] = 0;\n        signatures[i] = \"upgrade(address,address)\";\n        calldatas[i++] = abi.encode(controller, controllerImpl);\n\n        // IProxyAdmin(proxyAdmin).upgrade(\n        //     rewardDistributor,\n        //     rewardDistributorImpl\n        // );\n        targets[i] = proxyAdmin;\n        values[i] = 0;\n        signatures[i] = \"upgrade(address,address)\";\n        calldatas[i++] = abi.encode(rewardDistributor, rewardDistributorImpl);\n\n        // ControllerV2._upgrade() will call rewardDistributor._upgrade()\n        // IController(controller)._upgrade(\n        //     controllerExtraImp,\n        //     controllerExtraExp\n        // );\n        targets[i] = controller;\n        values[i] = 0;\n        signatures[i] = \"_upgrade(address,address)\";\n        calldatas[i++] = abi.encode(controllerExtraImp, controllerExtraExp);\n\n        ITimelock(timelock).executeTransactions(\n            targets,\n            values,\n            signatures,\n            calldatas\n        );\n    }\n\n    function upgrade() external onlyOwner {\n        _upgradeiTokens();\n        _upgradeController();\n    }\n\n    function _setInterestRateModelOf(\n        address _iToken,\n        address _irm\n    ) external onlyOwner {\n        newInterestRateModels[_iToken] = _irm;\n    }\n\n    function _setInterestRateModelsOf(\n        address[] calldata _iTokens,\n        address[] calldata _irms\n    ) external onlyOwner {\n        require(\n            _iTokens.length == _irms.length,\n            \"Input arrays length mismatch!\"\n        );\n\n        uint256 _len = _iTokens.length;\n        for (uint256 i = 0; i < _len; i++) {\n            newInterestRateModels[_iTokens[i]] = _irms[i];\n        }\n    }\n\n    function acceptOwnershipOf(address _target) external onlyOwner {\n        Ownable(_target)._acceptOwner();\n    }\n\n    function transferOwnershipOf(\n        address _target,\n        address payable _newOwner\n    ) external onlyOwner {\n        Ownable(_target)._setPendingOwner(_newOwner);\n    }\n}\n"
    },
    "src/library/Ownable.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {_setPendingOwner} and {_acceptOwner}.\n */\ncontract Ownable {\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    address payable public owner;\n\n    /**\n     * @dev Returns the address of the current pending owner.\n     */\n    address payable public pendingOwner;\n\n    event NewOwner(address indexed previousOwner, address indexed newOwner);\n    event NewPendingOwner(\n        address indexed oldPendingOwner,\n        address indexed newPendingOwner\n    );\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"onlyOwner: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal {\n        owner = msg.sender;\n        emit NewOwner(address(0), msg.sender);\n    }\n\n    /**\n     * @notice Base on the inputing parameter `newPendingOwner` to check the exact error reason.\n     * @dev Transfer contract control to a new owner. The newPendingOwner must call `_acceptOwner` to finish the transfer.\n     * @param newPendingOwner New pending owner.\n     */\n    function _setPendingOwner(\n        address payable newPendingOwner\n    ) external onlyOwner {\n        require(\n            newPendingOwner != address(0) && newPendingOwner != pendingOwner,\n            \"_setPendingOwner: New owenr can not be zero address and owner has been set!\"\n        );\n\n        // Gets current owner.\n        address oldPendingOwner = pendingOwner;\n\n        // Sets new pending owner.\n        pendingOwner = newPendingOwner;\n\n        emit NewPendingOwner(oldPendingOwner, newPendingOwner);\n    }\n\n    /**\n     * @dev Accepts the admin rights, but only for pendingOwenr.\n     */\n    function _acceptOwner() external {\n        require(\n            msg.sender == pendingOwner,\n            \"_acceptOwner: Only for pending owner!\"\n        );\n\n        // Gets current values for events.\n        address oldOwner = owner;\n        address oldPendingOwner = pendingOwner;\n\n        // Set the new contract owner.\n        owner = pendingOwner;\n\n        // Clear the pendingOwner.\n        pendingOwner = address(0);\n\n        emit NewOwner(oldOwner, owner);\n        emit NewPendingOwner(oldPendingOwner, pendingOwner);\n    }\n\n    uint256[50] private __gap;\n}\n"
    }
  }
}}