{{
  "language": "Solidity",
  "sources": {
    "src/base/DecodersAndSanitizers/EtherFiLiquidUsdDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\nimport {UniswapV3DecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/Protocols/UniswapV3DecoderAndSanitizer.sol\";\nimport {BalancerV2DecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/Protocols/BalancerV2DecoderAndSanitizer.sol\";\nimport {MorphoBlueDecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/Protocols/MorphoBlueDecoderAndSanitizer.sol\";\nimport {ERC4626DecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/Protocols/ERC4626DecoderAndSanitizer.sol\";\nimport {CurveDecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/Protocols/CurveDecoderAndSanitizer.sol\";\nimport {AuraDecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/Protocols/AuraDecoderAndSanitizer.sol\";\nimport {ConvexDecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/Protocols/ConvexDecoderAndSanitizer.sol\";\nimport {EtherFiDecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/Protocols/EtherFiDecoderAndSanitizer.sol\";\nimport {NativeWrapperDecoderAndSanitizer} from\n    \"src/base/DecodersAndSanitizers/Protocols/NativeWrapperDecoderAndSanitizer.sol\";\nimport {OneInchDecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/Protocols/OneInchDecoderAndSanitizer.sol\";\nimport {GearboxDecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/Protocols/GearboxDecoderAndSanitizer.sol\";\nimport {PendleRouterDecoderAndSanitizer} from\n    \"src/base/DecodersAndSanitizers/Protocols/PendleRouterDecoderAndSanitizer.sol\";\nimport {AaveV3DecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/Protocols/AaveV3DecoderAndSanitizer.sol\";\nimport {LidoDecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/Protocols/LidoDecoderAndSanitizer.sol\";\nimport {EthenaWithdrawDecoderAndSanitizer} from\n    \"src/base/DecodersAndSanitizers/Protocols/EthenaWithdrawDecoderAndSanitizer.sol\";\nimport {FluidFTokenDecoderAndSanitizer} from\n    \"src/base/DecodersAndSanitizers/Protocols/FluidFTokenDecoderAndSanitizer.sol\";\nimport {CompoundV3DecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/Protocols/CompoundV3DecoderAndSanitizer.sol\";\nimport {MerklDecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/Protocols/MerklDecoderAndSanitizer.sol\";\nimport {KarakDecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/Protocols/KarakDecoderAndSanitizer.sol\";\nimport {UsualMoneyDecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/Protocols/UsualMoneyDecoderAndSanitizer.sol\";\n\ncontract EtherFiLiquidUsdDecoderAndSanitizer is\n    UniswapV3DecoderAndSanitizer,\n    BalancerV2DecoderAndSanitizer,\n    MorphoBlueDecoderAndSanitizer,\n    ERC4626DecoderAndSanitizer,\n    CurveDecoderAndSanitizer,\n    AuraDecoderAndSanitizer,\n    ConvexDecoderAndSanitizer,\n    EtherFiDecoderAndSanitizer,\n    NativeWrapperDecoderAndSanitizer,\n    OneInchDecoderAndSanitizer,\n    GearboxDecoderAndSanitizer,\n    PendleRouterDecoderAndSanitizer,\n    AaveV3DecoderAndSanitizer,\n    LidoDecoderAndSanitizer,\n    EthenaWithdrawDecoderAndSanitizer,\n    FluidFTokenDecoderAndSanitizer,\n    CompoundV3DecoderAndSanitizer,\n    MerklDecoderAndSanitizer,\n    KarakDecoderAndSanitizer,\n    UsualMoneyDecoderAndSanitizer\n{\n    constructor(address _boringVault, address _uniswapV3NonFungiblePositionManager)\n        BaseDecoderAndSanitizer(_boringVault)\n        UniswapV3DecoderAndSanitizer(_uniswapV3NonFungiblePositionManager)\n    {}\n\n    //============================== HANDLE FUNCTION COLLISIONS ===============================\n    /**\n     * @notice BalancerV2, ERC4626, and Curve all specify a `deposit(uint256,address)`,\n     *         all cases are handled the same way.\n     */\n    function deposit(uint256, address receiver)\n        external\n        pure\n        override(BalancerV2DecoderAndSanitizer, ERC4626DecoderAndSanitizer, CurveDecoderAndSanitizer)\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(receiver);\n    }\n\n    /**\n     * @notice EtherFi, NativeWrapper all specify a `deposit()`,\n     *         all cases are handled the same way.\n     */\n    function deposit()\n        external\n        pure\n        override(EtherFiDecoderAndSanitizer, NativeWrapperDecoderAndSanitizer)\n        returns (bytes memory addressesFound)\n    {\n        return addressesFound;\n    }\n\n    /**\n     * @notice BalancerV2, NativeWrapper, Curve, Fluid FToken, and Gearbox all specify a `withdraw(uint256)`,\n     *         all cases are handled the same way.\n     */\n    function withdraw(uint256)\n        external\n        pure\n        override(\n            BalancerV2DecoderAndSanitizer,\n            CurveDecoderAndSanitizer,\n            NativeWrapperDecoderAndSanitizer,\n            GearboxDecoderAndSanitizer\n        )\n        returns (bytes memory addressesFound)\n    {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    /**\n     * @notice Aura, and Convex all specify a `getReward(address,bool)`,\n     *         all cases are handled the same way.\n     */\n    function getReward(address _addr, bool)\n        external\n        pure\n        override(AuraDecoderAndSanitizer, ConvexDecoderAndSanitizer)\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(_addr);\n    }\n\n    /**\n     * @notice EtherFi, and Lido all specify a `wrap(uint256)`,\n     *         all cases are handled the same way.\n     */\n    function wrap(uint256)\n        external\n        pure\n        override(EtherFiDecoderAndSanitizer, LidoDecoderAndSanitizer)\n        returns (bytes memory addressesFound)\n    {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    /**\n     * @notice EtherFi, and Lido all specify a `unwrap(uint256)`,\n     *         all cases are handled the same way.\n     */\n    function unwrap(uint256)\n        external\n        pure\n        override(EtherFiDecoderAndSanitizer, LidoDecoderAndSanitizer)\n        returns (bytes memory addressesFound)\n    {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    // term finance support\n    function lockOffers(DecoderCustomTypes.TermAuctionOfferSubmission[] calldata offerSubmissions)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        for (uint256 i = 0; i < offerSubmissions.length; i++) {\n            addressesFound = abi.encodePacked(addressesFound, offerSubmissions[i].offeror);\n            addressesFound = abi.encodePacked(addressesFound, offerSubmissions[i].purchaseToken);\n        }\n    }\n\n    function unlockOffers(bytes32[] calldata offerIds) external pure virtual returns (bytes memory addressesFound) {}\n\n    function revealOffers(bytes32[] calldata ids, uint256[] calldata prices, uint256[] calldata nonces)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {}\n\n    function redeemTermRepoTokens(address redeemer, uint256)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(redeemer);\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {DecoderCustomTypes} from \"src/interfaces/DecoderCustomTypes.sol\";\n\ncontract BaseDecoderAndSanitizer {\n    error BaseDecoderAndSanitizer__FunctionSelectorNotSupported();\n    //============================== IMMUTABLES ===============================\n\n    /**\n     * @notice The BoringVault contract address.\n     */\n    address internal immutable boringVault;\n\n    constructor(address _boringVault) {\n        boringVault = _boringVault;\n    }\n\n    function approve(address spender, uint256) external pure returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(spender);\n    }\n\n    function transfer(address _to, uint256) external pure returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(_to);\n    }\n\n    function claimFees(address feeAsset) external pure returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(feeAsset);\n    }\n\n    function withdrawNonBoringToken(address token, uint256 /*amount*/ )\n        external\n        pure\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(token);\n    }\n\n    function withdrawNativeFromDrone() external pure returns (bytes memory addressesFound) {\n        return addressesFound;\n    }\n\n    //============================== FALLBACK ===============================\n    /**\n     * @notice The purpose of this function is to revert with a known error,\n     *         so that during merkle tree creation we can verify that a\n     *         leafs decoder and sanitizer implments the required function\n     *         selector.\n     */\n    fallback() external {\n        revert BaseDecoderAndSanitizer__FunctionSelectorNotSupported();\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/UniswapV3DecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {INonFungiblePositionManager} from \"src/interfaces/RawDataDecoderAndSanitizerInterfaces.sol\";\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract UniswapV3DecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== ERRORS ===============================\n\n    error UniswapV3DecoderAndSanitizer__BadPathFormat();\n    error UniswapV3DecoderAndSanitizer__BadTokenId();\n\n    //============================== IMMUTABLES ===============================\n\n    /**\n     * @notice The networks uniswapV3 nonfungible position manager.\n     */\n    INonFungiblePositionManager internal immutable uniswapV3NonFungiblePositionManager;\n\n    constructor(address _uniswapV3NonFungiblePositionManager) {\n        uniswapV3NonFungiblePositionManager = INonFungiblePositionManager(_uniswapV3NonFungiblePositionManager);\n    }\n\n    //============================== UNISWAP V3 ===============================\n\n    function exactInput(DecoderCustomTypes.ExactInputParams calldata params)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        // Nothing to sanitize\n        // Return addresses found\n        // Determine how many addresses are in params.path.\n        uint256 chunkSize = 23; // 3 bytes for uint24 fee, and 20 bytes for address token\n        uint256 pathLength = params.path.length;\n        if (pathLength % chunkSize != 20) revert UniswapV3DecoderAndSanitizer__BadPathFormat();\n        uint256 pathAddressLength = 1 + (pathLength / chunkSize);\n        uint256 pathIndex;\n        for (uint256 i; i < pathAddressLength; ++i) {\n            addressesFound = abi.encodePacked(addressesFound, params.path[pathIndex:pathIndex + 20]);\n            pathIndex += chunkSize;\n        }\n        addressesFound = abi.encodePacked(addressesFound, params.recipient);\n    }\n\n    function mint(DecoderCustomTypes.MintParams calldata params)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        // Nothing to sanitize\n        // Return addresses found\n        addressesFound = abi.encodePacked(params.token0, params.token1, params.recipient);\n    }\n\n    function increaseLiquidity(DecoderCustomTypes.IncreaseLiquidityParams calldata params)\n        external\n        view\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        // Sanitize raw data\n        if (uniswapV3NonFungiblePositionManager.ownerOf(params.tokenId) != boringVault) {\n            revert UniswapV3DecoderAndSanitizer__BadTokenId();\n        }\n        // Extract addresses from uniswapV3NonFungiblePositionManager.positions(params.tokenId).\n        (, address operator, address token0, address token1,,,,,,,,) =\n            uniswapV3NonFungiblePositionManager.positions(params.tokenId);\n        addressesFound = abi.encodePacked(operator, token0, token1);\n    }\n\n    function decreaseLiquidity(DecoderCustomTypes.DecreaseLiquidityParams calldata params)\n        external\n        view\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        // Sanitize raw data\n        // NOTE ownerOf check is done in PositionManager contract as well, but it is added here\n        // just for completeness.\n        if (uniswapV3NonFungiblePositionManager.ownerOf(params.tokenId) != boringVault) {\n            revert UniswapV3DecoderAndSanitizer__BadTokenId();\n        }\n\n        // No addresses in data\n        return addressesFound;\n    }\n\n    function collect(DecoderCustomTypes.CollectParams calldata params)\n        external\n        view\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        // Sanitize raw data\n        // NOTE ownerOf check is done in PositionManager contract as well, but it is added here\n        // just for completeness.\n        if (uniswapV3NonFungiblePositionManager.ownerOf(params.tokenId) != boringVault) {\n            revert UniswapV3DecoderAndSanitizer__BadTokenId();\n        }\n\n        // Return addresses found\n        addressesFound = abi.encodePacked(params.recipient);\n    }\n\n    function burn(uint256 /*tokenId*/ ) external pure virtual returns (bytes memory addressesFound) {\n        // positionManager.burn(tokenId) will verify that the tokenId has no liquidity, and no tokens owed.\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/BalancerV2DecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract BalancerV2DecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== ERRORS ===============================\n\n    error BalancerV2DecoderAndSanitizer__SingleSwapUserDataLengthNonZero();\n    error BalancerV2DecoderAndSanitizer__InternalBalancesNotSupported();\n\n    //============================== BALANCER V2 ===============================\n\n    function flashLoan(address recipient, address[] calldata tokens, uint256[] calldata, bytes calldata)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(recipient);\n        for (uint256 i; i < tokens.length; ++i) {\n            addressesFound = abi.encodePacked(addressesFound, tokens[i]);\n        }\n    }\n\n    function swap(\n        DecoderCustomTypes.SingleSwap calldata singleSwap,\n        DecoderCustomTypes.FundManagement calldata funds,\n        uint256,\n        uint256\n    ) external pure virtual returns (bytes memory addressesFound) {\n        // Sanitize raw data\n        if (singleSwap.userData.length > 0) revert BalancerV2DecoderAndSanitizer__SingleSwapUserDataLengthNonZero();\n        if (funds.fromInternalBalance) revert BalancerV2DecoderAndSanitizer__InternalBalancesNotSupported();\n        if (funds.toInternalBalance) revert BalancerV2DecoderAndSanitizer__InternalBalancesNotSupported();\n\n        // Return addresses found\n        addressesFound = abi.encodePacked(\n            _getPoolAddressFromPoolId(singleSwap.poolId),\n            singleSwap.assetIn,\n            singleSwap.assetOut,\n            funds.sender,\n            funds.recipient\n        );\n    }\n\n    function joinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        DecoderCustomTypes.JoinPoolRequest calldata req\n    ) external pure virtual returns (bytes memory addressesFound) {\n        // Sanitize raw data\n        if (req.fromInternalBalance) revert BalancerV2DecoderAndSanitizer__InternalBalancesNotSupported();\n        // Return addresses found\n        addressesFound = abi.encodePacked(_getPoolAddressFromPoolId(poolId), sender, recipient);\n        uint256 assetsLength = req.assets.length;\n        for (uint256 i; i < assetsLength; ++i) {\n            addressesFound = abi.encodePacked(addressesFound, req.assets[i]);\n        }\n    }\n\n    function exitPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        DecoderCustomTypes.ExitPoolRequest calldata req\n    ) external pure virtual returns (bytes memory addressesFound) {\n        // Sanitize raw data\n        if (req.toInternalBalance) revert BalancerV2DecoderAndSanitizer__InternalBalancesNotSupported();\n        // Return addresses found\n        addressesFound = abi.encodePacked(_getPoolAddressFromPoolId(poolId), sender, recipient);\n        uint256 assetsLength = req.assets.length;\n        for (uint256 i; i < assetsLength; ++i) {\n            addressesFound = abi.encodePacked(addressesFound, req.assets[i]);\n        }\n    }\n\n    function deposit(uint256, address recipient) external pure virtual returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(recipient);\n    }\n\n    function withdraw(uint256) external pure virtual returns (bytes memory addressesFound) {\n        // No addresses in data\n        return addressesFound;\n    }\n\n    function mint(address gauge) external pure virtual returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(gauge);\n    }\n\n    // ========================================= INTERNAL HELPER FUNCTIONS =========================================\n\n    /**\n     * @notice Internal helper function that converts poolIds to pool addresses.\n     */\n    function _getPoolAddressFromPoolId(bytes32 poolId) internal pure returns (address) {\n        return address(uint160(uint256(poolId >> 96)));\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/MorphoBlueDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract MorphoBlueDecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== ERRORS ===============================\n\n    error MorphoBlueDecoderAndSanitizer__CallbackNotSupported();\n\n    //============================== MORPHO BLUE ===============================\n\n    function supply(\n        DecoderCustomTypes.MarketParams calldata params,\n        uint256,\n        uint256,\n        address onBehalf,\n        bytes calldata data\n    ) external pure returns (bytes memory addressesFound) {\n        // Sanitize raw data\n        if (data.length > 0) revert MorphoBlueDecoderAndSanitizer__CallbackNotSupported();\n        // Return addresses found\n        addressesFound = abi.encodePacked(params.loanToken, params.collateralToken, params.oracle, params.irm, onBehalf);\n    }\n\n    function withdraw(\n        DecoderCustomTypes.MarketParams calldata params,\n        uint256,\n        uint256,\n        address onBehalf,\n        address receiver\n    ) external pure returns (bytes memory addressesFound) {\n        // Nothing to sanitize\n        // Return addresses found\n        addressesFound =\n            abi.encodePacked(params.loanToken, params.collateralToken, params.oracle, params.irm, onBehalf, receiver);\n    }\n\n    function borrow(\n        DecoderCustomTypes.MarketParams calldata params,\n        uint256,\n        uint256,\n        address onBehalf,\n        address receiver\n    ) external pure returns (bytes memory addressesFound) {\n        addressesFound =\n            abi.encodePacked(params.loanToken, params.collateralToken, params.oracle, params.irm, onBehalf, receiver);\n    }\n\n    function repay(\n        DecoderCustomTypes.MarketParams calldata params,\n        uint256,\n        uint256,\n        address onBehalf,\n        bytes calldata data\n    ) external pure returns (bytes memory addressesFound) {\n        // Sanitize raw data\n        if (data.length > 0) revert MorphoBlueDecoderAndSanitizer__CallbackNotSupported();\n\n        // Return addresses found\n        addressesFound = abi.encodePacked(params.loanToken, params.collateralToken, params.oracle, params.irm, onBehalf);\n    }\n\n    function supplyCollateral(\n        DecoderCustomTypes.MarketParams calldata params,\n        uint256,\n        address onBehalf,\n        bytes calldata data\n    ) external pure returns (bytes memory addressesFound) {\n        // Sanitize raw data\n        if (data.length > 0) revert MorphoBlueDecoderAndSanitizer__CallbackNotSupported();\n\n        // Return addresses found\n        addressesFound = abi.encodePacked(params.loanToken, params.collateralToken, params.oracle, params.irm, onBehalf);\n    }\n\n    function withdrawCollateral(\n        DecoderCustomTypes.MarketParams calldata params,\n        uint256,\n        address onBehalf,\n        address receiver\n    ) external pure returns (bytes memory addressesFound) {\n        // Nothing to sanitize\n        // Return addresses found\n        addressesFound =\n            abi.encodePacked(params.loanToken, params.collateralToken, params.oracle, params.irm, onBehalf, receiver);\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/ERC4626DecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract ERC4626DecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== ERC4626 ===============================\n\n    function deposit(uint256, address receiver) external pure virtual returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(receiver);\n    }\n\n    function mint(uint256, address receiver) external pure virtual returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(receiver);\n    }\n\n    function withdraw(uint256, address receiver, address owner)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(receiver, owner);\n    }\n\n    function redeem(uint256, address receiver, address owner)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(receiver, owner);\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/CurveDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract CurveDecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== CURVE ===============================\n\n    function exchange(int128, int128, uint256, uint256) external pure virtual returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function add_liquidity(uint256[] calldata, uint256) external pure virtual returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function remove_liquidity(uint256, uint256[] calldata)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function deposit(uint256, address receiver) external pure virtual returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(receiver);\n    }\n\n    function withdraw(uint256) external pure virtual returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function claim_rewards(address _addr) external pure virtual returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(_addr);\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/AuraDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract AuraDecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== AURA ===============================\n\n    function getReward(address _user, bool) external pure virtual returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(_user);\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/ConvexDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract ConvexDecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== CONVEX ===============================\n\n    function deposit(uint256, uint256, bool) external view virtual returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function withdrawAndUnwrap(uint256, bool) external view virtual returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function getReward(address _addr, bool) external pure virtual returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(_addr);\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/EtherFiDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract EtherFiDecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== ETHERFI ===============================\n\n    function deposit() external pure virtual returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function wrap(uint256) external pure virtual returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function unwrap(uint256) external pure virtual returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function requestWithdraw(address _addr, uint256) external pure virtual returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(_addr);\n    }\n\n    function claimWithdraw(uint256) external pure virtual returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/NativeWrapperDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract NativeWrapperDecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== ETHERFI ===============================\n\n    function deposit() external pure virtual returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function withdraw(uint256) external pure virtual returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/OneInchDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract OneInchDecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== ERRORS ===============================\n\n    error OneInchDecoderAndSanitizer__PermitNotSupported();\n\n    //============================== ONEINCH ===============================\n\n    function swap(\n        address executor,\n        DecoderCustomTypes.SwapDescription calldata desc,\n        bytes calldata permit,\n        bytes calldata\n    ) external pure returns (bytes memory addressesFound) {\n        if (permit.length > 0) revert OneInchDecoderAndSanitizer__PermitNotSupported();\n        addressesFound = abi.encodePacked(executor, desc.srcToken, desc.dstToken, desc.srcReceiver, desc.dstReceiver);\n    }\n\n    function uniswapV3Swap(uint256, uint256, uint256[] calldata pools)\n        external\n        pure\n        returns (bytes memory addressesFound)\n    {\n        for (uint256 i; i < pools.length; ++i) {\n            addressesFound = abi.encodePacked(addressesFound, uint160(pools[i]));\n        }\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/GearboxDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract GearboxDecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== GEARBOX ===============================\n\n    function deposit(uint256) external pure virtual returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function withdraw(uint256) external pure virtual returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function claim() external pure virtual returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/PendleRouterDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract PendleRouterDecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== ERRORS ===============================\n\n    error PendleRouterDecoderAndSanitizer__AggregatorSwapsNotPermitted();\n    error PendleRouterDecoderAndSanitizer__LimitOrderYtMismatch(address ytFound, address ytExpected);\n    error PendleRouterDecoderAndSanitizer__NoBytes();\n\n    //============================== PENDLEROUTER ===============================\n\n    function mintSyFromToken(address user, address sy, uint256, DecoderCustomTypes.TokenInput calldata input)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        if (\n            input.swapData.swapType != DecoderCustomTypes.SwapType.NONE || input.swapData.extRouter != address(0)\n                || input.pendleSwap != address(0) || input.tokenIn != input.tokenMintSy\n        ) revert PendleRouterDecoderAndSanitizer__AggregatorSwapsNotPermitted();\n\n        addressesFound =\n            abi.encodePacked(user, sy, input.tokenIn, input.tokenMintSy, input.pendleSwap, input.swapData.extRouter);\n    }\n\n    function mintPyFromSy(address user, address yt, uint256, uint256)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(user, yt);\n    }\n\n    function swapExactPtForYt(address user, address market, uint256, uint256, DecoderCustomTypes.ApproxParams calldata)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(user, market);\n    }\n\n    function swapExactYtForPt(address user, address market, uint256, uint256, DecoderCustomTypes.ApproxParams calldata)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(user, market);\n    }\n\n    function addLiquidityDualSyAndPt(address user, address market, uint256, uint256, uint256)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(user, market);\n    }\n\n    function removeLiquidityDualSyAndPt(address user, address market, uint256, uint256, uint256)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(user, market);\n    }\n\n    function redeemPyToSy(address user, address yt, uint256, uint256)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(user, yt);\n    }\n\n    function redeemSyToToken(address user, address sy, uint256, DecoderCustomTypes.TokenOutput calldata output)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        if (\n            output.swapData.swapType != DecoderCustomTypes.SwapType.NONE || output.swapData.extRouter != address(0)\n                || output.pendleSwap != address(0) || output.tokenOut != output.tokenRedeemSy\n        ) revert PendleRouterDecoderAndSanitizer__AggregatorSwapsNotPermitted();\n\n        addressesFound = abi.encodePacked(\n            user, sy, output.tokenOut, output.tokenRedeemSy, output.pendleSwap, output.swapData.extRouter\n        );\n    }\n\n    function redeemDueInterestAndRewards(\n        address user,\n        address[] calldata sys,\n        address[] calldata yts,\n        address[] calldata markets\n    ) external pure virtual returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(user);\n        uint256 sysLength = sys.length;\n        for (uint256 i; i < sysLength; ++i) {\n            addressesFound = abi.encodePacked(addressesFound, sys[i]);\n        }\n        uint256 ytsLength = yts.length;\n        for (uint256 i; i < ytsLength; ++i) {\n            addressesFound = abi.encodePacked(addressesFound, yts[i]);\n        }\n        uint256 marketsLength = markets.length;\n        for (uint256 i; i < marketsLength; ++i) {\n            addressesFound = abi.encodePacked(addressesFound, markets[i]);\n        }\n    }\n\n    function swapExactSyForPt(\n        address receiver,\n        address market,\n        uint256, /*exactSyIn*/\n        uint256, /*minPtOut*/\n        DecoderCustomTypes.ApproxParams calldata,\n        DecoderCustomTypes.LimitOrderData calldata limit\n    ) external pure virtual returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(receiver, market, _sanitizeLimitOrderData(limit));\n    }\n\n    function swapExactPtForSy(\n        address receiver,\n        address market,\n        uint256, /*exactPtIn*/\n        uint256, /*minSyOut*/\n        DecoderCustomTypes.LimitOrderData calldata limit\n    ) external pure virtual returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(receiver, market, _sanitizeLimitOrderData(limit));\n    }\n\n    function swapExactSyForYt(\n        address receiver,\n        address market,\n        uint256, /*exactSyIn*/\n        uint256, /*minYtOut*/\n        DecoderCustomTypes.ApproxParams calldata, /*guessYtOut*/\n        DecoderCustomTypes.LimitOrderData calldata limit\n    ) external pure returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(receiver, market, _sanitizeLimitOrderData(limit));\n    }\n\n    function swapExactYtForSy(\n        address receiver,\n        address market,\n        uint256, /*exactYtIn*/\n        uint256, /*minSyOut*/\n        DecoderCustomTypes.LimitOrderData calldata limit\n    ) external pure returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(receiver, market, _sanitizeLimitOrderData(limit));\n    }\n\n    /**\n     * @notice `params[i].order.token` is restricted to be either an input or an output token for the SY,\n     *         so addressesFound only reports the YT address from the FillOrderParams, as the YT address derives\n     *      The SY address which restricts the input and output tokens.\n     */\n    function fill(\n        DecoderCustomTypes.FillOrderParams[] calldata params,\n        address receiver,\n        uint256, /*maxTaking*/\n        bytes calldata optData,\n        bytes calldata callback\n    ) external pure virtual returns (bytes memory addressesFound) {\n        if (optData.length > 0 || callback.length > 0) revert PendleRouterDecoderAndSanitizer__NoBytes();\n\n        addressesFound = abi.encodePacked(receiver);\n\n        address savedYt;\n        // Iterate through params, and make sure all orders have the same yt.\n        for (uint256 i; i < params.length; ++i) {\n            if (savedYt == address(0)) {\n                // Update saved yt.\n                savedYt = params[i].order.YT;\n            } else {\n                // Make sure this orders YT matches the saved yt.\n                if (savedYt != params[i].order.YT) {\n                    revert PendleRouterDecoderAndSanitizer__LimitOrderYtMismatch(params[i].order.YT, savedYt);\n                }\n            }\n        }\n\n        // If yt is set, encode it.\n        if (savedYt != address(0)) {\n            addressesFound = abi.encodePacked(addressesFound, savedYt);\n        }\n    }\n\n    function _sanitizeLimitOrderData(DecoderCustomTypes.LimitOrderData calldata limit)\n        internal\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        if (limit.limitRouter != address(0)) {\n            // Trying to fill limit orders.\n            addressesFound = abi.encodePacked(limit.limitRouter);\n            if (limit.optData.length > 0) revert PendleRouterDecoderAndSanitizer__NoBytes();\n\n            address savedYt;\n            // Make sure all normal fills have the same yt.\n            for (uint256 i; i < limit.normalFills.length; ++i) {\n                if (savedYt == address(0)) {\n                    // Update saved yt.\n                    savedYt = limit.normalFills[i].order.YT;\n                } else {\n                    // Make sure this orders YT matches the saved yt.\n                    if (savedYt != limit.normalFills[i].order.YT) {\n                        revert PendleRouterDecoderAndSanitizer__LimitOrderYtMismatch(\n                            limit.normalFills[i].order.YT, savedYt\n                        );\n                    }\n                }\n            }\n            // Make sure all flash fills have the same yt.\n            for (uint256 i; i < limit.flashFills.length; ++i) {\n                if (savedYt == address(0)) {\n                    // Update saved yt.\n                    savedYt = limit.flashFills[i].order.YT;\n                } else {\n                    // Make sure this orders YT matches the saved yt.\n                    if (savedYt != limit.flashFills[i].order.YT) {\n                        revert PendleRouterDecoderAndSanitizer__LimitOrderYtMismatch(\n                            limit.flashFills[i].order.YT, savedYt\n                        );\n                    }\n                }\n            }\n\n            // If yt is set, encode it.\n            if (savedYt != address(0)) {\n                addressesFound = abi.encodePacked(addressesFound, savedYt);\n            }\n        }\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/AaveV3DecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract AaveV3DecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== AAVEV3 ===============================\n\n    function supply(address asset, uint256, address onBehalfOf, uint16)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(asset, onBehalfOf);\n    }\n\n    function withdraw(address asset, uint256, address to) external pure virtual returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(asset, to);\n    }\n\n    function borrow(address asset, uint256, uint256, uint16, address onBehalfOf)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(asset, onBehalfOf);\n    }\n\n    function repay(address asset, uint256, uint256, address onBehalfOf)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(asset, onBehalfOf);\n    }\n\n    function setUserUseReserveAsCollateral(address asset, bool)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(asset);\n    }\n\n    function setUserEMode(uint8) external pure virtual returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/LidoDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract LidoDecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== LIDO ===============================\n\n    function submit(address referral) external pure virtual returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(referral);\n    }\n\n    function wrap(uint256) external pure virtual returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function unwrap(uint256) external pure virtual returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function requestWithdrawals(uint256[] calldata, address _owner)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(_owner);\n    }\n\n    function claimWithdrawal(uint256) external pure virtual returns (bytes memory addressesFound) {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n\n    function claimWithdrawals(uint256[] calldata, uint256[] calldata)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/EthenaWithdrawDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract EthenaWithdrawDecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== Ethena Withdraw ===============================\n\n    function cooldownAssets(uint256 /*assets*/ ) external pure virtual returns (bytes memory addressesFound) {\n        // Nothing to do.\n    }\n\n    function cooldownShares(uint256 /*shares*/ ) external pure virtual returns (bytes memory addressesFound) {\n        // Nothing to do.\n    }\n\n    function unstake(address receiver) external pure virtual returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(receiver);\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/FluidFTokenDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract FluidFTokenDecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== Fluid FToken ===============================\n\n    function deposit(uint256, /*assets_*/ address receiver_, uint256 /*minAmountOut_*/ )\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(receiver_);\n    }\n\n    function mint(uint256, /*shares_*/ address receiver_, uint256 /*maxAssets_*/ )\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(receiver_);\n    }\n\n    function withdraw(uint256, /*assets_*/ address receiver_, address owner_, uint256 /*maxSharesBurn_*/ )\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(receiver_, owner_);\n    }\n\n    function redeem(uint256, /*shares_*/ address receiver_, address owner_, uint256 /*minAmountOut_*/ )\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(receiver_, owner_);\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/CompoundV3DecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract CompoundV3DecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== CompoundV3 ===============================\n\n    function supply(address asset, uint256 /*amount*/ )\n        external\n        pure\n        virtual\n        returns (bytes memory sensitiveArguments)\n    {\n        // Extract sensitive arguments.\n        sensitiveArguments = abi.encodePacked(asset);\n    }\n\n    function withdraw(address asset, uint256 /*amount*/ )\n        external\n        pure\n        virtual\n        returns (bytes memory sensitiveArguments)\n    {\n        // Extract sensitive arguments.\n        sensitiveArguments = abi.encodePacked(asset);\n    }\n\n    function claim(address comet, address src, bool /*shouldAccrue*/ )\n        external\n        pure\n        virtual\n        returns (bytes memory sensitiveArguments)\n    {\n        // Extract sensitive arguments.\n        sensitiveArguments = abi.encodePacked(comet, src);\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/MerklDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract MerklDecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== Merkl ===============================\n\n    error MerklDecoderAndSanitizer__InputLengthMismatch();\n\n    function toggleOperator(address user, address operator)\n        external\n        pure\n        virtual\n        returns (bytes memory sensitiveArguments)\n    {\n        sensitiveArguments = abi.encodePacked(user, operator);\n    }\n\n    function claim(\n        address[] calldata users,\n        address[] calldata tokens,\n        uint256[] calldata amounts,\n        bytes32[][] calldata proofs\n    ) external pure virtual returns (bytes memory sensitiveArguments) {\n        // The distributor checks if the lengths match, but we also do it here just in case Distributors are upgraded.\n        uint256 usersLength = users.length;\n        if (usersLength != tokens.length || usersLength != amounts.length || usersLength != proofs.length) {\n            revert MerklDecoderAndSanitizer__InputLengthMismatch();\n        }\n\n        for (uint256 i; i < usersLength; ++i) {\n            sensitiveArguments = abi.encodePacked(sensitiveArguments, users[i], tokens[i]);\n        }\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/KarakDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract KarakDecoderAndSanitizer is BaseDecoderAndSanitizer {\n    error KarakDecoderAndSanitizer__InvalidRequestsLength();\n\n    //============================== KARAK ===============================\n\n    function deposit(address vault, uint256, /*amount*/ uint256 /*minOut*/ )\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(vault);\n    }\n\n    function gimmieShares(address vault, uint256 /*shares*/ )\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(vault);\n    }\n\n    function returnShares(address vault, uint256 /*shares*/ )\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(vault);\n    }\n\n    function startWithdraw(DecoderCustomTypes.WithdrawRequest[] calldata requests)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        if (requests.length != 1 || requests[0].vaults.length != 1 || requests[0].shares.length != 1) {\n            revert KarakDecoderAndSanitizer__InvalidRequestsLength();\n        }\n        addressesFound = abi.encodePacked(requests[0].vaults[0], requests[0].withdrawer);\n    }\n\n    function finishWithdraw(DecoderCustomTypes.QueuedWithdrawal[] calldata startedWithdrawals)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        if (\n            startedWithdrawals.length != 1 || startedWithdrawals[0].request.vaults.length != 1\n                || startedWithdrawals[0].request.shares.length != 1\n        ) {\n            revert KarakDecoderAndSanitizer__InvalidRequestsLength();\n        }\n        addressesFound = abi.encodePacked(\n            startedWithdrawals[0].staker,\n            startedWithdrawals[0].delegatedTo,\n            startedWithdrawals[0].request.vaults[0],\n            startedWithdrawals[0].request.withdrawer\n        );\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/UsualMoneyDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract UsualMoneyDecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== Usual Money ===============================\n\n    function mint(uint256 /*amountUsd0*/ ) external pure virtual returns (bytes memory sensitiveArgumentsFound) {\n        return sensitiveArgumentsFound;\n    }\n\n    function unwrap() external pure virtual returns (bytes memory sensitiveArgumentsFound) {\n        return sensitiveArgumentsFound;\n    }\n}\n"
    },
    "src/interfaces/DecoderCustomTypes.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\ncontract DecoderCustomTypes {\n    // ========================================= BALANCER =========================================\n    struct JoinPoolRequest {\n        address[] assets;\n        uint256[] maxAmountsIn;\n        bytes userData;\n        bool fromInternalBalance;\n    }\n\n    struct ExitPoolRequest {\n        address[] assets;\n        uint256[] minAmountsOut;\n        bytes userData;\n        bool toInternalBalance;\n    }\n\n    enum SwapKind {\n        GIVEN_IN,\n        GIVEN_OUT\n    }\n\n    struct SingleSwap {\n        bytes32 poolId;\n        SwapKind kind;\n        address assetIn;\n        address assetOut;\n        uint256 amount;\n        bytes userData;\n    }\n\n    struct FundManagement {\n        address sender;\n        bool fromInternalBalance;\n        address recipient;\n        bool toInternalBalance;\n    }\n\n    // ========================================= UNISWAP V3 =========================================\n\n    struct MintParams {\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n    }\n\n    struct IncreaseLiquidityParams {\n        uint256 tokenId;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    struct DecreaseLiquidityParams {\n        uint256 tokenId;\n        uint128 liquidity;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    struct CollectParams {\n        uint256 tokenId;\n        address recipient;\n        uint128 amount0Max;\n        uint128 amount1Max;\n    }\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    struct PancakeSwapExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    // ========================================= MORPHO BLUE =========================================\n\n    struct MarketParams {\n        address loanToken;\n        address collateralToken;\n        address oracle;\n        address irm;\n        uint256 lltv;\n    }\n\n    // ========================================= 1INCH =========================================\n\n    struct SwapDescription {\n        address srcToken;\n        address dstToken;\n        address payable srcReceiver;\n        address payable dstReceiver;\n        uint256 amount;\n        uint256 minReturnAmount;\n        uint256 flags;\n    }\n\n    // ========================================= PENDLE =========================================\n    struct TokenInput {\n        // TOKEN DATA\n        address tokenIn;\n        uint256 netTokenIn;\n        address tokenMintSy;\n        // AGGREGATOR DATA\n        address pendleSwap;\n        SwapData swapData;\n    }\n\n    struct TokenOutput {\n        // TOKEN DATA\n        address tokenOut;\n        uint256 minTokenOut;\n        address tokenRedeemSy;\n        // AGGREGATOR DATA\n        address pendleSwap;\n        SwapData swapData;\n    }\n\n    struct ApproxParams {\n        uint256 guessMin;\n        uint256 guessMax;\n        uint256 guessOffchain; // pass 0 in to skip this variable\n        uint256 maxIteration; // every iteration, the diff between guessMin and guessMax will be divided by 2\n        uint256 eps; // the max eps between the returned result & the correct result, base 1e18. Normally this number will be set\n            // to 1e15 (1e18/1000 = 0.1%)\n    }\n\n    struct SwapData {\n        SwapType swapType;\n        address extRouter;\n        bytes extCalldata;\n        bool needScale;\n    }\n\n    enum SwapType {\n        NONE,\n        KYBERSWAP,\n        ONE_INCH,\n        // ETH_WETH not used in Aggregator\n        ETH_WETH\n    }\n\n    struct LimitOrderData {\n        address limitRouter;\n        uint256 epsSkipMarket; // only used for swap operations, will be ignored otherwise\n        FillOrderParams[] normalFills;\n        FillOrderParams[] flashFills;\n        bytes optData;\n    }\n\n    struct FillOrderParams {\n        Order order;\n        bytes signature;\n        uint256 makingAmount;\n    }\n\n    struct Order {\n        uint256 salt;\n        uint256 expiry;\n        uint256 nonce;\n        OrderType orderType;\n        address token;\n        address YT;\n        address maker;\n        address receiver;\n        uint256 makingAmount;\n        uint256 lnImpliedRate;\n        uint256 failSafeRate;\n        bytes permit;\n    }\n\n    enum OrderType {\n        SY_FOR_PT,\n        PT_FOR_SY,\n        SY_FOR_YT,\n        YT_FOR_SY\n    }\n\n    // ========================================= EIGEN LAYER =========================================\n\n    struct QueuedWithdrawalParams {\n        // Array of strategies that the QueuedWithdrawal contains\n        address[] strategies;\n        // Array containing the amount of shares in each Strategy in the `strategies` array\n        uint256[] shares;\n        // The address of the withdrawer\n        address withdrawer;\n    }\n\n    struct Withdrawal {\n        // The address that originated the Withdrawal\n        address staker;\n        // The address that the staker was delegated to at the time that the Withdrawal was created\n        address delegatedTo;\n        // The address that can complete the Withdrawal + will receive funds when completing the withdrawal\n        address withdrawer;\n        // Nonce used to guarantee that otherwise identical withdrawals have unique hashes\n        uint256 nonce;\n        // Block number when the Withdrawal was created\n        uint32 startBlock;\n        // Array of strategies that the Withdrawal contains\n        address[] strategies;\n        // Array containing the amount of shares in each Strategy in the `strategies` array\n        uint256[] shares;\n    }\n\n    struct SignatureWithExpiry {\n        // the signature itself, formatted as a single bytes object\n        bytes signature;\n        // the expiration timestamp (UTC) of the signature\n        uint256 expiry;\n    }\n\n    struct EarnerTreeMerkleLeaf {\n        address earner;\n        bytes32 earnerTokenRoot;\n    }\n\n    struct TokenTreeMerkleLeaf {\n        address token;\n        uint256 cumulativeEarnings;\n    }\n\n    struct RewardsMerkleClaim {\n        uint32 rootIndex;\n        uint32 earnerIndex;\n        bytes earnerTreeProof;\n        EarnerTreeMerkleLeaf earnerLeaf;\n        uint32[] tokenIndices;\n        bytes[] tokenTreeProofs;\n        TokenTreeMerkleLeaf[] tokenLeaves;\n    }\n\n    // ========================================= CCIP =========================================\n\n    // If extraArgs is empty bytes, the default is 200k gas limit.\n    struct EVM2AnyMessage {\n        bytes receiver; // abi.encode(receiver address) for dest EVM chains\n        bytes data; // Data payload\n        EVMTokenAmount[] tokenAmounts; // Token transfers\n        address feeToken; // Address of feeToken. address(0) means you will send msg.value.\n        bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV2)\n    }\n\n    /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n    struct EVMTokenAmount {\n        address token; // token address on the local chain.\n        uint256 amount; // Amount of tokens.\n    }\n\n    struct EVMExtraArgsV1 {\n        uint256 gasLimit;\n    }\n\n    // ========================================= OFT =========================================\n\n    struct SendParam {\n        uint32 dstEid; // Destination endpoint ID.\n        bytes32 to; // Recipient address.\n        uint256 amountLD; // Amount to send in local decimals.\n        uint256 minAmountLD; // Minimum amount to send in local decimals.\n        bytes extraOptions; // Additional options supplied by the caller to be used in the LayerZero message.\n        bytes composeMsg; // The composed message for the send() operation.\n        bytes oftCmd; // The OFT command to be executed, unused in default OFT implementations.\n    }\n\n    struct MessagingFee {\n        uint256 nativeFee;\n        uint256 lzTokenFee;\n    }\n    // ========================================= L1StandardBridge =========================================\n\n    struct WithdrawalTransaction {\n        uint256 nonce;\n        address sender;\n        address target;\n        uint256 value;\n        uint256 gasLimit;\n        bytes data;\n    }\n\n    struct OutputRootProof {\n        bytes32 version;\n        bytes32 stateRoot;\n        bytes32 messagePasserStorageRoot;\n        bytes32 latestBlockhash;\n    }\n\n    // ========================================= Mantle L1StandardBridge =========================================\n\n    struct MantleWithdrawalTransaction {\n        uint256 nonce;\n        address sender;\n        address target;\n        uint256 mntValue;\n        uint256 value;\n        uint256 gasLimit;\n        bytes data;\n    }\n\n    // ========================================= Linea Bridge =========================================\n\n    struct ClaimMessageWithProofParams {\n        bytes32[] proof;\n        uint256 messageNumber;\n        uint32 leafIndex;\n        address from;\n        address to;\n        uint256 fee;\n        uint256 value;\n        address payable feeRecipient;\n        bytes32 merkleRoot;\n        bytes data;\n    }\n\n    // ========================================= Scroll Bridge =========================================\n\n    struct L2MessageProof {\n        uint256 batchIndex;\n        bytes merkleProof;\n    }\n\n    // ========================================= Camelot V3 =========================================\n\n    struct CamelotMintParams {\n        address token0;\n        address token1;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n    }\n    // ========================================= Velodrome V3 =========================================\n\n    struct VelodromeMintParams {\n        address token0;\n        address token1;\n        int24 tickSpacing;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n        uint160 sqrtPriceX96;\n    }\n\n    // ========================================= Karak =========================================\n\n    struct QueuedWithdrawal {\n        address staker;\n        address delegatedTo;\n        uint256 nonce;\n        uint256 start;\n        WithdrawRequest request;\n    }\n\n    struct WithdrawRequest {\n        address[] vaults;\n        uint256[] shares;\n        address withdrawer;\n    }\n\n    // ========================================= Term Finance ==================================\n\n    /// @dev TermAuctionOfferSubmission represents an offer submission to offeror an amount of money for a specific interest rate\n    struct TermAuctionOfferSubmission {\n        /// @dev For an existing offer this is the unique onchain identifier for this offer. For a new offer this is a randomized input that will be used to generate the unique onchain identifier.\n        bytes32 id;\n        /// @dev The address of the offeror\n        address offeror;\n        /// @dev Hash of the offered price as a percentage of the initial loaned amount vs amount returned at maturity. This stores 9 decimal places\n        bytes32 offerPriceHash;\n        /// @dev The maximum amount of purchase tokens that can be lent\n        uint256 amount;\n        /// @dev The address of the ERC20 purchase token\n        address purchaseToken;\n    }\n}\n"
    },
    "src/interfaces/RawDataDecoderAndSanitizerInterfaces.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\n// Swell\ninterface INonFungiblePositionManager {\n    struct Position {\n        // the nonce for permits\n        uint96 nonce;\n        // the address that is approved for spending this token\n        address operator;\n        // the ID of the pool with which this token is connected\n        uint80 poolId;\n        // the tick range of the position\n        int24 tickLower;\n        int24 tickUpper;\n        // the liquidity of the position\n        uint128 liquidity;\n        // the fee growth of the aggregate position as of the last action on the individual position\n        uint256 feeGrowthInside0LastX128;\n        uint256 feeGrowthInside1LastX128;\n        // how many uncollected tokens are owed to the position, as of the last computation\n        uint128 tokensOwed0;\n        uint128 tokensOwed1;\n    }\n\n    function ownerOf(uint256 tokenId) external view returns (address);\n    function positions(uint256 tokenId)\n        external\n        view\n        returns (\n            uint96 nonce,\n            address operator,\n            address token0,\n            address token1,\n            uint24 fee,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n}\n\ninterface PancakeSwapV3MasterChef {\n    function userPositionInfos(uint256 id)\n        external\n        view\n        returns (\n            uint128 liquidity,\n            uint128 boostLiquidity,\n            int24 tickLower,\n            int24 tickUpper,\n            uint256 rewardsGrowthInside,\n            uint256 reward,\n            address user,\n            uint256 pid,\n            uint256 boostMultiplier\n        );\n}\n\ninterface CamelotNonFungiblePositionManager {\n    function ownerOf(uint256 tokenId) external view returns (address);\n    function positions(uint256 tokenId)\n        external\n        view\n        returns (\n            uint96 nonce,\n            address operator,\n            address token0,\n            address token1,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@solmate/=lib/solmate/src/",
      "@forge-std/=lib/forge-std/src/",
      "@ds-test/=lib/forge-std/lib/ds-test/src/",
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "@openzeppelin/=lib/openzeppelin-contracts/",
      "@ccip/=lib/ccip/",
      "@devtools-oapp-evm/=lib/OAppAuth/lib/devtools/packages/oapp-evm/contracts/oapp/",
      "@layerzerolabs/lz-evm-messagelib-v2/=lib/OAppAuth/node_modules/@layerzerolabs/lz-evm-messagelib-v2/",
      "@layerzerolabs/lz-evm-protocol-v2/=lib/OAppAuth/lib/LayerZero-V2/packages/layerzero-v2/evm/protocol/",
      "@layerzerolabs/oapp-evm/=lib/OAppAuth/lib/devtools/packages/oapp-evm/",
      "@lz-oapp-evm/=lib/OAppAuth/lib/LayerZero-V2/packages/layerzero-v2/evm/oapp/contracts/oapp/",
      "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
      "LayerZero-V2/=lib/OAppAuth/lib/",
      "LayerZero-v2/=lib/LayerZero-v2/",
      "OAppAuth/=lib/OAppAuth/",
      "ccip/=lib/ccip/contracts/",
      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      "forge-std/=lib/forge-std/src/",
      "halmos-cheatcodes/=lib/OAppAuth/lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/",
      "solidity-bytes-utils/=lib/OAppAuth/node_modules/solidity-bytes-utils/",
      "solmate/=lib/solmate/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "evmVersion": "shanghai",
    "viaIR": false,
    "libraries": {}
  }
}}