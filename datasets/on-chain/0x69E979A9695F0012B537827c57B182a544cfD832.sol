{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "istanbul",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMathUpgradeable {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"../../math/SafeMathUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using SafeMathUpgradeable for uint256;\n    using AddressUpgradeable for address;\n\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint256(_at(set._inner, index)));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "src/Controller.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/EnumerableSetUpgradeable.sol\";\n\nimport \"./interface/IController.sol\";\nimport \"./interface/IPriceOracle.sol\";\nimport \"./interface/IiToken.sol\";\nimport \"./interface/IRewardDistributor.sol\";\n\nimport \"./library/Initializable.sol\";\nimport \"./library/Ownable.sol\";\nimport \"./library/SafeRatioMath.sol\";\n\nimport \"./ControllerStorage.sol\";\n\n/**\n * @title dForce's lending controller Contract\n * @author dForce\n */\ncontract Controller is\n    Initializable,\n    Ownable,\n    ControllerStorageV1,\n    IControllerV1\n{\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n    using SafeRatioMath for uint256;\n    using SafeMathUpgradeable for uint256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /**\n     * @dev Check if called by owner or pauseGuardian, and only owner can unpause\n     */\n    modifier checkPauser(bool _paused) {\n        require(\n            msg.sender == owner || (msg.sender == pauseGuardian && _paused),\n            \"Only owner and guardian can pause and only owner can unpause\"\n        );\n\n        _;\n    }\n\n    /**\n     * @notice Initializes the contract.\n     */\n    function initialize() public initializer {\n        __Ownable_init();\n    }\n\n    /*********************************/\n    /******** Security Check *********/\n    /*********************************/\n\n    /**\n     * @notice Ensure this is a Controller contract.\n     */\n    function isController() external view override returns (bool) {\n        return true;\n    }\n\n    /*********************************/\n    /******** Admin Operations *******/\n    /*********************************/\n\n    /**\n     * @notice Admin function to add iToken into supported markets\n     * Checks if the iToken already exsits\n     * Will `revert()` if any check fails\n     * @param _iToken The _iToken to add\n     * @param _collateralFactor The _collateralFactor of _iToken\n     * @param _borrowFactor The _borrowFactor of _iToken\n     * @param _supplyCapacity The _supplyCapacity of _iToken\n     * @param _distributionFactor The _distributionFactor of _iToken\n     */\n    function _addMarket(\n        address _iToken,\n        uint256 _collateralFactor,\n        uint256 _borrowFactor,\n        uint256 _supplyCapacity,\n        uint256 _borrowCapacity,\n        uint256 _distributionFactor\n    ) public virtual override onlyOwner {\n        require(IiToken(_iToken).isSupported(), \"Token is not supported\");\n\n        // Market must recognize this controller\n        require(\n            IiToken(_iToken).controller() == address(this),\n            \"Token's controller is not this one\"\n        );\n\n        // Market must not have been listed, EnumerableSet.add() will return false if it exsits\n        require(iTokens.add(_iToken), \"Token has already been listed\");\n\n        require(\n            _collateralFactor <= collateralFactorMaxMantissa,\n            \"Collateral factor invalid\"\n        );\n\n        require(\n            _borrowFactor > 0 && _borrowFactor <= borrowFactorMaxMantissa,\n            \"Borrow factor invalid\"\n        );\n\n        // Its value will be taken into account when calculate account equity\n        // Check if the price is available for the calculation\n        require(\n            IPriceOracle(priceOracle).getUnderlyingPrice(_iToken) != 0,\n            \"Underlying price is unavailable\"\n        );\n\n        markets[_iToken] = Market({\n            collateralFactorMantissa: _collateralFactor,\n            borrowFactorMantissa: _borrowFactor,\n            borrowCapacity: _borrowCapacity,\n            supplyCapacity: _supplyCapacity,\n            mintPaused: false,\n            redeemPaused: false,\n            borrowPaused: false\n        });\n\n        IRewardDistributor(rewardDistributor)._addRecipient(\n            _iToken,\n            _distributionFactor\n        );\n\n        emit MarketAdded(\n            _iToken,\n            _collateralFactor,\n            _borrowFactor,\n            _supplyCapacity,\n            _borrowCapacity,\n            _distributionFactor\n        );\n    }\n\n    /**\n     * @notice Sets price oracle\n     * @dev Admin function to set price oracle\n     * @param _newOracle New oracle contract\n     */\n    function _setPriceOracle(address _newOracle) external override onlyOwner {\n        address _oldOracle = priceOracle;\n        require(\n            _newOracle != address(0) && _newOracle != _oldOracle,\n            \"Oracle address invalid\"\n        );\n        priceOracle = _newOracle;\n        emit NewPriceOracle(_oldOracle, _newOracle);\n    }\n\n    /**\n     * @notice Sets the closeFactor used when liquidating borrows\n     * @dev Admin function to set closeFactor\n     * @param _newCloseFactorMantissa New close factor, scaled by 1e18\n     */\n    function _setCloseFactor(\n        uint256 _newCloseFactorMantissa\n    ) public virtual override onlyOwner {\n        require(\n            _newCloseFactorMantissa >= closeFactorMinMantissa &&\n                _newCloseFactorMantissa <= closeFactorMaxMantissa,\n            \"Close factor invalid\"\n        );\n\n        uint256 _oldCloseFactorMantissa = closeFactorMantissa;\n        closeFactorMantissa = _newCloseFactorMantissa;\n        emit NewCloseFactor(_oldCloseFactorMantissa, _newCloseFactorMantissa);\n    }\n\n    /**\n     * @notice Sets liquidationIncentive\n     * @dev Admin function to set liquidationIncentive\n     * @param _newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\n     */\n    function _setLiquidationIncentive(\n        uint256 _newLiquidationIncentiveMantissa\n    ) public virtual override onlyOwner {\n        require(\n            _newLiquidationIncentiveMantissa >=\n                liquidationIncentiveMinMantissa &&\n                _newLiquidationIncentiveMantissa <=\n                liquidationIncentiveMaxMantissa,\n            \"Liquidation incentive invalid\"\n        );\n\n        uint256 _oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\n        liquidationIncentiveMantissa = _newLiquidationIncentiveMantissa;\n\n        emit NewLiquidationIncentive(\n            _oldLiquidationIncentiveMantissa,\n            _newLiquidationIncentiveMantissa\n        );\n    }\n\n    /**\n     * @notice Sets the collateralFactor for a iToken\n     * @dev Admin function to set collateralFactor for a iToken\n     * @param _iToken The token to set the factor on\n     * @param _newCollateralFactorMantissa The new collateral factor, scaled by 1e18\n     */\n    function _setCollateralFactor(\n        address _iToken,\n        uint256 _newCollateralFactorMantissa\n    ) public virtual override onlyOwner {\n        _checkiTokenListed(_iToken);\n\n        require(\n            _newCollateralFactorMantissa <= collateralFactorMaxMantissa,\n            \"Collateral factor invalid\"\n        );\n\n        // Its value will be taken into account when calculate account equity\n        // Check if the price is available for the calculation\n        require(\n            IPriceOracle(priceOracle).getUnderlyingPrice(_iToken) != 0,\n            \"Failed to set collateral factor, underlying price is unavailable\"\n        );\n\n        Market storage _market = markets[_iToken];\n        uint256 _oldCollateralFactorMantissa = _market.collateralFactorMantissa;\n        _market.collateralFactorMantissa = _newCollateralFactorMantissa;\n\n        emit NewCollateralFactor(\n            _iToken,\n            _oldCollateralFactorMantissa,\n            _newCollateralFactorMantissa\n        );\n    }\n\n    /**\n     * @notice Sets the borrowFactor for a iToken\n     * @dev Admin function to set borrowFactor for a iToken\n     * @param _iToken The token to set the factor on\n     * @param _newBorrowFactorMantissa The new borrow factor, scaled by 1e18\n     */\n    function _setBorrowFactor(\n        address _iToken,\n        uint256 _newBorrowFactorMantissa\n    ) external override onlyOwner {\n        _checkiTokenListed(_iToken);\n\n        require(\n            _newBorrowFactorMantissa > 0 &&\n                _newBorrowFactorMantissa <= borrowFactorMaxMantissa,\n            \"Borrow factor invalid\"\n        );\n\n        // Its value will be taken into account when calculate account equity\n        // Check if the price is available for the calculation\n        require(\n            IPriceOracle(priceOracle).getUnderlyingPrice(_iToken) != 0,\n            \"Failed to set borrow factor, underlying price is unavailable\"\n        );\n\n        Market storage _market = markets[_iToken];\n        uint256 _oldBorrowFactorMantissa = _market.borrowFactorMantissa;\n        _market.borrowFactorMantissa = _newBorrowFactorMantissa;\n\n        emit NewBorrowFactor(\n            _iToken,\n            _oldBorrowFactorMantissa,\n            _newBorrowFactorMantissa\n        );\n    }\n\n    /**\n     * @notice Sets the borrowCapacity for a iToken\n     * @dev Admin function to set borrowCapacity for a iToken\n     * @param _iToken The token to set the capacity on\n     * @param _newBorrowCapacity The new borrow capacity\n     */\n    function _setBorrowCapacity(\n        address _iToken,\n        uint256 _newBorrowCapacity\n    ) external override onlyOwner {\n        _checkiTokenListed(_iToken);\n\n        Market storage _market = markets[_iToken];\n        uint256 oldBorrowCapacity = _market.borrowCapacity;\n        _market.borrowCapacity = _newBorrowCapacity;\n\n        emit NewBorrowCapacity(_iToken, oldBorrowCapacity, _newBorrowCapacity);\n    }\n\n    /**\n     * @notice Sets the supplyCapacity for a iToken\n     * @dev Admin function to set supplyCapacity for a iToken\n     * @param _iToken The token to set the capacity on\n     * @param _newSupplyCapacity The new supply capacity\n     */\n    function _setSupplyCapacity(\n        address _iToken,\n        uint256 _newSupplyCapacity\n    ) external override onlyOwner {\n        _checkiTokenListed(_iToken);\n\n        Market storage _market = markets[_iToken];\n        uint256 oldSupplyCapacity = _market.supplyCapacity;\n        _market.supplyCapacity = _newSupplyCapacity;\n\n        emit NewSupplyCapacity(_iToken, oldSupplyCapacity, _newSupplyCapacity);\n    }\n\n    /**\n     * @notice Sets the pauseGuardian\n     * @dev Admin function to set pauseGuardian\n     * @param _newPauseGuardian The new pause guardian\n     */\n    function _setPauseGuardian(\n        address _newPauseGuardian\n    ) external override onlyOwner {\n        address _oldPauseGuardian = pauseGuardian;\n\n        require(\n            _newPauseGuardian != address(0) &&\n                _newPauseGuardian != _oldPauseGuardian,\n            \"Pause guardian address invalid\"\n        );\n\n        pauseGuardian = _newPauseGuardian;\n\n        emit NewPauseGuardian(_oldPauseGuardian, _newPauseGuardian);\n    }\n\n    /**\n     * @notice pause/unpause mint() for all iTokens\n     * @dev Admin function, only owner and pauseGuardian can call this\n     * @param _paused whether to pause or unpause\n     */\n    function _setAllMintPaused(\n        bool _paused\n    ) external override checkPauser(_paused) {\n        EnumerableSetUpgradeable.AddressSet storage _iTokens = iTokens;\n        uint256 _len = _iTokens.length();\n\n        for (uint256 i = 0; i < _len; i++) {\n            _setMintPausedInternal(_iTokens.at(i), _paused);\n        }\n    }\n\n    /**\n     * @notice pause/unpause mint() for the iToken\n     * @dev Admin function, only owner and pauseGuardian can call this\n     * @param _iToken The iToken to pause/unpause\n     * @param _paused whether to pause or unpause\n     */\n    function _setMintPaused(\n        address _iToken,\n        bool _paused\n    ) external override checkPauser(_paused) {\n        _checkiTokenListed(_iToken);\n\n        _setMintPausedInternal(_iToken, _paused);\n    }\n\n    function _setMintPausedInternal(address _iToken, bool _paused) internal {\n        markets[_iToken].mintPaused = _paused;\n        emit MintPaused(_iToken, _paused);\n    }\n\n    /**\n     * @notice pause/unpause redeem() for all iTokens\n     * @dev Admin function, only owner and pauseGuardian can call this\n     * @param _paused whether to pause or unpause\n     */\n    function _setAllRedeemPaused(\n        bool _paused\n    ) external override checkPauser(_paused) {\n        EnumerableSetUpgradeable.AddressSet storage _iTokens = iTokens;\n        uint256 _len = _iTokens.length();\n\n        for (uint256 i = 0; i < _len; i++) {\n            _setRedeemPausedInternal(_iTokens.at(i), _paused);\n        }\n    }\n\n    /**\n     * @notice pause/unpause redeem() for the iToken\n     * @dev Admin function, only owner and pauseGuardian can call this\n     * @param _iToken The iToken to pause/unpause\n     * @param _paused whether to pause or unpause\n     */\n    function _setRedeemPaused(\n        address _iToken,\n        bool _paused\n    ) external override checkPauser(_paused) {\n        _checkiTokenListed(_iToken);\n\n        _setRedeemPausedInternal(_iToken, _paused);\n    }\n\n    function _setRedeemPausedInternal(address _iToken, bool _paused) internal {\n        markets[_iToken].redeemPaused = _paused;\n        emit RedeemPaused(_iToken, _paused);\n    }\n\n    /**\n     * @notice pause/unpause borrow() for all iTokens\n     * @dev Admin function, only owner and pauseGuardian can call this\n     * @param _paused whether to pause or unpause\n     */\n    function _setAllBorrowPaused(\n        bool _paused\n    ) external override checkPauser(_paused) {\n        EnumerableSetUpgradeable.AddressSet storage _iTokens = iTokens;\n        uint256 _len = _iTokens.length();\n\n        for (uint256 i = 0; i < _len; i++) {\n            _setBorrowPausedInternal(_iTokens.at(i), _paused);\n        }\n    }\n\n    /**\n     * @notice pause/unpause borrow() for the iToken\n     * @dev Admin function, only owner and pauseGuardian can call this\n     * @param _iToken The iToken to pause/unpause\n     * @param _paused whether to pause or unpause\n     */\n    function _setBorrowPaused(\n        address _iToken,\n        bool _paused\n    ) external override checkPauser(_paused) {\n        _checkiTokenListed(_iToken);\n\n        _setBorrowPausedInternal(_iToken, _paused);\n    }\n\n    function _setBorrowPausedInternal(address _iToken, bool _paused) internal {\n        markets[_iToken].borrowPaused = _paused;\n        emit BorrowPaused(_iToken, _paused);\n    }\n\n    /**\n     * @notice pause/unpause global transfer()\n     * @dev Admin function, only owner and pauseGuardian can call this\n     * @param _paused whether to pause or unpause\n     */\n    function _setTransferPaused(\n        bool _paused\n    ) external override checkPauser(_paused) {\n        _setTransferPausedInternal(_paused);\n    }\n\n    function _setTransferPausedInternal(bool _paused) internal {\n        transferPaused = _paused;\n        emit TransferPaused(_paused);\n    }\n\n    /**\n     * @notice pause/unpause global seize()\n     * @dev Admin function, only owner and pauseGuardian can call this\n     * @param _paused whether to pause or unpause\n     */\n    function _setSeizePaused(\n        bool _paused\n    ) external override checkPauser(_paused) {\n        _setSeizePausedInternal(_paused);\n    }\n\n    function _setSeizePausedInternal(bool _paused) internal {\n        seizePaused = _paused;\n        emit SeizePaused(_paused);\n    }\n\n    /**\n     * @notice pause/unpause all actions iToken, including mint/redeem/borrow\n     * @dev Admin function, only owner and pauseGuardian can call this\n     * @param _paused whether to pause or unpause\n     */\n    function _setiTokenPaused(\n        address _iToken,\n        bool _paused\n    ) external override checkPauser(_paused) {\n        _checkiTokenListed(_iToken);\n\n        _setiTokenPausedInternal(_iToken, _paused);\n    }\n\n    function _setiTokenPausedInternal(address _iToken, bool _paused) internal {\n        Market storage _market = markets[_iToken];\n\n        _market.mintPaused = _paused;\n        emit MintPaused(_iToken, _paused);\n\n        _market.redeemPaused = _paused;\n        emit RedeemPaused(_iToken, _paused);\n\n        _market.borrowPaused = _paused;\n        emit BorrowPaused(_iToken, _paused);\n    }\n\n    /**\n     * @notice pause/unpause entire protocol, including mint/redeem/borrow/seize/transfer\n     * @dev Admin function, only owner and pauseGuardian can call this\n     * @param _paused whether to pause or unpause\n     */\n    function _setProtocolPaused(\n        bool _paused\n    ) external override checkPauser(_paused) {\n        EnumerableSetUpgradeable.AddressSet storage _iTokens = iTokens;\n        uint256 _len = _iTokens.length();\n\n        for (uint256 i = 0; i < _len; i++) {\n            address _iToken = _iTokens.at(i);\n\n            _setiTokenPausedInternal(_iToken, _paused);\n        }\n\n        _setTransferPausedInternal(_paused);\n        _setSeizePausedInternal(_paused);\n    }\n\n    /**\n     * @notice Sets Reward Distributor\n     * @dev Admin function to set reward distributor\n     * @param _newRewardDistributor new reward distributor\n     */\n    function _setRewardDistributor(\n        address _newRewardDistributor\n    ) external override onlyOwner {\n        address _oldRewardDistributor = rewardDistributor;\n\n        require(\n            _oldRewardDistributor == address(0),\n            \"Reward Distributor cannot be replaced!\"\n        );\n        require(\n            IRewardDistributor(_newRewardDistributor).isRewardDistributor() &&\n                IRewardDistributor(_newRewardDistributor).controller() == this,\n            \"_newRewardDistributor is invalid or its controller mismatch!\"\n        );\n\n        rewardDistributor = _newRewardDistributor;\n        emit NewRewardDistributor(_oldRewardDistributor, _newRewardDistributor);\n    }\n\n    /*********************************/\n    /******** Policy Hooks **********/\n    /*********************************/\n\n    /**\n     * @notice Hook function before iToken `mint()`\n     * Checks if the account should be allowed to mint the given iToken\n     * Will `revert()` if any check fails\n     * @param _iToken The iToken to check the mint against\n     * @param _minter The account which would get the minted tokens\n     * @param _mintAmount The amount of underlying being minted to iToken\n     */\n    function beforeMint(\n        address _iToken,\n        address _minter,\n        uint256 _mintAmount\n    ) external override {\n        _checkiTokenListed(_iToken);\n\n        Market storage _market = markets[_iToken];\n        require(!_market.mintPaused, \"Token mint has been paused\");\n\n        // Check the iToken's supply capacity, -1 means no limit\n        uint256 _totalSupplyUnderlying = IERC20Upgradeable(_iToken)\n            .totalSupply()\n            .rmul(IiToken(_iToken).exchangeRateStored());\n        require(\n            _totalSupplyUnderlying.add(_mintAmount) <= _market.supplyCapacity,\n            \"Token supply capacity reached\"\n        );\n\n        // Update the Reward Distribution Supply state and distribute reward to suppplier\n        IRewardDistributor(rewardDistributor).updateDistributionState(\n            _iToken,\n            false\n        );\n        IRewardDistributor(rewardDistributor).updateReward(\n            _iToken,\n            _minter,\n            false\n        );\n    }\n\n    /**\n     * @notice Hook function after iToken `mint()`\n     * Will `revert()` if any operation fails\n     * @param _iToken The iToken being minted\n     * @param _minter The account which would get the minted tokens\n     * @param _mintAmount The amount of underlying being minted to iToken\n     * @param _mintedAmount The amount of iToken being minted\n     */\n    function afterMint(\n        address _iToken,\n        address _minter,\n        uint256 _mintAmount,\n        uint256 _mintedAmount\n    ) external override {\n        _iToken;\n        _minter;\n        _mintAmount;\n        _mintedAmount;\n    }\n\n    /**\n     * @notice Hook function before iToken `redeem()`\n     * Checks if the account should be allowed to redeem the given iToken\n     * Will `revert()` if any check fails\n     * @param _iToken The iToken to check the redeem against\n     * @param _redeemer The account which would redeem iToken\n     * @param _redeemAmount The amount of iToken to redeem\n     */\n    function beforeRedeem(\n        address _iToken,\n        address _redeemer,\n        uint256 _redeemAmount\n    ) external virtual override {\n        // _redeemAllowed below will check whether _iToken is listed\n\n        require(!markets[_iToken].redeemPaused, \"Token redeem has been paused\");\n\n        _redeemAllowed(_iToken, _redeemer, _redeemAmount);\n\n        // Update the Reward Distribution Supply state and distribute reward to suppplier\n        IRewardDistributor(rewardDistributor).updateDistributionState(\n            _iToken,\n            false\n        );\n        IRewardDistributor(rewardDistributor).updateReward(\n            _iToken,\n            _redeemer,\n            false\n        );\n    }\n\n    /**\n     * @notice Hook function after iToken `redeem()`\n     * Will `revert()` if any operation fails\n     * @param _iToken The iToken being redeemed\n     * @param _redeemer The account which redeemed iToken\n     * @param _redeemAmount  The amount of iToken being redeemed\n     * @param _redeemedUnderlying The amount of underlying being redeemed\n     */\n    function afterRedeem(\n        address _iToken,\n        address _redeemer,\n        uint256 _redeemAmount,\n        uint256 _redeemedUnderlying\n    ) external virtual override {\n        _iToken;\n        _redeemer;\n        _redeemAmount;\n        _redeemedUnderlying;\n    }\n\n    /**\n     * @notice Hook function before iToken `borrow()`\n     * Checks if the account should be allowed to borrow the given iToken\n     * Will `revert()` if any check fails\n     * @param _iToken The iToken to check the borrow against\n     * @param _borrower The account which would borrow iToken\n     * @param _borrowAmount The amount of underlying to borrow\n     */\n    function beforeBorrow(\n        address _iToken,\n        address _borrower,\n        uint256 _borrowAmount\n    ) public virtual override {\n        _checkiTokenListed(_iToken);\n\n        Market storage _market = markets[_iToken];\n        require(!_market.borrowPaused, \"Token borrow has been paused\");\n\n        if (!hasBorrowed(_borrower, _iToken)) {\n            // Unlike collaterals, borrowed asset can only be added by iToken,\n            // rather than enabled by user directly.\n            require(msg.sender == _iToken, \"sender must be iToken\");\n\n            // Have checked _iToken is listed, just add it\n            _addToBorrowed(_borrower, _iToken);\n        }\n\n        // Check borrower's equity\n        (, uint256 _shortfall, , ) = calcAccountEquityWithEffect(\n            _borrower,\n            _iToken,\n            0,\n            _borrowAmount\n        );\n\n        require(_shortfall == 0, \"Account has some shortfall\");\n\n        // Check the iToken's borrow capacity, -1 means no limit\n        uint256 _totalBorrows = IiToken(_iToken).totalBorrows();\n        require(\n            _totalBorrows.add(_borrowAmount) <= _market.borrowCapacity,\n            \"Token borrow capacity reached\"\n        );\n\n        // Update the Reward Distribution Borrow state and distribute reward to borrower\n        IRewardDistributor(rewardDistributor).updateDistributionState(\n            _iToken,\n            true\n        );\n        IRewardDistributor(rewardDistributor).updateReward(\n            _iToken,\n            _borrower,\n            true\n        );\n    }\n\n    /**\n     * @notice Hook function after iToken `borrow()`\n     * Will `revert()` if any operation fails\n     * @param _iToken The iToken being borrewd\n     * @param _borrower The account which borrowed iToken\n     * @param _borrowedAmount  The amount of underlying being borrowed\n     */\n    function afterBorrow(\n        address _iToken,\n        address _borrower,\n        uint256 _borrowedAmount\n    ) external virtual override {\n        _iToken;\n        _borrower;\n        _borrowedAmount;\n    }\n\n    /**\n     * @notice Hook function before iToken `repayBorrow()`\n     * Checks if the account should be allowed to repay the given iToken\n     * for the borrower. Will `revert()` if any check fails\n     * @param _iToken The iToken to verify the repay against\n     * @param _payer The account which would repay iToken\n     * @param _borrower The account which has borrowed\n     * @param _repayAmount The amount of underlying to repay\n     */\n    function beforeRepayBorrow(\n        address _iToken,\n        address _payer,\n        address _borrower,\n        uint256 _repayAmount\n    ) public override {\n        _checkiTokenListed(_iToken);\n\n        // Update the Reward Distribution Borrow state and distribute reward to borrower\n        IRewardDistributor(rewardDistributor).updateDistributionState(\n            _iToken,\n            true\n        );\n        IRewardDistributor(rewardDistributor).updateReward(\n            _iToken,\n            _borrower,\n            true\n        );\n\n        _payer;\n        _repayAmount;\n    }\n\n    /**\n     * @notice Hook function after iToken `repayBorrow()`\n     * Will `revert()` if any operation fails\n     * @param _iToken The iToken being repaid\n     * @param _payer The account which would repay\n     * @param _borrower The account which has borrowed\n     * @param _repayAmount  The amount of underlying being repaied\n     */\n    function afterRepayBorrow(\n        address _iToken,\n        address _payer,\n        address _borrower,\n        uint256 _repayAmount\n    ) public virtual override {\n        _checkiTokenListed(_iToken);\n\n        // Remove _iToken from borrowed list if new borrow balance is 0\n        if (IiToken(_iToken).borrowBalanceStored(_borrower) == 0) {\n            // Only allow called by iToken as we are going to remove this token from borrower's borrowed list\n            require(msg.sender == _iToken, \"sender must be iToken\");\n\n            // Have checked _iToken is listed, just remove it\n            _removeFromBorrowed(_borrower, _iToken);\n        }\n\n        _payer;\n        _repayAmount;\n    }\n\n    /**\n     * @notice Hook function before iToken `liquidateBorrow()`\n     * Checks if the account should be allowed to liquidate the given iToken\n     * for the borrower. Will `revert()` if any check fails\n     * @param _iTokenBorrowed The iToken was borrowed\n     * @param _iTokenCollateral The collateral iToken to be liqudate with\n     * @param _liquidator The account which would repay the borrowed iToken\n     * @param _borrower The account which has borrowed\n     * @param _repayAmount The amount of underlying to repay\n     */\n    function beforeLiquidateBorrow(\n        address _iTokenBorrowed,\n        address _iTokenCollateral,\n        address _liquidator,\n        address _borrower,\n        uint256 _repayAmount\n    ) external virtual override {\n        // Tokens must have been listed\n        require(\n            iTokens.contains(_iTokenBorrowed) &&\n                iTokens.contains(_iTokenCollateral),\n            \"Tokens have not been listed\"\n        );\n\n        (, uint256 _shortfall, , ) = calcAccountEquity(_borrower);\n\n        require(_shortfall > 0, \"Account does not have shortfall\");\n\n        // Only allowed to repay the borrow balance's close factor\n        uint256 _borrowBalance = IiToken(_iTokenBorrowed).borrowBalanceStored(\n            _borrower\n        );\n        uint256 _maxRepay = _borrowBalance.rmul(closeFactorMantissa);\n\n        require(_repayAmount <= _maxRepay, \"Repay exceeds max repay allowed\");\n\n        _liquidator;\n    }\n\n    /**\n     * @notice Hook function after iToken `liquidateBorrow()`\n     * Will `revert()` if any operation fails\n     * @param _iTokenBorrowed The iToken was borrowed\n     * @param _iTokenCollateral The collateral iToken to be seized\n     * @param _liquidator The account which would repay and seize\n     * @param _borrower The account which has borrowed\n     * @param _repaidAmount  The amount of underlying being repaied\n     * @param _seizedAmount  The amount of collateral being seized\n     */\n    function afterLiquidateBorrow(\n        address _iTokenBorrowed,\n        address _iTokenCollateral,\n        address _liquidator,\n        address _borrower,\n        uint256 _repaidAmount,\n        uint256 _seizedAmount\n    ) external override {\n        _iTokenBorrowed;\n        _iTokenCollateral;\n        _liquidator;\n        _borrower;\n        _repaidAmount;\n        _seizedAmount;\n\n        // Unlike repayBorrow, liquidateBorrow does not allow to repay all borrow balance\n        // No need to check whether should remove from borrowed asset list\n    }\n\n    /**\n     * @notice Hook function before iToken `seize()`\n     * Checks if the liquidator should be allowed to seize the collateral iToken\n     * Will `revert()` if any check fails\n     * @param _iTokenCollateral The collateral iToken to be seize\n     * @param _iTokenBorrowed The iToken was borrowed\n     * @param _liquidator The account which has repaid the borrowed iToken\n     * @param _borrower The account which has borrowed\n     * @param _seizeAmount The amount of collateral iToken to seize\n     */\n    function beforeSeize(\n        address _iTokenCollateral,\n        address _iTokenBorrowed,\n        address _liquidator,\n        address _borrower,\n        uint256 _seizeAmount\n    ) external override {\n        require(!seizePaused, \"Seize has been paused\");\n\n        // Markets must have been listed\n        require(\n            iTokens.contains(_iTokenBorrowed) &&\n                iTokens.contains(_iTokenCollateral),\n            \"Tokens have not been listed\"\n        );\n\n        // Sanity Check the controllers\n        require(\n            IiToken(_iTokenBorrowed).controller() ==\n                IiToken(_iTokenCollateral).controller(),\n            \"Controller mismatch between Borrowed and Collateral\"\n        );\n\n        // Update the Reward Distribution Supply state on collateral\n        IRewardDistributor(rewardDistributor).updateDistributionState(\n            _iTokenCollateral,\n            false\n        );\n\n        // Update reward of liquidator and borrower on collateral\n        IRewardDistributor(rewardDistributor).updateReward(\n            _iTokenCollateral,\n            _liquidator,\n            false\n        );\n        IRewardDistributor(rewardDistributor).updateReward(\n            _iTokenCollateral,\n            _borrower,\n            false\n        );\n\n        _seizeAmount;\n    }\n\n    /**\n     * @notice Hook function after iToken `seize()`\n     * Will `revert()` if any operation fails\n     * @param _iTokenCollateral The collateral iToken to be seized\n     * @param _iTokenBorrowed The iToken was borrowed\n     * @param _liquidator The account which has repaid and seized\n     * @param _borrower The account which has borrowed\n     * @param _seizedAmount  The amount of collateral being seized\n     */\n    function afterSeize(\n        address _iTokenCollateral,\n        address _iTokenBorrowed,\n        address _liquidator,\n        address _borrower,\n        uint256 _seizedAmount\n    ) external override {\n        _iTokenBorrowed;\n        _iTokenCollateral;\n        _liquidator;\n        _borrower;\n        _seizedAmount;\n    }\n\n    /**\n     * @notice Hook function before iToken `transfer()`\n     * Checks if the transfer should be allowed\n     * Will `revert()` if any check fails\n     * @param _iToken The iToken to be transfered\n     * @param _from The account to be transfered from\n     * @param _to The account to be transfered to\n     * @param _amount The amount to be transfered\n     */\n    function beforeTransfer(\n        address _iToken,\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external override {\n        // _redeemAllowed below will check whether _iToken is listed\n\n        require(!transferPaused, \"Transfer has been paused\");\n\n        // Check account equity with this amount to decide whether the transfer is allowed\n        _redeemAllowed(_iToken, _from, _amount);\n\n        // Update the Reward Distribution supply state\n        IRewardDistributor(rewardDistributor).updateDistributionState(\n            _iToken,\n            false\n        );\n\n        // Update reward of from and to\n        IRewardDistributor(rewardDistributor).updateReward(\n            _iToken,\n            _from,\n            false\n        );\n        IRewardDistributor(rewardDistributor).updateReward(_iToken, _to, false);\n    }\n\n    /**\n     * @notice Hook function after iToken `transfer()`\n     * Will `revert()` if any operation fails\n     * @param _iToken The iToken was transfered\n     * @param _from The account was transfer from\n     * @param _to The account was transfer to\n     * @param _amount  The amount was transfered\n     */\n    function afterTransfer(\n        address _iToken,\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external override {\n        _iToken;\n        _from;\n        _to;\n        _amount;\n    }\n\n    /**\n     * @notice Hook function before iToken `flashloan()`\n     * Checks if the flashloan should be allowed\n     * Will `revert()` if any check fails\n     * @param _iToken The iToken to be flashloaned\n     * @param _to The account flashloaned transfer to\n     * @param _amount The amount to be flashloaned\n     */\n    function beforeFlashloan(\n        address _iToken,\n        address _to,\n        uint256 _amount\n    ) external override {\n        // Flashloan share the same pause state with borrow\n        require(!markets[_iToken].borrowPaused, \"Token borrow has been paused\");\n\n        _checkiTokenListed(_iToken);\n\n        _to;\n        _amount;\n\n        // Update the Reward Distribution Borrow state\n        IRewardDistributor(rewardDistributor).updateDistributionState(\n            _iToken,\n            true\n        );\n    }\n\n    /**\n     * @notice Hook function after iToken `flashloan()`\n     * Will `revert()` if any operation fails\n     * @param _iToken The iToken was flashloaned\n     * @param _to The account flashloan transfer to\n     * @param _amount  The amount was flashloaned\n     */\n    function afterFlashloan(\n        address _iToken,\n        address _to,\n        uint256 _amount\n    ) external override {\n        _iToken;\n        _to;\n        _amount;\n    }\n\n    /*********************************/\n    /***** Internal  Functions *******/\n    /*********************************/\n\n    function _redeemAllowed(\n        address _iToken,\n        address _redeemer,\n        uint256 _amount\n    ) private view {\n        _checkiTokenListed(_iToken);\n\n        // No need to check liquidity if _redeemer has not used _iToken as collateral\n        if (!accountsData[_redeemer].collaterals.contains(_iToken)) {\n            return;\n        }\n\n        (, uint256 _shortfall, , ) = calcAccountEquityWithEffect(\n            _redeemer,\n            _iToken,\n            _amount,\n            0\n        );\n\n        require(_shortfall == 0, \"Account has some shortfall\");\n    }\n\n    /**\n     * @dev Check if _iToken is listed\n     */\n    function _checkiTokenListed(address _iToken) internal view {\n        require(iTokens.contains(_iToken), \"Token has not been listed\");\n    }\n\n    /*********************************/\n    /** Account equity calculation ***/\n    /*********************************/\n\n    /**\n     * @notice Calculates current account equity\n     * @param _account The account to query equity of\n     * @return account equity, shortfall, collateral value, borrowed value.\n     */\n    function calcAccountEquity(\n        address _account\n    ) public view override returns (uint256, uint256, uint256, uint256) {\n        return calcAccountEquityWithEffect(_account, address(0), 0, 0);\n    }\n\n    /**\n     * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\n     *  Note that `iTokenBalance` is the number of iTokens the account owns in the collateral,\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\n     */\n    struct AccountEquityLocalVars {\n        uint256 sumCollateral;\n        uint256 sumBorrowed;\n        uint256 iTokenBalance;\n        uint256 borrowBalance;\n        uint256 exchangeRateMantissa;\n        uint256 underlyingPrice;\n        uint256 collateralValue;\n        uint256 borrowValue;\n    }\n\n    /**\n     * @notice Calculates current account equity plus some token and amount to effect\n     * @param _account The account to query equity of\n     * @param _tokenToEffect The token address to add some additional redeeem/borrow\n     * @param _redeemAmount The additional amount to redeem\n     * @param _borrowAmount The additional amount to borrow\n     * @return account euqity, shortfall, collateral value, borrowed value plus the effect.\n     */\n    function calcAccountEquityWithEffect(\n        address _account,\n        address _tokenToEffect,\n        uint256 _redeemAmount,\n        uint256 _borrowAmount\n    ) internal view virtual returns (uint256, uint256, uint256, uint256) {\n        AccountEquityLocalVars memory _local;\n        AccountData storage _accountData = accountsData[_account];\n\n        // Calculate value of all collaterals\n        // collateralValuePerToken = underlyingPrice * exchangeRate * collateralFactor\n        // collateralValue = balance * collateralValuePerToken\n        // sumCollateral += collateralValue\n        uint256 _len = _accountData.collaterals.length();\n        for (uint256 i = 0; i < _len; i++) {\n            IiToken _token = IiToken(_accountData.collaterals.at(i));\n\n            _local.iTokenBalance = IERC20Upgradeable(address(_token)).balanceOf(\n                _account\n            );\n            _local.exchangeRateMantissa = _token.exchangeRateStored();\n\n            if (_tokenToEffect == address(_token) && _redeemAmount > 0) {\n                _local.iTokenBalance = _local.iTokenBalance.sub(_redeemAmount);\n            }\n\n            _local.underlyingPrice = IPriceOracle(priceOracle)\n                .getUnderlyingPrice(address(_token));\n\n            require(\n                _local.underlyingPrice != 0,\n                \"Invalid price to calculate account equity\"\n            );\n\n            _local.collateralValue = _local\n                .iTokenBalance\n                .mul(_local.underlyingPrice)\n                .rmul(_local.exchangeRateMantissa)\n                .rmul(markets[address(_token)].collateralFactorMantissa);\n\n            _local.sumCollateral = _local.sumCollateral.add(\n                _local.collateralValue\n            );\n        }\n\n        // Calculate all borrowed value\n        // borrowValue = underlyingPrice * underlyingBorrowed / borrowFactor\n        // sumBorrowed += borrowValue\n        _len = _accountData.borrowed.length();\n        for (uint256 i = 0; i < _len; i++) {\n            IiToken _token = IiToken(_accountData.borrowed.at(i));\n\n            _local.borrowBalance = _token.borrowBalanceStored(_account);\n\n            if (_tokenToEffect == address(_token) && _borrowAmount > 0) {\n                _local.borrowBalance = _local.borrowBalance.add(_borrowAmount);\n            }\n\n            _local.underlyingPrice = IPriceOracle(priceOracle)\n                .getUnderlyingPrice(address(_token));\n\n            require(\n                _local.underlyingPrice != 0,\n                \"Invalid price to calculate account equity\"\n            );\n\n            // borrowFactorMantissa can not be set to 0\n            _local.borrowValue = _local\n                .borrowBalance\n                .mul(_local.underlyingPrice)\n                .rdiv(markets[address(_token)].borrowFactorMantissa);\n\n            _local.sumBorrowed = _local.sumBorrowed.add(_local.borrowValue);\n        }\n\n        // Should never underflow\n        return\n            _local.sumCollateral > _local.sumBorrowed\n                ? (\n                    _local.sumCollateral - _local.sumBorrowed,\n                    uint256(0),\n                    _local.sumCollateral,\n                    _local.sumBorrowed\n                )\n                : (\n                    uint256(0),\n                    _local.sumBorrowed - _local.sumCollateral,\n                    _local.sumCollateral,\n                    _local.sumBorrowed\n                );\n    }\n\n    /**\n     * @notice Calculate amount of collateral iToken to seize after repaying an underlying amount\n     * @dev Used in liquidation\n     * @param _iTokenBorrowed The iToken was borrowed\n     * @param _iTokenCollateral The collateral iToken to be seized\n     * @param _actualRepayAmount The amount of underlying token liquidator has repaied\n     * @return _seizedTokenCollateral amount of iTokenCollateral tokens to be seized\n     */\n    function liquidateCalculateSeizeTokens(\n        address _iTokenBorrowed,\n        address _iTokenCollateral,\n        uint256 _actualRepayAmount\n    ) external view virtual override returns (uint256 _seizedTokenCollateral) {\n        /* Read oracle prices for borrowed and collateral assets */\n        uint256 _priceBorrowed = IPriceOracle(priceOracle).getUnderlyingPrice(\n            _iTokenBorrowed\n        );\n        uint256 _priceCollateral = IPriceOracle(priceOracle).getUnderlyingPrice(\n            _iTokenCollateral\n        );\n        require(\n            _priceBorrowed != 0 && _priceCollateral != 0,\n            \"Borrowed or Collateral asset price is invalid\"\n        );\n\n        uint256 _valueRepayPlusIncentive = _actualRepayAmount\n            .mul(_priceBorrowed)\n            .rmul(liquidationIncentiveMantissa);\n\n        // Use stored value here as it is view function\n        uint256 _exchangeRateMantissa = IiToken(_iTokenCollateral)\n            .exchangeRateStored();\n\n        // seizedTokenCollateral = valueRepayPlusIncentive / valuePerTokenCollateral\n        // valuePerTokenCollateral = exchangeRateMantissa * priceCollateral\n        _seizedTokenCollateral = _valueRepayPlusIncentive\n            .rdiv(_exchangeRateMantissa)\n            .div(_priceCollateral);\n    }\n\n    /*********************************/\n    /*** Account Markets Operation ***/\n    /*********************************/\n\n    /**\n     * @notice Returns the markets list the account has entered\n     * @param _account The address of the account to query\n     * @return _accountCollaterals The markets list the account has entered\n     */\n    function getEnteredMarkets(\n        address _account\n    ) external view override returns (address[] memory _accountCollaterals) {\n        AccountData storage _accountData = accountsData[_account];\n\n        uint256 _len = _accountData.collaterals.length();\n        _accountCollaterals = new address[](_len);\n        for (uint256 i = 0; i < _len; i++) {\n            _accountCollaterals[i] = _accountData.collaterals.at(i);\n        }\n    }\n\n    /**\n     * @notice Add markets to `msg.sender`'s markets list for liquidity calculations\n     * @param _iTokens The list of addresses of the iToken markets to be entered\n     * @return _results Success indicator for whether each corresponding market was entered\n     */\n    function enterMarkets(\n        address[] calldata _iTokens\n    ) external override returns (bool[] memory _results) {\n        uint256 _len = _iTokens.length;\n\n        _results = new bool[](_len);\n        for (uint256 i = 0; i < _len; i++) {\n            _results[i] = _enterMarket(_iTokens[i], msg.sender);\n        }\n    }\n\n    /**\n     * @notice Add the market to the account's markets list for liquidity calculations\n     * @param _iToken The market to enter\n     * @param _account The address of the account to modify\n     * @return True if entered successfully, false for non-listed market or other errors\n     */\n    function _enterMarket(\n        address _iToken,\n        address _account\n    ) internal virtual returns (bool) {\n        // Market not listed, skip it\n        if (!iTokens.contains(_iToken)) {\n            return false;\n        }\n\n        // add() will return false if iToken is in account's market list\n        if (accountsData[_account].collaterals.add(_iToken)) {\n            emit MarketEntered(_iToken, _account);\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Only expect to be called by iToken contract.\n     * @dev Add the market to the account's markets list for liquidity calculations\n     * @param _market The market to enter\n     * @param _account The address of the account to modify\n     */\n    function enterMarketFromiToken(\n        address _market,\n        address _account\n    ) external override {\n        // msg.sender must be listed iToken, typically a iMSDMiniPool\n        _checkiTokenListed(msg.sender);\n\n        require(\n            _enterMarket(_market, _account),\n            \"enterMarketFromiToken: Only can enter a listed market!\"\n        );\n    }\n\n    /**\n     * @notice Returns whether the given account has entered the market\n     * @param _account The address of the account to check\n     * @param _iToken The iToken to check against\n     * @return True if the account has entered the market, otherwise false.\n     */\n    function hasEnteredMarket(\n        address _account,\n        address _iToken\n    ) external view override returns (bool) {\n        return accountsData[_account].collaterals.contains(_iToken);\n    }\n\n    /**\n     * @notice Remove markets from `msg.sender`'s collaterals for liquidity calculations\n     * @param _iTokens The list of addresses of the iToken to exit\n     * @return _results Success indicators for whether each corresponding market was exited\n     */\n    function exitMarkets(\n        address[] calldata _iTokens\n    ) external override returns (bool[] memory _results) {\n        uint256 _len = _iTokens.length;\n        _results = new bool[](_len);\n        for (uint256 i = 0; i < _len; i++) {\n            _results[i] = _exitMarket(_iTokens[i], msg.sender);\n        }\n    }\n\n    /**\n     * @notice Remove the market to the account's markets list for liquidity calculations\n     * @param _iToken The market to exit\n     * @param _account The address of the account to modify\n     * @return True if exit successfully, false for non-listed market or other errors\n     */\n    function _exitMarket(\n        address _iToken,\n        address _account\n    ) internal returns (bool) {\n        // Market not listed, skip it\n        if (!iTokens.contains(_iToken)) {\n            return false;\n        }\n\n        // Account has not entered this market, skip it\n        if (!accountsData[_account].collaterals.contains(_iToken)) {\n            return false;\n        }\n\n        // Get the iToken balance\n        uint256 _balance = IERC20Upgradeable(_iToken).balanceOf(_account);\n\n        // Check account's equity if all balance are redeemed\n        // which means iToken can be removed from collaterals\n        _redeemAllowed(_iToken, _account, _balance);\n\n        // Have checked account has entered market before\n        accountsData[_account].collaterals.remove(_iToken);\n\n        emit MarketExited(_iToken, _account);\n\n        return true;\n    }\n\n    /**\n     * @notice Returns the asset list the account has borrowed\n     * @param _account The address of the account to query\n     * @return _borrowedAssets The asset list the account has borrowed\n     */\n    function getBorrowedAssets(\n        address _account\n    ) external view override returns (address[] memory _borrowedAssets) {\n        AccountData storage _accountData = accountsData[_account];\n\n        uint256 _len = _accountData.borrowed.length();\n        _borrowedAssets = new address[](_len);\n        for (uint256 i = 0; i < _len; i++) {\n            _borrowedAssets[i] = _accountData.borrowed.at(i);\n        }\n    }\n\n    /**\n     * @notice Add the market to the account's borrowed list for equity calculations\n     * @param _iToken The iToken of underlying to borrow\n     * @param _account The address of the account to modify\n     */\n    function _addToBorrowed(address _account, address _iToken) internal {\n        // add() will return false if iToken is in account's market list\n        if (accountsData[_account].borrowed.add(_iToken)) {\n            emit BorrowedAdded(_iToken, _account);\n        }\n    }\n\n    /**\n     * @notice Returns whether the given account has borrowed the given iToken\n     * @param _account The address of the account to check\n     * @param _iToken The iToken to check against\n     * @return True if the account has borrowed the iToken, otherwise false.\n     */\n    function hasBorrowed(\n        address _account,\n        address _iToken\n    ) public view override returns (bool) {\n        return accountsData[_account].borrowed.contains(_iToken);\n    }\n\n    /**\n     * @notice Remove the iToken from the account's borrowed list\n     * @param _iToken The iToken to remove\n     * @param _account The address of the account to modify\n     */\n    function _removeFromBorrowed(address _account, address _iToken) internal {\n        // remove() will return false if iToken does not exist in account's borrowed list\n        if (accountsData[_account].borrowed.remove(_iToken)) {\n            emit BorrowedRemoved(_iToken, _account);\n        }\n    }\n\n    /*********************************/\n    /****** General Information ******/\n    /*********************************/\n\n    /**\n     * @notice Return all of the iTokens\n     * @return _alliTokens The list of iToken addresses\n     */\n    function getAlliTokens()\n        public\n        view\n        override\n        returns (address[] memory _alliTokens)\n    {\n        EnumerableSetUpgradeable.AddressSet storage _iTokens = iTokens;\n\n        uint256 _len = _iTokens.length();\n        _alliTokens = new address[](_len);\n        for (uint256 i = 0; i < _len; i++) {\n            _alliTokens[i] = _iTokens.at(i);\n        }\n    }\n\n    /**\n     * @notice Check whether a iToken is listed in controller\n     * @param _iToken The iToken to check for\n     * @return true if the iToken is listed otherwise false\n     */\n    function hasiToken(address _iToken) public view override returns (bool) {\n        return iTokens.contains(_iToken);\n    }\n}\n"
    },
    "src/ControllerStock.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./Controller.sol\";\n\n/**\n * @title dForce's lending stock controller Contract\n * @author dForce\n */\ncontract ControllerStock is Controller {\n    /**\n     * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\n     *  Note that `iTokenBalance` is the number of iTokens the account owns in the collateral,\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\n     */\n    struct AccountEquityLocalVarsV2 {\n        uint256 sumCollateral;\n        uint256 sumBorrowed;\n        uint256 iTokenBalance;\n        uint256 borrowBalance;\n        uint256 exchangeRateMantissa;\n        uint256 underlyingPrice;\n        uint256 collateralValue;\n        uint256 borrowValue;\n        bool isPriceValid;\n    }\n\n    /**\n     * @notice Calculates current account equity plus some token and amount to effect\n     * @param _account The account to query equity of\n     * @param _tokenToEffect The token address to add some additional redeeem/borrow\n     * @param _redeemAmount The additional amount to redeem\n     * @param _borrowAmount The additional amount to borrow\n     * @return account equity, shortfall, collateral value, borrowed value plus the effect.\n     */\n    function calcAccountEquityWithEffect(\n        address _account,\n        address _tokenToEffect,\n        uint256 _redeemAmount,\n        uint256 _borrowAmount\n    ) internal view override returns (uint256, uint256, uint256, uint256) {\n        AccountEquityLocalVarsV2 memory _local;\n        AccountData storage _accountData = accountsData[_account];\n\n        // Calculate value of all collaterals\n        // collateralValuePerToken = underlyingPrice * exchangeRate * collateralFactor\n        // collateralValue = balance * collateralValuePerToken\n        // sumCollateral += collateralValue\n        uint256 _len = _accountData.collaterals.length();\n        for (uint256 i = 0; i < _len; i++) {\n            IiToken _token = IiToken(_accountData.collaterals.at(i));\n\n            _local.iTokenBalance = IERC20Upgradeable(address(_token)).balanceOf(\n                _account\n            );\n            _local.exchangeRateMantissa = _token.exchangeRateStored();\n\n            if (_tokenToEffect == address(_token) && _redeemAmount > 0) {\n                _local.iTokenBalance = _local.iTokenBalance.sub(_redeemAmount);\n            }\n\n            (_local.underlyingPrice, _local.isPriceValid) = IPriceOracle(\n                priceOracle\n            ).getUnderlyingPriceAndStatus(address(_token));\n\n            require(\n                _local.underlyingPrice != 0 && _local.isPriceValid,\n                \"Invalid price to calculate account equity\"\n            );\n\n            _local.collateralValue = _local\n                .iTokenBalance\n                .mul(_local.underlyingPrice)\n                .rmul(_local.exchangeRateMantissa)\n                .rmul(markets[address(_token)].collateralFactorMantissa);\n\n            _local.sumCollateral = _local.sumCollateral.add(\n                _local.collateralValue\n            );\n        }\n\n        // Calculate all borrowed value\n        // borrowValue = underlyingPrice * underlyingBorrowed / borrowFactor\n        // sumBorrowed += borrowValue\n        _len = _accountData.borrowed.length();\n        for (uint256 i = 0; i < _len; i++) {\n            IiToken _token = IiToken(_accountData.borrowed.at(i));\n\n            _local.borrowBalance = _token.borrowBalanceStored(_account);\n\n            if (_tokenToEffect == address(_token) && _borrowAmount > 0) {\n                _local.borrowBalance = _local.borrowBalance.add(_borrowAmount);\n            }\n\n            (_local.underlyingPrice, _local.isPriceValid) = IPriceOracle(\n                priceOracle\n            ).getUnderlyingPriceAndStatus(address(_token));\n\n            require(\n                _local.underlyingPrice != 0 && _local.isPriceValid,\n                \"Invalid price to calculate account equity\"\n            );\n\n            // borrowFactorMantissa can not be set to 0\n            _local.borrowValue = _local\n                .borrowBalance\n                .mul(_local.underlyingPrice)\n                .rdiv(markets[address(_token)].borrowFactorMantissa);\n\n            _local.sumBorrowed = _local.sumBorrowed.add(_local.borrowValue);\n        }\n\n        // Should never underflow\n        return\n            _local.sumCollateral > _local.sumBorrowed\n                ? (\n                    _local.sumCollateral - _local.sumBorrowed,\n                    uint256(0),\n                    _local.sumCollateral,\n                    _local.sumBorrowed\n                )\n                : (\n                    uint256(0),\n                    _local.sumBorrowed - _local.sumCollateral,\n                    _local.sumCollateral,\n                    _local.sumBorrowed\n                );\n    }\n\n    /**\n     * @notice Calculate amount of collateral iToken to seize after repaying an underlying amount\n     * @dev Used in liquidation\n     * @param _iTokenBorrowed The iToken was borrowed\n     * @param _iTokenCollateral The collateral iToken to be seized\n     * @param _actualRepayAmount The amount of underlying token liquidator has repaied\n     * @return _seizedTokenCollateral amount of iTokenCollateral tokens to be seized\n     */\n    function liquidateCalculateSeizeTokens(\n        address _iTokenBorrowed,\n        address _iTokenCollateral,\n        uint256 _actualRepayAmount\n    ) external view override returns (uint256 _seizedTokenCollateral) {\n        /* Read oracle prices for borrowed and collateral assets */\n        (uint256 _priceBorrowed, bool _isPriceBorrowedValid) = IPriceOracle(\n            priceOracle\n        ).getUnderlyingPriceAndStatus(_iTokenBorrowed);\n        (uint256 _priceCollateral, bool _isPriceCollateralValid) = IPriceOracle(\n            priceOracle\n        ).getUnderlyingPriceAndStatus(_iTokenCollateral);\n        require(\n            _priceBorrowed != 0 &&\n                _isPriceBorrowedValid &&\n                _priceCollateral != 0 &&\n                _isPriceCollateralValid,\n            \"Borrowed or Collateral asset price is invalid\"\n        );\n\n        uint256 _valueRepayPlusIncentive = _actualRepayAmount\n            .mul(_priceBorrowed)\n            .rmul(liquidationIncentiveMantissa);\n\n        // Use stored value here as it is view function\n        uint256 _exchangeRateMantissa = IiToken(_iTokenCollateral)\n            .exchangeRateStored();\n\n        // seizedTokenCollateral = valueRepayPlusIncentive / valuePerTokenCollateral\n        // valuePerTokenCollateral = exchangeRateMantissa * priceCollateral\n        _seizedTokenCollateral = _valueRepayPlusIncentive\n            .rdiv(_exchangeRateMantissa)\n            .div(_priceCollateral);\n    }\n}\n"
    },
    "src/ControllerStorage.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/EnumerableSetUpgradeable.sol\";\n\ncontract ControllerStorageV1 {\n    /// @dev EnumerableSet of all iTokens\n    EnumerableSetUpgradeable.AddressSet internal iTokens;\n\n    struct Market {\n        /*\n         *  Multiplier representing the most one can borrow against their collateral in this market.\n         *  For instance, 0.9 to allow borrowing 90% of collateral value.\n         *  Must be in [0, 0.9], and stored as a mantissa.\n         */\n        uint256 collateralFactorMantissa;\n        /*\n         *  Multiplier representing the most one can borrow the asset.\n         *  For instance, 0.5 to allow borrowing this asset 50% * collateral value * collateralFactor.\n         *  When calculating equity, 0.5 with 100 borrow balance will produce 200 borrow value\n         *  Must be between (0, 1], and stored as a mantissa.\n         */\n        uint256 borrowFactorMantissa;\n        /*\n         *  The borrow capacity of the asset, will be checked in beforeBorrow()\n         *  -1 means there is no limit on the capacity\n         *  0 means the asset can not be borrowed any more\n         */\n        uint256 borrowCapacity;\n        /*\n         *  The supply capacity of the asset, will be checked in beforeMint()\n         *  -1 means there is no limit on the capacity\n         *  0 means the asset can not be supplied any more\n         */\n        uint256 supplyCapacity;\n        // Whether market's mint is paused\n        bool mintPaused;\n        // Whether market's redeem is paused\n        bool redeemPaused;\n        // Whether market's borrow is paused\n        bool borrowPaused;\n    }\n\n    /// @notice Mapping of iTokens to corresponding markets\n    mapping(address => Market) public markets;\n\n    struct AccountData {\n        // Account's collateral assets\n        EnumerableSetUpgradeable.AddressSet collaterals;\n        // Account's borrowed assets\n        EnumerableSetUpgradeable.AddressSet borrowed;\n    }\n\n    /// @dev Mapping of accounts' data, including collateral and borrowed assets\n    mapping(address => AccountData) internal accountsData;\n\n    /**\n     * @notice Oracle to query the price of a given asset\n     */\n    address public priceOracle;\n\n    /**\n     * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\n     */\n    uint256 public closeFactorMantissa;\n\n    // closeFactorMantissa must be strictly greater than this value\n    uint256 internal constant closeFactorMinMantissa = 0.05e18; // 0.05\n\n    // closeFactorMantissa must not exceed this value\n    uint256 internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\n\n    /**\n     * @notice Multiplier representing the discount on collateral that a liquidator receives\n     */\n    uint256 public liquidationIncentiveMantissa;\n\n    // liquidationIncentiveMantissa must be no less than this value\n    uint256 internal constant liquidationIncentiveMinMantissa = 1.0e18; // 1.0\n\n    // liquidationIncentiveMantissa must be no greater than this value\n    uint256 internal constant liquidationIncentiveMaxMantissa = 1.5e18; // 1.5\n\n    // collateralFactorMantissa must not exceed this value\n    uint256 internal constant collateralFactorMaxMantissa = 1e18; // 1.0\n\n    // borrowFactorMantissa must not exceed this value\n    uint256 internal constant borrowFactorMaxMantissa = 1e18; // 1.0\n\n    /**\n     * @notice Guardian who can pause mint/borrow/liquidate/transfer in case of emergency\n     */\n    address public pauseGuardian;\n\n    /// @notice whether global transfer is paused\n    bool public transferPaused;\n\n    /// @notice whether global seize is paused\n    bool public seizePaused;\n\n    /**\n     * @notice the address of reward distributor\n     */\n    address public rewardDistributor;\n}\n\ncontract ControllerStorageV2 is ControllerStorageV1 {\n    /**\n     * @notice the address of extra implicit implementation for v2\n     */\n    address public extraImplicit;\n    /**\n     * @notice the address of extra explicit implementation for v2\n     */\n    address public extraExplicit;\n}\n\n/*\n *  ControllerStorageV2Extra should inherit from ControllerStorageV2\n *  But it expands the `MarketV1` to `MarketV2` by expanding serveral market configuration\n *  Therefore, just copying all the storage from it.\n *  Only ControllerExtraXXX have access to the new storages regarding V2 features such as sModes etc..\n */\n\ncontract ControllerStorageV2Extra {\n    /// @dev EnumerableSet of all iTokens\n    EnumerableSetUpgradeable.AddressSet internal iTokens;\n\n    struct MarketV2 {\n        /*\n         *  Multiplier representing the most one can borrow against their collateral in this market.\n         *  For instance, 0.9 to allow borrowing 90% of collateral value.\n         *  Must be in [0, 0.9], and stored as a mantissa.\n         */\n        uint256 collateralFactorMantissa;\n        /*\n         *  Multiplier representing the most one can borrow the asset.\n         *  For instance, 0.5 to allow borrowing this asset 50% * collateral value * collateralFactor.\n         *  When calculating equity, 0.5 with 100 borrow balance will produce 200 borrow value\n         *  Must be between (0, 1], and stored as a mantissa.\n         */\n        uint256 borrowFactorMantissa;\n        /*\n         *  The borrow capacity of the asset, will be checked in beforeBorrow()\n         *  -1 means there is no limit on the capacity\n         *  0 means the asset can not be borrowed any more\n         */\n        uint256 borrowCapacity;\n        /*\n         *  The supply capacity of the asset, will be checked in beforeMint()\n         *  -1 means there is no limit on the capacity\n         *  0 means the asset can not be supplied any more\n         */\n        uint256 supplyCapacity;\n        // Whether market's mint is paused\n        bool mintPaused;\n        // Whether market's redeem is paused\n        bool redeemPaused;\n        // Whether market's borrow is paused\n        bool borrowPaused;\n        // Supercharged Mode config\n        // SMode Id\n        uint8 sModeID;\n        // Segregation config\n        // Whether market can be borrowed in segregation mode\n        bool borrowableInSegregation;\n        // Debt ceiling for the market\n        uint256 debtCeiling;\n        // Current debt in segregation mode\n        uint256 currentDebt;\n    }\n\n    /// @notice Mapping of iTokens to corresponding markets\n    mapping(address => MarketV2) public markets;\n\n    struct AccountData {\n        // Account's collateral assets\n        EnumerableSetUpgradeable.AddressSet collaterals;\n        // Account's borrowed assets\n        EnumerableSetUpgradeable.AddressSet borrowed;\n    }\n\n    /// @dev Mapping of accounts' data, including collateral and borrowed assets\n    mapping(address => AccountData) internal accountsData;\n\n    /**\n     * @notice Oracle to query the price of a given asset\n     */\n    address public priceOracle;\n\n    /**\n     * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\n     */\n    uint256 public closeFactorMantissa;\n\n    // closeFactorMantissa must be strictly greater than this value\n    uint256 internal constant closeFactorMinMantissa = 0.05e18; // 0.05\n\n    // closeFactorMantissa must not exceed this value\n    uint256 internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\n\n    /**\n     * @notice Multiplier representing the discount on collateral that a liquidator receives\n     */\n    uint256 public liquidationIncentiveMantissa;\n\n    // liquidationIncentiveMantissa must be no less than this value\n    uint256 internal constant liquidationIncentiveMinMantissa = 1.0e18; // 1.0\n\n    // liquidationIncentiveMantissa must be no greater than this value\n    uint256 internal constant liquidationIncentiveMaxMantissa = 1.5e18; // 1.5\n\n    // collateralFactorMantissa must not exceed this value\n    uint256 internal constant collateralFactorMaxMantissa = 1e18; // 1.0\n\n    // borrowFactorMantissa must not exceed this value\n    uint256 internal constant borrowFactorMaxMantissa = 1e18; // 1.0\n\n    /**\n     * @notice Guardian who can pause mint/borrow/liquidate/transfer in case of emergency\n     */\n    address public pauseGuardian;\n\n    /// @notice whether global transfer is paused\n    bool public transferPaused;\n\n    /// @notice whether global seize is paused\n    bool public seizePaused;\n\n    /**\n     * @notice the address of reward distributor\n     */\n    address public rewardDistributor;\n\n    /**\n     * End of ControllerStorageV1\n     */\n\n    /**\n     * @notice the address of extra implicit implementation for v2\n     */\n    address public extraImplicit;\n    /**\n     * @notice the address of extra explicit implementation for v2\n     */\n    address public extraExplicit;\n\n    // Borrow/Withdraw delay\n    address public timeLockStrategy;\n    address public timeLock; // borrow/withdraw delay contract\n\n    /// @notice decimals for debt ceiling\n    uint256 public constant DEBT_CEILING_DECIMALS = 2;\n\n    // sMode configs\n    uint256 constant MAX_SMODE_ID = 255;\n\n    struct SModeConfig {\n        uint256 liquidationIncentive; // 1.01e18\n        uint256 closeFactor; // 0.5e18\n        string label; // Stablecoins\n    }\n\n    SModeConfig[] public sModes;\n\n    // [0] -> Normal LTV\n    // [1] -> Normal Liquidation Threshold\n    // [2] -> sMode LTV\n    // [3] -> sMode Liquidation Threshold\n    mapping(address => uint256[4]) public marketCollateralFactor;\n\n    // account => sMode id\n    mapping(address => uint8) public accountsSMode;\n}\n"
    },
    "src/ControllerV2ExtraBase.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/EnumerableSetUpgradeable.sol\";\n\nimport \"./interface/IController.sol\";\nimport \"./interface/IPriceOracle.sol\";\nimport \"./interface/IiToken.sol\";\nimport \"./interface/IRewardDistributor.sol\";\nimport \"./interface/ITimeLockStrategy.sol\";\nimport \"./interface/IDefaultTimeLock.sol\";\nimport \"./interface/IERC20Metadata.sol\";\n\nimport \"./library/Initializable.sol\";\nimport \"./library/Ownable.sol\";\nimport \"./library/SafeRatioMath.sol\";\n\nimport \"./ControllerStock.sol\";\n\n/**\n * @title dForce's lending controller Contract\n * @author dForce\n */\nabstract contract ControllerV2ExtraBase is\n    Initializable,\n    Ownable,\n    ControllerStorageV2Extra,\n    IControllerV2ExtraBase\n{\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n    using SafeRatioMath for uint256;\n    using SafeMathUpgradeable for uint256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    constructor() public {\n        __initialize();\n    }\n\n    function __initialize() internal initializer {\n        __Ownable_init();\n    }\n\n    /*********************************/\n    /***** Internal  Functions *******/\n    /*********************************/\n\n    /******** validations *******/\n\n    /**\n     * @dev Check if _iToken is listed\n     */\n    function _checkiTokenListed(address _iToken) internal view {\n        require(iTokens.contains(_iToken), \"Token has not been listed\");\n    }\n\n    /**\n     * @dev Check if the _sModeID is valid\n     */\n    function _validateSModeID(uint8 _sModeID, uint8 validFrom) internal view {\n        uint8 _totalSModes = uint8(sModes.length);\n        require(\n            _sModeID >= validFrom && _sModeID < _totalSModes,\n            \"_validateSModeID: Invalid sMode ID!\"\n        );\n    }\n\n    // Check if parameter `_liquidationIncentive` is valid in the sMode\n    function _validateSModeLiquidationIncentive(\n        uint256 _liquidationIncentive\n    ) internal pure {\n        require(\n            _liquidationIncentive >= liquidationIncentiveMinMantissa &&\n                _liquidationIncentive <= liquidationIncentiveMaxMantissa,\n            \"_validateSModeLiquidationIncentive: Invalid liquidation incentive!\"\n        );\n    }\n\n    // Check if parameter `_closeFactor` is valid in the sMode\n    function _validateSModeCloseFactor(uint256 _closeFactor) internal pure {\n        require(\n            _closeFactor >= closeFactorMinMantissa &&\n                _closeFactor <= closeFactorMaxMantissa,\n            \"_validateSModeCloseFactor: Invalid close factor!\"\n        );\n    }\n\n    // Check if parameter `_sModeLtv` is valid in the sMode\n    function _validateSModeLTV(\n        uint256 _collateralFactor,\n        uint256 _sModeLiquidationThreshold,\n        uint256 _sModeLtv\n    ) internal pure {\n        require(\n            _sModeLtv >= _collateralFactor &&\n                _sModeLtv <= _sModeLiquidationThreshold,\n            \"_validateSModeLTV: Invalid LTV!\"\n        );\n    }\n\n    // Check if parameter `_liquidationThreshold` is valid\n    function _validateLiquidationThreshold(\n        uint256 _ltv,\n        uint256 _liquidationThreshold\n    ) internal pure {\n        require(\n            _liquidationThreshold >= _ltv &&\n                _liquidationThreshold <= collateralFactorMaxMantissa,\n            \"_validateLiquidationThreshold: Invalid liquidation threshold!\"\n        );\n    }\n\n    // Check if parameter `_collateralFactor` is valid\n    function _validateCollateralFactor(\n        uint256 _collateralFactor,\n        uint256 _liquidationThreshold\n    ) internal pure {\n        // v1 has check some validation, only check against the liquidation threshold\n        require(\n            _collateralFactor <= _liquidationThreshold,\n            \"_validateCollateralFactor: Invalid collateral factor!\"\n        );\n    }\n\n    /******** Getters *******/\n\n    function _getDecimals(address _iToken) internal view returns (uint256) {\n        return uint256(IERC20Metadata(_iToken).decimals());\n    }\n\n    /**\n     * @dev Get sMode id by iToken address.\n     */\n    function _getiTokenSModeID(\n        address _iToken\n    ) internal view returns (uint8 _iTokenSModeID) {\n        MarketV2 storage _market = markets[_iToken];\n        _iTokenSModeID = _market.sModeID;\n    }\n\n    function _getEffectedSMode(\n        address _iToken,\n        address _account\n    ) internal view returns (uint8 _sModeID) {\n        uint8 _accountSMode = accountsSMode[_account];\n        _sModeID = _accountSMode == markets[_iToken].sModeID\n            ? _accountSMode\n            : 0;\n    }\n\n    /******** Setters *******/\n\n    function _setBorrowableInSegregationInternal(\n        address _iToken,\n        bool _borrowable\n    ) internal {\n        MarketV2 storage _market = markets[_iToken];\n        _market.borrowableInSegregation = _borrowable;\n\n        emit BorrowableInSegregationChanged(_iToken, _borrowable);\n    }\n\n    function _setDebtCeilingInternal(\n        address _iToken,\n        uint256 _newDebtCeiling\n    ) internal {\n        MarketV2 storage _market = markets[_iToken];\n        uint256 _oldDebtCeiling = _market.debtCeiling;\n\n        _market.debtCeiling = _newDebtCeiling;\n\n        emit DebtCeilingChanged(_iToken, _oldDebtCeiling, _newDebtCeiling);\n    }\n\n    function _setLiquidationThresholdInternal(\n        address _iToken,\n        uint256 _newLiquidationThresholdMantissa\n    ) internal {\n        _validateLiquidationThreshold(\n            marketCollateralFactor[_iToken][0],\n            _newLiquidationThresholdMantissa\n        );\n\n        uint256 _oldLiquidationThresholdMantissa = marketCollateralFactor[\n            _iToken\n        ][1];\n        marketCollateralFactor[_iToken][1] = _newLiquidationThresholdMantissa;\n\n        emit NewLiquidationThreshold(\n            _iToken,\n            _oldLiquidationThresholdMantissa,\n            _newLiquidationThresholdMantissa\n        );\n    }\n\n    /**\n     * @dev Sets the sMode config for iToken\n     */\n    function _setSModeInternal(\n        address _iToken,\n        uint8 _newSModeID,\n        uint256 _sModeLtv,\n        uint256 _sModeLiqThreshold\n    ) internal {\n        _validateSModeID(_newSModeID, 1);\n\n        MarketV2 storage _market = markets[_iToken];\n        uint8 _oldSModeID = _market.sModeID;\n\n        require(_oldSModeID == 0, \"_setSMode: Has set sMode id!\");\n        _validateSModeLTV(\n            _market.collateralFactorMantissa,\n            _sModeLiqThreshold,\n            _sModeLtv\n        );\n        _validateLiquidationThreshold(_sModeLtv, _sModeLiqThreshold);\n\n        _market.sModeID = _newSModeID;\n\n        uint256 _oldSModeLtv = marketCollateralFactor[_iToken][2];\n        marketCollateralFactor[_iToken][2] = _sModeLtv;\n        uint256 _oldSModeLiqThreshold = marketCollateralFactor[_iToken][3];\n        marketCollateralFactor[_iToken][3] = _sModeLiqThreshold;\n\n        emit SModeChanged(_iToken, _oldSModeID, _newSModeID);\n        emit NewSModeLTV(_iToken, _oldSModeLtv, _sModeLtv);\n        emit NewSModeLiquidationThreshold(\n            _iToken,\n            _oldSModeLiqThreshold,\n            _sModeLiqThreshold\n        );\n    }\n\n    function _addSModeInternal(\n        uint256 _liquidationIncentive,\n        uint256 _closeFactor,\n        string memory _label\n    ) internal {\n        uint8 _sModesLen = uint8(sModes.length);\n        require(_sModesLen < MAX_SMODE_ID, \"_addSMode: Max SMode reached!\");\n\n        // Check parameters in the sMode.\n        _validateSModeLiquidationIncentive(_liquidationIncentive);\n        _validateSModeCloseFactor(_closeFactor);\n\n        sModes.push(\n            SModeConfig({\n                liquidationIncentive: _liquidationIncentive,\n                closeFactor: _closeFactor,\n                label: _label\n            })\n        );\n\n        // Use the length of sModes as the new sMode id.\n        emit SModeAdded(\n            _sModesLen,\n            _liquidationIncentive,\n            _closeFactor,\n            _label\n        );\n    }\n\n    /**\n     * @notice Has already checked the parameter `_newSModeId`.\n     * @dev Update caller's sMode ID.\n     */\n    function _enterSMode(uint8 _newSModeId, address _account) internal {\n        uint8 _oldSModeID = accountsSMode[_account];\n        accountsSMode[_account] = _newSModeId;\n\n        emit SModeEntered(_oldSModeID, _newSModeId, _account);\n    }\n\n    /*********************************/\n    /****** General Information ******/\n    /*********************************/\n\n    /**\n     * @param _account The address of the account to query\n     * @return _len The length of the markets that account has entered\n     */\n    function getEnteredMarketsLength(\n        address _account\n    ) internal view returns (uint256 _len) {\n        AccountData storage _accountData = accountsData[_account];\n\n        _len = _accountData.collaterals.length();\n    }\n\n    function getSegregationModeState(\n        address _account\n    ) public view override returns (bool, address) {\n        AccountData storage _accountData = accountsData[_account];\n\n        if (_accountData.collaterals.length() > 0) {\n            // Has collateral\n            address firstCollateral = _accountData.collaterals.at(0);\n            MarketV2 storage _market = markets[firstCollateral];\n\n            if (_market.debtCeiling > 0) {\n                return (true, firstCollateral);\n            }\n        }\n\n        return (false, address(0));\n    }\n\n    function getLiquidationIncentive(\n        address _iToken,\n        address _account\n    ) public view override returns (uint256 _liquidationIncentive) {\n        uint8 effectedSMode = _getEffectedSMode(_iToken, _account);\n\n        _liquidationIncentive = sModes[effectedSMode].liquidationIncentive;\n    }\n}\n"
    },
    "src/ControllerV2ExtraExplicit.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/EnumerableSetUpgradeable.sol\";\n\nimport \"./interface/IController.sol\";\nimport \"./interface/IPriceOracle.sol\";\nimport \"./interface/IiToken.sol\";\nimport \"./interface/IRewardDistributorV3.sol\";\nimport \"./interface/ITimeLockStrategy.sol\";\nimport \"./interface/IDefaultTimeLock.sol\";\nimport \"./interface/IERC20Metadata.sol\";\n\nimport \"./library/Initializable.sol\";\nimport \"./library/Ownable.sol\";\nimport \"./library/SafeRatioMath.sol\";\n\nimport \"./ControllerV2ExtraBase.sol\";\n\n/**\n * @title dForce's lending controller Contract\n * @author dForce\n */\ncontract ControllerV2ExtraExplicit is\n    ControllerV2ExtraBase,\n    IControllerV2ExtraExplicit\n{\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n    using SafeRatioMath for uint256;\n    using SafeMathUpgradeable for uint256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*********************************/\n    /******** Security Check *********/\n    /*********************************/\n\n    /**\n     * @notice Ensure this is a Controller contract.\n     */\n    function isControllerExtraExplicit() external view override returns (bool) {\n        return true;\n    }\n\n    /**\n     * @notice upgrade the controller to V2.\n     */\n    function initialize() external override {\n        uint256 _liquidationIncentive = 0;\n        uint256 _closeFactor = 0;\n        string memory _label = \"Default\";\n\n        // Initialize the default sMode.\n        sModes.push(\n            SModeConfig({\n                liquidationIncentive: _liquidationIncentive,\n                closeFactor: _closeFactor,\n                label: _label\n            })\n        );\n\n        // Use the length of sModes as the new sMode id.\n        emit SModeAdded(0, _liquidationIncentive, _closeFactor, _label);\n    }\n\n    /**\n     * @notice upgrade the controller to V2.\n     */\n    function _upgrade() external override {\n        // Setup the liquidation threshold related configurations\n        uint256 _len = iTokens.length();\n\n        for (uint256 i = 0; i < _len; i++) {\n            address _iToken = iTokens.at(i);\n            MarketV2 storage market = markets[_iToken];\n            uint256 _collateralFactor = market.collateralFactorMantissa;\n\n            marketCollateralFactor[_iToken][0] = _collateralFactor;\n            // TODO: How should we define new ltv and liquidation threshold\n            _setLiquidationThresholdInternal(\n                _iToken,\n                _collateralFactor.mul(103).div(100)\n            );\n\n            IRewardDistributorSecondV3(rewardDistributor)._upgrade(_iToken);\n        }\n\n        // Initialize the default sMode.\n        _addSModeInternal(\n            liquidationIncentiveMantissa,\n            closeFactorMantissa,\n            \"Default\"\n        );\n    }\n\n    /*********************************/\n    /******** Admin Operations *******/\n    /*********************************/\n\n    /******** Protocol Operations *******/\n\n    /**\n     * @notice Admin function to add iToken into supported markets\n     * Checks if the iToken already exists\n     * Will `revert()` if any check fails\n     */\n    function _addMarketV2(\n        IControllerV2.AddMarketV2LocalVars memory _vars\n    ) external override {\n        // Collateral Factor was duplicated in marketCollateralFactor\n        marketCollateralFactor[_vars._iToken][0] = _vars._collateralFactor;\n\n        _setLiquidationThresholdInternal(\n            _vars._iToken,\n            _vars._liquidationThreshold\n        );\n\n        if (_vars._sModeID != 0) {\n            // Set config for sMode\n            _setSModeInternal(\n                _vars._iToken,\n                _vars._sModeID,\n                _vars._sModeLtv,\n                _vars._sModeLiqThreshold\n            );\n        }\n\n        if (_vars._borrowableInSegregation) {\n            _setBorrowableInSegregationInternal(\n                _vars._iToken,\n                _vars._borrowableInSegregation\n            );\n        }\n\n        if (_vars._debtCeiling != 0) {\n            _setDebtCeilingInternal(_vars._iToken, _vars._debtCeiling);\n        }\n    }\n\n    /**\n     * @notice duplicates the global closeFactor into the sMode 0\n     */\n    function _setCloseFactor(\n        uint256 _newCloseFactorMantissa\n    ) external override {\n        sModes[0].closeFactor = _newCloseFactorMantissa;\n    }\n\n    /**\n     * @notice duplicates the global liquidation incentive into the sMode 0\n     */\n    function _setLiquidationIncentive(\n        uint256 _newLiquidationIncentiveMantissa\n    ) external override {\n        sModes[0].liquidationIncentive = _newLiquidationIncentiveMantissa;\n    }\n\n    /******** Market Operations *******/\n\n    /**\n     * @notice duplicates the iToken collateral factor into the marketCollateralFactor 0\n     */\n    function _setCollateralFactor(\n        address _iToken,\n        uint256 _newCollateralFactorMantissa\n    ) external override {\n        _validateCollateralFactor(\n            _newCollateralFactorMantissa,\n            marketCollateralFactor[_iToken][1] // liquidation threshold\n        );\n        marketCollateralFactor[_iToken][0] = _newCollateralFactorMantissa;\n    }\n\n    /*********************************/\n    /********* Policy Hooks **********/\n    /*********************************/\n    /**\n     * @notice Hook function before iToken `borrow()`\n     * Checks if the account should be allowed to borrow the given iToken\n     * Will `revert()` if any check fails\n     * @param _iToken The iToken to check the borrow against\n     * @param _borrower The account which would borrow iToken\n     * @param _borrowAmount The amount of underlying to borrow\n     */\n    function beforeBorrow(\n        address _iToken,\n        address _borrower,\n        uint256 _borrowAmount\n    ) external override {\n        MarketV2 storage market = markets[_iToken];\n\n        (\n            bool _isInSegregationMode,\n            address _segregationModeCollateral\n        ) = getSegregationModeState(_borrower);\n\n        if (_isInSegregationMode) {\n            MarketV2 storage collateralMarket = markets[\n                _segregationModeCollateral\n            ];\n\n            require(\n                market.borrowableInSegregation,\n                \"beforeBorrow: Invalid to borrow in segregation mode!\"\n            );\n\n            uint256 _newDebt = collateralMarket.currentDebt.add(\n                _borrowAmount.div(\n                    10 ** (_getDecimals(_iToken).sub(DEBT_CEILING_DECIMALS))\n                )\n            );\n\n            require(\n                _newDebt <= collateralMarket.debtCeiling,\n                \"beforeBorrow: Segregation debt ceiling exceeded!\"\n            );\n\n            // only update state when called by corresponding iToken\n            if (msg.sender == _iToken) {\n                collateralMarket.currentDebt = _newDebt;\n            }\n        }\n\n        // Check sMode ID of the `_borrower` and `_iToken`\n        uint8 _borrowerSModeID = accountsSMode[_borrower];\n        uint8 _iTokenSModeID = _getiTokenSModeID(_iToken);\n        if (_borrowerSModeID != 0) {\n            require(\n                _iTokenSModeID == _borrowerSModeID,\n                \"beforeBorrow: Inconsistent sMode ID\"\n            );\n        }\n    }\n\n    /**\n     * @notice Hook function after iToken `repayBorrow()`\n     * Will `revert()` if any operation fails\n     * @param _iToken The iToken being repaid\n     * @param _payer The account which would repay\n     * @param _borrower The account which has borrowed\n     * @param _repayAmount  The amount of underlying being repaid\n     */\n    function afterRepayBorrow(\n        address _iToken,\n        address _payer,\n        address _borrower,\n        uint256 _repayAmount\n    ) external override {\n        // Only update state when called by corresponding iToken\n        if (msg.sender != _iToken) return;\n\n        (\n            bool _isInSegregationMode,\n            address _segregationModeCollateral\n        ) = getSegregationModeState(_borrower);\n\n        if (_isInSegregationMode) {\n            MarketV2 storage collateralMarket = markets[\n                _segregationModeCollateral\n            ];\n\n            uint256 _currentDebt = collateralMarket.currentDebt;\n            uint256 _repayDebt = _repayAmount.div(\n                10 ** (_getDecimals(_iToken).sub(DEBT_CEILING_DECIMALS))\n            );\n\n            collateralMarket.currentDebt = _currentDebt < _repayDebt\n                ? 0\n                : _currentDebt.sub(_repayDebt);\n        }\n\n        _payer;\n    }\n\n    /*********************************/\n    /*** Account Markets Operation ***/\n    /*********************************/\n\n    /**\n     * @notice 1.1 If user does not have any collateral, enters market directly;\n     *         1.2 If user has collaterals:\n     *             1.2.1 If user is in segregation mode, revert\n     *             1.2.2 If user is not in segregation mode:\n     *                  1.2.2.1 If _iToken does not have debt ceiling, enters market\n     *                  1.2.2.1 If _iToken has debt ceiling, revert\n     * @dev check should add _iToken to the account's markets list for equity calculations\n     * @param _iToken The MarketV2 to enter\n     * @param _account The address of the account to modify\n     */\n    function beforeEnterMarket(\n        address _iToken,\n        address _account\n    ) external view override {\n        uint256 _enteredMarketsLength = getEnteredMarketsLength(_account);\n\n        if (_enteredMarketsLength > 0) {\n            (bool _isInSegregationMode, ) = getSegregationModeState(_account);\n            MarketV2 storage market = markets[_iToken];\n\n            if (_isInSegregationMode || market.debtCeiling != 0) {\n                revert(\"_enterMarket: can only have one segregated collateral!\");\n            }\n        }\n    }\n\n    function getCloseFactor(\n        address _iToken,\n        address _account\n    ) external view override returns (uint256 _closeFactor) {\n        uint8 _effectedSMode = _getEffectedSMode(_iToken, _account);\n\n        _closeFactor = sModes[_effectedSMode].closeFactor;\n    }\n}\n"
    },
    "src/interface/IController.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface IControllerAdminV1 {\n    /// @notice Emitted when an admin supports a market\n    event MarketAdded(\n        address iToken,\n        uint256 collateralFactor,\n        uint256 borrowFactor,\n        uint256 supplyCapacity,\n        uint256 borrowCapacity,\n        uint256 distributionFactor\n    );\n\n    function _addMarket(\n        address _iToken,\n        uint256 _collateralFactor,\n        uint256 _borrowFactor,\n        uint256 _supplyCapacity,\n        uint256 _borrowCapacity,\n        uint256 _distributionFactor\n    ) external;\n\n    /// @notice Emitted when new price oracle is set\n    event NewPriceOracle(address oldPriceOracle, address newPriceOracle);\n\n    function _setPriceOracle(address newOracle) external;\n\n    /// @notice Emitted when close factor is changed by admin\n    event NewCloseFactor(\n        uint256 oldCloseFactorMantissa,\n        uint256 newCloseFactorMantissa\n    );\n\n    function _setCloseFactor(uint256 newCloseFactorMantissa) external;\n\n    /// @notice Emitted when liquidation incentive is changed by admin\n    event NewLiquidationIncentive(\n        uint256 oldLiquidationIncentiveMantissa,\n        uint256 newLiquidationIncentiveMantissa\n    );\n\n    function _setLiquidationIncentive(\n        uint256 newLiquidationIncentiveMantissa\n    ) external;\n\n    /// @notice Emitted when iToken's collateral factor is changed by admin\n    event NewCollateralFactor(\n        address iToken,\n        uint256 oldCollateralFactorMantissa,\n        uint256 newCollateralFactorMantissa\n    );\n\n    function _setCollateralFactor(\n        address iToken,\n        uint256 newCollateralFactorMantissa\n    ) external;\n\n    /// @notice Emitted when iToken's borrow factor is changed by admin\n    event NewBorrowFactor(\n        address iToken,\n        uint256 oldBorrowFactorMantissa,\n        uint256 newBorrowFactorMantissa\n    );\n\n    function _setBorrowFactor(\n        address iToken,\n        uint256 newBorrowFactorMantissa\n    ) external;\n\n    /// @notice Emitted when iToken's borrow capacity is changed by admin\n    event NewBorrowCapacity(\n        address iToken,\n        uint256 oldBorrowCapacity,\n        uint256 newBorrowCapacity\n    );\n\n    function _setBorrowCapacity(\n        address iToken,\n        uint256 newBorrowCapacity\n    ) external;\n\n    /// @notice Emitted when iToken's supply capacity is changed by admin\n    event NewSupplyCapacity(\n        address iToken,\n        uint256 oldSupplyCapacity,\n        uint256 newSupplyCapacity\n    );\n\n    function _setSupplyCapacity(\n        address iToken,\n        uint256 newSupplyCapacity\n    ) external;\n\n    /// @notice Emitted when pause guardian is changed by admin\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\n\n    function _setPauseGuardian(address newPauseGuardian) external;\n\n    /// @notice Emitted when mint is paused/unpaused by admin or pause guardian\n    event MintPaused(address iToken, bool paused);\n\n    function _setMintPaused(address iToken, bool paused) external;\n\n    function _setAllMintPaused(bool paused) external;\n\n    /// @notice Emitted when redeem is paused/unpaused by admin or pause guardian\n    event RedeemPaused(address iToken, bool paused);\n\n    function _setRedeemPaused(address iToken, bool paused) external;\n\n    function _setAllRedeemPaused(bool paused) external;\n\n    /// @notice Emitted when borrow is paused/unpaused by admin or pause guardian\n    event BorrowPaused(address iToken, bool paused);\n\n    function _setBorrowPaused(address iToken, bool paused) external;\n\n    function _setAllBorrowPaused(bool paused) external;\n\n    /// @notice Emitted when transfer is paused/unpaused by admin or pause guardian\n    event TransferPaused(bool paused);\n\n    function _setTransferPaused(bool paused) external;\n\n    /// @notice Emitted when seize is paused/unpaused by admin or pause guardian\n    event SeizePaused(bool paused);\n\n    function _setSeizePaused(bool paused) external;\n\n    function _setiTokenPaused(address iToken, bool paused) external;\n\n    function _setProtocolPaused(bool paused) external;\n\n    event NewRewardDistributor(\n        address oldRewardDistributor,\n        address _newRewardDistributor\n    );\n\n    function _setRewardDistributor(address _newRewardDistributor) external;\n}\n\ninterface IControllerPolicyV1 {\n    function beforeMint(\n        address iToken,\n        address account,\n        uint256 mintAmount\n    ) external;\n\n    function afterMint(\n        address iToken,\n        address minter,\n        uint256 mintAmount,\n        uint256 mintedAmount\n    ) external;\n\n    function beforeRedeem(\n        address iToken,\n        address redeemer,\n        uint256 redeemAmount\n    ) external;\n\n    function afterRedeem(\n        address iToken,\n        address redeemer,\n        uint256 redeemAmount,\n        uint256 redeemedAmount\n    ) external;\n\n    function beforeBorrow(\n        address iToken,\n        address borrower,\n        uint256 borrowAmount\n    ) external;\n\n    function afterBorrow(\n        address iToken,\n        address borrower,\n        uint256 borrowedAmount\n    ) external;\n\n    function beforeRepayBorrow(\n        address iToken,\n        address payer,\n        address borrower,\n        uint256 repayAmount\n    ) external;\n\n    function afterRepayBorrow(\n        address iToken,\n        address payer,\n        address borrower,\n        uint256 repayAmount\n    ) external;\n\n    function beforeLiquidateBorrow(\n        address iTokenBorrowed,\n        address iTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 repayAmount\n    ) external;\n\n    function afterLiquidateBorrow(\n        address iTokenBorrowed,\n        address iTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 repaidAmount,\n        uint256 seizedAmount\n    ) external;\n\n    function beforeSeize(\n        address iTokenBorrowed,\n        address iTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 seizeAmount\n    ) external;\n\n    function afterSeize(\n        address iTokenBorrowed,\n        address iTokenCollateral,\n        address liquidator,\n        address borrower,\n        uint256 seizedAmount\n    ) external;\n\n    function beforeTransfer(\n        address iToken,\n        address from,\n        address to,\n        uint256 amount\n    ) external;\n\n    function afterTransfer(\n        address iToken,\n        address from,\n        address to,\n        uint256 amount\n    ) external;\n\n    function beforeFlashloan(\n        address iToken,\n        address to,\n        uint256 amount\n    ) external;\n\n    function afterFlashloan(\n        address iToken,\n        address to,\n        uint256 amount\n    ) external;\n}\n\ninterface IControllerAccountEquityV1 {\n    function calcAccountEquity(\n        address account\n    ) external view returns (uint256, uint256, uint256, uint256);\n\n    function liquidateCalculateSeizeTokens(\n        address iTokenBorrowed,\n        address iTokenCollateral,\n        uint256 actualRepayAmount\n    ) external view returns (uint256);\n}\n\ninterface IControllerAccountV1 {\n    function hasEnteredMarket(\n        address account,\n        address iToken\n    ) external view returns (bool);\n\n    function getEnteredMarkets(\n        address account\n    ) external view returns (address[] memory);\n\n    /// @notice Emitted when an account enters a market\n    event MarketEntered(address iToken, address account);\n\n    function enterMarkets(\n        address[] calldata iTokens\n    ) external returns (bool[] memory);\n\n    function enterMarketFromiToken(address _market, address _account) external;\n\n    /// @notice Emitted when an account exits a market\n    event MarketExited(address iToken, address account);\n\n    function exitMarkets(\n        address[] calldata iTokens\n    ) external returns (bool[] memory);\n\n    /// @notice Emitted when an account add a borrow asset\n    event BorrowedAdded(address iToken, address account);\n\n    /// @notice Emitted when an account remove a borrow asset\n    event BorrowedRemoved(address iToken, address account);\n\n    function hasBorrowed(\n        address account,\n        address iToken\n    ) external view returns (bool);\n\n    function getBorrowedAssets(\n        address account\n    ) external view returns (address[] memory);\n}\n\ninterface IControllerV1 is\n    IControllerAdminV1,\n    IControllerPolicyV1,\n    IControllerAccountEquityV1,\n    IControllerAccountV1\n{\n    /**\n     * @notice Security checks when updating the comptroller of a market, always expect to return true.\n     */\n    function isController() external view returns (bool);\n\n    /**\n     * @notice Return all of the iTokens\n     * @return The list of iToken addresses\n     */\n    function getAlliTokens() external view returns (address[] memory);\n\n    /**\n     * @notice Check whether a iToken is listed in controller\n     * @param _iToken The iToken to check for\n     * @return true if the iToken is listed otherwise false\n     */\n    function hasiToken(address _iToken) external view returns (bool);\n}\n\ninterface IControllerV2 {\n    event NewExtraExplicit(\n        address _oldExtraExplicit,\n        address _newExtraExplicit\n    );\n\n    function _setExtraExplicit(address _newExtraExplicit) external;\n\n    event NewExtraImplicit(\n        address _oldExtraImplicit,\n        address _newExtraImplicit\n    );\n\n    function _setExtraImplicit(address _newExtraImplicit) external;\n\n    function _upgrade(\n        address _newExtraImplicit,\n        address _newExtraExplicit\n    ) external;\n\n    /**\n     * @param _iToken The _iToken to add\n     * @param _collateralFactor The _collateralFactor of _iToken\n     * @param _borrowFactor The _borrowFactor of _iToken\n     * @param _supplyCapacity The _supplyCapacity of _iToken\n     * @param _borrowCapacity The _borrowCapacity of _iToken\n     * @param _distributionFactor The _distributionFactor of _iToken\n     * @param _iTokenSModeID The SMode ID of _iToken\n     * @param _sModeLtv The collateral factor of _iToken in the sMode\n     * @param _sModeLiqThreshold The liquidation Threshold of _iToken in the  sMode\n     * @param _liquidationThreshold The liquidation Threshold of _iToken\n     * @param _debtCeiling The _debtCeiling of _iToken in segregation mode, notice its decimal `DEBT_CEILING_DECIMALS`\n     * @param _borrowableInSegregation True if the _iToken is borrowable in segregation mode\n     */\n    struct AddMarketV2LocalVars {\n        address _iToken;\n        uint256 _collateralFactor;\n        uint256 _borrowFactor;\n        uint256 _supplyCapacity;\n        uint256 _borrowCapacity;\n        uint256 _distributionFactor;\n        uint8 _sModeID;\n        uint256 _sModeLtv;\n        uint256 _sModeLiqThreshold;\n        uint256 _liquidationThreshold;\n        uint256 _debtCeiling;\n        bool _borrowableInSegregation;\n    }\n\n    function _addMarketV2(AddMarketV2LocalVars memory _vars) external;\n\n    function exitMarketFromiToken(address _market, address _account) external;\n}\n\ninterface IControllerV2ExtraBase {\n    event DebtCeilingChanged(\n        address iToken,\n        uint256 oldDebtCeiling,\n        uint256 newDebtCeiling\n    );\n\n    event BorrowableInSegregationChanged(address iToken, bool borrowable);\n\n    event NewTimeLock(address oldTimeLock, address newTimeLock);\n\n    event NewTimeLockStrategy(\n        address oldTimeLockStrategy,\n        address newTimeLockStrategy\n    );\n\n    event SModeAdded(\n        uint8 sModeId,\n        uint256 liquidationIncentive,\n        uint256 closeFactor,\n        string label\n    );\n\n    event SModeChanged(\n        address iToken,\n        uint8 oldCategoryId,\n        uint8 newCategoryId\n    );\n\n    event NewLiquidationThreshold(\n        address _iToken,\n        uint256 _oldLiquidationThresholdMantissa,\n        uint256 _newLiquidationThresholdMantissa\n    );\n\n    event NewSModeLiquidationIncentive(\n        uint8 _sModeID,\n        uint256 _oldSModeLiquidationIncentive,\n        uint256 _newSModeLiquidationIncentive\n    );\n\n    event NewSModeCloseFactor(\n        uint8 _sModeID,\n        uint256 _oldSModeCloseFactor,\n        uint256 _newSModeCloseFactor\n    );\n\n    event NewSModeLTV(\n        address _iToken,\n        uint256 _oldSModeLTV,\n        uint256 _newSModeLTV\n    );\n\n    event NewSModeLiquidationThreshold(\n        address _iToken,\n        uint256 _oldSModeLiquidationThreshold,\n        uint256 _newSModeLiquidationThreshold\n    );\n\n    event SModeEntered(uint8 oldSModeId, uint8 newSModeId, address account);\n\n    function getSegregationModeState(\n        address _account\n    ) external view returns (bool, address);\n\n    function getLiquidationIncentive(\n        address _iToken,\n        address _account\n    ) external view returns (uint256);\n}\n\ninterface IControllerV2ExtraExplicit is IControllerV2ExtraBase {\n    function isControllerExtraExplicit() external view returns (bool);\n\n    function initialize() external;\n\n    function _upgrade() external;\n\n    function _addMarketV2(\n        IControllerV2.AddMarketV2LocalVars memory _vars\n    ) external;\n\n    function _setCollateralFactor(\n        address iToken,\n        uint256 newCollateralFactorMantissa\n    ) external;\n\n    function _setCloseFactor(uint256 newCloseFactorMantissa) external;\n\n    function _setLiquidationIncentive(\n        uint256 newLiquidationIncentiveMantissa\n    ) external;\n\n    function beforeBorrow(\n        address iToken,\n        address borrower,\n        uint256 borrowAmount\n    ) external;\n\n    function afterRepayBorrow(\n        address iToken,\n        address payer,\n        address borrower,\n        uint256 repayAmount\n    ) external;\n\n    function beforeEnterMarket(address _iToken, address _account) external view;\n\n    function getCloseFactor(\n        address _iToken,\n        address _account\n    ) external view returns (uint256);\n}\n\ninterface IControllerV2ExtraImplicit is IControllerV2ExtraBase {\n    function isControllerExtraImplicit() external view returns (bool);\n\n    function _setDebtCeiling(address _iToken, uint256 _newDebtCeiling) external;\n\n    function _setBorrowableInSegregation(\n        address _iToken,\n        bool _borrowable\n    ) external;\n\n    function _setTimeLock(address _newTimeLock) external;\n\n    function _setTimeLockStrategy(address _newTimeLockStrategy) external;\n\n    function _addSMode(\n        uint256 _liquidationIncentive,\n        uint256 _closeFactor,\n        string memory _label\n    ) external;\n\n    function _setSMode(\n        address _iToken,\n        uint8 _sModeID,\n        uint256 _sModeLtv,\n        uint256 _sModeLiqThreshold\n    ) external;\n\n    function _setLiquidationThreshold(\n        address _iToken,\n        uint256 _newLiquidationThresholdMantissa\n    ) external;\n\n    function _setSModeLiquidationIncentive(\n        uint8 _sModeID,\n        uint256 _liquidationIncentive\n    ) external;\n\n    function _setSModeCloseFactor(\n        uint8 _sModeID,\n        uint256 _closeFactor\n    ) external;\n\n    function _setSModeLTV(address _iToken, uint256 _ltv) external;\n\n    function _setSModeLiquidationThreshold(\n        address _iToken,\n        uint256 _liquidationThreshold\n    ) external;\n\n    function beforeTransferUnderlying(\n        address _asset,\n        address _underlying,\n        uint256 _amount,\n        address _recipient\n    ) external returns (address _dst);\n\n    function liquidateCalculateSeizeTokensV2(\n        address iTokenBorrowed,\n        address iTokenCollateral,\n        uint256 actualRepayAmount,\n        address borrower\n    ) external view returns (uint256);\n\n    function calcAccountEquityWithEffectV2(\n        address _account,\n        address _tokenToEffect,\n        uint256 _redeemAmount,\n        uint256 _borrowAmount,\n        bool _isLiquidation\n    ) external view returns (uint256, uint256, uint256, uint256);\n\n    function enterSMode(uint8 _newSModeId) external;\n\n    function getSModeLength() external view returns (uint256 _sModeLength);\n\n    function getCollateralFactor(\n        address _iToken,\n        uint8 _accountSModeID,\n        uint8 _iTokenSModeID,\n        bool _isLiquidation\n    ) external view returns (uint256 _collateralFactor);\n\n    function getLTV(address _iToken) external view returns (uint256);\n\n    function getLiquidationThreshold(\n        address _iToken\n    ) external view returns (uint256);\n\n    function getSModeLTV(address _iToken) external view returns (uint256);\n\n    function getSModeLiquidationThreshold(\n        address _iToken\n    ) external view returns (uint256);\n}\n\n/**\n * @dev External Interfaces for test cases and front end\n */\ninterface IController is\n    IControllerV1,\n    IControllerV2,\n    IControllerV2ExtraImplicit\n{\n    struct MarketV2 {\n        /*\n         *  Multiplier representing the most one can borrow against their collateral in this market.\n         *  For instance, 0.9 to allow borrowing 90% of collateral value.\n         *  Must be in [0, 0.9], and stored as a mantissa.\n         */\n        uint256 collateralFactorMantissa;\n        /*\n         *  Multiplier representing the most one can borrow the asset.\n         *  For instance, 0.5 to allow borrowing this asset 50% * collateral value * collateralFactor.\n         *  When calculating equity, 0.5 with 100 borrow balance will produce 200 borrow value\n         *  Must be between (0, 1], and stored as a mantissa.\n         */\n        uint256 borrowFactorMantissa;\n        /*\n         *  The borrow capacity of the asset, will be checked in beforeBorrow()\n         *  -1 means there is no limit on the capacity\n         *  0 means the asset can not be borrowed any more\n         */\n        uint256 borrowCapacity;\n        /*\n         *  The supply capacity of the asset, will be checked in beforeMint()\n         *  -1 means there is no limit on the capacity\n         *  0 means the asset can not be supplied any more\n         */\n        uint256 supplyCapacity;\n        // Whether market's mint is paused\n        bool mintPaused;\n        // Whether market's redeem is paused\n        bool redeemPaused;\n        // Whether market's borrow is paused\n        bool borrowPaused;\n        // sMode config\n        // TODO: explanation\n        uint8 sModeID;\n        //  Whether market can be borrowed in segregation mode\n        bool borrowableInSegregation;\n        // Debt ceiling for the market\n        uint256 debtCeiling;\n        // Current debt in segregation mode\n        uint256 currentDebt;\n    }\n\n    function extraImplicit() external view returns (address);\n\n    function extraExplicit() external view returns (address);\n\n    function timeLock() external view returns (address);\n\n    function timeLockStrategy() external view returns (address);\n\n    function marketsV2(address _iToken) external view returns (MarketV2 memory);\n\n    function DEBT_CEILING_DECIMALS() external view returns (uint256);\n\n    function accountsSMode(\n        address account\n    ) external view returns (uint8 sModeID);\n\n    function sModes(\n        uint256 index\n    )\n        external\n        view\n        returns (\n            uint256 liquidationIncentive,\n            uint256 closeFactor,\n            string calldata label\n        );\n\n    function liquidationIncentiveMantissa() external view returns (uint256);\n\n    function closeFactorMantissa() external view returns (uint256);\n\n    function initializeV2(\n        address _newExtraImplicit,\n        address _newExtraExplicit\n    ) external;\n\n    function initialize() external;\n}\n"
    },
    "src/interface/IDefaultTimeLock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\n/** @title ITimeLock interface for the TimeLock smart contract */\ninterface IDefaultTimeLock {\n    /** @dev Struct representing a time-lock agreement\n     * @param isFrozen Indicates if the agreement is frozen\n     * @param asset Address of the asset\n     * @param beneficiary Address of the beneficiary\n     * @param releaseTime Timestamp when the assets can be claimed\n     * @param tokenAmounts Token amounts\n     */\n    struct Agreement {\n        bool isFrozen;\n        address asset;\n        address beneficiary;\n        uint256 releaseTime;\n        uint256 tokenAmounts;\n    }\n\n    /** @notice Event emitted when a new time-lock agreement is created\n     * @param agreementId ID of the created agreement\n     * @param asset Address of the asset\n     * @param tokenAmounts Token amounts\n     * @param beneficiary Address of the beneficiary\n     * @param releaseTime Timestamp when the assets can be claimed\n     */\n    event AgreementCreated(\n        uint256 agreementId,\n        address indexed asset,\n        uint256 tokenAmounts,\n        address indexed beneficiary,\n        uint256 releaseTime\n    );\n\n    /** @notice Event emitted when a time-lock agreement is claimed\n     * @param agreementId ID of the claimed agreement\n     * @param asset Address of the asset\n     * @param tokenAmounts Token amounts\n     * @param beneficiary Address of the beneficiary\n     */\n    event AgreementClaimed(\n        uint256 agreementId,\n        address indexed asset,\n        uint256 tokenAmounts,\n        address indexed beneficiary\n    );\n\n    /** @notice Event emitted when a time-lock agreement is frozen or unfrozen\n     * @param agreementId ID of the affected agreement\n     * @param value Indicates whether the agreement is frozen (true) or unfrozen (false)\n     */\n    event AgreementFrozen(uint256 agreementId, bool value);\n\n    /** @notice Event emitted when a time-lock agreement is released\n     * @param agreementId ID of the affected agreement\n     */\n    event AgreementReleased(uint256 agreementId);\n\n    /** @notice Event emitted when the entire TimeLock contract is frozen or unfrozen\n     * @param value Indicates whether the contract is frozen (true) or unfrozen (false)\n     */\n    event TimeLockFrozen(bool value);\n\n    /** @dev Function to create a new time-lock agreement\n     * @param asset Address of the asset\n     * @param tokenAmounts Token amounts\n     * @param beneficiary Address of the beneficiary\n     * @param releaseTime Timestamp when the assets can be claimed\n     * @return agreementId Returns the ID of the created agreement\n     */\n    function createAgreement(\n        address asset,\n        uint256 tokenAmounts,\n        address beneficiary,\n        uint256 releaseTime\n    ) external returns (uint256 agreementId);\n\n    /** @dev Function to claim assets from time-lock agreements\n     * @param agreementIds Array of agreement IDs to be claimed\n     */\n    function claim(uint256[] calldata agreementIds) external;\n\n    /** @dev Function to freeze some time-lock agreements\n     * @param agreementIds Array of agreement IDs to be frozen\n     */\n    function freezeAgreements(uint256[] calldata agreementIds) external;\n\n    /** @dev Function to unfreeze some time-lock agreements\n     * @param agreementIds Array of agreement IDs to be unfrozen\n     */\n    function unfreezeAgreements(uint256[] calldata agreementIds) external;\n\n    /** @dev Function to release some time-lock agreements\n     * @param agreementIds Array of agreement IDs to be release\n     */\n\n    function releaseAgreements(uint256[] calldata agreementIds) external;\n\n    /** @dev Function to freeze the claim function\n     * @notice This function can only be called by an authorized user\n     */\n    function freezeClaim() external;\n\n    /** @dev Function to unfreeze the claim function\n     * @notice This function can only be called by an authorized user\n     */\n    function unfreezeClaim() external;\n\n    function controller() external view returns (address);\n}\n"
    },
    "src/interface/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "src/interface/IInterestRateModel.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\n/**\n * @title dForce Lending Protocol's InterestRateModel Interface.\n * @author dForce Team.\n */\ninterface IInterestRateModel {\n    function isInterestRateModel() external view returns (bool);\n\n    /**\n     * @dev Calculates the current borrow interest rate per block.\n     * @param cash The total amount of cash the market has.\n     * @param borrows The total amount of borrows the market has.\n     * @param reserves The total amnount of reserves the market has.\n     * @return The borrow rate per block (as a percentage, and scaled by 1e18).\n     */\n    function getBorrowRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves\n    ) external view returns (uint256);\n\n    /**\n     * @dev Calculates the current supply interest rate per block.\n     * @param cash The total amount of cash the market has.\n     * @param borrows The total amount of borrows the market has.\n     * @param reserves The total amnount of reserves the market has.\n     * @param reserveRatio The current reserve factor the market has.\n     * @return The supply rate per block (as a percentage, and scaled by 1e18).\n     */\n    function getSupplyRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves,\n        uint256 reserveRatio\n    ) external view returns (uint256);\n}\n\ninterface IInterestRateSecondModelV2 {\n    function isInterestRateSecondModel() external view returns (bool);\n}\n"
    },
    "src/interface/IPriceOracle.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./IiToken.sol\";\n\ninterface IPriceOracle {\n    /**\n     * @notice Get the underlying price of a iToken asset\n     * @param _iToken The iToken to get the underlying price of\n     * @return The underlying asset price mantissa (scaled by 1e18).\n     *  Zero means the price is unavailable.\n     */\n    function getUnderlyingPrice(\n        address _iToken\n    ) external view returns (uint256);\n\n    /**\n     * @notice Get the price of a underlying asset\n     * @param _iToken The iToken to get the underlying price of\n     * @return The underlying asset price mantissa (scaled by 1e18).\n     *  Zero means the price is unavailable and whether the price is valid.\n     */\n    function getUnderlyingPriceAndStatus(\n        address _iToken\n    ) external view returns (uint256, bool);\n}\n"
    },
    "src/interface/IRewardDistributor.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"../Controller.sol\";\n\ninterface IRewardDistributor {\n    function isRewardDistributor() external view returns (bool);\n\n    function controller() external view returns (Controller);\n\n    function _setRewardToken(address newRewardToken) external;\n\n    /// @notice Emitted reward token address is changed by admin\n    event NewRewardToken(address oldRewardToken, address newRewardToken);\n\n    function _addRecipient(\n        address _iToken,\n        uint256 _distributionFactor\n    ) external;\n\n    event NewRecipient(address iToken, uint256 distributionFactor);\n\n    /// @notice Emitted when mint is paused/unpaused by admin\n    event Paused(bool paused);\n\n    function _pause() external;\n\n    function _unpause(uint256 _borrowSpeed, uint256 _supplySpeed) external;\n\n    /// @notice Emitted when Global Distribution speed for both supply and borrow are updated\n    event GlobalDistributionSpeedsUpdated(\n        uint256 borrowSpeed,\n        uint256 supplySpeed\n    );\n\n    function _setGlobalDistributionSpeeds(\n        uint256 borrowSpeed,\n        uint256 supplySpeed\n    ) external;\n\n    /// @notice Emitted when iToken's Distribution speed is updated\n    event DistributionSpeedsUpdated(\n        address iToken,\n        uint256 borrowSpeed,\n        uint256 supplySpeed\n    );\n\n    function updateDistributionSpeed() external;\n\n    /// @notice Emitted when iToken's Distribution factor is changed by admin\n    event NewDistributionFactor(\n        address iToken,\n        uint256 oldDistributionFactorMantissa,\n        uint256 newDistributionFactorMantissa\n    );\n\n    function _setDistributionFactors(\n        address[] calldata iToken,\n        uint256[] calldata distributionFactors\n    ) external;\n\n    function updateDistributionState(address _iToken, bool _isBorrow) external;\n\n    function updateReward(\n        address _iToken,\n        address _account,\n        bool _isBorrow\n    ) external;\n\n    function updateRewardBatch(\n        address[] memory _holders,\n        address[] memory _iTokens\n    ) external;\n\n    function claimReward(\n        address[] memory _holders,\n        address[] memory _iTokens\n    ) external;\n\n    function claimAllReward(address[] memory _holders) external;\n\n    /// @notice Emitted when reward of amount is distributed into account\n    event RewardDistributed(\n        address iToken,\n        address account,\n        uint256 amount,\n        uint256 accountIndex\n    );\n}\n"
    },
    "src/interface/IRewardDistributorV3.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"../Controller.sol\";\n\ninterface IRewardDistributorV3 {\n    function isRewardDistributor() external view returns (bool);\n\n    function controller() external view returns (Controller);\n\n    function rewardToken() external returns (address);\n\n    function _setRewardToken(address newRewardToken) external;\n\n    /// @notice Emitted reward token address is changed by admin\n    event NewRewardToken(address oldRewardToken, address newRewardToken);\n\n    function treasury() external returns (address);\n\n    function _setTreasury(address newTreasury) external;\n\n    /// @notice Emitted treasury address is changed by admin\n    event NewTreasury(address oldTreasury, address newTreasury);\n\n    function _addRecipient(\n        address _iToken,\n        uint256 _distributionFactor\n    ) external;\n\n    event NewRecipient(address iToken, uint256 distributionFactor);\n\n    /// @notice Emitted when mint is paused/unpaused by admin\n    event Paused(bool paused);\n\n    function _pause() external;\n\n    function _unpause(\n        address[] calldata _borrowiTokens,\n        uint256[] calldata _borrowSpeeds,\n        address[] calldata _supplyiTokens,\n        uint256[] calldata _supplySpeeds\n    ) external;\n\n    /// @notice Emitted when Global Distribution speed for both supply and borrow are updated\n    event GlobalDistributionSpeedsUpdated(\n        uint256 borrowSpeed,\n        uint256 supplySpeed\n    );\n\n    /// @notice Emitted when iToken's Distribution borrow speed is updated\n    event DistributionBorrowSpeedUpdated(address iToken, uint256 borrowSpeed);\n\n    /// @notice Emitted when iToken's Distribution supply speed is updated\n    event DistributionSupplySpeedUpdated(address iToken, uint256 supplySpeed);\n\n    /// @notice Emitted when iToken's Distribution factor is changed by admin\n    event NewDistributionFactor(\n        address iToken,\n        uint256 oldDistributionFactorMantissa,\n        uint256 newDistributionFactorMantissa\n    );\n\n    function updateDistributionState(address _iToken, bool _isBorrow) external;\n\n    function updateReward(\n        address _iToken,\n        address _account,\n        bool _isBorrow\n    ) external;\n\n    function updateRewardBatch(\n        address[] memory _holders,\n        address[] memory _iTokens\n    ) external;\n\n    function claimReward(\n        address[] memory _holders,\n        address[] memory _iTokens\n    ) external;\n\n    function claimAllReward(address[] memory _holders) external;\n\n    function claimRewards(\n        address[] memory _holders,\n        address[] memory _suppliediTokens,\n        address[] memory _borrowediTokens\n    ) external;\n\n    /// @notice Emitted when reward of amount is distributed into account\n    event RewardDistributed(\n        address iToken,\n        address account,\n        uint256 amount,\n        uint256 accountIndex\n    );\n}\n\ninterface IRewardDistributorSecondV3 is IRewardDistributorV3 {\n    function _upgrade(address _iToken) external;\n}\n"
    },
    "src/interface/ITimeLockStrategy.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\ninterface ITimeLockStrategy {\n    function calculateTimeLockParams(\n        address _asset,\n        uint256 _amount,\n        address _caller\n    ) external returns (uint256 _delayTime);\n\n    function controller() external view returns (address);\n}\n"
    },
    "src/interface/IiToken.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./IInterestRateModel.sol\";\n\ninterface IiToken {\n    function isSupported() external returns (bool);\n\n    function isiToken() external returns (bool);\n\n    //----------------------------------\n    //********* User Interface *********\n    //----------------------------------\n    function mint(address recipient, uint256 mintAmount) external;\n\n    function mintForSelfAndEnterMarket(uint256 mintAmount) external;\n\n    function redeem(address from, uint256 redeemTokens) external;\n\n    function redeemUnderlying(address from, uint256 redeemAmount) external;\n\n    function borrow(uint256 borrowAmount) external;\n\n    function repayBorrow(uint256 repayAmount) external;\n\n    function repayBorrowBehalf(address borrower, uint256 repayAmount) external;\n\n    function liquidateBorrow(\n        address borrower,\n        uint256 repayAmount,\n        address iTokenCollateral\n    ) external;\n\n    function flashloan(\n        address recipient,\n        uint256 loanAmount,\n        bytes memory data\n    ) external;\n\n    function seize(\n        address _liquidator,\n        address _borrower,\n        uint256 _seizeTokens\n    ) external;\n\n    function updateInterest() external returns (bool);\n\n    function controller() external view returns (address);\n\n    function exchangeRateCurrent() external returns (uint256);\n\n    function exchangeRateStored() external view returns (uint256);\n\n    function totalBorrowsCurrent() external returns (uint256);\n\n    function totalBorrows() external view returns (uint256);\n\n    function borrowBalanceCurrent(address _user) external returns (uint256);\n\n    function borrowBalanceStored(address _user) external view returns (uint256);\n\n    function borrowIndex() external view returns (uint256);\n\n    function getAccountSnapshot(\n        address _account\n    ) external view returns (uint256, uint256, uint256);\n\n    function borrowRatePerBlock() external view returns (uint256);\n\n    function supplyRatePerBlock() external view returns (uint256);\n\n    function getCash() external view returns (uint256);\n\n    //----------------------------------\n    //********* Owner Actions **********\n    //----------------------------------\n\n    function _setNewReserveRatio(uint256 _newReserveRatio) external;\n\n    function _setNewFlashloanFeeRatio(uint256 _newFlashloanFeeRatio) external;\n\n    function _setNewProtocolFeeRatio(uint256 _newProtocolFeeRatio) external;\n\n    function _setController(address _newController) external;\n\n    function _setInterestRateModel(\n        IInterestRateModel _newInterestRateModel\n    ) external;\n\n    function _withdrawReserves(uint256 _withdrawAmount) external;\n}\n"
    },
    "src/library/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(\n            !_initialized,\n            \"Initializable: contract is already initialized\"\n        );\n\n        _;\n\n        _initialized = true;\n    }\n}\n"
    },
    "src/library/Ownable.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {_setPendingOwner} and {_acceptOwner}.\n */\ncontract Ownable {\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    address payable public owner;\n\n    /**\n     * @dev Returns the address of the current pending owner.\n     */\n    address payable public pendingOwner;\n\n    event NewOwner(address indexed previousOwner, address indexed newOwner);\n    event NewPendingOwner(\n        address indexed oldPendingOwner,\n        address indexed newPendingOwner\n    );\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"onlyOwner: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal {\n        owner = msg.sender;\n        emit NewOwner(address(0), msg.sender);\n    }\n\n    /**\n     * @notice Base on the inputing parameter `newPendingOwner` to check the exact error reason.\n     * @dev Transfer contract control to a new owner. The newPendingOwner must call `_acceptOwner` to finish the transfer.\n     * @param newPendingOwner New pending owner.\n     */\n    function _setPendingOwner(\n        address payable newPendingOwner\n    ) external onlyOwner {\n        require(\n            newPendingOwner != address(0) && newPendingOwner != pendingOwner,\n            \"_setPendingOwner: New owenr can not be zero address and owner has been set!\"\n        );\n\n        // Gets current owner.\n        address oldPendingOwner = pendingOwner;\n\n        // Sets new pending owner.\n        pendingOwner = newPendingOwner;\n\n        emit NewPendingOwner(oldPendingOwner, newPendingOwner);\n    }\n\n    /**\n     * @dev Accepts the admin rights, but only for pendingOwenr.\n     */\n    function _acceptOwner() external {\n        require(\n            msg.sender == pendingOwner,\n            \"_acceptOwner: Only for pending owner!\"\n        );\n\n        // Gets current values for events.\n        address oldOwner = owner;\n        address oldPendingOwner = pendingOwner;\n\n        // Set the new contract owner.\n        owner = pendingOwner;\n\n        // Clear the pendingOwner.\n        pendingOwner = address(0);\n\n        emit NewOwner(oldOwner, owner);\n        emit NewPendingOwner(oldPendingOwner, pendingOwner);\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "src/library/SafeRatioMath.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\n\nlibrary SafeRatioMath {\n    using SafeMathUpgradeable for uint256;\n\n    uint256 private constant BASE = 10 ** 18;\n    uint256 private constant DOUBLE = 10 ** 36;\n\n    function divup(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x.add(y.sub(1)).div(y);\n    }\n\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x.mul(y).div(BASE);\n    }\n\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x.mul(BASE).div(y);\n    }\n\n    function rdivup(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x.mul(BASE).add(y.sub(1)).div(y);\n    }\n\n    function tmul(\n        uint256 x,\n        uint256 y,\n        uint256 z\n    ) internal pure returns (uint256 result) {\n        result = x.mul(y).mul(z).div(DOUBLE);\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 base\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    z := base\n                }\n                default {\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    z := base\n                }\n                default {\n                    z := x\n                }\n                let half := div(base, 2) // for rounding.\n\n                for {\n                    n := div(n, 2)\n                } n {\n                    n := div(n, 2)\n                } {\n                    let xx := mul(x, x)\n                    if iszero(eq(div(xx, x), x)) {\n                        revert(0, 0)\n                    }\n                    let xxRound := add(xx, half)\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n                    x := div(xxRound, base)\n                    if mod(n, 2) {\n                        let zx := mul(z, x)\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) {\n                            revert(0, 0)\n                        }\n                        let zxRound := add(zx, half)\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n                        z := div(zxRound, base)\n                    }\n                }\n            }\n        }\n    }\n}\n"
    }
  }
}}