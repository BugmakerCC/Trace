{{
  "language": "Solidity",
  "sources": {
    "src/base/DecodersAndSanitizers/BTCFiDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\nimport {UniswapV3DecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/Protocols/UniswapV3DecoderAndSanitizer.sol\";\nimport {OneInchDecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/Protocols/OneInchDecoderAndSanitizer.sol\";\nimport {PendleRouterDecoderAndSanitizer} from\n    \"src/base/DecodersAndSanitizers/Protocols/PendleRouterDecoderAndSanitizer.sol\";\nimport {PumpStakingDecoderAndSanitizer} from\n    \"src/base/DecodersAndSanitizers/Protocols/PumpStakingDecoderAndSanitizer.sol\";\nimport {CornStakingDecoderAndSanitizer} from\n    \"src/base/DecodersAndSanitizers/Protocols/CornStakingDecoderAndSanitizer.sol\";\n\ncontract BTCFiDecoderAndSanitizer is\n    UniswapV3DecoderAndSanitizer,\n    OneInchDecoderAndSanitizer,\n    PendleRouterDecoderAndSanitizer,\n    PumpStakingDecoderAndSanitizer,\n    CornStakingDecoderAndSanitizer\n{\n    constructor(address _boringVault, address _uniswapV3NonFungiblePositionManager)\n        BaseDecoderAndSanitizer(_boringVault)\n        UniswapV3DecoderAndSanitizer(_uniswapV3NonFungiblePositionManager)\n    {}\n\n    //============================== HANDLE FUNCTION COLLISIONS ===============================\n}\n"
    },
    "src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {DecoderCustomTypes} from \"src/interfaces/DecoderCustomTypes.sol\";\n\ncontract BaseDecoderAndSanitizer {\n    error BaseDecoderAndSanitizer__FunctionSelectorNotSupported();\n    //============================== IMMUTABLES ===============================\n\n    /**\n     * @notice The BoringVault contract address.\n     */\n    address internal immutable boringVault;\n\n    constructor(address _boringVault) {\n        boringVault = _boringVault;\n    }\n\n    function approve(address spender, uint256) external pure returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(spender);\n    }\n\n    function transfer(address _to, uint256) external pure returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(_to);\n    }\n\n    function claimFees(address feeAsset) external pure returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(feeAsset);\n    }\n\n    function withdrawNonBoringToken(address token, uint256 /*amount*/ )\n        external\n        pure\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(token);\n    }\n\n    function withdrawNativeFromDrone() external pure returns (bytes memory addressesFound) {\n        return addressesFound;\n    }\n\n    //============================== FALLBACK ===============================\n    /**\n     * @notice The purpose of this function is to revert with a known error,\n     *         so that during merkle tree creation we can verify that a\n     *         leafs decoder and sanitizer implments the required function\n     *         selector.\n     */\n    fallback() external {\n        revert BaseDecoderAndSanitizer__FunctionSelectorNotSupported();\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/UniswapV3DecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {INonFungiblePositionManager} from \"src/interfaces/RawDataDecoderAndSanitizerInterfaces.sol\";\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract UniswapV3DecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== ERRORS ===============================\n\n    error UniswapV3DecoderAndSanitizer__BadPathFormat();\n    error UniswapV3DecoderAndSanitizer__BadTokenId();\n\n    //============================== IMMUTABLES ===============================\n\n    /**\n     * @notice The networks uniswapV3 nonfungible position manager.\n     */\n    INonFungiblePositionManager internal immutable uniswapV3NonFungiblePositionManager;\n\n    constructor(address _uniswapV3NonFungiblePositionManager) {\n        uniswapV3NonFungiblePositionManager = INonFungiblePositionManager(_uniswapV3NonFungiblePositionManager);\n    }\n\n    //============================== UNISWAP V3 ===============================\n\n    function exactInput(DecoderCustomTypes.ExactInputParams calldata params)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        // Nothing to sanitize\n        // Return addresses found\n        // Determine how many addresses are in params.path.\n        uint256 chunkSize = 23; // 3 bytes for uint24 fee, and 20 bytes for address token\n        uint256 pathLength = params.path.length;\n        if (pathLength % chunkSize != 20) revert UniswapV3DecoderAndSanitizer__BadPathFormat();\n        uint256 pathAddressLength = 1 + (pathLength / chunkSize);\n        uint256 pathIndex;\n        for (uint256 i; i < pathAddressLength; ++i) {\n            addressesFound = abi.encodePacked(addressesFound, params.path[pathIndex:pathIndex + 20]);\n            pathIndex += chunkSize;\n        }\n        addressesFound = abi.encodePacked(addressesFound, params.recipient);\n    }\n\n    function mint(DecoderCustomTypes.MintParams calldata params)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        // Nothing to sanitize\n        // Return addresses found\n        addressesFound = abi.encodePacked(params.token0, params.token1, params.recipient);\n    }\n\n    function increaseLiquidity(DecoderCustomTypes.IncreaseLiquidityParams calldata params)\n        external\n        view\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        // Sanitize raw data\n        if (uniswapV3NonFungiblePositionManager.ownerOf(params.tokenId) != boringVault) {\n            revert UniswapV3DecoderAndSanitizer__BadTokenId();\n        }\n        // Extract addresses from uniswapV3NonFungiblePositionManager.positions(params.tokenId).\n        (, address operator, address token0, address token1,,,,,,,,) =\n            uniswapV3NonFungiblePositionManager.positions(params.tokenId);\n        addressesFound = abi.encodePacked(operator, token0, token1);\n    }\n\n    function decreaseLiquidity(DecoderCustomTypes.DecreaseLiquidityParams calldata params)\n        external\n        view\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        // Sanitize raw data\n        // NOTE ownerOf check is done in PositionManager contract as well, but it is added here\n        // just for completeness.\n        if (uniswapV3NonFungiblePositionManager.ownerOf(params.tokenId) != boringVault) {\n            revert UniswapV3DecoderAndSanitizer__BadTokenId();\n        }\n\n        // No addresses in data\n        return addressesFound;\n    }\n\n    function collect(DecoderCustomTypes.CollectParams calldata params)\n        external\n        view\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        // Sanitize raw data\n        // NOTE ownerOf check is done in PositionManager contract as well, but it is added here\n        // just for completeness.\n        if (uniswapV3NonFungiblePositionManager.ownerOf(params.tokenId) != boringVault) {\n            revert UniswapV3DecoderAndSanitizer__BadTokenId();\n        }\n\n        // Return addresses found\n        addressesFound = abi.encodePacked(params.recipient);\n    }\n\n    function burn(uint256 /*tokenId*/ ) external pure virtual returns (bytes memory addressesFound) {\n        // positionManager.burn(tokenId) will verify that the tokenId has no liquidity, and no tokens owed.\n        // Nothing to sanitize or return\n        return addressesFound;\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/OneInchDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract OneInchDecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== ERRORS ===============================\n\n    error OneInchDecoderAndSanitizer__PermitNotSupported();\n\n    //============================== ONEINCH ===============================\n\n    function swap(\n        address executor,\n        DecoderCustomTypes.SwapDescription calldata desc,\n        bytes calldata permit,\n        bytes calldata\n    ) external pure returns (bytes memory addressesFound) {\n        if (permit.length > 0) revert OneInchDecoderAndSanitizer__PermitNotSupported();\n        addressesFound = abi.encodePacked(executor, desc.srcToken, desc.dstToken, desc.srcReceiver, desc.dstReceiver);\n    }\n\n    function uniswapV3Swap(uint256, uint256, uint256[] calldata pools)\n        external\n        pure\n        returns (bytes memory addressesFound)\n    {\n        for (uint256 i; i < pools.length; ++i) {\n            addressesFound = abi.encodePacked(addressesFound, uint160(pools[i]));\n        }\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/PendleRouterDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer, DecoderCustomTypes} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract PendleRouterDecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== ERRORS ===============================\n\n    error PendleRouterDecoderAndSanitizer__AggregatorSwapsNotPermitted();\n    error PendleRouterDecoderAndSanitizer__LimitOrderYtMismatch(address ytFound, address ytExpected);\n    error PendleRouterDecoderAndSanitizer__NoBytes();\n\n    //============================== PENDLEROUTER ===============================\n\n    function mintSyFromToken(address user, address sy, uint256, DecoderCustomTypes.TokenInput calldata input)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        if (\n            input.swapData.swapType != DecoderCustomTypes.SwapType.NONE || input.swapData.extRouter != address(0)\n                || input.pendleSwap != address(0) || input.tokenIn != input.tokenMintSy\n        ) revert PendleRouterDecoderAndSanitizer__AggregatorSwapsNotPermitted();\n\n        addressesFound =\n            abi.encodePacked(user, sy, input.tokenIn, input.tokenMintSy, input.pendleSwap, input.swapData.extRouter);\n    }\n\n    function mintPyFromSy(address user, address yt, uint256, uint256)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(user, yt);\n    }\n\n    function swapExactPtForYt(address user, address market, uint256, uint256, DecoderCustomTypes.ApproxParams calldata)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(user, market);\n    }\n\n    function swapExactYtForPt(address user, address market, uint256, uint256, DecoderCustomTypes.ApproxParams calldata)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(user, market);\n    }\n\n    function addLiquidityDualSyAndPt(address user, address market, uint256, uint256, uint256)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(user, market);\n    }\n\n    function removeLiquidityDualSyAndPt(address user, address market, uint256, uint256, uint256)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(user, market);\n    }\n\n    function redeemPyToSy(address user, address yt, uint256, uint256)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(user, yt);\n    }\n\n    function redeemSyToToken(address user, address sy, uint256, DecoderCustomTypes.TokenOutput calldata output)\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        if (\n            output.swapData.swapType != DecoderCustomTypes.SwapType.NONE || output.swapData.extRouter != address(0)\n                || output.pendleSwap != address(0) || output.tokenOut != output.tokenRedeemSy\n        ) revert PendleRouterDecoderAndSanitizer__AggregatorSwapsNotPermitted();\n\n        addressesFound = abi.encodePacked(\n            user, sy, output.tokenOut, output.tokenRedeemSy, output.pendleSwap, output.swapData.extRouter\n        );\n    }\n\n    function redeemDueInterestAndRewards(\n        address user,\n        address[] calldata sys,\n        address[] calldata yts,\n        address[] calldata markets\n    ) external pure virtual returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(user);\n        uint256 sysLength = sys.length;\n        for (uint256 i; i < sysLength; ++i) {\n            addressesFound = abi.encodePacked(addressesFound, sys[i]);\n        }\n        uint256 ytsLength = yts.length;\n        for (uint256 i; i < ytsLength; ++i) {\n            addressesFound = abi.encodePacked(addressesFound, yts[i]);\n        }\n        uint256 marketsLength = markets.length;\n        for (uint256 i; i < marketsLength; ++i) {\n            addressesFound = abi.encodePacked(addressesFound, markets[i]);\n        }\n    }\n\n    function swapExactSyForPt(\n        address receiver,\n        address market,\n        uint256, /*exactSyIn*/\n        uint256, /*minPtOut*/\n        DecoderCustomTypes.ApproxParams calldata,\n        DecoderCustomTypes.LimitOrderData calldata limit\n    ) external pure virtual returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(receiver, market, _sanitizeLimitOrderData(limit));\n    }\n\n    function swapExactPtForSy(\n        address receiver,\n        address market,\n        uint256, /*exactPtIn*/\n        uint256, /*minSyOut*/\n        DecoderCustomTypes.LimitOrderData calldata limit\n    ) external pure virtual returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(receiver, market, _sanitizeLimitOrderData(limit));\n    }\n\n    function swapExactSyForYt(\n        address receiver,\n        address market,\n        uint256, /*exactSyIn*/\n        uint256, /*minYtOut*/\n        DecoderCustomTypes.ApproxParams calldata, /*guessYtOut*/\n        DecoderCustomTypes.LimitOrderData calldata limit\n    ) external pure returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(receiver, market, _sanitizeLimitOrderData(limit));\n    }\n\n    function swapExactYtForSy(\n        address receiver,\n        address market,\n        uint256, /*exactYtIn*/\n        uint256, /*minSyOut*/\n        DecoderCustomTypes.LimitOrderData calldata limit\n    ) external pure returns (bytes memory addressesFound) {\n        addressesFound = abi.encodePacked(receiver, market, _sanitizeLimitOrderData(limit));\n    }\n\n    /**\n     * @notice `params[i].order.token` is restricted to be either an input or an output token for the SY,\n     *         so addressesFound only reports the YT address from the FillOrderParams, as the YT address derives\n     *      The SY address which restricts the input and output tokens.\n     */\n    function fill(\n        DecoderCustomTypes.FillOrderParams[] calldata params,\n        address receiver,\n        uint256, /*maxTaking*/\n        bytes calldata optData,\n        bytes calldata callback\n    ) external pure virtual returns (bytes memory addressesFound) {\n        if (optData.length > 0 || callback.length > 0) revert PendleRouterDecoderAndSanitizer__NoBytes();\n\n        addressesFound = abi.encodePacked(receiver);\n\n        address savedYt;\n        // Iterate through params, and make sure all orders have the same yt.\n        for (uint256 i; i < params.length; ++i) {\n            if (savedYt == address(0)) {\n                // Update saved yt.\n                savedYt = params[i].order.YT;\n            } else {\n                // Make sure this orders YT matches the saved yt.\n                if (savedYt != params[i].order.YT) {\n                    revert PendleRouterDecoderAndSanitizer__LimitOrderYtMismatch(params[i].order.YT, savedYt);\n                }\n            }\n        }\n\n        // If yt is set, encode it.\n        if (savedYt != address(0)) {\n            addressesFound = abi.encodePacked(addressesFound, savedYt);\n        }\n    }\n\n    function _sanitizeLimitOrderData(DecoderCustomTypes.LimitOrderData calldata limit)\n        internal\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        if (limit.limitRouter != address(0)) {\n            // Trying to fill limit orders.\n            addressesFound = abi.encodePacked(limit.limitRouter);\n            if (limit.optData.length > 0) revert PendleRouterDecoderAndSanitizer__NoBytes();\n\n            address savedYt;\n            // Make sure all normal fills have the same yt.\n            for (uint256 i; i < limit.normalFills.length; ++i) {\n                if (savedYt == address(0)) {\n                    // Update saved yt.\n                    savedYt = limit.normalFills[i].order.YT;\n                } else {\n                    // Make sure this orders YT matches the saved yt.\n                    if (savedYt != limit.normalFills[i].order.YT) {\n                        revert PendleRouterDecoderAndSanitizer__LimitOrderYtMismatch(\n                            limit.normalFills[i].order.YT, savedYt\n                        );\n                    }\n                }\n            }\n            // Make sure all flash fills have the same yt.\n            for (uint256 i; i < limit.flashFills.length; ++i) {\n                if (savedYt == address(0)) {\n                    // Update saved yt.\n                    savedYt = limit.flashFills[i].order.YT;\n                } else {\n                    // Make sure this orders YT matches the saved yt.\n                    if (savedYt != limit.flashFills[i].order.YT) {\n                        revert PendleRouterDecoderAndSanitizer__LimitOrderYtMismatch(\n                            limit.flashFills[i].order.YT, savedYt\n                        );\n                    }\n                }\n            }\n\n            // If yt is set, encode it.\n            if (savedYt != address(0)) {\n                addressesFound = abi.encodePacked(addressesFound, savedYt);\n            }\n        }\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/PumpStakingDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract PumpStakingDecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== PUMP STAKING ===============================\n\n    function stake(uint256 /*amount*/ ) external pure virtual returns (bytes memory addressesFound) {\n        return addressesFound;\n    }\n\n    function unstakeRequest(uint256 /*amount*/ ) external pure virtual returns (bytes memory addressesFound) {\n        return addressesFound;\n    }\n\n    function claimSlot(uint8 /*slot*/ ) external pure virtual returns (bytes memory addressesFound) {\n        return addressesFound;\n    }\n\n    function claimAll() external pure virtual returns (bytes memory addressesFound) {\n        return addressesFound;\n    }\n\n    function unstakeInstant(uint256 /*amount*/ ) external pure virtual returns (bytes memory addressesFound) {\n        return addressesFound;\n    }\n}\n"
    },
    "src/base/DecodersAndSanitizers/Protocols/CornStakingDecoderAndSanitizer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\nimport {BaseDecoderAndSanitizer} from \"src/base/DecodersAndSanitizers/BaseDecoderAndSanitizer.sol\";\n\nabstract contract CornStakingDecoderAndSanitizer is BaseDecoderAndSanitizer {\n    //============================== CORN STAKING ===============================\n\n    // For staking general ERC20s\n    function deposit(address _token, uint256 /*_amount*/ )\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(_token);\n    }\n\n    function mintAndDepositBitcorn(uint256 /*_amount*/ ) external pure virtual returns (bytes memory addressesFound) {\n        return addressesFound;\n    }\n\n    // For redeeming general ERC20s\n    function redeemToken(address _token, uint256 /*_amount*/ )\n        external\n        pure\n        virtual\n        returns (bytes memory addressesFound)\n    {\n        addressesFound = abi.encodePacked(_token);\n    }\n\n    function redeemBitcorn(uint256 /*_amount*/ ) external pure virtual returns (bytes memory addressesFound) {\n        return addressesFound;\n    }\n}\n"
    },
    "src/interfaces/DecoderCustomTypes.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\ncontract DecoderCustomTypes {\n    // ========================================= BALANCER =========================================\n    struct JoinPoolRequest {\n        address[] assets;\n        uint256[] maxAmountsIn;\n        bytes userData;\n        bool fromInternalBalance;\n    }\n\n    struct ExitPoolRequest {\n        address[] assets;\n        uint256[] minAmountsOut;\n        bytes userData;\n        bool toInternalBalance;\n    }\n\n    enum SwapKind {\n        GIVEN_IN,\n        GIVEN_OUT\n    }\n\n    struct SingleSwap {\n        bytes32 poolId;\n        SwapKind kind;\n        address assetIn;\n        address assetOut;\n        uint256 amount;\n        bytes userData;\n    }\n\n    struct FundManagement {\n        address sender;\n        bool fromInternalBalance;\n        address recipient;\n        bool toInternalBalance;\n    }\n\n    // ========================================= UNISWAP V3 =========================================\n\n    struct MintParams {\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n    }\n\n    struct IncreaseLiquidityParams {\n        uint256 tokenId;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    struct DecreaseLiquidityParams {\n        uint256 tokenId;\n        uint128 liquidity;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    struct CollectParams {\n        uint256 tokenId;\n        address recipient;\n        uint128 amount0Max;\n        uint128 amount1Max;\n    }\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    struct PancakeSwapExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    // ========================================= MORPHO BLUE =========================================\n\n    struct MarketParams {\n        address loanToken;\n        address collateralToken;\n        address oracle;\n        address irm;\n        uint256 lltv;\n    }\n\n    // ========================================= 1INCH =========================================\n\n    struct SwapDescription {\n        address srcToken;\n        address dstToken;\n        address payable srcReceiver;\n        address payable dstReceiver;\n        uint256 amount;\n        uint256 minReturnAmount;\n        uint256 flags;\n    }\n\n    // ========================================= PENDLE =========================================\n    struct TokenInput {\n        // TOKEN DATA\n        address tokenIn;\n        uint256 netTokenIn;\n        address tokenMintSy;\n        // AGGREGATOR DATA\n        address pendleSwap;\n        SwapData swapData;\n    }\n\n    struct TokenOutput {\n        // TOKEN DATA\n        address tokenOut;\n        uint256 minTokenOut;\n        address tokenRedeemSy;\n        // AGGREGATOR DATA\n        address pendleSwap;\n        SwapData swapData;\n    }\n\n    struct ApproxParams {\n        uint256 guessMin;\n        uint256 guessMax;\n        uint256 guessOffchain; // pass 0 in to skip this variable\n        uint256 maxIteration; // every iteration, the diff between guessMin and guessMax will be divided by 2\n        uint256 eps; // the max eps between the returned result & the correct result, base 1e18. Normally this number will be set\n            // to 1e15 (1e18/1000 = 0.1%)\n    }\n\n    struct SwapData {\n        SwapType swapType;\n        address extRouter;\n        bytes extCalldata;\n        bool needScale;\n    }\n\n    enum SwapType {\n        NONE,\n        KYBERSWAP,\n        ONE_INCH,\n        // ETH_WETH not used in Aggregator\n        ETH_WETH\n    }\n\n    struct LimitOrderData {\n        address limitRouter;\n        uint256 epsSkipMarket; // only used for swap operations, will be ignored otherwise\n        FillOrderParams[] normalFills;\n        FillOrderParams[] flashFills;\n        bytes optData;\n    }\n\n    struct FillOrderParams {\n        Order order;\n        bytes signature;\n        uint256 makingAmount;\n    }\n\n    struct Order {\n        uint256 salt;\n        uint256 expiry;\n        uint256 nonce;\n        OrderType orderType;\n        address token;\n        address YT;\n        address maker;\n        address receiver;\n        uint256 makingAmount;\n        uint256 lnImpliedRate;\n        uint256 failSafeRate;\n        bytes permit;\n    }\n\n    enum OrderType {\n        SY_FOR_PT,\n        PT_FOR_SY,\n        SY_FOR_YT,\n        YT_FOR_SY\n    }\n\n    // ========================================= EIGEN LAYER =========================================\n\n    struct QueuedWithdrawalParams {\n        // Array of strategies that the QueuedWithdrawal contains\n        address[] strategies;\n        // Array containing the amount of shares in each Strategy in the `strategies` array\n        uint256[] shares;\n        // The address of the withdrawer\n        address withdrawer;\n    }\n\n    struct Withdrawal {\n        // The address that originated the Withdrawal\n        address staker;\n        // The address that the staker was delegated to at the time that the Withdrawal was created\n        address delegatedTo;\n        // The address that can complete the Withdrawal + will receive funds when completing the withdrawal\n        address withdrawer;\n        // Nonce used to guarantee that otherwise identical withdrawals have unique hashes\n        uint256 nonce;\n        // Block number when the Withdrawal was created\n        uint32 startBlock;\n        // Array of strategies that the Withdrawal contains\n        address[] strategies;\n        // Array containing the amount of shares in each Strategy in the `strategies` array\n        uint256[] shares;\n    }\n\n    struct SignatureWithExpiry {\n        // the signature itself, formatted as a single bytes object\n        bytes signature;\n        // the expiration timestamp (UTC) of the signature\n        uint256 expiry;\n    }\n\n    // ========================================= CCIP =========================================\n\n    // If extraArgs is empty bytes, the default is 200k gas limit.\n    struct EVM2AnyMessage {\n        bytes receiver; // abi.encode(receiver address) for dest EVM chains\n        bytes data; // Data payload\n        EVMTokenAmount[] tokenAmounts; // Token transfers\n        address feeToken; // Address of feeToken. address(0) means you will send msg.value.\n        bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV2)\n    }\n\n    /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n    struct EVMTokenAmount {\n        address token; // token address on the local chain.\n        uint256 amount; // Amount of tokens.\n    }\n\n    struct EVMExtraArgsV1 {\n        uint256 gasLimit;\n    }\n\n    // ========================================= OFT =========================================\n\n    struct SendParam {\n        uint32 dstEid; // Destination endpoint ID.\n        bytes32 to; // Recipient address.\n        uint256 amountLD; // Amount to send in local decimals.\n        uint256 minAmountLD; // Minimum amount to send in local decimals.\n        bytes extraOptions; // Additional options supplied by the caller to be used in the LayerZero message.\n        bytes composeMsg; // The composed message for the send() operation.\n        bytes oftCmd; // The OFT command to be executed, unused in default OFT implementations.\n    }\n\n    struct MessagingFee {\n        uint256 nativeFee;\n        uint256 lzTokenFee;\n    }\n    // ========================================= L1StandardBridge =========================================\n\n    struct WithdrawalTransaction {\n        uint256 nonce;\n        address sender;\n        address target;\n        uint256 value;\n        uint256 gasLimit;\n        bytes data;\n    }\n\n    struct OutputRootProof {\n        bytes32 version;\n        bytes32 stateRoot;\n        bytes32 messagePasserStorageRoot;\n        bytes32 latestBlockhash;\n    }\n\n    // ========================================= Mantle L1StandardBridge =========================================\n\n    struct MantleWithdrawalTransaction {\n        uint256 nonce;\n        address sender;\n        address target;\n        uint256 mntValue;\n        uint256 value;\n        uint256 gasLimit;\n        bytes data;\n    }\n\n    // ========================================= Linea Bridge =========================================\n\n    struct ClaimMessageWithProofParams {\n        bytes32[] proof;\n        uint256 messageNumber;\n        uint32 leafIndex;\n        address from;\n        address to;\n        uint256 fee;\n        uint256 value;\n        address payable feeRecipient;\n        bytes32 merkleRoot;\n        bytes data;\n    }\n\n    // ========================================= Scroll Bridge =========================================\n\n    struct L2MessageProof {\n        uint256 batchIndex;\n        bytes merkleProof;\n    }\n\n    // ========================================= Camelot V3 =========================================\n\n    struct CamelotMintParams {\n        address token0;\n        address token1;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n    }\n    // ========================================= Velodrome V3 =========================================\n\n    struct VelodromeMintParams {\n        address token0;\n        address token1;\n        int24 tickSpacing;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n        uint160 sqrtPriceX96;\n    }\n\n    // ========================================= Karak =========================================\n\n    struct QueuedWithdrawal {\n        address staker;\n        address delegatedTo;\n        uint256 nonce;\n        uint256 start;\n        WithdrawRequest request;\n    }\n\n    struct WithdrawRequest {\n        address[] vaults;\n        uint256[] shares;\n        address withdrawer;\n    }\n}\n"
    },
    "src/interfaces/RawDataDecoderAndSanitizerInterfaces.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\n// Swell\ninterface INonFungiblePositionManager {\n    struct Position {\n        // the nonce for permits\n        uint96 nonce;\n        // the address that is approved for spending this token\n        address operator;\n        // the ID of the pool with which this token is connected\n        uint80 poolId;\n        // the tick range of the position\n        int24 tickLower;\n        int24 tickUpper;\n        // the liquidity of the position\n        uint128 liquidity;\n        // the fee growth of the aggregate position as of the last action on the individual position\n        uint256 feeGrowthInside0LastX128;\n        uint256 feeGrowthInside1LastX128;\n        // how many uncollected tokens are owed to the position, as of the last computation\n        uint128 tokensOwed0;\n        uint128 tokensOwed1;\n    }\n\n    function ownerOf(uint256 tokenId) external view returns (address);\n    function positions(uint256 tokenId)\n        external\n        view\n        returns (\n            uint96 nonce,\n            address operator,\n            address token0,\n            address token1,\n            uint24 fee,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n}\n\ninterface PancakeSwapV3MasterChef {\n    function userPositionInfos(uint256 id)\n        external\n        view\n        returns (\n            uint128 liquidity,\n            uint128 boostLiquidity,\n            int24 tickLower,\n            int24 tickUpper,\n            uint256 rewardsGrowthInside,\n            uint256 reward,\n            address user,\n            uint256 pid,\n            uint256 boostMultiplier\n        );\n}\n\ninterface CamelotNonFungiblePositionManager {\n    function ownerOf(uint256 tokenId) external view returns (address);\n    function positions(uint256 tokenId)\n        external\n        view\n        returns (\n            uint96 nonce,\n            address operator,\n            address token0,\n            address token1,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@solmate/=lib/solmate/src/",
      "@forge-std/=lib/forge-std/src/",
      "@ds-test/=lib/forge-std/lib/ds-test/src/",
      "ds-test/=lib/forge-std/lib/ds-test/src/",
      "@openzeppelin/=lib/openzeppelin-contracts/",
      "@ccip/=lib/ccip/",
      "@devtools-oapp-evm/=lib/OAppAuth/lib/devtools/packages/oapp-evm/contracts/oapp/",
      "@layerzerolabs/lz-evm-messagelib-v2/=lib/OAppAuth/node_modules/@layerzerolabs/lz-evm-messagelib-v2/",
      "@layerzerolabs/lz-evm-protocol-v2/=lib/OAppAuth/lib/layerzero-v2/packages/layerzero-v2/evm/protocol/",
      "@layerzerolabs/oapp-evm/=lib/OAppAuth/lib/devtools/packages/oapp-evm/",
      "@lz-oapp-evm/=lib/OAppAuth/lib/LayerZero-V2/packages/layerzero-v2/evm/oapp/contracts/oapp/",
      "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
      "LayerZero-V2/=lib/OAppAuth/lib/",
      "LayerZero-v2/=lib/LayerZero-v2/",
      "OAppAuth/=lib/OAppAuth/",
      "ccip/=lib/ccip/contracts/",
      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      "forge-std/=lib/forge-std/src/",
      "halmos-cheatcodes/=lib/OAppAuth/lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/",
      "solidity-bytes-utils/=lib/OAppAuth/node_modules/solidity-bytes-utils/",
      "solmate/=lib/solmate/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "evmVersion": "shanghai",
    "viaIR": false,
    "libraries": {}
  }
}}