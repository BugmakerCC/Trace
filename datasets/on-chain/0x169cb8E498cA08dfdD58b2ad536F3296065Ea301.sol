{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "london",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 10
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@solidstate/contracts/access/access_control/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IAccessControl } from './IAccessControl.sol';\nimport { AccessControlInternal } from './AccessControlInternal.sol';\n\n/**\n * @title Role-based access control system\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nabstract contract AccessControl is IAccessControl, AccessControlInternal {\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function grantRole(\n        bytes32 role,\n        address account\n    ) external onlyRole(_getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function hasRole(\n        bytes32 role,\n        address account\n    ) external view returns (bool) {\n        return _hasRole(role, account);\n    }\n\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32) {\n        return _getRoleAdmin(role);\n    }\n\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function revokeRole(\n        bytes32 role,\n        address account\n    ) external onlyRole(_getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function renounceRole(bytes32 role) external {\n        _renounceRole(role);\n    }\n\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function getRoleMember(\n        bytes32 role,\n        uint256 index\n    ) external view returns (address) {\n        return _getRoleMember(role, index);\n    }\n\n    /**\n     * @inheritdoc IAccessControl\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256) {\n        return _getRoleMemberCount(role);\n    }\n}\n"
    },
    "@solidstate/contracts/access/access_control/AccessControlInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { EnumerableSet } from '../../data/EnumerableSet.sol';\nimport { AddressUtils } from '../../utils/AddressUtils.sol';\nimport { UintUtils } from '../../utils/UintUtils.sol';\nimport { IAccessControlInternal } from './IAccessControlInternal.sol';\nimport { AccessControlStorage } from './AccessControlStorage.sol';\n\n/**\n * @title Role-based access control system\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nabstract contract AccessControlInternal is IAccessControlInternal {\n    using AddressUtils for address;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using UintUtils for uint256;\n\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /*\n     * @notice query whether role is assigned to account\n     * @param role role to query\n     * @param account account to query\n     * @return whether role is assigned to account\n     */\n    function _hasRole(\n        bytes32 role,\n        address account\n    ) internal view virtual returns (bool) {\n        return\n            AccessControlStorage.layout().roles[role].members.contains(account);\n    }\n\n    /**\n     * @notice revert if sender does not have given role\n     * @param role role to query\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, msg.sender);\n    }\n\n    /**\n     * @notice revert if given account does not have given role\n     * @param role role to query\n     * @param account to query\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!_hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        'AccessControl: account ',\n                        account.toString(),\n                        ' is missing role ',\n                        uint256(role).toHexString(32)\n                    )\n                )\n            );\n        }\n    }\n\n    /*\n     * @notice query admin role for given role\n     * @param role role to query\n     * @return admin role\n     */\n    function _getRoleAdmin(\n        bytes32 role\n    ) internal view virtual returns (bytes32) {\n        return AccessControlStorage.layout().roles[role].adminRole;\n    }\n\n    /**\n     * @notice set role as admin role\n     * @param role role to set\n     * @param adminRole admin role to set\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = _getRoleAdmin(role);\n        AccessControlStorage.layout().roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /*\n     * @notice assign role to given account\n     * @param role role to assign\n     * @param account recipient of role assignment\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        AccessControlStorage.layout().roles[role].members.add(account);\n        emit RoleGranted(role, account, msg.sender);\n    }\n\n    /*\n     * @notice unassign role from given account\n     * @param role role to unassign\n     * @parm account\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        AccessControlStorage.layout().roles[role].members.remove(account);\n        emit RoleRevoked(role, account, msg.sender);\n    }\n\n    /**\n     * @notice relinquish role\n     * @param role role to relinquish\n     */\n    function _renounceRole(bytes32 role) internal virtual {\n        _revokeRole(role, msg.sender);\n    }\n\n    /**\n     * @notice query role for member at given index\n     * @param role role to query\n     * @param index index to query\n     */\n    function _getRoleMember(\n        bytes32 role,\n        uint256 index\n    ) internal view virtual returns (address) {\n        return AccessControlStorage.layout().roles[role].members.at(index);\n    }\n\n    /**\n     * @notice query role for member count\n     * @param role role to query\n     */\n    function _getRoleMemberCount(\n        bytes32 role\n    ) internal view virtual returns (uint256) {\n        return AccessControlStorage.layout().roles[role].members.length();\n    }\n}\n"
    },
    "@solidstate/contracts/access/access_control/AccessControlStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { EnumerableSet } from '../../data/EnumerableSet.sol';\n\nlibrary AccessControlStorage {\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    struct Layout {\n        mapping(bytes32 => RoleData) roles;\n    }\n\n    bytes32 internal constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.AccessControl');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/access/access_control/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IAccessControlInternal } from './IAccessControlInternal.sol';\n\n/**\n * @title AccessControl interface\n */\ninterface IAccessControl is IAccessControlInternal {\n    /*\n     * @notice query whether role is assigned to account\n     * @param role role to query\n     * @param account account to query\n     * @return whether role is assigned to account\n     */\n    function hasRole(\n        bytes32 role,\n        address account\n    ) external view returns (bool);\n\n    /*\n     * @notice query admin role for given role\n     * @param role role to query\n     * @return admin role\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /*\n     * @notice assign role to given account\n     * @param role role to assign\n     * @param account recipient of role assignment\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /*\n     * @notice unassign role from given account\n     * @param role role to unassign\n     * @parm account\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @notice relinquish role\n     * @param role role to relinquish\n     */\n    function renounceRole(bytes32 role) external;\n\n    /**\n     * @notice Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(\n        bytes32 role,\n        uint256 index\n    ) external view returns (address);\n\n    /**\n     * @notice Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@solidstate/contracts/access/access_control/IAccessControlInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Partial AccessControl interface needed by internal functions\n */\ninterface IAccessControlInternal {\n    event RoleAdminChanged(\n        bytes32 indexed role,\n        bytes32 indexed previousAdminRole,\n        bytes32 indexed newAdminRole\n    );\n\n    event RoleGranted(\n        bytes32 indexed role,\n        address indexed account,\n        address indexed sender\n    );\n\n    event RoleRevoked(\n        bytes32 indexed role,\n        address indexed account,\n        address indexed sender\n    );\n}\n"
    },
    "@solidstate/contracts/data/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Set implementation with enumeration functions\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\n */\nlibrary EnumerableSet {\n    error EnumerableSet__IndexOutOfBounds();\n\n    struct Set {\n        bytes32[] _values;\n        // 1-indexed to allow 0 to signify nonexistence\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    function at(\n        Bytes32Set storage set,\n        uint256 index\n    ) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    function at(\n        AddressSet storage set,\n        uint256 index\n    ) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    function at(\n        UintSet storage set,\n        uint256 index\n    ) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    function contains(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    function contains(\n        AddressSet storage set,\n        address value\n    ) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function contains(\n        UintSet storage set,\n        uint256 value\n    ) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    function indexOf(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, value);\n    }\n\n    function indexOf(\n        AddressSet storage set,\n        address value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function indexOf(\n        UintSet storage set,\n        uint256 value\n    ) internal view returns (uint256) {\n        return _indexOf(set._inner, bytes32(value));\n    }\n\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function add(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    function add(\n        AddressSet storage set,\n        address value\n    ) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    function remove(\n        Bytes32Set storage set,\n        bytes32 value\n    ) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    function remove(\n        AddressSet storage set,\n        address value\n    ) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function remove(\n        UintSet storage set,\n        uint256 value\n    ) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    function toArray(\n        Bytes32Set storage set\n    ) internal view returns (bytes32[] memory) {\n        return set._inner._values;\n    }\n\n    function toArray(\n        AddressSet storage set\n    ) internal view returns (address[] memory) {\n        bytes32[] storage values = set._inner._values;\n        address[] storage array;\n\n        assembly {\n            array.slot := values.slot\n        }\n\n        return array;\n    }\n\n    function toArray(\n        UintSet storage set\n    ) internal view returns (uint256[] memory) {\n        bytes32[] storage values = set._inner._values;\n        uint256[] storage array;\n\n        assembly {\n            array.slot := values.slot\n        }\n\n        return array;\n    }\n\n    function _at(\n        Set storage set,\n        uint256 index\n    ) private view returns (bytes32) {\n        if (index >= set._values.length)\n            revert EnumerableSet__IndexOutOfBounds();\n        return set._values[index];\n    }\n\n    function _contains(\n        Set storage set,\n        bytes32 value\n    ) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    function _indexOf(\n        Set storage set,\n        bytes32 value\n    ) private view returns (uint256) {\n        unchecked {\n            return set._indexes[value] - 1;\n        }\n    }\n\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    function _add(\n        Set storage set,\n        bytes32 value\n    ) private returns (bool status) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            set._indexes[value] = set._values.length;\n            status = true;\n        }\n    }\n\n    function _remove(\n        Set storage set,\n        bytes32 value\n    ) private returns (bool status) {\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            unchecked {\n                bytes32 last = set._values[set._values.length - 1];\n\n                // move last value to now-vacant index\n\n                set._values[valueIndex - 1] = last;\n                set._indexes[last] = valueIndex;\n            }\n            // clear last index\n\n            set._values.pop();\n            delete set._indexes[value];\n\n            status = true;\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/utils/AddressUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { UintUtils } from './UintUtils.sol';\n\nlibrary AddressUtils {\n    using UintUtils for uint256;\n\n    error AddressUtils__InsufficientBalance();\n    error AddressUtils__NotContract();\n    error AddressUtils__SendValueFailed();\n\n    function toString(address account) internal pure returns (string memory) {\n        return uint256(uint160(account)).toHexString(20);\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function sendValue(address payable account, uint256 amount) internal {\n        (bool success, ) = account.call{ value: amount }('');\n        if (!success) revert AddressUtils__SendValueFailed();\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data\n    ) internal returns (bytes memory) {\n        return\n            functionCall(target, data, 'AddressUtils: failed low-level call');\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory error\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, error);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                'AddressUtils: failed low-level call with value'\n            );\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) internal returns (bytes memory) {\n        if (value > address(this).balance)\n            revert AddressUtils__InsufficientBalance();\n        return _functionCallWithValue(target, data, value, error);\n    }\n\n    /**\n     * @notice execute arbitrary external call with limited gas usage and amount of copied return data\n     * @dev derived from https://github.com/nomad-xyz/ExcessivelySafeCall (MIT License)\n     * @param target recipient of call\n     * @param gasAmount gas allowance for call\n     * @param value native token value to include in call\n     * @param maxCopy maximum number of bytes to copy from return data\n     * @param data encoded call data\n     * @return success whether call is successful\n     * @return returnData copied return data\n     */\n    function excessivelySafeCall(\n        address target,\n        uint256 gasAmount,\n        uint256 value,\n        uint16 maxCopy,\n        bytes memory data\n    ) internal returns (bool success, bytes memory returnData) {\n        returnData = new bytes(maxCopy);\n\n        assembly {\n            // execute external call via assembly to avoid automatic copying of return data\n            success := call(\n                gasAmount,\n                target,\n                value,\n                add(data, 0x20),\n                mload(data),\n                0,\n                0\n            )\n\n            // determine whether to limit amount of data to copy\n            let toCopy := returndatasize()\n\n            if gt(toCopy, maxCopy) {\n                toCopy := maxCopy\n            }\n\n            // store the length of the copied bytes\n            mstore(returnData, toCopy)\n\n            // copy the bytes from returndata[0:toCopy]\n            returndatacopy(add(returnData, 0x20), 0, toCopy)\n        }\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) private returns (bytes memory) {\n        if (!isContract(target)) revert AddressUtils__NotContract();\n\n        (bool success, bytes memory returnData) = target.call{ value: value }(\n            data\n        );\n\n        if (success) {\n            return returnData;\n        } else if (returnData.length > 0) {\n            assembly {\n                let returnData_size := mload(returnData)\n                revert(add(32, returnData), returnData_size)\n            }\n        } else {\n            revert(error);\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/utils/UintUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title utility functions for uint256 operations\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nlibrary UintUtils {\n    error UintUtils__InsufficientHexLength();\n\n    bytes16 private constant HEX_SYMBOLS = '0123456789abcdef';\n\n    function add(uint256 a, int256 b) internal pure returns (uint256) {\n        return b < 0 ? sub(a, -b) : a + uint256(b);\n    }\n\n    function sub(uint256 a, int256 b) internal pure returns (uint256) {\n        return b < 0 ? add(a, -b) : a - uint256(b);\n    }\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0';\n        }\n\n        uint256 temp = value;\n        uint256 digits;\n\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n\n        bytes memory buffer = new bytes(digits);\n\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n\n        return string(buffer);\n    }\n\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0x00';\n        }\n\n        uint256 length = 0;\n\n        for (uint256 temp = value; temp != 0; temp >>= 8) {\n            unchecked {\n                length++;\n            }\n        }\n\n        return toHexString(value, length);\n    }\n\n    function toHexString(\n        uint256 value,\n        uint256 length\n    ) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n\n        unchecked {\n            for (uint256 i = 2 * length + 1; i > 1; --i) {\n                buffer[i] = HEX_SYMBOLS[value & 0xf];\n                value >>= 4;\n            }\n        }\n\n        if (value != 0) revert UintUtils__InsufficientHexLength();\n\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/common/admin/interfaces/ICrossPaymentModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { IPaymentModule } from \"./IPaymentModule.sol\";\n\ninterface ICrossPaymentModule {\n    struct CrossPaymentSignatureInput {\n        address payer;\n        uint256 sourceChainId;\n        uint256 paymentIndex;\n        bytes signature;\n    }\n\n    struct ProcessCrossPaymentOutput {\n        bytes32 platformId;\n        uint32[] services;\n        uint32[] serviceAmounts;\n        address spender;\n        uint256 destinationChainId;\n        address payer;\n        uint256 sourceChainId;\n        uint256 paymentIndex;\n    }\n\n    function updateCrossPaymentSignerAddress(address newSignerAddress) external;\n    function processCrossPayment(\n        IPaymentModule.ProcessPaymentInput memory paymentInput,\n        address spender,\n        uint256 destinationChainId\n    ) external payable returns (uint256);\n    function processCrossPaymentForDelegator(\n        IPaymentModule.ProcessPaymentInput memory paymentInput,\n        address delegator,\n        uint256 destinationChainId,\n        uint256 gasFee,\n        bytes memory signature\n    ) external payable returns (uint256);\n    function processCrossPaymentBuyTokenForDelegator(\n        IPaymentModule.ProcessPaymentInput memory paymentInput,\n        address delegator,\n        uint256 gasFee,\n        bytes memory signature\n    ) external payable returns (uint256);\n    function spendCrossPaymentSignature(address spender, ProcessCrossPaymentOutput memory output, bytes memory signature) external;\n    function getCrossPaymentSignerAddress() external view returns (address);\n    function getCrossPaymentOutputByIndex(uint256 paymentIndex) external view returns (ProcessCrossPaymentOutput memory);\n    function prefixedMessage(bytes32 hash) external pure returns (bytes32);\n    function getHashedMessage(ProcessCrossPaymentOutput memory output) external pure returns (bytes32);\n    function recoverSigner(bytes32 message, bytes memory signature) external pure returns (address);\n    function checkSignature(ProcessCrossPaymentOutput memory output, bytes memory signature) external view;\n    function getDelegatorHashedMessage(address delegator, uint256 destinationChainId, uint256 gasFee) external pure returns (bytes32);\n    function checkDelegatorSignature(address delegator, uint256 destinationChainId, uint256 gasFee, bytes memory signature) external pure;\n    function getDelegatorBuyTokenHashedMessage(\n        address delegator,\n        address destinationAddress,\n        uint32 destinationChainId,\n        uint256 gasFee\n    ) external pure returns (bytes32);\n    function checkDelegatorBuyTokenSignature(\n        address delegator,\n        address destinationAddress,\n        uint32 destinationChainId,\n        uint256 gasFee,\n        bytes memory signature\n    ) external pure;\n    function getChainID() external view returns (uint256);\n\n    /** EVENTS */\n    event CrossPaymentProcessed(uint256 indexed previousBlock, uint256 indexed paymentIndex);\n    event CrossPaymentSignatureSpent(uint256 indexed previousBlock, uint256 indexed sourceChainId, uint256 indexed paymentIndex);\n    event CrossPaymentSignerAddressUpdated(address indexed oldSigner, address indexed newSigner);\n    event CrossPaymentProcessedBuyToken(\n        uint256 indexed paymentIndex,\n        address delegator,\n        uint256 indexed destinationChainId,\n        address indexed destinationAddress\n    );\n\n    /** ERRORS */\n    error ProcessCrossPaymentError(string errorMessage);\n    error CheckSignatureError(string errorMessage);\n    error ProcessCrossPaymentSignatureError(string errorMessage);\n}\n"
    },
    "contracts/common/admin/interfaces/IFacetsManagerFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\ninterface IFacetsManagerFacet {\n    function approveFacets(address[] memory facets) external;\n\n    function disapproveFacets(address[] memory facets) external;\n\n    function isFacetApproved(address facet) external view returns (bool);\n}\n"
    },
    "contracts/common/admin/interfaces/IPaymentModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\ninterface IPaymentModule {\n    enum PaymentMethod {\n        NATIVE,\n        USD,\n        ALTCOIN\n    }\n\n    enum PaymentType {\n        NATIVE,\n        GIFT,\n        CROSSCHAIN\n    }\n\n    struct AcceptedToken {\n        string name;\n        PaymentMethod tokenType;\n        address token;\n        address router;\n        bool isV2Router;\n        uint256 slippageTolerance;\n    }\n\n    struct ProcessPaymentInput {\n        bytes32 platformId;\n        uint32[] services;\n        uint32[] serviceAmounts;\n        address referrer;\n        address user;\n        address tokenAddress;\n    }\n\n    struct ProcessPaymentOutput {\n        ProcessPaymentInput processPaymentInput;\n        uint256 usdPrice;\n        uint256 paymentAmount;\n        uint256 burnedAmount;\n        uint256 treasuryShare;\n        uint256 referrerShare;\n    }\n\n    struct ProcessCrossPaymentOutput {\n        bytes32 platformId;\n        uint32[] services;\n        uint32[] serviceAmounts;\n        address payer;\n        address spender;\n        uint256 sourceChainId;\n        uint256 destinationChainId;\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function PAYMENT_PROCESSOR_ROLE() external pure returns (bytes32);\n    function adminWithdraw(address tokenAddress, uint256 amount, address treasury) external;\n    function setUsdToken(address newUsdToken) external;\n    function setRouterAddress(address newRouter, bool _isV2Router) external;\n    function addAcceptedToken(AcceptedToken memory acceptedToken) external;\n    function removeAcceptedToken(address tokenAddress) external;\n    function updateAcceptedToken(AcceptedToken memory acceptedToken) external;\n    function setV3PoolFeeForTokenNative(address token, uint24 poolFee) external;\n    function getUsdToken() external view returns (address);\n    function processPayment(ProcessPaymentInput memory params) external payable returns (uint256);\n    function getPaymentByIndex(uint256 paymentIndex) external view returns (ProcessPaymentOutput memory);\n    function getQuoteTokenPrice(address token0, address token1) external view returns (uint256 price);\n    function getV3PoolFeeForTokenWithNative(address token) external view returns (uint24);\n    function isV2Router() external view returns (bool);\n    function getRouterAddress() external view returns (address);\n    function getAcceptedTokenByAddress(address tokenAddress) external view returns (AcceptedToken memory);\n    function getAcceptedTokens() external view returns (address[] memory);\n\n    /** EVENTS */\n    event TokenBurned(uint256 indexed tokenBurnedLastBlock, address indexed tokenAddress, uint256 amount);\n    event PaymentProcessed(uint256 indexed previousBlock, uint256 indexed paymentIndex);\n    event TreasuryAddressUpdated(address indexed oldTreasury, address indexed newTreasury);\n\n    /** ERRORS */\n    error ProcessPaymentError(string errorMessage);\n}\n"
    },
    "contracts/common/admin/interfaces/IWhitelistFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\ninterface IWhitelistFacet {\n    function isWhitelistEnabled(bytes32 productId) external view returns (bool);\n\n    function setWhitelistEnabled(bool enabled, bytes32 productId) external;\n}\n"
    },
    "contracts/common/admin/libraries/LibAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nlibrary LibAccessControl {\n    bytes32 internal constant DEFAULT_ADMIN_ROLE = 0x00;\n    bytes32 internal constant WHITELIST_ADMIN_ROLE = keccak256(\"WHITELIST_ADMIN_ROLE\");\n    bytes32 internal constant WHITELISTED_ROLE = keccak256(\"WHITELISTED_ROLE\");\n    bytes32 internal constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 internal constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n}\n"
    },
    "contracts/launchpad/interfaces/ILaunchPadCommon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\ninterface ILaunchPadCommon {\n    enum LaunchPadType {\n        FlokiPadCreatedBefore,\n        FlokiPadCreatedAfter\n    }\n\n    struct IdoInfo {\n        bool enabled;\n        address dexRouter;\n        address pairToken;\n        uint256 price;\n        uint256 amountToList;\n    }\n\n    struct RefundInfo {\n        uint256 penaltyFeePercent;\n        uint256 expireDuration;\n    }\n\n    struct FundTarget {\n        uint256 softCap;\n        uint256 hardCap;\n    }\n\n    struct ReleaseSchedule {\n        uint256 timestamp;\n        uint256 percent;\n    }\n\n    struct ReleaseScheduleV2 {\n        uint256 timestamp;\n        uint256 percent;\n        bool isVesting;\n    }\n\n    struct CreateErc20Input {\n        string name;\n        string symbol;\n        string logo;\n        uint8 decimals;\n        uint256 maxSupply;\n        address owner;\n        uint256 treasuryReserved;\n    }\n\n    struct LaunchPadInfo {\n        address owner;\n        address tokenAddress;\n        address paymentTokenAddress;\n        uint256 price;\n        FundTarget fundTarget;\n        uint256 maxInvestPerWallet;\n        uint256 startTimestamp;\n        uint256 duration;\n        uint256 tokenCreationDeadline;\n        RefundInfo refundInfo;\n        IdoInfo idoInfo;\n    }\n\n    struct CreateLaunchPadInput {\n        LaunchPadType launchPadType;\n        LaunchPadInfo launchPadInfo;\n        ReleaseScheduleV2[] releaseSchedule;\n        CreateErc20Input createErc20Input;\n        address referrer;\n        bool isSuperchargerEnabled;\n        uint256 feePercentage;\n        address paymentTokenAddress;\n    }\n}\n"
    },
    "contracts/launchpad/interfaces/ILaunchPadFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ILaunchPadCommon } from \"./ILaunchPadCommon.sol\";\nimport { ICrossPaymentModule } from \"../../common/admin/interfaces/ICrossPaymentModule.sol\";\n\ninterface ILaunchPadFactory {\n    struct StoreLaunchPadInput {\n        ILaunchPadCommon.LaunchPadType launchPadType;\n        address launchPadAddress;\n        address owner;\n        address referrer;\n    }\n\n    function addInvestorToLaunchPad(address investor) external;\n    function createLaunchPad(ILaunchPadCommon.CreateLaunchPadInput memory input) external payable;\n    function createLaunchPadWithPaymentSignature(\n        ILaunchPadCommon.CreateLaunchPadInput memory storeInput,\n        ICrossPaymentModule.CrossPaymentSignatureInput memory crossPaymentSignatureInput\n    ) external;\n}\n"
    },
    "contracts/launchpad/interfaces/ILaunchPadProject.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ILaunchPadCommon } from \"./ILaunchPadCommon.sol\";\n\ninterface ILaunchPadProject {\n    struct PurchasedInfo {\n        uint256 purchasedTokenAmount;\n        uint256 claimedTokenAmount;\n        uint256 paidTokenAmount;\n    }\n\n    struct BuyTokenInput {\n        uint256 tokenAmount;\n        uint256 tier;\n        uint256 nonce;\n        uint256 deadline;\n        bytes signature;\n    }\n\n    struct ClaimTokenWithSuperchargerInput {\n        uint256 timestamp;\n        uint256 deadline;\n        bytes signature;\n    }\n\n    struct RefundWithSuperchargerInput {\n        uint256 timestamp;\n        uint256 deadline;\n        bytes signature;\n    }\n\n    function buyTokens(uint256 tokenAmount) external payable;\n\n    function buyTokensWithSupercharger(BuyTokenInput memory input) external payable;\n\n    function reserveTokens(address user, uint256 tokenAmount, uint256 sourceChainId, uint256 paymentIndex, bytes memory signature) external;\n\n    function processRefund(address user, uint256 tokenAmount, bytes memory signature) external;\n\n    function processRefundOnTokenCreationExpired(address user, uint256 tokenAmount, bytes memory signature) external;\n\n    function processRefundOnSoftCapFailure(address user, bytes memory signature) external;\n\n    function checkSignature(address wallet, uint256 tier, uint256 nonce, uint256 deadline, bytes memory signature) external view;\n\n    function checkSignatureForCrossPayment(address wallet, uint256 amount, uint256 sourceChainId, uint256 paymentIndex, bytes memory signature) external view;\n\n    function checkSignatureForRefund(address wallet, uint256 amount, bytes memory signature) external view;\n\n    function claimTokens() external;\n\n    function claimTokensWithSupercharger(ILaunchPadProject.ClaimTokenWithSuperchargerInput memory input) external;\n\n    function getAllInvestors() external view returns (address[] memory);\n\n    function getCurrentTier() external view returns (uint256);\n\n    function getFeeShare() external view returns (uint256);\n\n    function getHardCapPerTier(uint256 tier) external view returns (uint256);\n\n    function getInvestorAddressByIndex(uint256 index) external view returns (address);\n\n    function getInvestorsLength() external view returns (uint256);\n\n    function getLaunchPadAddress() external view returns (address);\n\n    function getLaunchPadInfo() external view returns (ILaunchPadCommon.LaunchPadInfo memory);\n\n    function getMaxInvestPerWalletPerTier(uint256 tier) external view returns (uint256);\n\n    function getNextNonce(address user) external view returns (uint256);\n\n    function getProjectOwnerRole() external view returns (bytes32);\n\n    function getPurchasedInfoByUser(address user) external view returns (PurchasedInfo memory);\n\n    function getReleasedTokensPercentage() external view returns (uint256);\n\n    function getReleaseSchedule() external view returns (ILaunchPadCommon.ReleaseScheduleV2[] memory);\n\n    function getTokensAvailableToBeClaimed(address user) external view returns (uint256);\n\n    function getTokenCreationDeadline() external view returns (uint256);\n\n    function getTotalRaised() external view returns (uint256);\n\n    function getInvestorsRefundedCount() external view returns (uint256);\n\n    function getMaxInvestorsToRefund() external view returns (uint256);\n\n    function getRemainingInvestorsToRefund() external view returns (uint256);\n\n    function setMaxInvestorsToRefund(uint256 maxInvestorsUpdate) external;\n\n    function isSuperchargerEnabled() external view returns (bool);\n\n    function recoverSigner(bytes32 message, bytes memory signature) external view returns (address);\n\n    function refund(uint256 tokenAmount) external;\n\n    function refundOnSoftCapFailure() external;\n\n    function refundOnTokenCreationExpired(uint256 tokenAmount) external;\n\n    function refundAllInvestors() external;\n\n    function refundOnUnstakedDuringSales(ILaunchPadProject.RefundWithSuperchargerInput memory input) external;\n\n    function tokenDecimals() external view returns (uint256);\n\n    function totalTokensClaimed() external view returns (uint256);\n\n    function totalTokensSold() external view returns (uint256);\n}\n"
    },
    "contracts/launchpad/interfaces/ILaunchPadProjectAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ILaunchPadCommon } from \"./ILaunchPadCommon.sol\";\n\ninterface ILaunchPadProjectAdmin {\n    function setSupercharger(bool isSuperchargerEnabled) external;\n\n    function updateStartTimestamp(uint256 newStartTimestamp) external;\n\n    function extendDuration(uint256 durationIncrease) external;\n\n    function updateReleaseSchedule(ILaunchPadCommon.ReleaseScheduleV2[] memory releaseSchedule) external;\n\n    function setTokenAddress(address tokenAddress) external;\n\n    function withdrawFees() external;\n\n    function withdrawTokens(address tokenAddress) external;\n\n    function withdrawTokensToRecipient(address tokenAddress, address recipient) external;\n\n    /** EVENTS */\n\n    event SuperchargerUpdated(bool isSuperchargerEnabled);\n    event StartTimestampUpdated(uint256 newStartTimestamp);\n    event DurationExtended(uint256 durationIncrease);\n    event ReleaseScheduleUpdated(ILaunchPadCommon.ReleaseScheduleV2[] releaseSchedule);\n    event TokenAddressUpdated(address tokenAddress);\n    event FeesWithdrawn(uint256 feeAmount);\n    event TokensWithdrawn(address tokenAddress);\n    event TokensWithdrawnToRecipient(address tokenAddress, address recipient);\n\n    /** ERRORS */\n    error UPDATE_RELEASE_SCHEDULE_ERROR(string errorMessage);\n    error UPDATE_START_TIMESTAMP_ERROR(string errorMessage);\n    error EXTEND_DURATION_ERROR(string errorMessage);\n}\n"
    },
    "contracts/launchpad/libraries/LibLaunchPadConsts.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nlibrary LibLaunchPadConsts {\n    bytes32 internal constant PRODUCT_ID = keccak256(\"tokenfi.launchpad\");\n    uint256 internal constant BURN_BASIS_POINTS = 5_000;\n    uint256 internal constant MAX_INVESTORS_TO_REFUND = 100;\n}\n"
    },
    "contracts/launchpad/libraries/LibLaunchPadFactoryStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { ILaunchPadCommon } from \"../interfaces/ILaunchPadCommon.sol\";\nimport { ILaunchPadFactory } from \"../interfaces/ILaunchPadFactory.sol\";\nimport { ILaunchPadProject } from \"../interfaces/ILaunchPadProject.sol\";\nimport { ILaunchPadProjectAdmin } from \"../interfaces/ILaunchPadProjectAdmin.sol\";\n\nlibrary LibLaunchPadFactoryStorage {\n    bytes32 internal constant DIAMOND_STORAGE_POSITION = keccak256(\"tokenfi.launchpad.factory.diamond.storage\");\n\n    struct DiamondStorage {\n        address[] launchPads;\n        mapping(address => address[]) launchPadsByOwner;\n        mapping(address => address[]) launchPadsByInvestor;\n        mapping(address => address) launchPadOwner;\n        mapping(address => bool) isLaunchPad;\n        mapping(address => ILaunchPadCommon.CreateErc20Input) tokenInfoByLaunchPadAddress;\n        uint256 currentBlockLaunchPadCreated;\n        uint256 currentBlockLaunchPadOwnerUpdated;\n        address _tokenLauncherERC20; // deprecated (available on Diamond itself)\n        address _tokenLauncherStore; // deprecated (available on Diamond itself)\n        address _tokenLauncherBuybackHandler; // deprecated (available on Diamond itself)\n        address launchPadProjectFacet;\n        address accessControlFacet;\n        address pausableFacet;\n        address loupeFacet;\n        address proxyFacet;\n        address launchPadProjectDiamondInit;\n        address _tokenfiToken; // deprecated (available on LaunchPadPaymentStorage)\n        address _usdToken; // deprecated (available on LaunchPadPaymentStorage)\n        address _router; // deprecated (available on LaunchPadPaymentStorage)\n        address _treasury; // deprecated (available on LaunchPadPaymentStorage)\n        address signerAddress;\n        uint256 maxTokenCreationDeadline;\n        uint256[] _superChargerMultiplierByTier; // deprecated (cause of wrong updates by v1)\n        uint256[] _superChargerHeadstartByTier; // deprecated (cause of wrong updates by v1)\n        uint256[] _superChargerTokensPercByTier; // deprecated (cause of wrong updates by v1)\n        uint256 maxDurationIncrement;\n        address launchPadProjectAdminFacet;\n        address launchPadImplementation;\n        uint256[] superChargerMultiplierByTier;\n        uint256[] superChargerHeadstartByTier;\n        uint256[] superChargerTokensPercByTier;\n        address diamondCutWithApprovalFacet;\n    }\n\n    event LaunchPadCreated(uint256 indexed previousBlock, ILaunchPadFactory.StoreLaunchPadInput launchPad);\n    event LaunchPadOwnerUpdated(uint256 indexed previousBlock, address owner, address newOwner);\n    event MaxTokenCreationDeadlineUpdated(uint256 indexed previousMaxTokenCreationDeadline, uint256 newMaxTokenCreationDeadline);\n    event LaunchpadRemoved(address indexed launchPadAddress, address indexed owner);\n    event SignerAddressUpdated(address indexed previousSignerAddress, address indexed newSignerAddress);\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    function getLaunchPadProjectSelectors() internal pure returns (bytes4[] memory) {\n        bytes4[] memory functionSelectors = new bytes4[](38);\n        functionSelectors[0] = ILaunchPadProject.buyTokens.selector;\n        functionSelectors[1] = ILaunchPadProject.buyTokensWithSupercharger.selector;\n        functionSelectors[2] = ILaunchPadProject.checkSignature.selector;\n        functionSelectors[3] = ILaunchPadProject.claimTokens.selector;\n        functionSelectors[4] = ILaunchPadProject.getAllInvestors.selector;\n        functionSelectors[5] = ILaunchPadProject.getCurrentTier.selector;\n        functionSelectors[6] = ILaunchPadProject.getFeeShare.selector;\n        functionSelectors[7] = ILaunchPadProject.getHardCapPerTier.selector;\n        functionSelectors[8] = ILaunchPadProject.getInvestorAddressByIndex.selector;\n        functionSelectors[9] = ILaunchPadProject.getInvestorsLength.selector;\n        functionSelectors[10] = ILaunchPadProject.getLaunchPadAddress.selector;\n        functionSelectors[11] = ILaunchPadProject.getLaunchPadInfo.selector;\n        functionSelectors[12] = ILaunchPadProject.getMaxInvestPerWalletPerTier.selector;\n        functionSelectors[13] = ILaunchPadProject.getNextNonce.selector;\n        functionSelectors[14] = ILaunchPadProject.getProjectOwnerRole.selector;\n        functionSelectors[15] = ILaunchPadProject.getPurchasedInfoByUser.selector;\n        functionSelectors[16] = ILaunchPadProject.getReleasedTokensPercentage.selector;\n        functionSelectors[17] = ILaunchPadProject.getReleaseSchedule.selector;\n        functionSelectors[18] = ILaunchPadProject.getTokensAvailableToBeClaimed.selector;\n        functionSelectors[19] = ILaunchPadProject.getTokenCreationDeadline.selector;\n        functionSelectors[20] = ILaunchPadProject.getTotalRaised.selector;\n        functionSelectors[21] = ILaunchPadProject.isSuperchargerEnabled.selector;\n        functionSelectors[22] = ILaunchPadProject.recoverSigner.selector;\n        functionSelectors[23] = ILaunchPadProject.refund.selector;\n        functionSelectors[24] = ILaunchPadProject.refundOnSoftCapFailure.selector;\n        functionSelectors[25] = ILaunchPadProject.refundOnTokenCreationExpired.selector;\n        functionSelectors[26] = ILaunchPadProject.tokenDecimals.selector;\n        functionSelectors[27] = ILaunchPadProject.totalTokensClaimed.selector;\n        functionSelectors[28] = ILaunchPadProject.totalTokensSold.selector;\n        functionSelectors[29] = ILaunchPadProject.reserveTokens.selector;\n        functionSelectors[30] = ILaunchPadProject.processRefund.selector;\n        functionSelectors[31] = ILaunchPadProject.processRefundOnTokenCreationExpired.selector;\n        functionSelectors[32] = ILaunchPadProject.processRefundOnSoftCapFailure.selector;\n        functionSelectors[33] = ILaunchPadProject.refundAllInvestors.selector;\n        functionSelectors[34] = ILaunchPadProject.getInvestorsRefundedCount.selector;\n        functionSelectors[35] = ILaunchPadProject.getMaxInvestorsToRefund.selector;\n        functionSelectors[36] = ILaunchPadProject.setMaxInvestorsToRefund.selector;\n        functionSelectors[37] = ILaunchPadProject.getRemainingInvestorsToRefund.selector;\n\n        return functionSelectors;\n    }\n\n    function getLaunchPadProjectAdminSelectors() internal pure returns (bytes4[] memory) {\n        bytes4[] memory functionSelectors = new bytes4[](9);\n        functionSelectors[0] = ILaunchPadProjectAdmin.setSupercharger.selector;\n        functionSelectors[1] = ILaunchPadProjectAdmin.setTokenAddress.selector;\n        functionSelectors[2] = ILaunchPadProjectAdmin.withdrawFees.selector;\n        functionSelectors[3] = ILaunchPadProjectAdmin.withdrawTokens.selector;\n        functionSelectors[4] = ILaunchPadProjectAdmin.withdrawTokensToRecipient.selector;\n        functionSelectors[5] = ILaunchPadProjectAdmin.updateStartTimestamp.selector;\n        functionSelectors[6] = ILaunchPadProjectAdmin.extendDuration.selector;\n        functionSelectors[7] = ILaunchPadProjectAdmin.updateReleaseSchedule.selector;\n\n        return functionSelectors;\n    }\n}\n"
    },
    "contracts/launchpad/upgradeInitializers/LaunchPadFactoryDiamondInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport { AccessControl } from \"@solidstate/contracts/access/access_control/AccessControl.sol\";\n\nimport { LibLaunchPadFactoryStorage } from \"../libraries/LibLaunchPadFactoryStorage.sol\";\nimport { LibLaunchPadConsts } from \"../libraries/LibLaunchPadConsts.sol\";\nimport { LibAccessControl } from \"../../common/admin/libraries/LibAccessControl.sol\";\nimport { IWhitelistFacet } from \"../../common/admin/interfaces/IWhitelistFacet.sol\";\nimport { IFacetsManagerFacet } from \"../../common/admin/interfaces/IFacetsManagerFacet.sol\";\n\ncontract LaunchPadFactoryDiamondInit is AccessControl {\n    struct InitDiamondArgs {\n        address accessControlFacet;\n        address pausableFacet;\n        address loupeFacet;\n        address proxyFacet;\n        address launchPadProjectFacet;\n        address launchPadProjectDiamondInit;\n        address signerAddress;\n        uint256 maxTokenCreationDeadline;\n        bool enableWhitelist;\n        address[] whitelisted;\n        bool overrideSuperchargerTiers;\n        uint256[] superChargerMultipliers;\n        uint256[] superChargerHeadstarts;\n        uint256[] superChargerTokensPercentages;\n        uint256 maxDurationIncrement;\n        address launchPadProjectAdminFacet;\n        address launchPadImplementation;\n        address diamondCutWithApprovalFacet;\n        address diamontProjectUpdate;\n    }\n\n    function init(InitDiamondArgs memory _input) external {\n        LibLaunchPadFactoryStorage.DiamondStorage storage ds = LibLaunchPadFactoryStorage.diamondStorage();\n\n        ds.launchPadProjectFacet = _input.launchPadProjectFacet;\n        ds.accessControlFacet = _input.accessControlFacet;\n        ds.pausableFacet = _input.pausableFacet;\n        ds.loupeFacet = _input.loupeFacet;\n        ds.proxyFacet = _input.proxyFacet;\n        ds.launchPadProjectDiamondInit = _input.launchPadProjectDiamondInit;\n        ds.maxTokenCreationDeadline = _input.maxTokenCreationDeadline;\n        ds.signerAddress = _input.signerAddress;\n        ds.maxDurationIncrement = _input.maxDurationIncrement;\n        ds.launchPadProjectAdminFacet = _input.launchPadProjectAdminFacet;\n        ds.launchPadImplementation = _input.launchPadImplementation;\n        ds.diamondCutWithApprovalFacet = _input.diamondCutWithApprovalFacet;\n\n        // Approve facets\n        address[] memory facets = new address[](9);\n        facets[0] = _input.accessControlFacet;\n        facets[1] = _input.pausableFacet;\n        facets[2] = _input.loupeFacet;\n        facets[3] = _input.proxyFacet;\n        facets[4] = _input.launchPadProjectFacet;\n        facets[5] = _input.launchPadProjectAdminFacet;\n        facets[6] = _input.launchPadProjectDiamondInit;\n        facets[7] = _input.diamondCutWithApprovalFacet;\n        facets[8] = _input.diamontProjectUpdate;\n\n        IFacetsManagerFacet(address(this)).approveFacets(facets);\n\n        // Deprecated fields\n        // ds._tokenLauncherERC20 = address(0);\n        // ds._tokenLauncherStore = address(0);\n        // ds._tokenLauncherBuybackHandler = address(0);\n        ds._tokenfiToken = address(0);\n        ds._usdToken = address(0);\n        ds._router = address(0);\n        ds._treasury = address(0);\n\n        // Supercharger setup\n        if (_input.overrideSuperchargerTiers) {\n            if (ds.superChargerMultiplierByTier.length > 0) {\n                delete ds.superChargerMultiplierByTier;\n                delete ds.superChargerHeadstartByTier;\n                delete ds.superChargerTokensPercByTier;\n            }\n            for (uint256 i = 0; i < _input.superChargerMultipliers.length; i++) {\n                ds.superChargerMultiplierByTier.push(_input.superChargerMultipliers[i]);\n                ds.superChargerHeadstartByTier.push(_input.superChargerHeadstarts[i]);\n                ds.superChargerTokensPercByTier.push(_input.superChargerTokensPercentages[i]);\n            }\n        }\n\n        _grantRole(LibAccessControl.WHITELIST_ADMIN_ROLE, msg.sender);\n\n        if (_input.enableWhitelist) {\n            IWhitelistFacet(address(this)).setWhitelistEnabled(true, LibLaunchPadConsts.PRODUCT_ID);\n            // whitelist users\n            for (uint256 i = 0; i < _input.whitelisted.length; i++) {\n                _grantRole(LibAccessControl.WHITELISTED_ROLE, _input.whitelisted[i]);\n            }\n        }\n    }\n}\n"
    }
  }
}}