{{
  "language": "Solidity",
  "sources": {
    "src/Inbox.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.4;\n\nimport {Registry} from \"./Registry.sol\";\nimport {Coordinated} from \"./utility/Coordinated.sol\";\n\n/*//////////////////////////////////////////////////////////////\n                            PUBLIC STRUCTS\n//////////////////////////////////////////////////////////////*/\n\n/// @notice An inbox item contains data about a compute response\n/// @dev An inbox item must have an associated immutable `timestamp` of when it was first recorded\n/// @dev An inbox item must have a `subscriptionId` and an `interval` if it is storing the response to a `Subscription`\n/// @dev An inbox item may optionally have an `input`, `output`, and `proof` (compute response parameters)\n/// @dev Tightly-packed struct:\n///     - [timestamp, subscriptionId, interval]: [32, 32, 32] = 96\n//      - [input, output, proof] = dynamic\nstruct InboxItem {\n    uint32 timestamp;\n    uint32 subscriptionId;\n    uint32 interval;\n    bytes input;\n    bytes output;\n    bytes proof;\n}\n\n/// @title Inbox\n/// @notice Optionally stores container compute responses\n/// @dev Inherits `Coordinated` to use `onlyCoordinator` modifier for coordinator-permissioned functions\n/// @dev Allows `Coordinator` to store compute responses for lazy consumption with associated `Subscription`(s)\n/// @dev Allows any address to store compute responses for lazy consumptions without associated `Subscription`(s)\ncontract Inbox is Coordinated {\n    /*//////////////////////////////////////////////////////////////\n                                MUTABLE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice containerId => delivering node address => array of delivered compute responses\n    /// @dev Notice that validation of an `InboxItem` corresponding to a `containerId` is left to a downstream consumer\n    /// @dev Even though we have a `read` function for `items`, we keep visbility `public` because it may be useful to collect `InboxItem[]` length\n    mapping(bytes32 => mapping(address => InboxItem[])) public items;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Emitted when a new InboxItem is added\n    /// @param containerId compute container ID\n    /// @param node delivering node address\n    /// @param index index of newly-added inbox item\n    event NewInboxItem(bytes32 indexed containerId, address indexed node, uint256 index);\n\n    /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Initializes new Inbox\n    /// @param registry registry contract\n    constructor(Registry registry) Coordinated(registry) {}\n\n    /*//////////////////////////////////////////////////////////////\n                           INTERNAL FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Allows pushing an `InboxItem` to `items`\n    /// @param containerId compute container ID\n    /// @param node delivering node address\n    /// @param subscriptionId optional associated subscription ID (`0` if none)\n    /// @param interval optional associated subscription interval (`0` if none)\n    /// @param input optional compute container input\n    /// @param output optional compute container output\n    /// @param proof optional compute container proof\n    /// @return index of newly-added inbox item\n    function _write(\n        bytes32 containerId,\n        address node,\n        uint32 subscriptionId,\n        uint32 interval,\n        bytes calldata input,\n        bytes calldata output,\n        bytes calldata proof\n    ) internal returns (uint256) {\n        // Push new inbox item to items store\n        items[containerId][node].push(\n            InboxItem({\n                timestamp: uint32(block.timestamp),\n                subscriptionId: subscriptionId,\n                interval: interval,\n                input: input,\n                output: output,\n                proof: proof\n            })\n        );\n\n        // Collect index of newly-added inbox item\n        uint256 index = items[containerId][node].length - 1;\n\n        // Emit newly-added inbox item\n        emit NewInboxItem(containerId, node, index);\n\n        // Explicitly return index\n        return index;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Allows any address to optimistically deliver compute responses\n    /// @dev Zeroes out `subscriptionId` and `interval` since compute response is not associated to a subscription request\n    /// @param containerId compute container ID\n    /// @param input optional compute container input\n    /// @param output optional compute container output\n    /// @param proof optional compute container proof\n    /// @return index of newly-added inbox item\n    function write(bytes32 containerId, bytes calldata input, bytes calldata output, bytes calldata proof)\n        external\n        returns (uint256)\n    {\n        return _write(containerId, msg.sender, 0, 0, input, output, proof);\n    }\n\n    /// @notice Allows `Coordinator` to store container compute response during `deliverCompute()` execution\n    /// @dev `node` address is explicitly passed because `tx.origin` may not be accurate\n    /// @dev `msg.sender` must be `address(COORDINATOR)` for authenticated write (storing subscriptionId, interval)\n    /// @param containerId compute container ID\n    /// @param node delivering node address\n    /// @param subscriptionId optional associated subscription ID (`0` if none)\n    /// @param interval optional associated subscription interval (`0` if none)\n    /// @param input optional compute container input\n    /// @param output optional compute container output\n    /// @param proof optional compute container proof\n    /// @return index of newly-added inbox item\n    function writeViaCoordinator(\n        bytes32 containerId,\n        address node,\n        uint32 subscriptionId,\n        uint32 interval,\n        bytes calldata input,\n        bytes calldata output,\n        bytes calldata proof\n    ) external onlyCoordinator returns (uint256) {\n        return _write(containerId, node, subscriptionId, interval, input, output, proof);\n    }\n\n    /// @notice Read a stored `InboxItem`\n    /// @dev By default, structs as values in public mappings return destructured parameters\n    /// @dev This function allows returning a coerced `InboxItem` type instead of destructured parameters\n    /// @param containerId compute container ID\n    /// @param node delivering node address\n    /// @param index item index\n    /// @return inbox item\n    function read(bytes32 containerId, address node, uint256 index) external view returns (InboxItem memory) {\n        return items[containerId][node][index];\n    }\n}\n"
    },
    "src/Registry.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.4;\n\n/// @title Registry\n/// @notice Allows registering Infernet contracts for inter-contract discovery\n/// @dev Requires deploy-time decleration of contract addresses\n/// @dev Immutable with no upgradeability; used only for discovery\ncontract Registry {\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Coordinator address\n    address public immutable COORDINATOR;\n\n    /// @notice Inbox address\n    address public immutable INBOX;\n\n    /// @notice Reader address\n    address public immutable READER;\n\n    /// @notice Fee registry address\n    address public immutable FEE;\n\n    /// @notice Wallet factory address\n    address public immutable WALLET_FACTORY;\n\n    /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Initializes new Registry\n    /// @dev Requires pre-computing expected deployed addresses\n    /// @param coordinator Coordinator address\n    /// @param inbox Inbox address\n    /// @param reader Reader address\n    /// @param fee Fee registry address\n    /// @param walletFactory Wallet factory address\n    constructor(address coordinator, address inbox, address reader, address fee, address walletFactory) {\n        COORDINATOR = coordinator;\n        INBOX = inbox;\n        READER = reader;\n        FEE = fee;\n        WALLET_FACTORY = walletFactory;\n    }\n}\n"
    },
    "src/utility/Coordinated.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.4;\n\nimport {Registry} from \"../Registry.sol\";\n\n/// @title Coordinated\n/// @notice Exposes utility modifier `onlyCoordinator` for coordinator-permissioned functions\n/// @dev Best used when implementing contract needs just a msg.sender check (and not call access to coordinator itself)\nabstract contract Coordinated {\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Coordinator contract address\n    /// @dev Private to prevent conflicting with similar public variables in namespace\n    /// @dev Immutable to prevent address changes given registry deployment is immutable\n    address private immutable COORDINATOR;\n\n    /*//////////////////////////////////////////////////////////////\n                                 ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Thrown if coordinator-permissioned function is called from non-coordinator address\n    /// @dev 4-byte signature: `0x9ec853e6`\n    error NotCoordinator();\n\n    /*//////////////////////////////////////////////////////////////\n                               MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Allows calls from only the coordinator\n    modifier onlyCoordinator() {\n        if (msg.sender != COORDINATOR) {\n            revert NotCoordinator();\n        }\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Initializes new Coordinated\n    /// @param registry registry contract\n    constructor(Registry registry) {\n        // Collect coordinator address from registry\n        COORDINATOR = registry.COORDINATOR();\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "solady/=lib/solady/src/",
      "forge-std/=lib/forge-std/src/",
      "weird-erc20/=lib/weird-erc20/src/",
      "ds-test/=lib/forge-std/lib/ds-test/src/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "evmVersion": "paris",
    "viaIR": true,
    "libraries": {}
  }
}}