{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "paris",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@lazy-sol/access-control-upgradeable/contracts/InitializableAccessControlCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4; // custom errors (0.8.4)\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @title Initializable Role-based Access Control Core (I-RBAC-C)\n *\n * @notice Access control smart contract provides an API to check\n *      if a specific operation is permitted globally and/or\n *      if a particular user has a permission to execute it.\n *\n * @notice This contract is inherited by other contracts requiring the role-based access control (RBAC)\n *      protection for the restricted access functions\n *\n * @notice It deals with two main entities: features and roles.\n *\n * @notice Features are designed to be used to enable/disable public functions\n *      of the smart contract (used by a wide audience).\n * @notice User roles are designed to control the access to restricted functions\n *      of the smart contract (used by a limited set of maintainers).\n *\n * @notice Terms \"role\", \"permissions\" and \"set of permissions\" have equal meaning\n *      in the documentation text and may be used interchangeably.\n * @notice Terms \"permission\", \"single permission\" implies only one permission bit set.\n *\n * @notice Access manager is a special role which allows to grant/revoke other roles.\n *      Access managers can only grant/revoke permissions which they have themselves.\n *      As an example, access manager with no other roles set can only grant/revoke its own\n *      access manager permission and nothing else.\n *\n * @notice Access manager permission should be treated carefully, as a super admin permission:\n *      Access manager with even no other permission can interfere with another account by\n *      granting own access manager permission to it and effectively creating more powerful\n *      permission set than its own.\n *\n * @dev Both current and OpenZeppelin AccessControl implementations feature a similar API\n *      to check/know \"who is allowed to do this thing\".\n * @dev Zeppelin implementation is more flexible:\n *      - it allows setting unlimited number of roles, while current is limited to 256 different roles\n *      - it allows setting an admin for each role, while current allows having only one global admin\n * @dev Current implementation is more lightweight:\n *      - it uses only 1 bit per role, while Zeppelin uses 256 bits\n *      - it allows setting up to 256 roles at once, in a single transaction, while Zeppelin allows\n *        setting only one role in a single transaction\n *\n * @dev This smart contract is designed to be inherited by other\n *      smart contracts which require access control management capabilities.\n *\n * @dev Access manager permission has a bit 255 set.\n *      This bit must not be used by inheriting contracts for any other permissions/features.\n *\n * @dev This is an initializable version of the RBAC, based on Zeppelin implementation,\n *      it can be used for EIP-1167 minimal proxies, for ERC1967 proxies, etc.\n *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#Clones\n *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\n *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\n *      see https://forum.openzeppelin.com/t/uups-proxies-tutorial-solidity-javascript/7786\n *      see https://eips.ethereum.org/EIPS/eip-1167\n *\n * @dev The 'core' version of the RBAC contract hides three rarely used external functions from the public ABI,\n *      making them internal and thus reducing the overall compiled implementation size.\n *      isFeatureEnabled() public -> _isFeatureEnabled() internal\n *      isSenderInRole() public -> _isSenderInRole() internal\n *      isOperatorInRole() public -> _isOperatorInRole() internal\n *\n * @custom:since 1.1.0\n *\n * @author Basil Gorin\n */\nabstract contract InitializableAccessControlCore is Initializable {\n\t/**\n\t * @dev Privileged addresses with defined roles/permissions\n\t * @dev In the context of ERC20/ERC721 tokens these can be permissions to\n\t *      allow minting or burning tokens, transferring on behalf and so on\n\t *\n\t * @dev Maps user address to the permissions bitmask (role), where each bit\n\t *      represents a permission\n\t * @dev Bitmask 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n\t *      represents all possible permissions\n\t * @dev 'This' address mapping represents global features of the smart contract\n\t *\n\t * @dev We keep the mapping private to prevent direct writes to it from the inheriting\n\t *      contracts, `getRole()` and `updateRole()` functions should be used instead\n\t */\n\tmapping(address => uint256) private userRoles;\n\n\t/**\n\t * @dev Empty reserved space in storage. The size of the __gap array is calculated so that\n\t *      the amount of storage used by a contract always adds up to the 50.\n\t *      See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n\t */\n\tuint256[49] private __gap;\n\n\t/**\n\t * @notice Access manager is responsible for assigning the roles to users,\n\t *      enabling/disabling global features of the smart contract\n\t * @notice Access manager can add, remove and update user roles,\n\t *      remove and update global features\n\t *\n\t * @dev Role ROLE_ACCESS_MANAGER allows modifying user roles and global features\n\t * @dev Role ROLE_ACCESS_MANAGER has single bit at position 255 enabled\n\t */\n\tuint256 public constant ROLE_ACCESS_MANAGER = 0x8000000000000000000000000000000000000000000000000000000000000000;\n\n\t/**\n\t * @notice Upgrade manager is responsible for smart contract upgrades,\n\t *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\n\t *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\n\t *\n\t * @dev Role ROLE_UPGRADE_MANAGER allows passing the _authorizeUpgrade() check\n\t * @dev Role ROLE_UPGRADE_MANAGER has single bit at position 254 enabled\n\t */\n\tuint256 public constant ROLE_UPGRADE_MANAGER = 0x4000000000000000000000000000000000000000000000000000000000000000;\n\n\t/**\n\t * @dev Bitmask representing all the possible permissions (super admin role)\n\t * @dev Has all the bits are enabled (2^256 - 1 value)\n\t */\n\tuint256 internal constant FULL_PRIVILEGES_MASK = type(uint256).max; // before 0.8.0: uint256(-1) overflows to 0xFFFF...\n\n\t/**\n\t * @notice Thrown when a function is executed by an account that does not have\n\t *      the required access permission(s) (role)\n\t *\n\t * @dev This error is used to enforce role-based access control (RBAC) restrictions\n\t */\n\terror AccessDenied();\n\n\t/**\n\t * @dev Fired in updateRole() and updateFeatures()\n\t *\n\t * @param operator address which was granted/revoked permissions\n\t * @param requested permissions requested\n\t * @param assigned permissions effectively set\n\t */\n\tevent RoleUpdated(address indexed operator, uint256 requested, uint256 assigned);\n\n\t/**\n\t * @notice Function modifier making a function defined as public behave as restricted\n\t *      (so that only a pre-configured set of accounts can execute it)\n\t *\n\t * @param role the role transaction executor is required to have;\n\t *      the function throws an \"access denied\" exception if this condition is not met\n\t */\n\tmodifier restrictedTo(uint256 role) {\n\t\t// verify the access permission\n\t\t_requireSenderInRole(role);\n\n\t\t// execute the rest of the function\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Creates/deploys the RBAC implementation to be used in a proxy\n\t *\n\t * @dev Note:\n\t *      the implementation is already initialized and\n\t *      `_postConstruct` is not executable on the implementation\n\t *      `_postConstruct` is still available in the context of a proxy\n\t *      and should be executed on the proxy deployment (in the same tx)\n\t */\n\tconstructor() initializer {}\n\n\t/**\n\t * @dev Contract initializer, sets the contract owner to have full privileges\n\t *\n\t * @dev Can be executed only once, reverts when executed second time\n\t *\n\t * @dev IMPORTANT:\n\t *      this function SHOULD be executed during proxy deployment (in the same transaction)\n\t *\n\t * @param _owner smart contract owner having full privileges, can be zero\n\t * @param _features initial features mask of the contract, can be zero\n\t */\n\tfunction _postConstruct(address _owner, uint256 _features) internal virtual onlyInitializing {\n\t\t// grant owner full privileges\n\t\t__setRole(_owner, FULL_PRIVILEGES_MASK, FULL_PRIVILEGES_MASK);\n\t\t// update initial features bitmask\n\t\t__setRole(address(this), _features, _features);\n\t}\n\n\t/**\n\t * @dev Highest version that has been initialized.\n\t *      Non-zero value means contract was already initialized.\n\t * @dev see {Initializable}, {reinitializer}.\n\t *\n\t * @return highest version that has been initialized\n\t */\n\tfunction getInitializedVersion() public view returns(uint64) {\n\t\t// delegate to `_getInitializedVersion`\n\t\treturn _getInitializedVersion();\n\t}\n\n\t/**\n\t * @notice Retrieves globally set of features enabled\n\t *\n\t * @dev Effectively reads userRoles role for the contract itself\n\t *\n\t * @return 256-bit bitmask of the features enabled\n\t */\n\tfunction features() public view returns (uint256) {\n\t\t// features are stored in 'this' address mapping of `userRoles`\n\t\treturn getRole(address(this));\n\t}\n\n\t/**\n\t * @notice Updates set of the globally enabled features (`features`),\n\t *      taking into account sender's permissions\n\t *\n\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n\t * @dev Function is left for backward compatibility with older versions\n\t *\n\t * @param _mask bitmask representing a set of features to enable/disable\n\t */\n\tfunction updateFeatures(uint256 _mask) public {\n\t\t// delegate call to `updateRole`\n\t\tupdateRole(address(this), _mask);\n\t}\n\n\t/**\n\t * @notice Reads the permissions (role) for a given user from the `userRoles` mapping\n\t *      (privileged addresses with defined roles/permissions)\n\t * @notice In the context of ERC20/ERC721 tokens these can be permissions to\n\t *      allow minting or burning tokens, transferring on behalf and so on\n\t *\n\t * @dev Having a simple getter instead of making the mapping public\n\t *      allows enforcing the encapsulation of the mapping and protects from\n\t *      writing to it directly in the inheriting smart contracts\n\t *\n\t * @param operator address of a user to read permissions for,\n\t *      or self address to read global features of the smart contract\n\t */\n\tfunction getRole(address operator) public view returns(uint256) {\n\t\t// read the value from `userRoles` and return\n\t\treturn userRoles[operator];\n\t}\n\n\t/**\n\t * @notice Updates set of permissions (role) for a given user,\n\t *      taking into account sender's permissions.\n\t *\n\t * @dev Setting role to zero is equivalent to removing an all permissions\n\t * @dev Setting role to `FULL_PRIVILEGES_MASK` is equivalent to\n\t *      copying senders' permissions (role) to the user\n\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n\t *\n\t * @param operator address of a user to alter permissions for,\n\t *       or self address to alter global features of the smart contract\n\t * @param role bitmask representing a set of permissions to\n\t *      enable/disable for a user specified\n\t */\n\tfunction updateRole(address operator, uint256 role) public {\n\t\t// caller must have a permission to update user roles\n\t\t_requireSenderInRole(ROLE_ACCESS_MANAGER);\n\n\t\t// evaluate the role and reassign it\n\t\t__setRole(operator, role, _evaluateBy(msg.sender, getRole(operator), role));\n\t}\n\n\t/**\n\t * @notice Determines the permission bitmask an operator can set on the\n\t *      target permission set\n\t * @notice Used to calculate the permission bitmask to be set when requested\n\t *     in `updateRole` and `updateFeatures` functions\n\t *\n\t * @dev Calculated based on:\n\t *      1) operator's own permission set read from userRoles[operator]\n\t *      2) target permission set - what is already set on the target\n\t *      3) desired permission set - what do we want set target to\n\t *\n\t * @dev Corner cases:\n\t *      1) Operator is super admin and its permission set is `FULL_PRIVILEGES_MASK`:\n\t *        `desired` bitset is returned regardless of the `target` permission set value\n\t *        (what operator sets is what they get)\n\t *      2) Operator with no permissions (zero bitset):\n\t *        `target` bitset is returned regardless of the `desired` value\n\t *        (operator has no authority and cannot modify anything)\n\t *\n\t * @dev Example:\n\t *      Consider an operator with the permissions bitmask     00001111\n\t *      is about to modify the target permission set          01010101\n\t *      Operator wants to set that permission set to          00110011\n\t *      Based on their role, an operator has the permissions\n\t *      to update only lowest 4 bits on the target, meaning that\n\t *      high 4 bits of the target set in this example is left\n\t *      unchanged and low 4 bits get changed as desired:      01010011\n\t *\n\t * @param operator address of the contract operator which is about to set the permissions\n\t * @param target input set of permissions to operator is going to modify\n\t * @param desired desired set of permissions operator would like to set\n\t * @return resulting set of permissions given operator will set\n\t */\n\tfunction _evaluateBy(address operator, uint256 target, uint256 desired) internal view returns (uint256) {\n\t\t// read operator's permissions\n\t\tuint256 p = getRole(operator);\n\n\t\t// taking into account operator's permissions,\n\t\t// 1) enable the permissions desired on the `target`\n\t\ttarget |= p & desired;\n\t\t// 2) disable the permissions desired on the `target`\n\t\ttarget &= FULL_PRIVILEGES_MASK ^ (p & (FULL_PRIVILEGES_MASK ^ desired));\n\n\t\t// return calculated result\n\t\treturn target;\n\t}\n\n\t/**\n\t * @notice Ensures that the transaction sender has the required access permission(s) (role)\n\t *\n\t * @dev Reverts with an `AccessDenied` error if the sender does not have the required role\n\t *\n\t * @param required the set of permissions (role) that the transaction sender is required to have\n\t */\n\tfunction _requireSenderInRole(uint256 required) internal view {\n\t\t// check if the transaction has the required permission(s),\n\t\t// reverting with the \"access denied\" error if not\n\t\t_requireAccessCondition(_isSenderInRole(required));\n\t}\n\n\t/**\n\t * @notice Ensures that a specific condition is met\n\t *\n\t * @dev Reverts with an `AccessDenied` error if the condition is not met\n\t *\n\t * @param condition the condition that needs to be true for the function to proceed\n\t */\n\tfunction _requireAccessCondition(bool condition) internal pure {\n\t\t// check if the condition holds\n\t\tif(!condition) {\n\t\t\t// revert with the \"access denied\" error if not\n\t\t\trevert AccessDenied();\n\t\t}\n\t}\n\n\t/**\n\t * @notice Checks if requested set of features is enabled globally on the contract\n\t *\n\t * @param required set of features to check against\n\t * @return true if all the features requested are enabled, false otherwise\n\t */\n\tfunction _isFeatureEnabled(uint256 required) internal view returns (bool) {\n\t\t// delegate call to `__hasRole`, passing `features` property\n\t\treturn __hasRole(features(), required);\n\t}\n\n\t/**\n\t * @notice Checks if transaction sender `msg.sender` has all the permissions required\n\t *\n\t * @param required set of permissions (role) to check against\n\t * @return true if all the permissions requested are enabled, false otherwise\n\t */\n\tfunction _isSenderInRole(uint256 required) internal view returns (bool) {\n\t\t// delegate call to `isOperatorInRole`, passing transaction sender\n\t\treturn _isOperatorInRole(msg.sender, required);\n\t}\n\n\t/**\n\t * @notice Checks if operator has all the permissions (role) required\n\t *\n\t * @param operator address of the user to check role for\n\t * @param required set of permissions (role) to check\n\t * @return true if all the permissions requested are enabled, false otherwise\n\t */\n\tfunction _isOperatorInRole(address operator, uint256 required) internal view returns (bool) {\n\t\t// delegate call to `__hasRole`, passing operator's permissions (role)\n\t\treturn __hasRole(getRole(operator), required);\n\t}\n\n\t/**\n\t * @dev Sets the `assignedRole` role to the operator, logs both `requestedRole` and `actualRole`\n\t *\n\t * @dev Unsafe:\n\t *      provides direct write access to `userRoles` mapping without any security checks,\n\t *      doesn't verify the executor (msg.sender) permissions,\n\t *      must be kept private at all times\n\t *\n\t * @param operator address of a user to alter permissions for,\n\t *       or self address to alter global features of the smart contract\n\t * @param requestedRole bitmask representing a set of permissions requested\n\t *      to be enabled/disabled for a user specified, used only to be logged into event\n\t * @param assignedRole bitmask representing a set of permissions to\n\t *      enable/disable for a user specified, used to update the mapping and to be logged into event\n\t */\n\tfunction __setRole(address operator, uint256 requestedRole, uint256 assignedRole) private {\n\t\t// assign the role to the operator\n\t\tuserRoles[operator] = assignedRole;\n\n\t\t// fire an event\n\t\temit RoleUpdated(operator, requestedRole, assignedRole);\n\t}\n\n\t/**\n\t * @dev Checks if role `actual` contains all the permissions required `required`\n\t *\n\t * @param actual existent role\n\t * @param required required role\n\t * @return true if actual has required role (all permissions), false otherwise\n\t */\n\tfunction __hasRole(uint256 actual, uint256 required) private pure returns (bool) {\n\t\t// check the bitmask for the role required and return the result\n\t\treturn actual & required == required;\n\t}\n}\n"
    },
    "@lazy-sol/access-control-upgradeable/contracts/UpgradeableAccessControlCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"./InitializableAccessControlCore.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/**\n * @title Upgradeable Role-based Access Control Core (U-RBAC-C) // ERC1967Proxy\n *\n * @notice Access control smart contract provides an API to check\n *      if a specific operation is permitted globally and/or\n *      if a particular user has a permission to execute it.\n *\n * @notice This contract is inherited by other contracts requiring the role-based access control (RBAC)\n *      protection for the restricted access functions\n *\n * @notice It deals with two main entities: features and roles.\n *\n * @notice Features are designed to be used to enable/disable public functions\n *      of the smart contract (used by a wide audience).\n * @notice User roles are designed to control the access to restricted functions\n *      of the smart contract (used by a limited set of maintainers).\n *\n * @notice Terms \"role\", \"permissions\" and \"set of permissions\" have equal meaning\n *      in the documentation text and may be used interchangeably.\n * @notice Terms \"permission\", \"single permission\" implies only one permission bit set.\n *\n * @notice Access manager is a special role which allows to grant/revoke other roles.\n *      Access managers can only grant/revoke permissions which they have themselves.\n *      As an example, access manager with no other roles set can only grant/revoke its own\n *      access manager permission and nothing else.\n *\n * @notice Access manager permission should be treated carefully, as a super admin permission:\n *      Access manager with even no other permission can interfere with another account by\n *      granting own access manager permission to it and effectively creating more powerful\n *      permission set than its own.\n *\n * @dev Both current and OpenZeppelin AccessControl implementations feature a similar API\n *      to check/know \"who is allowed to do this thing\".\n * @dev Zeppelin implementation is more flexible:\n *      - it allows setting unlimited number of roles, while current is limited to 256 different roles\n *      - it allows setting an admin for each role, while current allows having only one global admin\n * @dev Current implementation is more lightweight:\n *      - it uses only 1 bit per role, while Zeppelin uses 256 bits\n *      - it allows setting up to 256 roles at once, in a single transaction, while Zeppelin allows\n *        setting only one role in a single transaction\n *\n * @dev This smart contract is designed to be inherited by other\n *      smart contracts which require access control management capabilities.\n *\n * @dev Access manager permission has a bit 255 set.\n *      This bit must not be used by inheriting contracts for any other permissions/features.\n *\n * @dev This is an upgradeable version of the RBAC, based on Zeppelin implementation for ERC1967,\n *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\n *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\n *      see https://forum.openzeppelin.com/t/uups-proxies-tutorial-solidity-javascript/7786\n *\n * @dev The 'core' version of the RBAC contract hides three rarely used external functions from the public ABI,\n *      making them internal and thus reducing the overall compiled implementation size.\n *      isFeatureEnabled() public -> _isFeatureEnabled() internal\n *      isSenderInRole() public -> _isSenderInRole() internal\n *      isOperatorInRole() public -> _isOperatorInRole() internal\n *\n * @custom:since 1.1.0\n *\n * @author Basil Gorin\n */\nabstract contract UpgradeableAccessControlCore is InitializableAccessControlCore, UUPSUpgradeable {\n\t/**\n\t * @notice Returns an address of the implementation smart contract,\n\t *      see ERC1967Upgrade._getImplementation()\n\t *\n\t * @return the current implementation address\n\t */\n\tfunction getImplementation() public view virtual returns (address) {\n\t\t// delegate to `ERC1967Upgrade._getImplementation()`\n\t\treturn _getImplementation();\n\t}\n\n\t/**\n\t * @inheritdoc UUPSUpgradeable\n\t */\n\tfunction _authorizeUpgrade(address) internal virtual override {\n\t\t// caller must have a permission to upgrade the contract\n\t\t_requireSenderInRole(ROLE_UPGRADE_MANAGER);\n\t}\n}\n"
    },
    "@lazy-sol/advanced-erc20/contracts/interfaces/ERC1363Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./ERC20Spec.sol\";\nimport \"./ERC165Spec.sol\";\n\n/**\n * @title ERC1363 Interface\n *\n * @dev Interface defining a ERC1363 Payable Token contract.\n *      Implementing contracts MUST implement the ERC1363 interface as well as the ERC20 and ERC165 interfaces.\n */\ninterface ERC1363 is ERC20, ERC165  {\n\t/*\n\t * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n\t * 0xb0202a11 ===\n\t *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n\t *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n\t *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n\t *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n\t *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n\t *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n\t */\n\n\t/**\n\t * @notice Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver\n\t * @param to address The address which you want to transfer to\n\t * @param value uint256 The amount of tokens to be transferred\n\t * @return true unless throwing\n\t */\n\tfunction transferAndCall(address to, uint256 value) external returns (bool);\n\n\t/**\n\t * @notice Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver\n\t * @param to address The address which you want to transfer to\n\t * @param value uint256 The amount of tokens to be transferred\n\t * @param data bytes Additional data with no specified format, sent in call to `to`\n\t * @return true unless throwing\n\t */\n\tfunction transferAndCall(address to, uint256 value, bytes memory data) external returns (bool);\n\n\t/**\n\t * @notice Transfer tokens from one address to another and then call `onTransferReceived` on receiver\n\t * @param from address The address which you want to send tokens from\n\t * @param to address The address which you want to transfer to\n\t * @param value uint256 The amount of tokens to be transferred\n\t * @return true unless throwing\n\t */\n\tfunction transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n\t/**\n\t * @notice Transfer tokens from one address to another and then call `onTransferReceived` on receiver\n\t * @param from address The address which you want to send tokens from\n\t * @param to address The address which you want to transfer to\n\t * @param value uint256 The amount of tokens to be transferred\n\t * @param data bytes Additional data with no specified format, sent in call to `to`\n\t * @return true unless throwing\n\t */\n\tfunction transferFromAndCall(address from, address to, uint256 value, bytes memory data) external returns (bool);\n\n\t/**\n\t * @notice Approve the passed address to spend the specified amount of tokens on behalf of msg.sender\n\t * and then call `onApprovalReceived` on spender.\n\t * @param spender address The address which will spend the funds\n\t * @param value uint256 The amount of tokens to be spent\n\t */\n\tfunction approveAndCall(address spender, uint256 value) external returns (bool);\n\n\t/**\n\t * @notice Approve the passed address to spend the specified amount of tokens on behalf of msg.sender\n\t * and then call `onApprovalReceived` on spender.\n\t * @param spender address The address which will spend the funds\n\t * @param value uint256 The amount of tokens to be spent\n\t * @param data bytes Additional data with no specified format, sent in call to `spender`\n\t */\n\tfunction approveAndCall(address spender, uint256 value, bytes memory data) external returns (bool);\n}\n\n/**\n * @title ERC1363Receiver Interface\n *\n * @dev Interface for any contract that wants to support `transferAndCall` or `transferFromAndCall`\n *      from ERC1363 token contracts.\n */\ninterface ERC1363Receiver {\n\t/*\n\t * Note: the ERC-165 identifier for this interface is 0x88a7ca5c.\n\t * 0x88a7ca5c === bytes4(keccak256(\"onTransferReceived(address,address,uint256,bytes)\"))\n\t */\n\n\t/**\n\t * @notice Handle the receipt of ERC1363 tokens\n\t *\n\t * @dev Any ERC1363 smart contract calls this function on the recipient\n\t *      after a `transfer` or a `transferFrom`. This function MAY throw to revert and reject the\n\t *      transfer. Return of other than the magic value MUST result in the\n\t *      transaction being reverted.\n\t *      Note: the token contract address is always the message sender.\n\t *\n\t * @param operator address The address which called `transferAndCall` or `transferFromAndCall` function\n\t * @param from address The address which are token transferred from\n\t * @param value uint256 The amount of tokens transferred\n\t * @param data bytes Additional data with no specified format\n\t * @return `bytes4(keccak256(\"onTransferReceived(address,address,uint256,bytes)\"))`\n\t *      unless throwing\n\t */\n\tfunction onTransferReceived(address operator, address from, uint256 value, bytes memory data) external returns (bytes4);\n}\n\n/**\n * @title ERC1363Spender Interface\n *\n * @dev Interface for any contract that wants to support `approveAndCall`\n *      from ERC1363 token contracts.\n */\ninterface ERC1363Spender {\n\t/*\n\t * Note: the ERC-165 identifier for this interface is 0x7b04a2d0.\n\t * 0x7b04a2d0 === bytes4(keccak256(\"onApprovalReceived(address,uint256,bytes)\"))\n\t */\n\n\t/**\n\t * @notice Handle the approval of ERC1363 tokens\n\t *\n\t * @dev Any ERC1363 smart contract calls this function on the recipient\n\t *      after an `approve`. This function MAY throw to revert and reject the\n\t *      approval. Return of other than the magic value MUST result in the\n\t *      transaction being reverted.\n\t *      Note: the token contract address is always the message sender.\n\t *\n\t * @param owner address The address which called `approveAndCall` function\n\t * @param value uint256 The amount of tokens to be spent\n\t * @param data bytes Additional data with no specified format\n\t * @return `bytes4(keccak256(\"onApprovalReceived(address,uint256,bytes)\"))`\n\t *      unless throwing\n\t */\n\tfunction onApprovalReceived(address owner, uint256 value, bytes memory data) external returns (bytes4);\n}\n\n/**\n * @title Mintable ERC1363 Extension\n *\n * @notice Adds mint functions to the ERC1363 interface, these functions\n *      follow the same idea and logic as ERC1363 transferAndCall functions,\n *      allowing to notify the recipient ERC1363Receiver contract about the tokens received\n */\ninterface MintableERC1363 is ERC1363 {\n\t/**\n\t * @notice Mint tokens to the receiver and then call `onTransferReceived` on the receiver\n\t * @param to address The address which you want to mint to\n\t * @param value uint256 The amount of tokens to be minted\n\t * @return true unless throwing\n\t */\n\tfunction mintAndCall(address to, uint256 value) external returns (bool);\n\n\t/**\n\t * @notice Mint tokens to the receiver and then call `onTransferReceived` on the receiver\n\t * @param to address The address which you want to mint to\n\t * @param value uint256 The amount of tokens to be minted\n\t * @param data bytes Additional data with no specified format, sent in call to `to`\n\t * @return true unless throwing\n\t */\n\tfunction mintAndCall(address to, uint256 value, bytes memory data) external returns (bool);\n}\n"
    },
    "@lazy-sol/advanced-erc20/contracts/interfaces/ERC165Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title ERC-165 Standard Interface Detection\n *\n * @dev Interface of the ERC165 standard, as defined in the\n *       https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * @dev Implementers can declare support of contract interfaces,\n *      which can then be queried by others.\n *\n * @author Christian ReitwieÃŸner, Nick Johnson, Fabian Vogelsteller, Jordi Baylina, Konrad Feldmeier, William Entriken\n */\ninterface ERC165 {\n\t/**\n\t * @notice Query if a contract implements an interface\n\t *\n\t * @dev Interface identification is specified in ERC-165.\n\t *      This function uses less than 30,000 gas.\n\t *\n\t * @param interfaceID The interface identifier, as specified in ERC-165\n\t * @return `true` if the contract implements `interfaceID` and\n\t *      `interfaceID` is not 0xffffffff, `false` otherwise\n\t */\n\tfunction supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "@lazy-sol/advanced-erc20/contracts/interfaces/ERC20Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title EIP-20: ERC-20 Token Standard\n *\n * @notice The ERC-20 (Ethereum Request for Comments 20), proposed by Fabian Vogelsteller in November 2015,\n *      is a Token Standard that implements an API for tokens within Smart Contracts.\n *\n * @notice It provides functionalities like to transfer tokens from one account to another,\n *      to get the current token balance of an account and also the total supply of the token available on the network.\n *      Besides these it also has some other functionalities like to approve that an amount of\n *      token from an account can be spent by a third party account.\n *\n * @notice If a Smart Contract implements the following methods and events it can be called an ERC-20 Token\n *      Contract and, once deployed, it will be responsible to keep track of the created tokens on Ethereum.\n *\n * @notice See https://ethereum.org/en/developers/docs/standards/tokens/erc-20/\n * @notice See https://eips.ethereum.org/EIPS/eip-20\n */\ninterface ERC20 {\n\t/**\n\t * @dev Fired in transfer(), transferFrom() to indicate that token transfer happened\n\t *\n\t * @param from an address tokens were consumed from\n\t * @param to an address tokens were sent to\n\t * @param value number of tokens transferred\n\t */\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\n\t/**\n\t * @dev Fired in approve() to indicate an approval event happened\n\t *\n\t * @param owner an address which granted a permission to transfer\n\t *      tokens on its behalf\n\t * @param spender an address which received a permission to transfer\n\t *      tokens on behalf of the owner `owner`\n\t * @param value amount of tokens granted to transfer on behalf\n\t */\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n\n\t/**\n\t * @return name of the token (ex.: USD Coin)\n\t */\n\t// OPTIONAL - This method can be used to improve usability,\n\t// but interfaces and other contracts MUST NOT expect these values to be present.\n\t// function name() external view returns (string memory);\n\n\t/**\n\t * @return symbol of the token (ex.: USDC)\n\t */\n\t// OPTIONAL - This method can be used to improve usability,\n\t// but interfaces and other contracts MUST NOT expect these values to be present.\n\t// function symbol() external view returns (string memory);\n\n\t/**\n\t * @dev Returns the number of decimals used to get its user representation.\n\t *      For example, if `decimals` equals `2`, a balance of `505` tokens should\n\t *      be displayed to a user as `5,05` (`505 / 10 ** 2`).\n\t *\n\t * @dev Tokens usually opt for a value of 18, imitating the relationship between\n\t *      Ether and Wei. This is the value {ERC20} uses, unless this function is\n\t *      overridden;\n\t *\n\t * @dev NOTE: This information is only used for _display_ purposes: it in\n\t *      no way affects any of the arithmetic of the contract, including\n\t *      {IERC20-balanceOf} and {IERC20-transfer}.\n\t *\n\t * @return token decimals\n\t */\n\t// OPTIONAL - This method can be used to improve usability,\n\t// but interfaces and other contracts MUST NOT expect these values to be present.\n\t// function decimals() external view returns (uint8);\n\n\t/**\n\t * @return the amount of tokens in existence\n\t */\n\tfunction totalSupply() external view returns (uint256);\n\n\t/**\n\t * @notice Gets the balance of a particular address\n\t *\n\t * @param owner the address to query the the balance for\n\t * @return balance an amount of tokens owned by the address specified\n\t */\n\tfunction balanceOf(address owner) external view returns (uint256 balance);\n\n\t/**\n\t * @notice Transfers some tokens to an external address or a smart contract\n\t *\n\t * @dev Called by token owner (an address which has a\n\t *      positive token balance tracked by this smart contract)\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `to` address:\n\t *          * zero address or\n\t *          * self address or\n\t *          * smart contract which doesn't support ERC20\n\t *\n\t * @param to an address to transfer tokens to,\n\t *      must be either an external address or a smart contract,\n\t *      compliant with the ERC20 standard\n\t * @param value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction transfer(address to, uint256 value) external returns (bool success);\n\n\t/**\n\t * @notice Transfers some tokens on behalf of address `from' (token owner)\n\t *      to some other address `to`\n\t *\n\t * @dev Called by token owner on his own or approved address,\n\t *      an address approved earlier by token owner to\n\t *      transfer some amount of tokens on its behalf\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `to` address:\n\t *          * zero address or\n\t *          * same as `from` address (self transfer)\n\t *          * smart contract which doesn't support ERC20\n\t *\n\t * @param from token owner which approved caller (transaction sender)\n\t *      to transfer `value` of tokens on its behalf\n\t * @param to an address to transfer tokens to,\n\t *      must be either an external address or a smart contract,\n\t *      compliant with the ERC20 standard\n\t * @param value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction transferFrom(address from, address to, uint256 value) external returns (bool success);\n\n\t/**\n\t * @notice Approves address called `spender` to transfer some amount\n\t *      of tokens on behalf of the owner (transaction sender)\n\t *\n\t * @dev Transaction sender must not necessarily own any tokens to grant the permission\n\t *\n\t * @param spender an address approved by the caller (token owner)\n\t *      to spend some tokens on its behalf\n\t * @param value an amount of tokens spender `spender` is allowed to\n\t *      transfer on behalf of the token owner\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction approve(address spender, uint256 value) external returns (bool success);\n\n\t/**\n\t * @notice Returns the amount which `spender` is still allowed to withdraw from `owner`.\n\t *\n\t * @dev A function to check an amount of tokens owner approved\n\t *      to transfer on its behalf by some other address called \"spender\"\n\t *\n\t * @param owner an address which approves transferring some tokens on its behalf\n\t * @param spender an address approved to transfer some tokens on behalf\n\t * @return remaining an amount of tokens approved address `spender` can transfer on behalf\n\t *      of token owner `owner`\n\t */\n\tfunction allowance(address owner, address spender) external view returns (uint256 remaining);\n}\n\n/**\n * @title Mintable/burnable ERC20 Extension\n *\n * @notice Adds mint/burn functions to the ERC20 interface;\n *      these functions are usually present in ERC20 implementations;\n *      they become a must for the bridged tokens since the bridge usually\n *      needs to have a way to mint tokens deposited from L1 to L2\n *      and to burn tokens to be withdrawn from L2 to L1\n */\ninterface MintableBurnableERC20 is ERC20 {\n\t/**\n\t * @dev Mints (creates) some tokens to address specified\n\t * @dev The value specified is treated as is without taking\n\t *      into account what `decimals` value is\n\t *\n\t * @param to an address to mint tokens to\n\t * @param value an amount of tokens to mint (create)\n\t * @return success true on success, false otherwise\n\t */\n\tfunction mint(address to, uint256 value) external returns (bool success);\n\n\t/**\n\t * @dev Burns (destroys) some tokens from the address specified\n\t *\n\t * @dev The value specified is treated as is without taking\n\t *      into account what `decimals` value is\n\t *\n\t * @param from an address to burn some tokens from\n\t * @param value an amount of tokens to burn (destroy)\n\t * @return success true on success, false otherwise\n\t */\n\tfunction burn(address from, uint256 value) external returns (bool success);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC1967Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.8.3._\n */\ninterface IERC1967Upgradeable {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822ProxiableUpgradeable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../interfaces/IERC1967Upgradeable.sol\";\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\nimport \"../utils/Initializable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n */\nabstract contract ERC1967UpgradeUpgradeable is Initializable, IERC1967Upgradeable {\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../ERC1967/ERC1967UpgradeUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n        _;\n    }\n\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "contracts/lib/MathLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title Math Library\n *\n * @notice On-demand math utilities used by at least two contracts in the project\n *\n * @author Lizard Labs Core Contributors\n */\nlibrary MathLib {\n\t/**\n\t * @dev Checks if number `n` has bit `i` set\n\t */\n\tfunction isBitSet(uint256 n, uint8 i) internal pure returns(bool) {\n\t\t// extract the required bit and check if it is not zero\n\t\treturn n & (1 << i) != 0;\n\t}\n}\n"
    },
    "contracts/lib/SafeERC20Lib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title SafeERC20\n *\n * @dev Inspired by OZ SafeERC20 implementation (v5.0.0), this contract doesn't require the ERC20\n *      token to follow any of the ERC20 interfaces (OZ IERC20, or others) at compile time.\n *\n * @dev Wrappers around ERC20 operations that throw on failure (when the token contract returns false).\n *      Tokens that return no value (and instead revert or throw on failure) are also supported,\n *      non-reverting calls are assumed to be successful.\n *\n * @dev To use this library you can add a `using SafeERC20 for address;` statement to your contract,\n *      which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Lib {\n\tusing Address for address;\n\n\t/**\n\t * @dev An operation with an ERC20 token failed.\n\t */\n\terror SafeERC20FailedOperation(address token);\n\n\t/**\n\t * @dev Transfers `value` amount of `token` from the calling contract to `to`.\n\t *      If `token` returns no value, non-reverting calls are assumed to be successful.\n\t */\n\tfunction safeTransfer(address token, address to, uint256 value) internal {\n\t\t_callOptionalReturn(token, abi.encodeWithSignature(\"transfer(address,uint256)\", to, value));\n\t}\n\n\t/**\n\t * @dev Transfers `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the calling contract.\n\t *      If `token` returns no value, non-reverting calls are assumed to be successful.\n\t */\n\tfunction safeTransferFrom(address token, address from, address to, uint256 value) internal {\n\t\t_callOptionalReturn(token, abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", from, to, value));\n\t}\n\n\t/**\n\t * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n\t *      on the return value: the return value is optional (but if data is returned, it must not be false).\n\t *\n\t * @param token The token address targeted by the call.\n\t * @param data The call data (encoded using abi.encode or one of its variants).\n\t */\n\tfunction _callOptionalReturn(address token, bytes memory data) private {\n\t\t// We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n\t\t// we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n\t\t// the target address contains contract code and also asserts for success in the low-level call.\n\n\t\tbytes memory returndata = token.functionCall(data);\n\t\tif (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n\t\t\trevert SafeERC20FailedOperation(token);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n\t *      on the return value: the return value is optional (but if data is returned, it must not be false).\n\t *\n\t * @dev This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n\t *\n\t * @param token The token targeted by the call.\n\t * @param data The call data (encoded using abi.encode or one of its variants).\n\t */\n\tfunction _callOptionalReturnBool(address token, bytes memory data) private returns (bool) {\n\t\t// We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n\t\t// we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n\t\t// and not revert is the subcall reverts.\n\n\t\t(bool success, bytes memory returndata) = token.call(data);\n\t\treturn success && (returndata.length == 0 || abi.decode(returndata, (bool))) && token.code.length > 0;\n\t}\n}\n"
    },
    "contracts/lib/SafeMathLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title Safe Math Library\n *\n * @notice Starting from Solidity 0.8 most of the arithmetic operations became safe by default.\n *      Integer type casting operation remains unsafe and can silently trim the integers.\n *      This library provides an overflow safe integer type casting functions.\n *\n * @author Lizard Labs Core Contributors\n */\nlibrary SafeMathLib {\n\t/// @dev Safely converts unsigned integer value to uint96, throwing on overflow\n\tfunction toUint96(uint256 value) internal pure returns(uint96) {\n\t\t// check for overflow\n\t\trequire(value <= type(uint96).max, \"uint96 79.2B overflow\");\n\t\t// return the result\n\t\treturn uint96(value);\n\t}\n}\n"
    },
    "contracts/protocol/multicall/Multicall.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title Multicall\n *\n * @notice Simplified version of the OZ Multicall contract\n *\n * @dev The use case of the Multicall is to be inherited by the contacts\n *      wishing to allow their clients to execute several functions in a batch\n *\n * @dev Executes in the self-context (storage) via `delegatecall`\n *\n * @author OpenZeppelin\n * @author Lizard Labs Core Contributors\n */\nabstract contract Multicall {\n\t/**\n\t * @dev Multicall support: a function to batch together multiple calls in a single external call.\n\t * @dev Receives and executes a batch of function calls on this contract.\n\t *\n\t * @param data an array of ABI-encoded function calls\n\t * @return results an array of ABI-encoded results of the function calls\n\t */\n\tfunction multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {\n\t\t// the implementation is copied from OZ Multicall contract;\n\t\t// Context-related stuff is dropped as it's not supported by this contract\n\t\tresults = new bytes[](data.length);\n\t\tfor (uint256 i = 0; i < data.length; i++) {\n\t\t\tresults[i] = Address.functionDelegateCall(address(this), data[i]);\n\t\t}\n\t\treturn results;\n\t}\n}\n"
    },
    "contracts/protocol/vesting/LizVestingV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@lazy-sol/access-control-upgradeable/contracts/UpgradeableAccessControlCore.sol\";\nimport \"@lazy-sol/advanced-erc20/contracts/interfaces/ERC20Spec.sol\";\nimport \"@lazy-sol/advanced-erc20/contracts/interfaces/ERC1363Spec.sol\";\n\nimport \"../../lib/SafeERC20Lib.sol\";\nimport \"../../lib/SafeMathLib.sol\";\nimport \"../../lib/MathLib.sol\";\nimport \"../multicall/Multicall.sol\";\n\n/**\n * @title Lizard Labs Token Vesting\n *\n * @notice An ERC20 token vesting contract for Lizcoin ERC20 token vesting featuring\n *      - immediate exchange of the cLIZ convertable coin (ERC20 token) into LIZ coin (Lizcoin ERC20 token)\n *      - vesting schedule creation with convertable ERC-20 tokens (coins), such as vLIZ, kLIZ, or veLIZ\n *      - configurable behavior (conversion, vesting schedule settings) per convertable coin\n *      - vesting schedule creation by a privileged role (ROLE_VESTING_SCHEDULE_CREATOR)\n *      - vesting schedule immutability: once created, the schedule cannot be deleted or modified\n *            (unless the contract is upgraded which requires an upgrade manager authority)\n *\n * @notice A token vesting schedule is a plan that determines when and how tokens are released\n *      to their holders over time. It is often used to incentivize long-term commitment and\n *      loyalty from the project team, investors, or partners. \n *\n * @notice In Lizard Labs' documentation, the token vesting terms are defined as follows:\n *\n *      - Vesting Start = TGE\n *      - Vesting End = TGE + 18 months\n *      - Vesting Period = time from Vesting Start to Vesting End;\n *        holders can send veLIZ / vLIZ to contract, but no veLIZ / vLIZ unlocking happens;\n *        cLIZ can be exchanged for LIZ at any time during this period (or after); \n *      - Unlocking = starts at Vesting End;\n *        2 year linear unlock for all veLIZ / vLIZ in the contract starts at that time\n *        If holder sends veLIZ / vLIZ to the contract AFTER Vesting End,\n *        their linear unlock starts from the date that the user sent their veLIZ / vLIZ to the contract.\n *        This is so these coins always have a 2 year unlock.\n *       - kLIZ coin rules are similar to vLIZ, except unlocking time, and percent are different\n *\n * @notice Industry standardized terms and definitions are somewhat different:\n *\n *      - vesting start date (we call this \"unlocking start date\"), unix timestamp;\n *        the date when the vesting schedule begins; this is the date when tokens begin to vest,\n *        however they still may be unavailable for claiming if there is a cliff (see below)\n *\n *      - cliff = 0 (we don't use this);\n *        a period of time before any tokens are released;\n *        the tokens are released starting from `vesting start date` + `cliff` date,\n *        and if cliff is not zero some amount of tokens is released immediately when cliff is reached:\n *        `cliff / vesting duration` (see below)\n *\n *      - vesting duration (we call this \"unlocking duration\"), seconds;\n *        the total length of time for the vesting schedule;\n *        measured from the unlocking start date to the date when all tokens are released\n *\n *      - slice period = 1 second (we don't use this);\n *        the interval of time between each token release;\n *        ex.: a monthly slice period means that tokens are unlocked every month according to the vesting schedule\n *\n *      - vesting amount, wei;\n *        total amount of tokens to be released to the token holder;\n *        this value can increase before unlocking starts since the contract supports vesting balance top-up\n *\n *      - claimed amount, wei, initially zero;\n *        total amount of tokens already released to the token holder;\n *        this value increases every time token holders withdraws their tokens, until it reaches vesting amount\n *\n * @notice Preliminary values for the vesting schedule:\n *\n *      - unlocking start date: TGE + 18 months (6 months for kLIZ)\n *      - cliff: zero (tokens begin linear unlock immediately on vesting start date, without a delay)\n *      - unlocking duration: 2 years (18 months for kLIZ)\n *      - slice period: 1 second (hardcoded into the smart contract and non-modifiable)\n *\n * @notice Tokens and convertable coins (ERC-20 tokens)\n *      LIZ: Lizcoin ERC20 token - Lizard Labs Gaming DAO ownership token;\n *           participates in liquidity staking, governance, token airdrops, revenue sharing etc\n *      cLIZ: Contributor LIZ - temporary token to be exchanged into LIZ\n *      vLIZ, kLIZ, and veLIZ: Vested LIZ - temporary tokens to be exchanged into LIZ and vested\n *\n * @notice cLIZ coins are converted into LIZ coins without any vesting applied;\n *      LIZ conversion rate is configurable, default value is 1:100;\n *      vLIZ, kLIZ, and veLIZ coins are used to create vesting schedules:\n *\n *      - cLIZ: converted to LIZ, LIZ returned immediately to holder, no locking applied\n *      - vLIZ: converted to LIZ,\n *              10% (configurable) of LIZ returned immediately to holder;\n *              remaining 90% vested for `unlocking duration`\n *      - kLIZ: converted to LIZ,\n *              20% (configurable) of LIZ returned immediately to holder;\n *              remaining 80% vested for `unlocking duration`\n *      - veLIZ: converted to LIZ, all LIZ vested for `unlocking duration`\n *\n * @dev All the rules mentioned above are configurable:\n *      - number of convertable/lockable tokens, and their addresses\n *      - vesting settings for each configured token, including\n *            - unlocking start\n *            - unlocking duration\n *            - conversion rate\n *            - immediate unlock percent\n *\n * @dev kLIZ deprecation notice:\n *      the contract is deployed without kLIZ token initially configured, but it can be added manually\n *\n * @dev All token amounts are uint96, meaning the max value ~79.2*10^27 wei, or ~79.2B LIZ\n *      in all the arithmetic operations\n *\n * @dev All dates, times, and durations are uint32, meaning the max value 4294967295,\n *      or February 7, 2106 6:28:15 AM\n *\n * @author Lizard Labs Core Contributors\n */\ncontract LizVestingV1 is UpgradeableAccessControlCore, Multicall {\n\t/// @dev Using SafeERC20Lib for \"safe\" ERC20 transfers (non-standard ERC20 support)\n\tusing SafeERC20Lib for address;\n\n\t/// @dev Using SafeMathLib for safe type conversions\n\tusing SafeMathLib for uint128;\n\tusing SafeMathLib for uint160;\n\tusing SafeMathLib for uint192;\n\n\t/// @dev Using MathLib to work with bitmasks (bitflags)\n\tusing MathLib for uint8;\n\tusing MathLib for uint32;\n\n\t/**\n\t * @dev Vesting settings stores vesting schedule settings for each convertable coin;\n\t *      these settings are used to create individual vesting schedules for the holders\n\t *\n\t * @dev It also stores conversion rate and immediate unlocking settings\n\t *\n\t * @dev [Most likely] these will be set only once after the contract deployment\n\t *\n\t * @dev Size: 256 bits (1 storage slot)\n\t */\n\tstruct VestingSettings {\n\t\t/**\n\t\t * @dev Unlocking start date, unix timestamp; max value 4294967295, or February 7, 2106 6:28:15 AM\n\t\t *      Default value: now\n\t\t */\n\t\tuint32 unlockingStartDate;\n\t\t/**\n\t\t * @dev Unlocking duration, seconds\n\t\t *      Default value: 2 years\n\t\t */\n\t\tuint32 unlockingDuration;\n\t\t/**\n\t\t * @dev Vesting settings flags, containing bitflags (bitmask)\n\t\t *      bit 0 (lower bit): unlockingStartDate override, unlocking start date will be set\n\t\t *            to the current timestamp for vesting schedules created after the unlockingStartDate\n\t\t *      bit 1 (next to lower): switch the default convert() function access policy from\n\t\t *            \"allow all except forbidden\" to \"forbid all except allowed\"\n\t\t *      bits 2-31: not in use\n\t\t */\n\t\tuint32 flags;\n\t\t/**\n\t\t * @dev A conversion rate is a measure of how much units of one asset\n\t\t *      are needed to obtain one unit of another asset.\n\t\t * @dev cLIZ/vLIZ/kLIZ/veLIZ to LIZ conversion rate with 18 decimals:\n\t\t *      10^18 stands for 1:1, 10^17 for 1:10, 10^19 for 10:1 and so on\n\t\t * @dev Default value is 1:100 (10^16)\n\t\t */\n\t\tuint96 conversionRate;\n\t\t/**\n\t\t * @dev Percentage of vLIZ/kLIZ immediately converted into LIZ with 18 decimals:\n\t\t *      10^18 stands for 100%, 10^17 for 10%, 10^16 for 1% and so on\n\t\t * @dev Default value is 0% for veLIZ, 10% for vLIZ, 20% for kLIZ, 100% for cLIZ\n\t\t */\n\t\tuint64 immUnlockPercent;\n\t}\n\n\t/**\n\t * @dev Vesting schedule stores individual holder vesting schedule details\n\t *\n\t * @dev Amount claimed is [potentially] highly mutable and frequently updated\n\t *\n\t * @dev Size: 256 bits (1 storage slot)\n\t */\n\tstruct VestingSchedule {\n\t\t/// @dev unlocking start date, unix timestamp; max value 4294967295, or February 7, 2106 6:28:15 AM\n\t\tuint32 startDate;\n\t\t/// @dev unlocking duration, seconds\n\t\tuint32 duration;\n\t\t/// @dev vesting amount, wei; max theoretical value ~79.2*10^27 wei, or ~79.2B LIZ\n\t\tuint96 amountVested;\n\t\t/// @dev claimed amount, wei; max theoretical value ~79.2*10^27 wei, or ~79.2B LIZ\n\t\tuint96 amountClaimed;\n\t}\n\n\t/**\n\t * @dev Coin vesting settings used to create individual vesting schedules;\n\t *      every convertable coin (cLIZ, vLIZ, kLIZ, veLIZ) has its own settings\n\t *\n\t * @dev Maps convertable coin address to its default vesting settings\n\t */\n\tmapping(address => VestingSettings) private coinSettings;\n\n\t/**\n\t * @dev An optional mapping to store access flags (whitelist/blacklist) for coins/addresses.\n\t *      Whitelist flag is lower bit (bit zero), blacklist flag is the next bit (bit one).\n\t * @dev The default convert() function access policy is \"allow all except forbidden\",\n\t *      which has an effect only when FEATURE_KYC_ENABLED global feature is enabled.\n\t *      The default \"allow all except forbidden\" policy can be changed to the opposite\n\t *      \"forbid all except allowed\" by setting the bit number 1 in the \"flags\" of the\n\t *      VestingSettings for the given coin.\n\t */\n\tmapping(address => mapping(address => uint8)) private kycSettings;\n\n\t/**\n\t * @dev Individual vesting schedules\n\t *      maps token holder address => individual vesting schedules array\n\t *\n\t * @dev Vesting schedules at lower indexes can be topped up;\n\t *      this may happen when schedules sharing the same start date and duration are added\n\t */\n\tmapping(address => VestingSchedule[]) private vestingSchedules;\n\n\t/**\n\t * @dev Lizcoin (LIZ) ERC20 / ERC1363 token address, effectively immutable\n\t *      Can only be set during smart contract initialization\n\t *\n\t * @dev This is fully ERC20 compliant instance, not requiring OZ \"safe\" transfers\n\t */\n\tERC1363 private lizcoin;\n\n\t/**\n\t * @dev Lizcoin ERC20 treasury wallet to transfer LIZ coins from\n\t *\n\t * @dev May be zero, may be set to the vesting contract address;\n\t *      in such a case, vesting contract will use its own LIZ balance for payments\n\t */\n\taddress private treasury;\n\n\t// Global vesting counters\n\t/**\n\t * @dev Total vested amount is a sum of all individual vested amounts; frequently updated\n\t */\n\tuint128 private _totalVested;\n\t/**\n\t * @dev Total claimed amount is a sum of all individual claimed amounts; frequently updated\n\t */\n\tuint128 private _totalClaimed;\n\n\t/**\n\t * @dev A replacement for the zero address used to send tokens to instead of\n\t *      burning or sending to the real zero address for the default OZ-based\n\t *      ERC20 implementations which don't support burning\n\t */\n\taddress public constant DEAD_ADDRESS = address(0xDEAD);\n\n\t/**\n\t * @notice Enables cLIZ, vLIZ, and kLIZ into LIZ conversions\n\t *      (with non-zero immediate unlock percent)\n\t *\n\t * @dev Feature FEATURE_CONVERSION_ENABLED is required for the convert() function\n\t *      to succeed if cLIZ, vLIZ, and/or kLIZ token is used\n\t */\n\tuint32 public constant FEATURE_CONVERSION_ENABLED = 0x0000_0001;\n\n\t/**\n\t * @notice Enables vesting schedule creations from vLIZ, kLIZ, and veLIZ convertable coins\n\t *      (with less than 100% immediate unlock percent)\n\t *\n\t * @dev Feature FEATURE_SCHEDULE_CREATION_ENABLED is required for the convert() function\n\t *      to succeed if vLIZ, kLIZ, and/or veLIZ token is used\n\t */\n\tuint32 public constant FEATURE_SCHEDULE_CREATION_ENABLED = 0x0000_0002;\n\n\t/**\n\t * @notice Enables LIZ claiming from the vesting schedules\n\t *\n\t * @dev Feature FEATURE_CLAIMING_ENABLED is required for claiming\n\t *      functions to succeed\n\t */\n\tuint32 public constant FEATURE_CLAIMING_ENABLED = 0x0000_0004;\n\n\t/**\n\t * @notice Enables KYC (address whitelisting/blacklisting) capabilities\n\t *\n\t * @dev When enabled contract will check if the address using the convert() function\n\t *      satisfies the KYC requirement (is whitelisted, is not blacklisted)\n\t */\n\tuint32 public constant FEATURE_KYC_ENABLED = 0x0000_0008;\n\n\t/**\n\t * @notice Enables the ERC1363 callable transfers extension, allowing clients to\n\t *      execute arbitrary callbacks on the contracts they are sending tokens to\n\t *\n\t * @dev Feature FEATURE_ERC1363_EXECUTION_ENABLED is required for convertAndCall()\n\t *      function to succeed\n\t */\n\tuint32 public constant FEATURE_ERC1363_EXECUTION_ENABLED = 0x0000_0010;\n\n\t/**\n\t * @notice Treasury manager is responsible for LIZ coin supply to the vesting contract\n\t *\n\t * @dev Role ROLE_TREASURY_MANAGER allows updating the treasury wallet address via updateTreasuryAddress()\n\t */\n\tuint32 public constant ROLE_TREASURY_MANAGER = 0x0001_0000;\n\n\t/**\n\t * @notice Vesting settings manager is responsible for convertable coin vesting settings setup\n\t *\n\t * @dev Role ROLE_VESTING_SETTINGS_MANAGER allows\n\t *      updating global vesting settings via updateCoinVestingSettings(), and\n\t *      deleting global vesting settings via deleteCoinVestingSettings()\n\t */\n\tuint32 public constant ROLE_VESTING_SETTINGS_MANAGER = 0x0002_0000;\n\n\t/**\n\t * @notice Vesting schedule creator is responsible for manual vesting schedules creation\n\t *\n\t * @dev Role ROLE_VESTING_SCHEDULE_CREATOR allows creating vesting schedules via createVestingSchedule()\n\t */\n\tuint32 public constant ROLE_VESTING_SCHEDULE_CREATOR = 0x0004_0000;\n\n\t/**\n\t * @notice KYC whitelist manager is responsible for allowing the convertable coins holders'\n\t *      addresses to use the convert() function to convert/vest their tokens\n\t * @dev Role ROLE_KYC_WHITELIST_MANAGER is required to whitelist the addresses by making them\n\t *      in the `kycSettings` mapping as allowed addresses\n\t */\n\tuint32 public constant ROLE_KYC_WHITELIST_MANAGER = 0x0008_0000;\n\n\t/**\n\t * @notice People do mistakes and may send tokens by mistake\n\t *\n\t * @notice Rescue manager is responsible for \"rescuing\" ERC20/ERC721 tokens\n\t *      accidentally sent to the smart contract\n\t *\n\t * @dev Role ROLE_RESCUE_MANAGER allows withdrawing non-bridged ERC20/ERC721\n\t *      tokens stored on the smart contract balance via `rescueTokens` function\n\t */\n\tuint32 public constant ROLE_RESCUE_MANAGER = 0x0010_0000;\n\n\t/**\n\t * @dev Fired in the convert() and convertAndCall() functions when convertable coins\n\t *      (cLIZ, vLIZ, kLIZ, or veLIZ) are converted into LIZ, and possibly vested\n\t *\n\t * @param coinAddress address of the converted token (cLIZ, vLIZ, kLIZ, or veLIZ)\n\t * @param coinSupplier spender of the converted token, usually this is the holder itself;\n\t *      cLIZ, vLIZ, kLIZ, or veLIZ tokens are spent by this address to be converted/vested\n\t * @param releasedTo receiver of the converted and immediately payed out LIZ tokens (if any)\n\t * @param vestedTo an address vesting schedule was created/updated for (from the LIZ vested)\n\t * @param depositedAmount how much of the convertable coin was taken and burnt from spender\n\t * @param releasedAmount how much LIZ were immediately released to the beneficiary\n\t * @param scheduleId vesting schedule ID which was created or topped up\n\t * @param vestedAmount how much LIZ coins were added to the beneficiary vesting schedule\n\t */\n\tevent CoinConverted(\n\t\taddress coinAddress,\n\t\taddress indexed coinSupplier,\n\t\taddress indexed releasedTo,\n\t\taddress indexed vestedTo,\n\t\tuint96 depositedAmount,\n\t\tuint96 releasedAmount,\n\t\tuint256 scheduleId,\n\t\tuint96 vestedAmount\n\t);\n\n\t/**\n\t * @dev Fired in the convert() and convertAndCall() functions when convertable coins\n\t *      (cLIZ, vLIZ, or kLIZ) are converted into LIZ, immediately unlocked and sent out\n\t *\n\t * @param coinSupplier spender of the converted token, usually this is the holder itself;\n\t *      cLIZ, vLIZ, kLIZ, or veLIZ tokens are spent by this address to be converted/vested\n\t * @param coinAddresses address of the converted coins (cLIZ, vLIZ, kLIZ, or veLIZ)\n\t * @param depositedAmounts corresponding amounts of the converted coins taken and burnt from spender\n\t * @param releasedTo an account where tokens were released to, or ERC1363Receiver smart contract\n\t *       where tokens were sent to and the `onTransferReceived` callback function was triggered on\n\t * @param releasedAmount amount of the tokens released\n\t * @param withCallback true if `target` was treated as the ERC1363Receiver smart contract and\n\t *      `onTransferReceived` callback was executed on it; false otherwise\n\t * @param callbackPayload ERC1363 payload passed to the target contract's `onTransferReceived` callback\n\t */\n\tevent LizcoinReleased(\n\t\taddress indexed coinSupplier,\n\t\taddress[] coinAddresses,\n\t\tuint96[] depositedAmounts,\n\t\taddress indexed releasedTo,\n\t\tuint128 releasedAmount, \n\t\tbool withCallback,\n\t\tbytes callbackPayload\n\t);\n\n\t/**\n\t * @dev Fired in createVestingSchedule() restricted access function when vesting schedule is created\n\t *      by the privileged account (ROLE_VESTING_SCHEDULE_CREATOR)\n\t *\n\t * @param to beneficiary, receiver of the vested LIZ tokens\n\t * @param scheduleId vesting schedule ID which was created\n\t * @param vestedAmount how much LIZ coins were added to the beneficiary vesting schedule\n\t * @param startDate vesting start date, unix timestamp\n\t * @param duration vesting duration, seconds\n\t */\n\tevent VestingScheduleCreated(\n\t\taddress indexed to,\n\t\tuint256 indexed scheduleId,\n\t\tuint96 vestedAmount,\n\t\tuint32 startDate,\n\t\tuint32 duration\n\t);\n\n\t/**\n\t * @dev Fired in the claimTo() function when LIZ tokens are claimed from the vesting schedule\n\t *\n\t * @param from vesting schedule holder, an account which vesting balance was used for claiming\n\t * @param scheduleId vesting schedule ID tokens were claimed from\n\t * @param to beneficiary, receiver of the LIZ tokens, usually this is the vesting schedule holder himself\n\t * @param amountClaimed how much LIZ was claimed and transferred to the beneficiary\n\t * @param amountCap amount cap used for this operation; zero - no cap\n\t */\n\tevent LizcoinClaimed(\n\t\taddress indexed from,\n\t\tuint256 indexed scheduleId,\n\t\taddress indexed to,\n\t\tuint96 amountClaimed,\n\t\tuint96 amountCap\n\t);\n\n\t/**\n\t * @dev Fired in updateTreasuryAddress() function\n\t *\n\t * @param treasuryAddress new treasury wallet address (note: it can be zero)\n\t * @param lizBalance LIZ token balance of the new treasury wallet\n\t */\n\tevent TreasuryAddressUpdated(address treasuryAddress, uint256 lizBalance);\n\n\t/**\n\t * @dev Fired in updateCoinVestingSettings() function\n\t *\n\t * @param coinAddress address of the convertable coin (cLIZ, vLIZ, kLIZ, or veLIZ)\n\t * @param unlockingStartDate unlocking start date, unix timestamp;\n\t *      max value 4294967295, or February 7, 2106 6:28:15 AM\n\t * @param unlockingDuration unlocking duration, seconds\n\t * @param flags vesting settings flags, bitmask\n\t *      bit 0 (lower bit): unlockingStartDate override, unlocking start date will be set\n\t *            to current timestamp for vesting schedules created after unlockingStartDate\n\t *      bits 1-31: not in use\n\t * @param conversionRate cLIZ, vLIZ, kLIZ, or veLIZ to LIZ conversion rate with 18 decimals:\n\t *      10^18 stands for 1:1, 10^17 for 1:10, 10^19 for 10:1 and so on\n\t * @param immUnlockPercent Percentage of vLIZ/kLIZ immediately converted into LIZ with 18 decimals:\n\t *      10^18 stands for 100%, 10^17 for 10%, 10^16 for 1% and so on\n\t */\n\tevent CoinVestingSettingsUpdated(\n\t\taddress indexed coinAddress,\n\t\tuint32 unlockingStartDate,\n\t\tuint32 unlockingDuration,\n\t\tuint32 flags,\n\t\tuint96 conversionRate,\n\t\tuint64 immUnlockPercent\n\t);\n\n\t/**\n\t * @dev Fired in deleteCoinVestingSettings() function\n\t *\n\t * @param coinAddress address of the convertable coin (cLIZ, vLIZ, kLIZ, or veLIZ)\n\t */\n\tevent CoinVestingSettingsDeleted(address indexed coinAddress);\n\n\t/**\n\t * @dev Fired in whitelistCoinHolders() function\n\t *\n\t * @param coinAddress address of the convertable coin (cLIZ, vLIZ, kLIZ, or veLIZ)\n\t * @param holderAddress whitelisted convertable coin holder address\n\t */\n\tevent CoinHolderWhitelisted(address indexed coinAddress, address indexed holderAddress);\n\n\t/**\n\t * @dev \"Constructor replacement\" for a smart contract with a delayed initialization (post-deployment initialization)\n\t *      Creates \"VestingSettings\" for every coin, which can be read back later with getCoinVestingSettings() function\n\t *\n\t * @param tgeDate the Token Generation Event (TGE) date, default configurations are created\n\t *      using this date as an unlocking start offset date\n\t * @param lizAddress address of the ERC1363 compatible Lizcoin ERC20 token\n\t * @param cLizAddress address of the cLIZ convertable ERC20 token\n\t * @param vLizAddress address of the vLIZ convertable ERC20 token\n\t * param kLizAddress address of the kLIZ convertable ERC20 token\n\t * @param veLizAddress address of the veLIZ convertable ERC20 token\n\t */\n\tfunction postConstruct(\n\t\tuint32 tgeDate,\n\t\taddress lizAddress,\n\t\taddress cLizAddress,\n\t\taddress vLizAddress,\n//\t\taddress kLizAddress,\n\t\taddress veLizAddress\n\t) public initializer {\n\t\t// verify the inputs are set\n\t\trequire(tgeDate != 0, \"zero date\");\n\t\trequire(\n\t\t\tlizAddress != address(0)\n\t\t\t&& cLizAddress != address(0)\n\t\t\t&& vLizAddress != address(0)\n//\t\t\t&& kLizAddress != address(0)\n\t\t\t&& veLizAddress != address(0),\n\t\t\t\"zero address\"\n\t\t);\n\n\t\t// initialize contract storage\n\t\tlizcoin = ERC1363(lizAddress);\n\n\t\t// initialize default coin vesting settings for cLIZ\n\t\t__updateCoinVestingSettings(\n\t\t\t// cLIZ convertable coin address\n\t\t\tcLizAddress,\n\t\t\t// cLIZ convertable coin vesting settings\n\t\t\tVestingSettings({\n\t\t\t\t// default unlocking start: TGE + half a year (6 months)\n\t\t\t\tunlockingStartDate: tgeDate + 365 days / 2,\n\t\t\t\t// default unlocking duration: 1 year\n\t\t\t\tunlockingDuration: 365 days,\n\t\t\t\t// no special flags\n\t\t\t\tflags: 0x00000000,\n\t\t\t\t// default conversion rate: 1:100\n\t\t\t\tconversionRate: 1e16,\n\t\t\t\t// default immediate unlock percent: 100%\n\t\t\t\timmUnlockPercent: 1 ether\n\t\t\t})\n\t\t);\n\n\t\t// initialize default coin vesting settings for vLIZ\n\t\t__updateCoinVestingSettings(\n\t\t\t// vLIZ convertable coin address\n\t\t\tvLizAddress,\n\t\t\t// vLIZ convertable coin vesting settings\n\t\t\tVestingSettings({\n\t\t\t\t// default unlocking start: TGE + half a year (6 months)\n\t\t\t\tunlockingStartDate: tgeDate + 365 days / 2,\n\t\t\t\t// default unlocking duration: 1 year\n\t\t\t\tunlockingDuration: 365 days,\n\t\t\t\t// no special flags\n\t\t\t\tflags: 0x00000000,\n\t\t\t\t// default conversion rate: 1:100\n\t\t\t\tconversionRate: 1e16,\n\t\t\t\t// default immediate unlock percent: 10%\n\t\t\t\timmUnlockPercent: 10e16\n\t\t\t})\n\t\t);\n\n/*\n\t\t// initialize default coin vesting settings for kLIZ\n\t\t__updateCoinVestingSettings(\n\t\t\t// kLIZ convertable coin address\n\t\t\tkLizAddress,\n\t\t\t// kLIZ convertable coin vesting settings\n\t\t\tVestingSettings({\n\t\t\t\t// default unlocking start: TGE + quarter of a year (3 months)\n\t\t\t\tunlockingStartDate: tgeDate + 365 days / 4,\n\t\t\t\t// default unlocking duration: quarter of a year (3 months)\n\t\t\t\tunlockingDuration: 365 days / 4,\n\t\t\t\t// bit0 unlockingStartDate override enabled\n\t\t\t\tflags: 0x00000001,\n\t\t\t\t// default conversion rate: 1:100\n\t\t\t\tconversionRate: 1e16,\n\t\t\t\t// default immediate unlock percent: 15%\n\t\t\t\timmUnlockPercent: 15e16\n\t\t\t})\n\t\t);\n*/\n\n\t\t// initialize default coin vesting settings for veLIZ\n\t\t__updateCoinVestingSettings(\n\t\t\t// veLIZ convertable coin address\n\t\t\tveLizAddress,\n\t\t\t// veLIZ convertable coin vesting settings\n\t\t\tVestingSettings({\n\t\t\t\t// default unlocking start: TGE + half a year (6 months)\n\t\t\t\tunlockingStartDate: tgeDate + 365 days / 2,\n\t\t\t\t// default unlocking duration: 1 year\n\t\t\t\tunlockingDuration: 365 days,\n\t\t\t\t// bit0 unlockingStartDate override enabled\n\t\t\t\tflags: 0x00000001,\n\t\t\t\t// default conversion rate: 1:100\n\t\t\t\tconversionRate: 1e16,\n\t\t\t\t// default immediate unlock percent: 0%\n\t\t\t\timmUnlockPercent: 0\n\t\t\t})\n\t\t);\n\n\t\t// initialize the RBAC module\n\t\t_postConstruct(msg.sender, 0);\n\t}\n\n\t/**\n\t * @notice Gets the address of the main Lizcoin ERC20 token\n\t *\n\t * @dev The address returned by this function is immutable: client applications\n\t *      may safely cache the result\n\t *\n\t * @return lizcoinAddress Lizcoin (LIZ) ERC20 token address, immutable\n\t */\n\tfunction getLizcoinAddress() public view returns(ERC1363 lizcoinAddress) {\n\t\t// read from the storage and return\n\t\treturn lizcoin;\n\t}\n\n\t/**\n\t * @dev Explicit treasury wallet address getter\n\t *\n\t * @return treasury wallet address\n\t */\n\tfunction getTreasuryAddress() public view returns(address) {\n\t\t// read from storage and return\n\t\treturn treasury;\n\t}\n\n\t/**\n\t * @notice Restricted access function to update treasury wallet address,\n\t *      which is used to transfer LIZ coins from\n\t *\n\t * @param _treasury new treasury wallet address, can be zero\n\t */\n\tfunction updateTreasuryAddress(address _treasury) public {\n\t\t// verify the access permission\n\t\t_requireSenderInRole(ROLE_TREASURY_MANAGER);\n\n\t\t// update the treasury wallet address\n\t\ttreasury = _treasury;\n\n\t\t// emit an event\n\t\temit TreasuryAddressUpdated(_treasury, __treasuryBalance(_treasury));\n\t}\n\n\t/**\n\t * @notice Global vesting counters: total vested and total claimed counters\n\t *\n\t * @return totalVested total vested amount, sum of all vesting positions,\n\t *      including open (locked), and closed (unlocked and/or paid)\n\t * @param totalClaimed total claimed amount, sum of all already processed LIZ payments;\n\t *      Total pending obligations is a difference of total vested and claimed\n\t */\n\tfunction getGlobalVestingCounters() public view returns(uint128 totalVested, uint128 totalClaimed) {\n\t\t// read from storage and return\n\t\treturn (_totalVested, _totalClaimed);\n\t}\n\n\t/**\n\t * @dev Convertable coin default vesting settings getter\n\t *\n\t * @dev Returns vesting settings for a specific coin (cLIZ, vLIZ, kLIZ, or veLIZ)\n\t *\n\t * @param coinAddress address of the convertable coin to query settings for\n\t * @return settings convertable coin default vesting settings\n\t */\n\tfunction getCoinVestingSettings(address coinAddress) public view returns(VestingSettings memory settings) {\n\t\t// read from the storage\n\t\tsettings = coinSettings[coinAddress];\n\n\t\t// verify the settings read indeed exist and we're not just reading empty storage\n\t\trequire(settings.unlockingStartDate > 0, \"unknown coin\");\n\n\t\t// explicitly return the result for better code readability\n\t\treturn settings;\n\t}\n\n\t/**\n\t * @notice Restricted access function to delete convertable coin vesting settings,\n\t *      previously created by `updateCoinVestingSettings()` or during deployment\n\t *\n\t * @dev Deleting coin vesting settings for a coin doesn't affect already\n\t *      created vesting schedules which used these settings\n\t *\n\t * @param coinAddress address of the convertable coin to delete vesting settings for\n\t */\n\tfunction deleteCoinVestingSettings(address coinAddress) public {\n\t\t// verify the access permission\n\t\t_requireSenderInRole(ROLE_VESTING_SETTINGS_MANAGER);\n\n\t\t// delete coin vesting settings\n\t\tdelete coinSettings[coinAddress];\n\n\t\t// emit an event\n\t\temit CoinVestingSettingsDeleted(coinAddress);\n\t}\n\n\t/**\n\t * @notice Restricted access function to update convertable coin vesting settings,\n\t *      which are used to create individual holders' vesting schedules\n\t *\n\t * @dev Updating coin vesting settings for a coin doesn't affect already\n\t *      created vesting schedules which used these settings\n\t *\n\t * @param coinAddress address of the convertable coin to update vesting settings for\n\t * @param settings new default vesting schedules to use\n\t */\n\tfunction updateCoinVestingSettings(address coinAddress, VestingSettings calldata settings) public {\n\t\t// verify the access permission\n\t\t_requireSenderInRole(ROLE_VESTING_SETTINGS_MANAGER);\n\n\t\t// verify the setting (make sure they make some sense)\n\t\trequire(coinAddress != address(0), \"zero coin address\");\n\t\trequire(settings.unlockingStartDate > 0, \"unlocking start date not set\");\n\t\trequire(settings.unlockingDuration > 0, \"unlocking duration not set\");\n\t\trequire(settings.flags & 0xFFFFFFFC == 0, \"unknown flag\");\n\t\trequire(settings.conversionRate > 0, \"conversion rate not set\");\n\t\trequire(\n\t\t\tsettings.conversionRate >= 1_000_000_000 && settings.conversionRate <= 1_000_000_000 ether,\n\t\t\t\"conversion rate out of bounds\"\n\t\t);\n\t\trequire(\n\t\t\t(settings.immUnlockPercent == 0 || settings.immUnlockPercent > 1_000_000_000)\n\t\t\t&& settings.immUnlockPercent <= 1 ether,\n\t\t\t\"immediate unlock percent out of bounds\"\n\t\t);\n\n\t\t// delegate to unsafe `__updateCoinVestingSettings`\n\t\t__updateCoinVestingSettings(coinAddress, settings);\n\t}\n\n\t/**\n\t * @notice Reads the convert() function access settings for the given convertable coin,\n\t *      evaluates if the given holder address can convert the given coin\n\t *\n\t * @param coinAddress address of the convertable coin to read the convert() function\n\t *      access control settings for\n\t * @param holder convertable coin holder address to read the convert() function\n\t *      access control settings for\n\t * @return policy the convert() function access policy for the convertable coin,\n\t *      false - \"allow all except forbidden\", true - \"forbid all expect allowed\"\n\t * @return blacklisted true if given holder address is blacklisted\n\t * @return whitelisted true if given holder address is whitelisted\n\t * @return allowed true if given holder address is allowed to access the convert() function,\n\t *      this is calculated from all the flags above\n\t */\n\tfunction getKycStatus(address coinAddress, address holder) public view returns(\n\t\tbool policy,\n\t\tbool blacklisted,\n\t\tbool whitelisted,\n\t\tbool allowed\n\t) {\n\t\t// load the default policy from the coin settings\n\t\t(,policy) = __parseFlags(coinSettings[coinAddress].flags);\n\t\t// load the whitelisted/blacklisted access flags\n\t\t(blacklisted, whitelisted) = __parseKycFlags(kycSettings[coinAddress][holder]);\n\t\t// calculate the resulting allowed/forbidden flag\n\t\tallowed = policy && whitelisted || !policy && !blacklisted;\n\t}\n\n\t/**\n\t * @notice Restricted access function to whitelist more addresses eligible to convert\n\t *      the convertable coins into LIZ token and/or to create LIZ vesting schedules\n\t *\n\t * @dev Removal of the previously whitelisted addresses is not currently possible\n\t *\n\t * @param coinAddress address of the convertable coin to add whitelisted addresses for\n\t * @param holders array of the addresses to whitelist\n\t */\n\tfunction whitelistCoinHolders(address coinAddress, address[] calldata holders) public {\n\t\t// verify the access permission\n\t\t_requireSenderInRole(ROLE_KYC_WHITELIST_MANAGER);\n\n\t\t// verify the inputs are set\n\t\trequire(coinAddress != address(0), \"zero address\");\n\t\trequire(holders.length > 0, \"empty array\");\n\t\t// verify the settings for the convertable coin exist\n\t\trequire(coinSettings[coinAddress].unlockingStartDate > 0, \"unknown coin\");\n\n\t\t// cache the pointer to the mapping to avoid recalculating keccak256 of coinAddress\n\t\tmapping(address => uint8) storage kycPointer = kycSettings[coinAddress];\n\n\t\t// iterate the entire holders array\n\t\tfor(uint256 i = 0; i < holders.length; i++) {\n\t\t\t// and whitelist every address:\n\t\t\t// set whitelisted bit 0 to 1;\n\t\t\t// set blacklisted bit 1 to 0;\n\t\t\tkycPointer[holders[i]] = 0x01;\n\t\t\t// emit an event\n\t\t\temit CoinHolderWhitelisted(coinAddress, holders[i]);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Based on the status of the `FEATURE_KYC_ENABLED` feature, convertable coin settings\n\t *      and convertable coin holder address, evaluates if the holder is allowed to access the\n\t *      convert() function for the given convertable coin\n\t *\n\t * @param coinAddress address of the convertable coin to check the convert() function access for\n\t * @param holder convertable coin holder address to check the convert() function access for\n\t * @return true if access to the convert() function is allowed to the (convertable coin, holder)\n\t *      pair specified\n\t */\n\tfunction __accessToConvertAllowed(address coinAddress, address holder) private view returns(bool) {\n\t\t// if the corresponding feature is not enabled\n\t\tif(!_isFeatureEnabled(FEATURE_KYC_ENABLED)) {\n\t\t\t// the access is allowed to anyone, independently of any other settings\n\t\t\treturn true;\n\t\t}\n\n\t\t// calculate the access status\n\t\t(,,,bool allowed) = getKycStatus(coinAddress, holder);\n\t\t// return the calculated result\n\t\treturn allowed;\n\t}\n\n\t/**\n\t * @dev Updates convertable coin vesting settings.\n\t *      Unsafe. Must be kept private at all times.\n\t *\n\t * @param coinAddress convertable coin address (cLIZ, vLIZ, kLIZ, or veLIZ)\n\t * @param settings new default vesting settings to use\n\t */\n\tfunction __updateCoinVestingSettings(address coinAddress, VestingSettings memory settings) private {\n\t\t// update the settings\n\t\tcoinSettings[coinAddress] = settings;\n\n\t\t// emit an event\n\t\temit CoinVestingSettingsUpdated(\n\t\t\tcoinAddress,\n\t\t\tsettings.unlockingStartDate,\n\t\t\tsettings.unlockingDuration,\n\t\t\tsettings.flags,\n\t\t\tsettings.conversionRate,\n\t\t\tsettings.immUnlockPercent\n\t\t);\n\t}\n\t\n\t/**\n\t * @notice Gets vesting schedules array for the given token holder\n\t *\n\t * @dev WARNING: potentially gas expensive function!\n\t *      This function is not guaranteed to succeed (out of gas).\n\t *\n\t * @param holder token holder address to query information for\n\t * @return array of the token holder individual vesting schedules\n\t */\n\tfunction getVestingSchedulesArray(address holder) public view returns(VestingSchedule[] memory) {\n\t\t// read from the storage and return\n\t\treturn vestingSchedules[holder];\n\t}\n\n\t/**\n\t * @notice  Gets vesting schedules array length for the given token holder\n\t *\n\t * @param holder token holder address to query information for\n\t * @return length of the array of the token holder individual vesting schedules\n\t */\n\tfunction getVestingSchedulesLength(address holder) public view returns(uint256) {\n\t\t// read from the storage and return\n\t\treturn vestingSchedules[holder].length;\n\t}\n\n\t/**\n\t * @notice Gets vesting schedule details for the given token holder\n\t *\n\t * @dev Throws if scheduleId is incorrect (doesn't pass array bounds check)\n\t *\n\t * @param holder token holder address to query information for\n\t * @param scheduleId vesting schedule ID, which is an index of the schedule\n\t *      in the vesting schedules array\n\t * @return schedule token holder individual vesting schedule\n\t */\n\tfunction getVestingSchedule(address holder, uint256 scheduleId) public view returns(VestingSchedule memory schedule) {\n\t\t// read from the storage and return\n\t\treturn vestingSchedules[holder][scheduleId];\n\t}\n\n\t/**\n\t * @notice Restricted access function to create token vesting schedule\n\t *\n\t * @param holder beneficiary, receiver of the vested LIZ tokens\n\t * @param amount how much LIZ coins to add to the beneficiary vesting schedule\n\t * @param startDate vesting start date, unix timestamp\n\t * @param duration vesting duration, seconds\n\t * @return scheduleId created vesting schedule ID\n\t */\n\tfunction createVestingSchedule(\n\t\taddress holder,\n\t\tuint96 amount,\n\t\tuint32 startDate,\n\t\tuint32 duration\n\t) public returns (uint256 scheduleId) {\n\t\t// verify the access permission\n\t\t_requireSenderInRole(ROLE_VESTING_SCHEDULE_CREATOR);\n\n\t\t// delegate to `__vest`, force new schedule creation; set the return result\n\t\tscheduleId = __vest(holder, amount, startDate, duration, true);\n\n\t\t// emit an event\n\t\temit VestingScheduleCreated(holder, scheduleId, amount, startDate, duration);\n\t}\n\n\t/**\n\t * @notice Converts convertable coins (cLIZ, vLIZ, kLIZ, and/or veLIZ) into LIZ.\n\t *      Converted LIZ tokens are subject to vesting according to the following configurable rules:\n\t *      - cLIZ: converted LIZ returned immediately to the holder specified destination, no vesting applied\n\t *      - vLIZ: 10% of converted LIZ returned immediately to holder specified destination;\n\t *              remaining 90% are vested, use getVestingSchedule() to get vesting info\n\t *      - kLIZ: 20% of converted LIZ returned immediately to holder specified destination;\n\t *              remaining 80% are vested, use getVestingSchedule() to get vesting info\n\t *      - veLIZ: converted LIZ are vested, use getVestingSchedule() to get vesting info\n\t *\n\t * @notice Subject to KYC access policies.\n\t *      When `FEATURE_KYC_ENABLED` feature is enabled, the function consults individual\n\t *      convertable coin settings, their respective convert() function access policies, whitelist/blacklist.\n\t *\n\t * @dev Specified amounts of the convertable coins are taken and burnt from the transaction executor;\n\t *      executor must approve spending of at least amounts specified by the vesting contract;\n\t *      burning of the tokens is done by transferring them to the address 0xdEaD\n\t *\n\t * @dev To claim the available vested tokens in the same transaction use multicall()\n\t *\n\t * @dev Emits \"CoinConverted\" event for each coin converted / vested\n\t *\n\t * @param releaseTo receiver of the converted and immediately payed out LIZ tokens (if any)\n\t * @param vestTo an address to create/update vesting schedule for (from the LIZ to be vested)\n\t * @param coins convertable coins addresses to convert\n\t * @param amounts how much of each coin to take and burn from the transaction executor\n\t */\n\tfunction convert(address releaseTo, address vestTo, address[] calldata coins, uint96[] calldata amounts) public {\n\t\t// delegate to `__convert` with the ERC1363 payload switch disabled\n\t\t__convert(releaseTo, vestTo, coins, amounts, false, \"\");\n\t}\n\n\t/**\n\t * @notice ERC1363-friendly version of convert() capable of executing the ERC1363Receiver\n\t  *     `onTransferReceived` callback on the target contract and smooth on-chain integration\n\t *\n\t * @dev To send the immediately returned LIZ tokens to the staking contract,\n\t *      1) set the `target` address to the staking contract address and\n\t *      2) set the bytes `data` field to ERC1363 depositTo() payload on the staking contract\n\t *      3) specify the deposit owner in the ERC1363 depositTo() payload\n\t *\n\t * @param target ERC1363Receiver smart contract to send the converted and immediately payed out LIZ tokens to,\n\t *       and trigger the `onTransferReceived` callback function on\n\t * @param vestTo an address to create/update vesting schedule for (from the LIZ to be vested)\n\t * @param coins convertable coins addresses to convert\n\t * @param amounts how much of each coin to take and burn from the transaction executor\n\t * @param data ERC1363 payload to be passed to the target contract's `onTransferReceived` callback\n\t */\n\tfunction convertAndCall(\n\t\taddress target,\n\t\taddress vestTo,\n\t\taddress[] calldata coins,\n\t\tuint96[] calldata amounts,\n\t\tbytes memory data\n\t) public {\n\t\t// delegate to `__convert` with the ERC1363 payload switch enabled\n\t\t__convert(target, vestTo, coins, amounts, true, data);\n\t}\n\n\t/**\n\t * @dev Conversion convert() and convertAndCall() logic implementation\n\t *\n\t * @param releaseTo receiver of the converted and immediately payed out LIZ tokens (if any), or\n\t *       ERC1363Receiver smart contract to send the converted and immediately payed out LIZ tokens to,\n\t *       and trigger the `onTransferReceived` callback function on\n\t * @param vestTo an address to create/update vesting schedule for (from the LIZ to be vested)\n\t * @param coins convertable coins addresses to convert\n\t * @param amounts how much of each coin to take and burn from the transaction executor\n\t * @param withPayload either treat the `releaseTo` as ERC1363Receiver and trigger the\n\t *       `onTransferReceived` callback on it (true) or not (false)\n\t * @param data ERC1363 payload to be passed to the target contract's `onTransferReceived` callback\n\t */\n\tfunction __convert(\n\t\taddress releaseTo,\n\t\taddress vestTo,\n\t\taddress[] calldata coins,\n\t\tuint96[] calldata amounts,\n\t\tbool withPayload,\n\t\tbytes memory data\n\t) private {\n\t\t// verify the inputs are set\n\t\trequire(vestTo != address(0), \"zero address\");\n\t\trequire(coins.length > 0 && amounts.length > 0, \"empty input\");\n\t\trequire(coins.length == amounts.length, \"arrays lengths mismatch\");\n\n\t\t// how much LIZ we will have to transfer to the beneficiary\n\t\tuint128 payoutAmount = 0;\n\n\t\t// iterate over the requested conversions\n\t\tfor(uint256 i = 0; i < coins.length; i++) {\n\t\t\t// delegate to `__convertSingle` helper to reduce stack usage\n\t\t\tpayoutAmount += __convertSingle(releaseTo, vestTo, coins[i], amounts[i]);\n\t\t}\n\n\t\t// if there is anything to pay out\n\t\tif(payoutAmount > 0) {\n\t\t\t// verify the LIZ conversion feature is enabled\n\t\t\trequire(_isFeatureEnabled(FEATURE_CONVERSION_ENABLED), \"LIZ conversion is not enabled\");\n\t\t\t// if the ERC1363 transfer with callback is requested\n\t\t\tif(withPayload) {\n\t\t\t\t// verify if ERC1363 callable transfers are enabled\n\t\t\t\trequire(_isFeatureEnabled(FEATURE_ERC1363_EXECUTION_ENABLED), \"ERC1363 execution disabled\");\n\t\t\t\t// execute the ERC1363 payout with callback\n\t\t\t\t__treasuryTransferAndCall(releaseTo, payoutAmount, data);\n\t\t\t\t// emit an event with the ERC1363 payload\n\t\t\t\temit LizcoinReleased(msg.sender, coins, amounts, releaseTo, payoutAmount, true, data);\n\t\t\t}\n\t\t\t// otherwise execute simple ERC20 transfer\n\t\t\telse {\n\t\t\t\t// execute the payout\n\t\t\t\t__treasuryTransfer(releaseTo, payoutAmount);\n\t\t\t\t// emit an event without the ERC1363 payload\n\t\t\t\temit LizcoinReleased(msg.sender, coins, amounts, releaseTo, payoutAmount, false, \"\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @dev Helper function to support the __convert() function processing\n\t */\n\tfunction __convertSingle(address releaseTo, address vestTo, address coin, uint96 amount) private returns(uint96) {\n\t\t// verify function access permission\n\t\t_requireAccessCondition(__accessToConvertAllowed(coin, msg.sender));\n\n\t\t// verify the inputs\n\t\trequire(coin != address(0), \"zero coin address\");\n\t\trequire(amount > 0, \"zero amount\");\n\n\t\t// read the convertable coin vesting settings\n\t\tVestingSettings memory settings = getCoinVestingSettings(coin);\n\n\t\t// burn the token by safe transferring (require) it to the \"dead\" address\n\t\tcoin.safeTransferFrom(msg.sender, DEAD_ADDRESS, amount);\n\n\t\t// split the token amount into the shares to unlock immediately and to vest\n\t\t(uint96 toUnlock, uint96 toVest) = __split(\n\t\t\t__convert(amount, settings.conversionRate),\n\t\t\tsettings.immUnlockPercent\n\t\t);\n\n\t\t// vesting schedule ID 0 is the default one\n\t\tuint256 scheduleId = 0;\n\t\t// if there is anything to vest\n\t\tif(toVest > 0) {\n\t\t\t// verify vesting schedule creation feature is enabled\n\t\t\trequire(_isFeatureEnabled(FEATURE_SCHEDULE_CREATION_ENABLED), \"vesting schedule creation is not enabled\");\n\t\t\t// create/update vesting schedule, determine vesting schedule ID\n\t\t\tscheduleId = __vest(vestTo, toVest, __startDate(settings), settings.unlockingDuration, false);\n\t\t}\n\n\t\t// emit an event\n\t\temit CoinConverted(coin, msg.sender, releaseTo, vestTo, amount, toUnlock, scheduleId, toVest);\n\n\t\t// return amount of coins to release immediately\n\t\treturn toUnlock;\n\t}\n\n\t/**\n\t * @notice Claims the LIZ tokens available for claiming on the specified\n\t *      vesting schedule (defined by its ID) of the transaction executor\n\t *\n\t * @dev Throws if the schedule specified has nothing to claim\n\t *\n\t * @param scheduleId vesting schedule ID to claim\n\t * @param to an address to send claimed LIZ tokens to\n\t * @param amountCap if specified (not zero), limits the amount claimed;\n\t *      use this if claiming all the tokens available on the schedule is undesirable\n\t */\n\tfunction claimTo(uint256 scheduleId, address to, uint96 amountCap) public {\n\t\t// verify claiming feature is enabled\n\t\trequire(_isFeatureEnabled(FEATURE_CLAIMING_ENABLED), \"claiming is not enabled\");\n\n\t\t// execute the claim\n\t\t__executeClaimTo(to, __prepareClaimTo(scheduleId, to, amountCap));\n\t}\n\n\t/**\n\t * @notice Claims the tokens available for claiming on the specified\n\t *      vesting schedules (defined by their IDs) of the transaction executor\n\t *\n\t * @dev Throws if ALL the schedules specified have nothing to claim\n\t *\n\t * @param scheduleIds vesting schedules IDs to claim\n\t * @param to an address to send claimed tokens to\n\t * @param amountCap if specified (not zero), limits the total amount claimed;\n\t *      use this if claiming all the tokens available on the schedules is undesirable\n\t */\n\tfunction claimTo(uint256[] calldata scheduleIds, address to, uint96 amountCap) public {\n\t\t// verify claiming feature is enabled\n\t\trequire(_isFeatureEnabled(FEATURE_CLAIMING_ENABLED), \"claiming is not enabled\");\n\n\t\t// verify there is at least one schedule to claim\n\t\trequire(scheduleIds.length > 0, \"no schedules to claim\");\n\n\t\t// counter for the total claimed amount from all the schedules\n\t\tuint96 claimedAmount = 0;\n\n\t\t// iterate the specified scheduleIds array\n\t\tfor(uint256 i = 0; i < scheduleIds.length && (amountCap == 0 || amountCap > claimedAmount); i++) {\n\t\t\t// and prepare each claim individually, delaying real transfer\n\t\t\tclaimedAmount += __prepareClaimTo(scheduleIds[i], to, amountCap == 0? 0: amountCap - claimedAmount);\n\t\t}\n\n\t\t// execute all the claims, execute the delayed transfer\n\t\t__executeClaimTo(to, claimedAmount);\n\t}\n\n\t/**\n\t * @notice Claims the tokens available for claiming on the specified\n\t *      vesting schedules (defined by their IDs) of the transaction executor\n\t *\n\t * @dev Throws if ANY of the schedules specified has nothing to claim\n\t *\n\t * @param scheduleIds vesting schedules IDs to claim\n\t * @param tos addresses to send claimed tokens to\n\t * @param amountCaps if specified (not zero), limits the amount claimed;\n\t *      use this if claiming all the tokens available on the schedules is undesirable\n\t */\n\tfunction claimTo(uint256[] calldata scheduleIds, address[] calldata tos, uint96[] calldata amountCaps) public {\n\t\t// verify claiming feature is enabled\n\t\trequire(_isFeatureEnabled(FEATURE_CLAIMING_ENABLED), \"claiming is not enabled\");\n\n\t\t// ensure arrays have the same lengths\n\t\trequire(scheduleIds.length == tos.length && scheduleIds.length == amountCaps.length, \"arrays lengths mismatch\");\n\n\t\t// verify there is at least one schedule to claim\n\t\trequire(scheduleIds.length > 0, \"no schedules to claim\");\n\n\t\t// iterate both scheduleIds and tos arrays\n\t\tfor(uint256 i = 0; i < scheduleIds.length; i++) {\n\t\t\t// and execute each claim individually\n\t\t\t__executeClaimTo(tos[i], __prepareClaimTo(scheduleIds[i], tos[i], amountCaps[i]));\n\t\t}\n\t}\n\n\t/**\n\t * @notice Claims all the tokens available for claiming (on all vesting schedules)\n\t *      of the transaction executor\n\t *\n\t * @dev Throws if there is nothing to claim\n\t *\n\t * @dev WARNING: potentially gas expensive function!\n\t *      This function is not guaranteed to succeed (out of gas).\n\t *\n\t * @param to address to send claimed tokens to\n\t * @param amountCap if specified (not zero), limits the amount claimed;\n\t *      use this if claiming all the tokens available on the schedules is undesirable\n\t */\n\tfunction claimAllTo(address to, uint96 amountCap) public {\n\t\t// verify claiming feature is enabled\n\t\trequire(_isFeatureEnabled(FEATURE_CLAIMING_ENABLED), \"claiming is not enabled\");\n\n\t\t// cache the array length on stack\n\t\tuint256 length = vestingSchedules[msg.sender].length;\n\n\t\t// verify there is at least one schedule to claim\n\t\trequire(length > 0, \"no schedules to claim\");\n\n\t\t// counter for the total claimed amount from all the schedules\n\t\tuint96 claimedAmount = 0;\n\n\t\t// iterate all the schedules\n\t\tfor(uint256 i = 0; i < length && (amountCap == 0 || amountCap > claimedAmount); i++) {\n\t\t\t// and prepare each claim individually, delaying real transfer\n\t\t\tclaimedAmount += __prepareClaimTo(i, to, amountCap == 0? 0: amountCap - claimedAmount);\n\t\t}\n\n\t\t// execute all the claims, execute the delayed transfer\n\t\t__executeClaimTo(to, claimedAmount);\n\t}\n\n\t/**\n\t * @dev Prepares the claim for tokens available on the specified vesting schedule (identified by its ID)\n\t *     for the transaction executor:\n\t *     verifies the inputs,\n\t *     claims the tokens from the vesting schedule (updates the vesting schedule),\n\t *     DOESN'T transfer the tokens claimed from the vesting schedule\n\t *\n\t * @dev Parent caller function MUST finish the claim using `__executeClaimTo` function; or revert\n\t *\n\t * @param scheduleId vesting schedule ID to claim\n\t * @param to beneficiary, an address to send claimed tokens to\n\t * @param amountCap if specified (not zero), limits the amount claimed\n\t * @return the amount claimed to be passed to `__executeClaimTo` function;\n\t *      if amountCap is not zero, amount is guaranteed not to exceed the amountCap\n\t */\n\tfunction __prepareClaimTo(uint256 scheduleId, address to, uint96 amountCap) private returns (uint96) {\n\t\t// calculate the claimable amount\n\t\tuint96 claimableAmount = getClaimableAmount(msg.sender, scheduleId);\n\n\t\t// check if we are asked to exit silently\n\t\tif(claimableAmount == 0) {\n\t\t\t// exit if conditions are met\n\t\t\treturn 0;\n\t\t}\n\n\t\t// if cap the amount is requested and is applicable\n\t\tif(amountCap > 0 && claimableAmount > amountCap) {\n\t\t\t// apply the amount cap\n\t\t\tclaimableAmount = amountCap;\n\t\t}\n\n\t\t// update vesting schedule\n\t\t__claim(msg.sender, scheduleId, claimableAmount);\n\n\t\t// emit an event\n\t\temit LizcoinClaimed(msg.sender, scheduleId, to, claimableAmount, amountCap);\n\n\t\t// return the amount claimed from the vesting schedule\n\t\treturn claimableAmount;\n\t}\n\n\t/**\n\t * @notice Finishes the claim of the tokens available for claiming by sending\n\t *      the specified amount of tokens to the beneficiary\n\t *\n\t * @dev Sends the tokens to the beneficiary but doesn't update the vesting schedule;\n\t *      caller MUST initialize the claim using `__prepareClaimTo` function prior to\n\t *      executing this real transfer\n\t *\n\t * @param to beneficiary, an address to send tokens to\n\t * @param amount the amount claimed returned by `__prepareClaimTo` function\n\t */\n\tfunction __executeClaimTo(address to, uint96 amount) private {\n\t\t// fail the transaction if it claimed nothing\n\t\trequire(amount > 0, \"nothing to claim\");\n\n\t\t// execute the token transfer from the treasury\n\t\t__treasuryTransfer(to, amount);\n\t}\n\n\t/**\n\t * @notice Current claimable amount for the given holder and given schedule\n\t *\n\t * @param holder address of the vesting schedule holder\n\t * @param scheduleId vesting schedule ID to query information for\n\t * @return claimableAmount an amount available for claiming right now\n\t */\n\tfunction getClaimableAmount(address holder, uint256 scheduleId) public view returns(uint96 claimableAmount) {\n\t\t// verify scheduleId is valid\n\t\trequire(scheduleId < vestingSchedules[holder].length, \"invalid vesting schedule ID\");\n\n\t\t// load vesting schedule into memory\n\t\tVestingSchedule memory vestingSchedule = vestingSchedules[holder][scheduleId];\n\n\t\t// apply the pure function and return\n\t\treturn getClaimableAmount(\n\t\t\tvestingSchedule.startDate,\n\t\t\tvestingSchedule.duration,\n\t\t\tvestingSchedule.amountVested,\n\t\t\tvestingSchedule.amountClaimed,\n\t\t\tnow32()\n\t\t);\n\t}\n\n\t/**\n\t * @notice Current claimable amounts for the given holder and multiple schedules\n\t *\n\t * @param holder address of the vesting schedule holder\n\t * @param scheduleIds an array of vesting schedule IDs to query information for\n\t * @return claimableAmounts an array of amounts available for claiming right now\n\t */\n\tfunction getClaimableAmounts(address holder, uint256[] calldata scheduleIds) public view returns(\n\t\tuint96[] memory claimableAmounts\n\t) {\n\t\t// allocate memory for the result array\n\t\tclaimableAmounts = new uint96[](scheduleIds.length);\n\n\t\t// iterate the specified scheduleIds array\n\t\tfor(uint256 i = 0; i < scheduleIds.length; i++) {\n\t\t\t// and save the claimable amount for each schedule\n\t\t\tclaimableAmounts[i] = getClaimableAmount(holder, scheduleIds[i]);\n\t\t}\n\n\t\t// do an explicit return for better code readability\n\t\treturn claimableAmounts;\n\t}\n\n\t/**\n\t * @notice Current claimable amounts for multiple holders and multiple schedules\n\t *\n\t * @param holders an array of addresses of the vesting schedule holders\n\t * @param scheduleIds an array of vesting schedule IDs to query information for\n\t * @return claimableAmounts an array of amounts available for claiming right now\n\t */\n\tfunction getClaimableAmounts(address[] calldata holders, uint256[] calldata scheduleIds) public view returns(\n\t\tuint96[] memory claimableAmounts\n\t) {\n\t\t// ensure arrays have the same lengths\n\t\trequire(holders.length == scheduleIds.length, \"arrays lengths mismatch\");\n\n\t\t// allocate memory for the result array\n\t\tclaimableAmounts = new uint96[](scheduleIds.length);\n\n\t\t// iterate the specified scheduleIds array\n\t\tfor(uint256 i = 0; i < scheduleIds.length; i++) {\n\t\t\t// and save the claimable amount for each schedule\n\t\t\tclaimableAmounts[i] = getClaimableAmount(holders[i], scheduleIds[i]);\n\t\t}\n\n\t\t// do an explicit return for better code readability\n\t\treturn claimableAmounts;\n\t}\n\n\t/**\n\t * @notice Current claimable amounts for the given holder (for all the schedules)\n\t *\n\t * @dev WARNING: potentially gas expensive function!\n\t *      This function is not guaranteed to succeed (out of gas).\n\t *\n\t * @param holder address of the vesting schedule holder\n\t * @return claimableAmounts an array of amounts available for claiming right now\n\t */\n\tfunction getAllClaimableAmounts(address holder) public view returns(uint96[] memory claimableAmounts) {\n\t\t// allocate memory for the result array\n\t\tclaimableAmounts = new uint96[](vestingSchedules[holder].length);\n\n\t\t// iterate the array\n\t\tfor(uint256 i = 0; i < claimableAmounts.length; i++) {\n\t\t\t// and save the claimable amount for each schedule\n\t\t\tclaimableAmounts[i] = getClaimableAmount(holder, i);\n\t\t}\n\n\t\t// do an explicit return for better code readability\n\t\treturn claimableAmounts;\n\t}\n\n\t/**\n\t * @notice Current total claimable amount for the given holder (for all the schedules)\n\t *\n\t * @dev WARNING: potentially gas expensive function!\n\t *      This function is not guaranteed to succeed (out of gas).\n\t *\n\t * @param holder address of the vesting schedule holder\n\t * @return claimableAmount total amount available for claiming right now (across all the schedules)\n\t */\n\tfunction getTotalClaimableAmount(address holder) public view returns(uint96 claimableAmount) {\n\t\t// cache the array length on stack\n\t\tuint256 length = vestingSchedules[holder].length;\n\t\t// iterate the vesting schedules array\n\t\tfor(uint256 i = 0; i < length; i++) {\n\t\t\t// and accumulate the claimable amount for each schedule\n\t\t\tclaimableAmount += getClaimableAmount(holder, i);\n\t\t}\n\n\t\t// do an explicit return for better code readability\n\t\treturn claimableAmount;\n\t}\n\n\t/**\n\t * @notice Claimable amount function for the vesting schedule params\n\t *\n\t * @dev Pure function convenient for tests of the various nature\n\t *\n\t * @dev Cliff is zero, slice period is one second\n\t *\n\t * @param startDate vesting schedule start date, unix timestamp\n\t * @param duration vesting schedule duration, seconds\n\t * @param amountVested vesting schedule vested amount, wei\n\t * @param amountClaimed vesting schedule claimed amount, wei\n\t * @param timestamp unix timestamp to evaluate the claimable amount for\n\t * @return claimableAmount an amount available for claiming\n\t */\n\tfunction getClaimableAmount(\n\t\tuint32 startDate,\n\t\tuint32 duration,\n\t\tuint96 amountVested,\n\t\tuint96 amountClaimed,\n\t\tuint32 timestamp\n\t) public pure returns(uint96 claimableAmount) {\n\t\t// if vesting is already finished in full\n\t\tif(duration >= timestamp || startDate <= timestamp - duration) {\n\t\t\t// everything is claimable in full\n\t\t\treturn amountVested - amountClaimed;\n\t\t}\n\n\t\t// if it is too early (cliff didn't yet pass)\n\t\tif(timestamp <= startDate) {\n\t\t\t// there is nothing to claim\n\t\t\treturn 0;\n\t\t}\n\n\t\t// otherwise, calculate based on current time and return\n\t\treturn (uint128(amountVested) * (timestamp - startDate) / duration - amountClaimed).toUint96();\n\t}\n\n\t/**\n\t * @dev Converts amount A into amount B using the conversion rate;\n\t *      more formally, converts an amount into amount / rate\n\t *\n\t * @param amount an amount to convert, wei\n\t * @param rate conversion rate with 18 digits precision: 1:1 is 10^18\n\t *      a conversion rate is a measure of how much units of one asset are needed to obtain one unit of another asset\n\t * @return amount / rate \n\t */\n\tfunction __convert(uint96 amount, uint96 rate) private pure returns(uint96) {\n\t\t// calculate and return\n\t\treturn (uint192(amount) * 1 ether / rate).toUint96();\n\t}\n\n\t/**\n\t * @dev Splits an amount into amount% and 1 - amount% portions\n\t *\n\t * @dev amount an amount to split, wei\n\t * @dev percent a share percent to use for split, [0, 100%] with 18 digits precision: 100% is 10^18\n\t * @return a amount * percent\n\t * @return b amount * (1 - percent)\n\t */\n\tfunction __split(uint96 amount, uint64 percent) private pure returns(uint96 a, uint96 b) {\n\t\t// calculate the first share\n\t\ta = (uint160(amount) * percent / 1 ether).toUint96();\n\t\t// put the remainder into the second share\n\t\tb = amount - a;\n\t}\n\n\t/**\n\t * @dev Utility function to top up holder's vesting schedule\n\t *      Unsafe. Must be kept private at all times.\n\t *\n\t * @param holder beneficiary, receiver of the vested LIZ tokens\n\t * @param amount how much LIZ coins to add to the beneficiary vesting schedule\n\t * @param startDate vesting start date, unix timestamp\n\t * @param duration vesting duration, seconds\n\t * @param forceNewScheduleCreation false to allow existing schedule top-up instead\n\t *      of creating new one; true to forbid existing schedule top-up and enforce\n\t *      new vesting schedule creation\n\t * @return scheduleId created/updated vesting schedule ID\n\t */\n\tfunction __vest(\n\t\taddress holder,\n\t\tuint96 amount,\n\t\tuint32 startDate,\n\t\tuint32 duration,\n\t\tbool forceNewScheduleCreation\n\t) private returns (uint256 scheduleId) {\n\t\t// update global counter\n\t\t_totalVested += amount;\n\n\t\t// we will be adding the schedule to the end of the array\n\t\tscheduleId = vestingSchedules[holder].length;\n\n\t\t// if unlocking didn't yet start and vesting schedule was already created\n\t\tif(!forceNewScheduleCreation && startDate > now32() && scheduleId > 0) {\n\t\t\t// we may try topping it up instead of creating new one\n\t\t\t// search for the schedule with the same settings\n\t\t\tfor(uint256 i = 0; i < __min(5, scheduleId); i++) {\n\t\t\t\t// read the schedule into the memory\n\t\t\t\tVestingSchedule memory schedule = vestingSchedules[holder][i];\n\n\t\t\t\t// check if vesting schedule has the same settings\n\t\t\t\tif(schedule.startDate == startDate && schedule.duration == duration) {\n\t\t\t\t\t// calculate the new value (for the the schedule topped up)\n\t\t\t\t\tuint128 amountVested = uint128(schedule.amountVested) + amount;\n\t\t\t\t\t// only if the new amount fits into the uint96\n\t\t\t\t\tif(amountVested <= type(uint96).max) {\n\t\t\t\t\t\t// update the vesting schedule (top it up)\n\t\t\t\t\t\tvestingSchedules[holder][i].amountVested = uint96(amountVested);\n\t\t\t\t\t\t// exit early, return the vesting schedule ID found\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// otherwise we're creating a new one\n\t\tvestingSchedules[holder].push(VestingSchedule({\n\t\t\tstartDate: startDate,\n\t\t\tduration: duration,\n\t\t\tamountVested: amount,\n\t\t\tamountClaimed: 0\n\t\t}));\n\t}\n\n\t/**\n\t * @dev Utility function to claim from holder's vesting schedule\n\t *      Unsafe. Must be kept private at all times.\n\t */\n\tfunction __claim(address holder, uint256 scheduleId, uint96 amount) private {\n\t\t// update the vesting schedule\n\t\tvestingSchedules[holder][scheduleId].amountClaimed += amount;\n\t\t// update global counter\n\t\t_totalClaimed += amount;\n\t}\n\n\t/**\n\t * @dev Transfers LIZ tokens from the treasury wallet to the destination address\n\t *      and, optionally executes the ERC1363 callback on the destination.\n\t *\n\t * @dev Unsafe. Must be kept private at all times.\n\t *\n\t * @param to destination address to transfer the tokens to\n\t * @param value amount of the tokens to transfer\n\t */\n\tfunction __treasuryTransfer(address to, uint256 value) private {\n\t\t// if treasury is not set, transfer from the contract itself\n\t\t// if treasury is set, use transfer on behalf transfer even if the treasury\n\t\t// is set to the vesting contract address\n\t\trequire(\n\t\t\ttreasury == address(0) && lizcoin.transfer(to, value)\n\t\t\t|| lizcoin.transferFrom(treasury, to, value),\n\t\t\t\"treasury transfer failed\"\n\t\t);\n\t}\n\n\t/**\n\t * @dev Sends LIZ tokens to the specified ERC1361Receiver contract and executes the\n\t *      `onTransferReceived` callback on it\n\t *\n\t * @dev Unsafe. Must be kept private at all times.\n\t *\n\t * @param target ERC1363Receiver smart contract to send the converted and immediately payed out LIZ tokens to,\n\t *       and trigger the `onTransferReceived` callback function on\n\t * @param value amount of the tokens to transfer\n\t * @param data ERC1363 payload to be passed to the target contract's `onTransferReceived` callback\n\t */\n\tfunction __treasuryTransferAndCall(address target, uint256 value, bytes memory data) private {\n\t\t// if treasury is not set, transfer from the contract itself\n\t\t// if treasury is set, use transfer on behalf transfer even if the treasury\n\t\t// is set to the vesting contract address\n\t\trequire(\n\t\t\ttreasury == address(0) && lizcoin.transferAndCall(target, value, data)\n\t\t\t|| lizcoin.transferFromAndCall(treasury, target, value, data),\n\t\t\t\"treasury transfer failed\"\n\t\t);\n\t}\n\n\t/**\n\t * @dev Checks LIZ tokens balance of the treasury wallet, fallbacks to self-balance if\n\t *      the treasury wallet address is not set (zero)\n\t *\n\t * @param treasuryAddress treasury wallet address, or zero address to check self-balance\n\t * @return LIZ token balance of the treasury wallet, or self-balance if the treasury is not set\n\t */\n\tfunction __treasuryBalance(address treasuryAddress) internal view returns(uint256) {\n\t\t// if treasury is zero address, check vesting contract's own balance\n\t\t// if treasury is not zero, check its balance\n\t\treturn treasuryAddress == address(0)? lizcoin.balanceOf(address(this)): lizcoin.balanceOf(treasuryAddress);\n\t}\n\n\t/**\n\t * @dev Utility function to calculate vesting start date based on settings and current time\n\t */\n\tfunction __startDate(VestingSettings memory settings) private view returns(uint32) {\n\t\t// read vesting settings flags as booleans\n\t\t(bool startDateOverride,) = __parseFlags(settings.flags);\n\t\t// effective start date is a maximum of the configured date and current time\n\t\treturn settings.unlockingStartDate < now32() && startDateOverride? now32(): settings.unlockingStartDate;\n\t}\n\n\t/**\n\t * @dev Utility function to extract vesting flags as booleans from the bitmask\n\t */\n\tfunction __parseFlags(uint32 flags) private pure returns(bool startDateOverride, bool forbidAllExceptAllowed) {\n\t\t// extract known flags one by one\n\t\tstartDateOverride = flags.isBitSet(0);\n\t\tforbidAllExceptAllowed = flags.isBitSet(1);\n\t}\n\n\t/**\n\t * @dev Utility function to extract the access flags as booleans from the bitmask\n\t */\n\tfunction __parseKycFlags(uint8 flags) private pure returns(bool blacklisted, bool whitelisted) {\n\t\t// extract known access flags one by one\n\t\twhitelisted = flags.isBitSet(0);\n\t\tblacklisted = flags.isBitSet(1);\n\t}\n\n\t/**\n\t * @dev Returns minimum of the two unsigned integers\n\t */\n\tfunction __min(uint256 a, uint256 b) private pure returns(uint256) {\n\t\t// compare and return\n\t\treturn a < b? a: b;\n\t}\n\n\t/**\n\t * @notice People do mistakes and may send tokens by mistake.\n\t *      This function allows to recover from some of these mistakes.\n\t *\n\t * @dev Restricted access function to rescue tokens accidentally sent into\n\t *      the vesting smart contract\n\t *\n\t * @dev The tokens are rescued via ERC20 `transfer` function call on the\n\t *      contract address specified and with the parameters specified:\n\t *      `contractAddress.transfer(to, value)`\n\t *\n\t * @dev Requires executor to have `ROLE_RESCUE_MANAGER` permission\n\t *\n\t * @param contractAddress smart contract address to execute `transfer` function on\n\t * @param to to address in `transfer(to, value)`\n\t * @param value value to transfer in `transfer(to, value)`\n\t */\n\tfunction rescueErc20(address contractAddress, address to, uint256 value) public {\n\t\t// verify the access permission\n\t\t_requireSenderInRole(ROLE_RESCUE_MANAGER);\n\n\t\t// perform the transfer as requested, without any checks\n\t\tcontractAddress.safeTransfer(to, value);\n\t}\n\n\t/**\n\t * @notice People do mistakes and may send tokens by mistake.\n\t *      This function allows to recover from some of these mistakes.\n\t *\n\t * @dev Restricted access function to rescue tokens accidentally sent into\n\t *      the vesting smart contract\n\t *\n\t * @dev The tokens are rescued via ERC20/ERC721 `transferFrom` function call on the\n\t *      contract address specified and with the parameters specified:\n\t *      `contractAddress.transferFrom(this, to, tokenId)`\n\t *\n\t * @dev Requires executor to have `ROLE_RESCUE_MANAGER` permission\n\t *\n\t * @param contractAddress smart contract address to execute `transfer` function on\n\t * @param to to address in `transferFrom(this, to, value)`\n\t * @param value value to transfer in `transferFrom(this, to, value)`;\n\t *      this can also be a tokenId for ERC721 transfer\n\t */\n\tfunction rescueToken(address contractAddress, address to, uint256 value) public {\n\t\t// verify the access permission\n\t\t_requireSenderInRole(ROLE_RESCUE_MANAGER);\n\n\t\t// perform the transfer as requested, without any checks\n\t\tcontractAddress.safeTransferFrom(address(this), to, value);\n\t}\n\n\t/**\n\t * @dev Testing time-dependent functionality may be difficult;\n\t *      we override time in the helper test smart contract (mock)\n\t *\n\t * @return `block.timestamp` in mainnet, custom values in testnets (if overridden)\n\t */\n\tfunction now32() public view virtual returns(uint32) {\n\t\t// return current block timestamp\n\t\treturn uint32(block.timestamp);\n\t}\n}\n"
    }
  }
}}