{{
  "language": "Solidity",
  "sources": {
    "src/contracts/BCoWHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.25;\n\nimport {IBCoWFactory} from 'interfaces/IBCoWFactory.sol';\nimport {IBCoWPool} from 'interfaces/IBCoWPool.sol';\n\nimport {ICOWAMMPoolHelper} from '@cow-amm/interfaces/ICOWAMMPoolHelper.sol';\n\nimport {IERC20} from '@cowprotocol/interfaces/IERC20.sol';\nimport {GPv2Interaction} from '@cowprotocol/libraries/GPv2Interaction.sol';\nimport {GPv2Order} from '@cowprotocol/libraries/GPv2Order.sol';\n\nimport {BCoWConst} from './BCoWConst.sol';\nimport {BMath} from './BMath.sol';\n\n/**\n * @title BCoWHelper\n * @notice Helper contract that allows to trade on CoW Swap Protocol.\n * @dev This contract supports only 2-token pools.\n */\ncontract BCoWHelper is ICOWAMMPoolHelper, BMath, BCoWConst {\n  using GPv2Order for GPv2Order.Data;\n\n  /**\n   * @dev Collection of pool information on a specific token\n   * @param token The token all fields depend on\n   * @param balance The pool balance for the token\n   * @param denormWeight Denormalized weight of the token\n   * @param normWeight Normalized weight of the token\n   */\n  struct Reserves {\n    IERC20 token;\n    uint256 balance;\n    uint256 denormWeight;\n    uint256 normWeight;\n  }\n\n  /// @notice The app data used by this helper's factory.\n  bytes32 internal immutable _APP_DATA;\n\n  /// @inheritdoc ICOWAMMPoolHelper\n  // solhint-disable-next-line style-guide-casing\n  address public immutable factory;\n\n  /// @notice The input token to the call is not traded on the pool.\n  error InvalidToken();\n\n  constructor(address factory_) {\n    factory = factory_;\n    _APP_DATA = IBCoWFactory(factory_).APP_DATA();\n  }\n\n  /// @inheritdoc ICOWAMMPoolHelper\n  function order(\n    address pool,\n    uint256[] calldata prices\n  )\n    external\n    view\n    returns (\n      GPv2Order.Data memory order_,\n      GPv2Interaction.Data[] memory preInteractions,\n      GPv2Interaction.Data[] memory postInteractions,\n      bytes memory sig\n    )\n  {\n    address[] memory tokenPair = tokens(pool);\n    Reserves memory reservesToken0 = _reserves(IBCoWPool(pool), IERC20(tokenPair[0]));\n    Reserves memory reservesToken1 = _reserves(IBCoWPool(pool), IERC20(tokenPair[1]));\n\n    (Reserves memory reservesIn, uint256 amountIn, Reserves memory reservesOut) =\n      _amountInFromPrices(reservesToken0, reservesToken1, prices);\n\n    return _orderFromBuyAmount(pool, reservesIn, amountIn, reservesOut);\n  }\n\n  /// @notice Method for returning the canonical order required to satisfy the\n  /// pool's invariants, given a buy token and exact buy amount.\n  /// @param pool Pool to calculate the order / signature for\n  /// @param buyToken The address used in the resulting order as the buy token\n  /// @param buyAmount The exact buy amount used in the resulting order\n  /// @return order_ The CoW Protocol JIT order\n  /// @return preInteractions The array array for any **PRE** interactions(empty if none)\n  /// @return postInteractions The array array for any **POST** interactions (empty if none)\n  /// @return sig A valid CoW-Protocol signature for the resulting order using\n  /// the ERC-1271 signature scheme.\n  function orderFromBuyAmount(\n    address pool,\n    address buyToken,\n    uint256 buyAmount\n  )\n    external\n    view\n    returns (\n      GPv2Order.Data memory order_,\n      GPv2Interaction.Data[] memory preInteractions,\n      GPv2Interaction.Data[] memory postInteractions,\n      bytes memory sig\n    )\n  {\n    address tokenIn = buyToken;\n    address tokenOut = _otherTokenInPair(pool, tokenIn);\n    Reserves memory reservesIn = _reserves(IBCoWPool(pool), IERC20(tokenIn));\n    Reserves memory reservesOut = _reserves(IBCoWPool(pool), IERC20(tokenOut));\n\n    return _orderFromBuyAmount(pool, reservesIn, buyAmount, reservesOut);\n  }\n\n  /// @notice Method for returning the canonical order required to satisfy the\n  /// pool's invariants, given a sell token and a **tentative** sell amount.\n  /// The sell amount of the resulting order will not exactly be the input sell\n  /// amount, however it should be fairly close for typical pool configurations.\n  /// @param pool Pool to calculate the order / signature for\n  /// @param sellToken The address used in the resulting order as the sell token\n  /// @param sellAmount The **tentative** sell amount used in the resulting order\n  /// @return order_ The CoW Protocol JIT order\n  /// @return preInteractions The array array for any **PRE** interactions (empty if none)\n  /// @return postInteractions The array array for any **POST** interactions (empty if none)\n  /// @return sig A valid CoW-Protocol signature for the resulting order using\n  /// the ERC-1271 signature scheme.\n  function orderFromSellAmount(\n    address pool,\n    address sellToken,\n    uint256 sellAmount\n  )\n    external\n    view\n    returns (\n      GPv2Order.Data memory order_,\n      GPv2Interaction.Data[] memory preInteractions,\n      GPv2Interaction.Data[] memory postInteractions,\n      bytes memory sig\n    )\n  {\n    address tokenOut = sellToken;\n    address tokenIn = _otherTokenInPair(pool, tokenOut);\n\n    Reserves memory reservesIn = _reserves(IBCoWPool(pool), IERC20(tokenIn));\n    Reserves memory reservesOut = _reserves(IBCoWPool(pool), IERC20(tokenOut));\n\n    uint256 amountIn = calcInGivenOut({\n      tokenBalanceIn: reservesIn.balance,\n      tokenWeightIn: reservesIn.denormWeight,\n      tokenBalanceOut: reservesOut.balance,\n      tokenWeightOut: reservesOut.denormWeight,\n      tokenAmountOut: sellAmount,\n      swapFee: 0\n    });\n    return _orderFromBuyAmount(pool, reservesIn, amountIn, reservesOut);\n  }\n\n  /// @inheritdoc ICOWAMMPoolHelper\n  function tokens(address pool) public view virtual returns (address[] memory tokens_) {\n    // reverts in case pool is not deployed by the helper's factory\n    if (!IBCoWFactory(factory).isBPool(pool)) {\n      revert PoolDoesNotExist();\n    }\n\n    // call reverts with `BPool_PoolNotFinalized()` in case pool is not finalized\n    tokens_ = IBCoWPool(pool).getFinalTokens();\n\n    // reverts in case pool is not supported (non-2-token pool)\n    if (tokens_.length != 2) {\n      revert PoolDoesNotExist();\n    }\n  }\n\n  /// @notice Helper method to compute the output of `orderFromBuyAmount`.\n  /// @param pool Pool to calculate the order / signature for\n  /// @param reservesIn Details for the input token to the pool\n  /// @param amountIn Token amount moving into the pool for this order\n  /// @param reservesOut Details for the output token to the pool\n  /// @return order_ The CoW Protocol JIT order\n  /// @return preInteractions The array array for any **PRE** interactions (empty if none)\n  /// @return postInteractions The array array for any **POST** interactions (empty if none)\n  /// @return sig A valid CoW-Protocol signature for the resulting order using\n  /// the ERC-1271 signature scheme.\n  function _orderFromBuyAmount(\n    address pool,\n    Reserves memory reservesIn,\n    uint256 amountIn,\n    Reserves memory reservesOut\n  )\n    internal\n    view\n    returns (\n      GPv2Order.Data memory order_,\n      GPv2Interaction.Data[] memory preInteractions,\n      GPv2Interaction.Data[] memory postInteractions,\n      bytes memory sig\n    )\n  {\n    order_ = _rawOrderFrom(reservesIn, amountIn, reservesOut);\n    (preInteractions, postInteractions, sig) = _prepareSettlement(pool, order_);\n  }\n\n  /// @notice Helper method to compute interactions and signature for the input\n  /// CoW Protocol JIT order.\n  /// @param pool Pool to calculate the interactions / signature for\n  /// @param order_ The CoW Protocol JIT order\n  /// @return preInteractions The array array for any **PRE** interactions (empty if none)\n  /// @return postInteractions The array array for any **POST** interactions (empty if none)\n  /// @return sig A valid CoW-Protocol signature for the resulting order using\n  /// the ERC-1271 signature scheme.\n  function _prepareSettlement(\n    address pool,\n    GPv2Order.Data memory order_\n  )\n    internal\n    view\n    returns (\n      GPv2Interaction.Data[] memory preInteractions,\n      GPv2Interaction.Data[] memory postInteractions,\n      bytes memory sig\n    )\n  {\n    // A ERC-1271 signature on CoW Protocol is composed of two parts: the\n    // signer address and the valid ERC-1271 signature data for that signer.\n    bytes memory eip1271sig;\n    eip1271sig = abi.encode(order_);\n    sig = abi.encodePacked(pool, eip1271sig);\n\n    // Generate the order commitment pre-interaction\n    bytes32 domainSeparator = IBCoWPool(pool).SOLUTION_SETTLER_DOMAIN_SEPARATOR();\n    bytes32 orderCommitment = order_.hash(domainSeparator);\n\n    preInteractions = new GPv2Interaction.Data[](1);\n    preInteractions[0] = GPv2Interaction.Data({\n      target: pool,\n      value: 0,\n      callData: abi.encodeWithSelector(IBCoWPool.commit.selector, orderCommitment)\n    });\n\n    return (preInteractions, postInteractions, sig);\n  }\n\n  /// @notice Returns the order that is suggested to be executed to CoW Protocol\n  /// for specific reserves of a pool given the current chain state and the\n  /// traded amount. The price of the order is on the AMM curve for the traded\n  /// amount.\n  /// @dev This function takes an input amount and guarantees that the final\n  /// order has that input amount and is a valid order. We use `calcOutGivenIn`\n  /// to compute the output amount as this is the function used to check that\n  /// the CoW Swap order is valid in the contract. It would not be possible to\n  /// just define the same function by specifying an output amount and use\n  /// `calcInGiveOut`: because of rounding issues the resulting order could be\n  /// invalid.\n  /// @param reservesIn Data related to the input token of this trade\n  /// @param amountIn Token amount moving into the pool for this order\n  /// @param reservesOut Data related to the output token of this trade\n  /// @return order_ The CoW Protocol JIT order\n  function _rawOrderFrom(\n    Reserves memory reservesIn,\n    uint256 amountIn,\n    Reserves memory reservesOut\n  ) internal view returns (GPv2Order.Data memory order_) {\n    uint256 amountOut = calcOutGivenIn({\n      tokenBalanceIn: reservesIn.balance,\n      tokenWeightIn: reservesIn.denormWeight,\n      tokenBalanceOut: reservesOut.balance,\n      tokenWeightOut: reservesOut.denormWeight,\n      tokenAmountIn: amountIn,\n      swapFee: 0\n    });\n    return GPv2Order.Data({\n      sellToken: reservesOut.token,\n      buyToken: reservesIn.token,\n      receiver: GPv2Order.RECEIVER_SAME_AS_OWNER,\n      sellAmount: amountOut,\n      buyAmount: amountIn,\n      validTo: uint32(block.timestamp) + MAX_ORDER_DURATION,\n      appData: _APP_DATA,\n      feeAmount: 0,\n      kind: GPv2Order.KIND_SELL,\n      partiallyFillable: true,\n      sellTokenBalance: GPv2Order.BALANCE_ERC20,\n      buyTokenBalance: GPv2Order.BALANCE_ERC20\n    });\n  }\n\n  /// @notice Returns which trade is suggested to be executed on CoW Protocol\n  /// for specific reserves of a pool given the current chain state and prices\n  /// @param reservesToken0 Data related to the first token traded in the pool\n  /// @param reservesToken1 Data related to the second token traded in the pool\n  /// @param prices supplied for determining the order; the format is specified\n  /// in the `order` function\n  /// @return reservesIn Data related to the input token in the trade\n  /// @return amountIn How much input token should be trated\n  /// @return reservesOut Data related to the input token in the trade\n  function _amountInFromPrices(\n    Reserves memory reservesToken0,\n    Reserves memory reservesToken1,\n    uint256[] calldata prices\n  ) internal view returns (Reserves memory reservesIn, uint256 amountIn, Reserves memory reservesOut) {\n    reservesOut = reservesToken0;\n    reservesIn = reservesToken1;\n\n    // The out amount is computed according to the following formula:\n    // aO = amountOut\n    // bI = reservesIn.balance                   bO * wI - p * bI * wO\n    // bO = reservesOut.balance            aO =  ---------------------\n    // wI = reservesIn.denormWeight                     wI + wO\n    // wO = reservesOut.denormWeight\n    // p  = priceNumerator / priceDenominator\n    //\n    // Note that in the code we use normalized weights instead of computing the\n    // full expression from raw weights. Since BCoW pools support only two\n    // tokens, this is equivalent to assuming that wI + wO = 1.\n\n    // The price of this function is expressed as amount of token1 per amount\n    // of token0. The `prices` vector is expressed the other way around, as\n    // confirmed by dimensional analysis of the expression above.\n    uint256 priceNumerator = prices[1]; // x token = sell token = out amount\n    uint256 priceDenominator = prices[0];\n    uint256 balanceOutTimesWeightIn = bmul(reservesOut.balance, reservesIn.normWeight);\n    uint256 balanceInTimesWeightOut = bmul(reservesIn.balance, reservesOut.normWeight);\n\n    // This check compares the (weight-adjusted) pool spot price with the input\n    // price. The formula for the pool's spot price can be found in the\n    // definition of `calcSpotPrice`, assuming no swap fee. The comparison is\n    // derived from the following expression:\n    //\n    //       priceNumerator    bO / wO      /   bO * wI  \\\n    //      ---------------- > -------     |  = -------   |\n    //      priceDenominator   bI / wI      \\   bI * wO  /\n    //\n    // This inequality also guarantees that the amount out is positive: the\n    // amount out is positive if and only if this inequality is false, meaning\n    // that if the following condition matches then we want to invert the sell\n    // and buy tokens.\n    if (bmul(balanceInTimesWeightOut, priceNumerator) > bmul(balanceOutTimesWeightIn, priceDenominator)) {\n      (reservesOut, reservesIn) = (reservesIn, reservesOut);\n      (balanceOutTimesWeightIn, balanceInTimesWeightOut) = (balanceInTimesWeightOut, balanceOutTimesWeightIn);\n      (priceNumerator, priceDenominator) = (priceDenominator, priceNumerator);\n    }\n    uint256 par = bdiv(bmul(balanceInTimesWeightOut, priceNumerator), priceDenominator);\n    uint256 amountOut = balanceOutTimesWeightIn - par;\n    amountIn = calcInGivenOut({\n      tokenBalanceIn: reservesIn.balance,\n      tokenWeightIn: reservesIn.denormWeight,\n      tokenBalanceOut: reservesOut.balance,\n      tokenWeightOut: reservesOut.denormWeight,\n      tokenAmountOut: amountOut,\n      swapFee: 0\n    });\n  }\n\n  /// @notice Returns information on pool reserves for a specific pool and token\n  /// @dev This is mostly used for the readability of grouping all parameters\n  /// relative to the same token are grouped together in the same variable\n  /// @param pool The pool with the funds\n  /// @param token The token on which to recover information\n  /// @return Parameters relative to the token reserves in the pool\n  function _reserves(IBCoWPool pool, IERC20 token) internal view returns (Reserves memory) {\n    uint256 balance = token.balanceOf(address(pool));\n    uint256 normalizedWeight = pool.getNormalizedWeight(address(token));\n    uint256 denormalizedWeight = pool.getDenormalizedWeight(address(token));\n    return Reserves({token: token, balance: balance, denormWeight: denormalizedWeight, normWeight: normalizedWeight});\n  }\n\n  /// @notice For a two-token pool, this method takes one of the two traded\n  /// tokens and returns the other.\n  /// If the token is not traded in the pool, this function reverts.\n  /// @param pool Two-token pool supporting the tokens\n  /// @param token A token that is supported by the pool\n  /// @return otherToken The other token supported by the two-token pool\n  function _otherTokenInPair(address pool, address token) internal view returns (address otherToken) {\n    address[] memory tokenPair = tokens(pool);\n\n    if (tokenPair[0] == token) {\n      otherToken = tokenPair[1];\n    } else if (tokenPair[1] == token) {\n      otherToken = tokenPair[0];\n    } else {\n      revert InvalidToken();\n    }\n  }\n}\n"
    },
    "src/interfaces/IBCoWFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.25;\n\nimport {IBFactory} from 'interfaces/IBFactory.sol';\n\ninterface IBCoWFactory is IBFactory {\n  /**\n   * @notice Emitted when a bCoWPool created by this factory is finalized\n   * @param bCoWPool The pool just finalized\n   */\n  event COWAMMPoolCreated(address indexed bCoWPool);\n\n  /**\n   * @notice thrown when the caller of `logBCoWPool()` is not a bCoWPool created by this factory\n   */\n  error BCoWFactory_NotValidBCoWPool();\n\n  /**\n   * @notice Emits the COWAMMPoolCreated event if the caller is a bCoWPool, to be indexed by off-chain agents\n   */\n  function logBCoWPool() external;\n\n  /**\n   * @notice The address of the CoW Protocol settlement contract. It is the\n   * only address that can set commitments.\n   * @return solutionSettler The address of the solution settler.\n   */\n  // solhint-disable-next-line style-guide-casing\n  function SOLUTION_SETTLER() external view returns (address solutionSettler);\n\n  /**\n   * @notice The identifier describing which `GPv2Order.AppData` currently\n   * apply to this AMM.\n   * @return appData The 32 bytes identifier of the allowed GPv2Order AppData.\n   */\n  // solhint-disable-next-line style-guide-casing\n  function APP_DATA() external view returns (bytes32 appData);\n}\n"
    },
    "src/interfaces/IBCoWPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.25;\n\nimport {GPv2Order} from '@cowprotocol/libraries/GPv2Order.sol';\nimport {IERC1271} from '@openzeppelin/contracts/interfaces/IERC1271.sol';\nimport {IBPool} from 'interfaces/IBPool.sol';\nimport {ISettlement} from 'interfaces/ISettlement.sol';\n\ninterface IBCoWPool is IERC1271, IBPool {\n  /**\n   * @notice Thrown when a CoW order has a non-zero fee\n   */\n  error BCoWPool_FeeMustBeZero();\n\n  /**\n   * @notice Thrown when a CoW order is executed after its deadline\n   */\n  error BCoWPool_OrderValidityTooLong();\n\n  /**\n   * @notice Thrown when a CoW order has an unknown type (must be GPv2Order.KIND_SELL)\n   */\n  error BCoWPool_InvalidOperation();\n\n  /**\n   * @notice Thrown when a CoW order has an invalid balance marker. BCoWPool\n   * only supports BALANCE_ERC20, instructing to use the underlying ERC20\n   * balance directly instead of balancer's internal accounting\n   */\n  error BCoWPool_InvalidBalanceMarker();\n\n  /**\n   * @notice The `commit` function can only be called inside a CoW Swap\n   * settlement. This error is thrown when the function is called from another\n   * context.\n   */\n  error CommitOutsideOfSettlement();\n\n  /**\n   * @notice Error thrown when a solver tries to settle an AMM order on CoW\n   * Protocol whose hash doesn't match the one that has been committed to.\n   */\n  error OrderDoesNotMatchCommitmentHash();\n\n  /**\n   * @notice On signature verification, the hash of the order supplied as part\n   * of the signature does not match the provided message hash.\n   * This usually means that the verification function is being provided a\n   * signature that belongs to a different order.\n   */\n  error OrderDoesNotMatchMessageHash();\n\n  /**\n   * @notice Thrown when AppData that was provided during signature verification\n   * does not match the one stored in this contract.\n   */\n  error AppDataDoesNotMatch();\n\n  /**\n   * @notice Thrown when the receiver of the order is not the bCoWPool itself.\n   */\n  error BCoWPool_ReceiverIsNotBCoWPool();\n\n  /**\n   * @notice Restricts a specific AMM to being able to trade only the order\n   * with the specified hash.\n   * @dev The commitment is used to enforce that exactly one AMM order is\n   * valid when a CoW Protocol batch is settled.\n   * @param orderHash the order hash that will be enforced by the order\n   * verification function.\n   */\n  function commit(bytes32 orderHash) external;\n\n  /**\n   * @notice The address that can pull funds from the AMM vault to execute an order\n   * @return vaultRelayer The address of the vault relayer.\n   */\n  // solhint-disable-next-line style-guide-casing\n  function VAULT_RELAYER() external view returns (address vaultRelayer);\n\n  /**\n   * @notice The domain separator used for hashing CoW Protocol orders.\n   * @return solutionSettlerDomainSeparator The domain separator.\n   */\n  // solhint-disable-next-line style-guide-casing\n  function SOLUTION_SETTLER_DOMAIN_SEPARATOR() external view returns (bytes32 solutionSettlerDomainSeparator);\n\n  /**\n   * @notice The address of the CoW Protocol settlement contract. It is the\n   * only address that can set commitments.\n   * @return solutionSettler The address of the solution settler.\n   */\n  // solhint-disable-next-line style-guide-casing\n  function SOLUTION_SETTLER() external view returns (ISettlement solutionSettler);\n\n  /**\n   * @notice The identifier describing which `GPv2Order.AppData` currently\n   * apply to this AMM.\n   * @return appData The 32 bytes identifier of the allowed GPv2Order AppData.\n   */\n  // solhint-disable-next-line style-guide-casing\n  function APP_DATA() external view returns (bytes32 appData);\n\n  /**\n   * @notice This function checks that the input order is admissible for the\n   * constant-product curve for the given trading parameters.\n   * @param order `GPv2Order.Data` of a discrete order to be verified.\n   */\n  function verify(GPv2Order.Data memory order) external view;\n}\n"
    },
    "node_modules/cow-amm/src/interfaces/ICOWAMMPoolHelper.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity ^0.8.24;\n\nimport {GPv2Order} from \"cowprotocol/contracts/libraries/GPv2Order.sol\";\nimport {GPv2Interaction} from \"cowprotocol/contracts/libraries/GPv2Interaction.sol\";\n\n/**\n * @notice Pool-specific helper interface for AMM's operating in CoW Protocol.\n */\ninterface ICOWAMMPoolHelper {\n    /**\n     * All functions that take `pool` as an argument MUST revert with this error\n     * if the `pool` does not exist.\n     * @dev Indexers monitoring CoW AMM pools MAY use this as a signal to purge the\n     *      pool from their index.\n     */\n    error PoolDoesNotExist();\n    /**\n     * All functions that take `pool` as an argument MUST revert with this error\n     * in the event that the pool is paused (ONLY applicable if the pool is pausable).\n     * @dev Indexers monitoring CoW AMM pools SHOULD use this as a signal to retain\n     *      the pool in the index with back-off on polling for orders.\n     */\n    error PoolIsPaused();\n    /**\n     * All functions that take `pool` as an argument MUST revert with this error\n     * in the event that the pool is closed (ONLY applicable if the pool can be\n     * closed).\n     * @dev Indexers monitoring CoW AMM pools MAY use this as a signal to purge the\n     *      pool from their index.\n     */\n    error PoolIsClosed();\n    /**\n     * Returned by the `order` function if there is no order matching the supplied\n     * parameters.\n     */\n    error NoOrder();\n\n    /**\n     * AMM Pool helpers MUST return the factory target for indexing of CoW AMM pools.\n     */\n    function factory() external view returns (address);\n    /**\n     * AMM Pool helpers MUST return all tokens that may be traded on this pool.\n     * The order of the tokens is expected to be consistent and must be the same\n     * as that used for the input price vector in the `order` function.\n     */\n    function tokens(address pool) external view returns (address[] memory);\n    /**\n     * AMM Pool helpers MUST provide a method for returning the canonical order\n     * required to satisfy the pool's invariants, given a pricing vector.\n     * @dev Reverts with `NoOrder` if the `pool` has no canonical order matching the\n     *      given price vector.\n     * @param pool to calculate the order / signature for\n     * @param prices supplied for determining the order, assumed to be in the\n     *        same order as returned from `tokens(pool)`. Tokens prices are\n     *        expressed relative to each other: for example, if tokens[0] is\n     *        WETH, tokens[2] is DAI, and the price is 1 WETH per 3000 DAI, then\n     *        a valid price vector is [3000, *, 1, ...]. If tokens[1] is another\n     *        stablecoin with 18 decimals, then a valid price vector could be\n     *        [3000, 3000, 1, ...].\n     *        This price vector is compatible with the price vector used in a\n     *        call to `settle`, assuming the traded token array is in the same\n     *        order as in `tokens(pool)`.\n     * @return order The CoW Protocol JIT order\n     * @return preInteractions The array array for any **PRE** interactions (empty if none)\n     * @return postInteractions The array array for any **POST** interactions (empty if none)\n     * @return sig A valid CoW-Protocol signature for the resulting order using\n     * the ERC-1271 signature scheme.\n     */\n    function order(address pool, uint256[] calldata prices)\n        external\n        view\n        returns (\n            GPv2Order.Data memory order,\n            GPv2Interaction.Data[] memory preInteractions,\n            GPv2Interaction.Data[] memory postInteractions,\n            bytes memory sig\n        );\n}\n"
    },
    "node_modules/@cowprotocol/contracts/src/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// Vendored from OpenZeppelin contracts with minor modifications:\n// - Modified Solidity version\n// - Formatted code\n// - Added `name`, `symbol` and `decimals` function declarations\n// <https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/token/ERC20/IERC20.sol>\n\npragma solidity >=0.7.6 <0.9.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the number of decimals the token uses.\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
    },
    "node_modules/@cowprotocol/contracts/src/contracts/libraries/GPv2Interaction.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity >=0.7.6 <0.9.0;\n\n/// @title Gnosis Protocol v2 Interaction Library\n/// @author Gnosis Developers\nlibrary GPv2Interaction {\n    /// @dev Interaction data for performing arbitrary contract interactions.\n    /// Submitted to [`GPv2Settlement.settle`] for code execution.\n    struct Data {\n        address target;\n        uint256 value;\n        bytes callData;\n    }\n\n    /// @dev Execute an arbitrary contract interaction.\n    ///\n    /// @param interaction Interaction data.\n    function execute(Data calldata interaction) internal {\n        address target = interaction.target;\n        uint256 value = interaction.value;\n        bytes calldata callData = interaction.callData;\n\n        // NOTE: Use assembly to call the interaction instead of a low level\n        // call for two reasons:\n        // - We don't want to copy the return data, since we discard it for\n        // interactions.\n        // - Solidity will under certain conditions generate code to copy input\n        // calldata twice to memory (the second being a \"memcopy loop\").\n        // <https://github.com/gnosis/gp-v2-contracts/pull/417#issuecomment-775091258>\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            calldatacopy(freeMemoryPointer, callData.offset, callData.length)\n            if iszero(\n                call(\n                    gas(),\n                    target,\n                    value,\n                    freeMemoryPointer,\n                    callData.length,\n                    0,\n                    0\n                )\n            ) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n\n    /// @dev Extracts the Solidity ABI selector for the specified interaction.\n    ///\n    /// @param interaction Interaction data.\n    /// @return result The 4 byte function selector of the call encoded in\n    /// this interaction.\n    function selector(\n        Data calldata interaction\n    ) internal pure returns (bytes4 result) {\n        bytes calldata callData = interaction.callData;\n        if (callData.length >= 4) {\n            // NOTE: Read the first word of the interaction's calldata. The\n            // value does not need to be shifted since `bytesN` values are left\n            // aligned, and the value does not need to be masked since masking\n            // occurs when the value is accessed and not stored:\n            // <https://docs.soliditylang.org/en/v0.7.6/abi-spec.html#encoding-of-indexed-event-parameters>\n            // <https://docs.soliditylang.org/en/v0.7.6/assembly.html#access-to-external-variables-functions-and-libraries>\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                result := calldataload(callData.offset)\n            }\n        }\n    }\n}\n"
    },
    "node_modules/@cowprotocol/contracts/src/contracts/libraries/GPv2Order.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity >=0.7.6 <0.9.0;\n\nimport \"../interfaces/IERC20.sol\";\n\n/// @title Gnosis Protocol v2 Order Library\n/// @author Gnosis Developers\nlibrary GPv2Order {\n    /// @dev The complete data for a Gnosis Protocol order. This struct contains\n    /// all order parameters that are signed for submitting to GP.\n    struct Data {\n        IERC20 sellToken;\n        IERC20 buyToken;\n        address receiver;\n        uint256 sellAmount;\n        uint256 buyAmount;\n        uint32 validTo;\n        bytes32 appData;\n        uint256 feeAmount;\n        bytes32 kind;\n        bool partiallyFillable;\n        bytes32 sellTokenBalance;\n        bytes32 buyTokenBalance;\n    }\n\n    /// @dev The order EIP-712 type hash for the [`GPv2Order.Data`] struct.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(\n    ///     \"Order(\" +\n    ///         \"address sellToken,\" +\n    ///         \"address buyToken,\" +\n    ///         \"address receiver,\" +\n    ///         \"uint256 sellAmount,\" +\n    ///         \"uint256 buyAmount,\" +\n    ///         \"uint32 validTo,\" +\n    ///         \"bytes32 appData,\" +\n    ///         \"uint256 feeAmount,\" +\n    ///         \"string kind,\" +\n    ///         \"bool partiallyFillable,\" +\n    ///         \"string sellTokenBalance,\" +\n    ///         \"string buyTokenBalance\" +\n    ///     \")\"\n    /// )\n    /// ```\n    bytes32 internal constant TYPE_HASH =\n        hex\"d5a25ba2e97094ad7d83dc28a6572da797d6b3e7fc6663bd93efb789fc17e489\";\n\n    /// @dev The marker value for a sell order for computing the order struct\n    /// hash. This allows the EIP-712 compatible wallets to display a\n    /// descriptive string for the order kind (instead of 0 or 1).\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(\"sell\")\n    /// ```\n    bytes32 internal constant KIND_SELL =\n        hex\"f3b277728b3fee749481eb3e0b3b48980dbbab78658fc419025cb16eee346775\";\n\n    /// @dev The OrderKind marker value for a buy order for computing the order\n    /// struct hash.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(\"buy\")\n    /// ```\n    bytes32 internal constant KIND_BUY =\n        hex\"6ed88e868af0a1983e3886d5f3e95a2fafbd6c3450bc229e27342283dc429ccc\";\n\n    /// @dev The TokenBalance marker value for using direct ERC20 balances for\n    /// computing the order struct hash.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(\"erc20\")\n    /// ```\n    bytes32 internal constant BALANCE_ERC20 =\n        hex\"5a28e9363bb942b639270062aa6bb295f434bcdfc42c97267bf003f272060dc9\";\n\n    /// @dev The TokenBalance marker value for using Balancer Vault external\n    /// balances (in order to re-use Vault ERC20 approvals) for computing the\n    /// order struct hash.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(\"external\")\n    /// ```\n    bytes32 internal constant BALANCE_EXTERNAL =\n        hex\"abee3b73373acd583a130924aad6dc38cfdc44ba0555ba94ce2ff63980ea0632\";\n\n    /// @dev The TokenBalance marker value for using Balancer Vault internal\n    /// balances for computing the order struct hash.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(\"internal\")\n    /// ```\n    bytes32 internal constant BALANCE_INTERNAL =\n        hex\"4ac99ace14ee0a5ef932dc609df0943ab7ac16b7583634612f8dc35a4289a6ce\";\n\n    /// @dev Marker address used to indicate that the receiver of the trade\n    /// proceeds should the owner of the order.\n    ///\n    /// This is chosen to be `address(0)` for gas efficiency as it is expected\n    /// to be the most common case.\n    address internal constant RECEIVER_SAME_AS_OWNER = address(0);\n\n    /// @dev The byte length of an order unique identifier.\n    uint256 internal constant UID_LENGTH = 56;\n\n    /// @dev Returns the actual receiver for an order. This function checks\n    /// whether or not the [`receiver`] field uses the marker value to indicate\n    /// it is the same as the order owner.\n    ///\n    /// @return receiver The actual receiver of trade proceeds.\n    function actualReceiver(\n        Data memory order,\n        address owner\n    ) internal pure returns (address receiver) {\n        if (order.receiver == RECEIVER_SAME_AS_OWNER) {\n            receiver = owner;\n        } else {\n            receiver = order.receiver;\n        }\n    }\n\n    /// @dev Return the EIP-712 signing hash for the specified order.\n    ///\n    /// @param order The order to compute the EIP-712 signing hash for.\n    /// @param domainSeparator The EIP-712 domain separator to use.\n    /// @return orderDigest The 32 byte EIP-712 struct hash.\n    function hash(\n        Data memory order,\n        bytes32 domainSeparator\n    ) internal pure returns (bytes32 orderDigest) {\n        bytes32 structHash;\n\n        // NOTE: Compute the EIP-712 order struct hash in place. As suggested\n        // in the EIP proposal, noting that the order struct has 12 fields, and\n        // prefixing the type hash `(1 + 12) * 32 = 416` bytes to hash.\n        // <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#rationale-for-encodedata>\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let dataStart := sub(order, 32)\n            let temp := mload(dataStart)\n            mstore(dataStart, TYPE_HASH)\n            structHash := keccak256(dataStart, 416)\n            mstore(dataStart, temp)\n        }\n\n        // NOTE: Now that we have the struct hash, compute the EIP-712 signing\n        // hash using scratch memory past the free memory pointer. The signing\n        // hash is computed from `\"\\x19\\x01\" || domainSeparator || structHash`.\n        // <https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html#layout-in-memory>\n        // <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#specification>\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, \"\\x19\\x01\")\n            mstore(add(freeMemoryPointer, 2), domainSeparator)\n            mstore(add(freeMemoryPointer, 34), structHash)\n            orderDigest := keccak256(freeMemoryPointer, 66)\n        }\n    }\n\n    /// @dev Packs order UID parameters into the specified memory location. The\n    /// result is equivalent to `abi.encodePacked(...)` with the difference that\n    /// it allows re-using the memory for packing the order UID.\n    ///\n    /// This function reverts if the order UID buffer is not the correct size.\n    ///\n    /// @param orderUid The buffer pack the order UID parameters into.\n    /// @param orderDigest The EIP-712 struct digest derived from the order\n    /// parameters.\n    /// @param owner The address of the user who owns this order.\n    /// @param validTo The epoch time at which the order will stop being valid.\n    function packOrderUidParams(\n        bytes memory orderUid,\n        bytes32 orderDigest,\n        address owner,\n        uint32 validTo\n    ) internal pure {\n        require(orderUid.length == UID_LENGTH, \"GPv2: uid buffer overflow\");\n\n        // NOTE: Write the order UID to the allocated memory buffer. The order\n        // parameters are written to memory in **reverse order** as memory\n        // operations write 32-bytes at a time and we want to use a packed\n        // encoding. This means, for example, that after writing the value of\n        // `owner` to bytes `20:52`, writing the `orderDigest` to bytes `0:32`\n        // will **overwrite** bytes `20:32`. This is desirable as addresses are\n        // only 20 bytes and `20:32` should be `0`s:\n        //\n        //        |           1111111111222222222233333333334444444444555555\n        //   byte | 01234567890123456789012345678901234567890123456789012345\n        // -------+---------------------------------------------------------\n        //  field | [.........orderDigest..........][......owner.......][vT]\n        // -------+---------------------------------------------------------\n        // mstore |                         [000000000000000000000000000.vT]\n        //        |                     [00000000000.......owner.......]\n        //        | [.........orderDigest..........]\n        //\n        // Additionally, since Solidity `bytes memory` are length prefixed,\n        // 32 needs to be added to all the offsets.\n        //\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(add(orderUid, 56), validTo)\n            mstore(add(orderUid, 52), owner)\n            mstore(add(orderUid, 32), orderDigest)\n        }\n    }\n\n    /// @dev Extracts specific order information from the standardized unique\n    /// order id of the protocol.\n    ///\n    /// @param orderUid The unique identifier used to represent an order in\n    /// the protocol. This uid is the packed concatenation of the order digest,\n    /// the validTo order parameter and the address of the user who created the\n    /// order. It is used by the user to interface with the contract directly,\n    /// and not by calls that are triggered by the solvers.\n    /// @return orderDigest The EIP-712 signing digest derived from the order\n    /// parameters.\n    /// @return owner The address of the user who owns this order.\n    /// @return validTo The epoch time at which the order will stop being valid.\n    function extractOrderUidParams(\n        bytes calldata orderUid\n    )\n        internal\n        pure\n        returns (bytes32 orderDigest, address owner, uint32 validTo)\n    {\n        require(orderUid.length == UID_LENGTH, \"GPv2: invalid uid\");\n\n        // Use assembly to efficiently decode packed calldata.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            orderDigest := calldataload(orderUid.offset)\n            owner := shr(96, calldataload(add(orderUid.offset, 32)))\n            validTo := shr(224, calldataload(add(orderUid.offset, 52)))\n        }\n    }\n}\n"
    },
    "src/contracts/BCoWConst.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.25;\n\n/**\n * @title BCoWConst\n * @notice Constants used in the scope of the BCoWPool contract.\n */\ncontract BCoWConst {\n  /**\n   * @notice The largest possible duration of any AMM order, starting from the\n   * current block timestamp.\n   * @return _maxOrderDuration The maximum order duration.\n   */\n  uint32 public constant MAX_ORDER_DURATION = 5 minutes;\n}\n"
    },
    "src/contracts/BMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.25;\n\nimport {BConst} from './BConst.sol';\nimport {BNum} from './BNum.sol';\n\n/**\n * @title BMath\n * @notice Includes functions for calculating the BPool related math.\n */\ncontract BMath is BConst, BNum {\n  /**\n   * @notice Calculate the spot price of a token in terms of another one\n   * @dev The price denomination depends on the decimals of the tokens.\n   * @dev To obtain the price with 18 decimals the next formula should be applied to the result\n   * @dev spotPrice = spotPrice ÷ (10^tokenInDecimals) × (10^tokenOutDecimals)\n   * @param tokenBalanceIn The balance of the input token in the pool\n   * @param tokenWeightIn The weight of the input token in the pool\n   * @param tokenBalanceOut The balance of the output token in the pool\n   * @param tokenWeightOut The weight of the output token in the pool\n   * @param swapFee The swap fee of the pool\n   * @return spotPrice The spot price of a token in terms of another one\n   * @dev Formula:\n   * sP = spotPrice\n   * bI = tokenBalanceIn                ( bI / wI )         1\n   * bO = tokenBalanceOut         sP =  -----------  *  ----------\n   * wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )\n   * wO = tokenWeightOut\n   * sF = swapFee\n   */\n  function calcSpotPrice(\n    uint256 tokenBalanceIn,\n    uint256 tokenWeightIn,\n    uint256 tokenBalanceOut,\n    uint256 tokenWeightOut,\n    uint256 swapFee\n  ) public pure returns (uint256 spotPrice) {\n    uint256 numer = bdiv(tokenBalanceIn, tokenWeightIn);\n    uint256 denom = bdiv(tokenBalanceOut, tokenWeightOut);\n    uint256 ratio = bdiv(numer, denom);\n    uint256 scale = bdiv(BONE, bsub(BONE, swapFee));\n    return (spotPrice = bmul(ratio, scale));\n  }\n\n  /**\n   * @notice Calculate the amount of token out given the amount of token in for a swap\n   * @param tokenBalanceIn The balance of the input token in the pool\n   * @param tokenWeightIn The weight of the input token in the pool\n   * @param tokenBalanceOut The balance of the output token in the pool\n   * @param tokenWeightOut The weight of the output token in the pool\n   * @param tokenAmountIn The amount of the input token\n   * @param swapFee The swap fee of the pool\n   * @return tokenAmountOut The amount of token out given the amount of token in for a swap\n   * @dev Formula:\n   * aO = tokenAmountOut\n   * bO = tokenBalanceOut\n   * bI = tokenBalanceIn              /      /            bI             \\    (wI / wO) \\\n   * aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |\n   * wI = tokenWeightIn               \\      \\ ( bI + ( aI * ( 1 - sF )) /              /\n   * wO = tokenWeightOut\n   * sF = swapFee\n   */\n  function calcOutGivenIn(\n    uint256 tokenBalanceIn,\n    uint256 tokenWeightIn,\n    uint256 tokenBalanceOut,\n    uint256 tokenWeightOut,\n    uint256 tokenAmountIn,\n    uint256 swapFee\n  ) public pure returns (uint256 tokenAmountOut) {\n    uint256 weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\n    uint256 adjustedIn = bsub(BONE, swapFee);\n    adjustedIn = bmul(tokenAmountIn, adjustedIn);\n    uint256 y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\n    uint256 foo = bpow(y, weightRatio);\n    uint256 bar = bsub(BONE, foo);\n    tokenAmountOut = bmul(tokenBalanceOut, bar);\n    return tokenAmountOut;\n  }\n\n  /**\n   * @notice Calculate the amount of token in given the amount of token out for a swap\n   * @param tokenBalanceIn The balance of the input token in the pool\n   * @param tokenWeightIn The weight of the input token in the pool\n   * @param tokenBalanceOut The balance of the output token in the pool\n   * @param tokenWeightOut The weight of the output token in the pool\n   * @param tokenAmountOut The amount of the output token\n   * @param swapFee The swap fee of the pool\n   * @return tokenAmountIn The amount of token in given the amount of token out for a swap\n   * @dev Formula:\n   * aI = tokenAmountIn\n   * bO = tokenBalanceOut               /  /     bO      \\    (wO / wI)      \\\n   * bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |\n   * aO = tokenAmountOut    aI =        \\  \\ ( bO - aO ) /                   /\n   * wI = tokenWeightIn           --------------------------------------------\n   * wO = tokenWeightOut                          ( 1 - sF )\n   * sF = swapFee\n   */\n  function calcInGivenOut(\n    uint256 tokenBalanceIn,\n    uint256 tokenWeightIn,\n    uint256 tokenBalanceOut,\n    uint256 tokenWeightOut,\n    uint256 tokenAmountOut,\n    uint256 swapFee\n  ) public pure returns (uint256 tokenAmountIn) {\n    uint256 weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\n    uint256 diff = bsub(tokenBalanceOut, tokenAmountOut);\n    uint256 y = bdiv(tokenBalanceOut, diff);\n    uint256 foo = bpow(y, weightRatio);\n    foo = bsub(foo, BONE);\n    tokenAmountIn = bsub(BONE, swapFee);\n    tokenAmountIn = bdiv(bmul(tokenBalanceIn, foo), tokenAmountIn);\n    return tokenAmountIn;\n  }\n}\n"
    },
    "src/interfaces/IBFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.25;\n\nimport {IBPool} from 'interfaces/IBPool.sol';\n\ninterface IBFactory {\n  /**\n   * @notice Emitted when creating a new pool\n   * @param caller The caller of the function that will be set as the controller\n   * @param bPool The address of the new pool\n   */\n  event LOG_NEW_POOL(address indexed caller, address indexed bPool);\n\n  /**\n   * @notice Emitted when setting the BDao address\n   * @param caller The caller of the set BDao function\n   * @param bDao The address of the new BDao\n   */\n  event LOG_BDAO(address indexed caller, address indexed bDao);\n\n  /**\n   * @notice Thrown when setting a variable to address zero\n   */\n  error BFactory_AddressZero();\n\n  /**\n   * @notice Thrown when caller is not BDao address\n   */\n  error BFactory_NotBDao();\n\n  /**\n   * @notice Creates a new BPool, assigning the caller as the pool controller\n   * @param name The name of the Pool ERC20 token\n   * @param symbol The symbol of the Pool ERC20 token\n   * @return bPool The new BPool\n   */\n  function newBPool(string memory name, string memory symbol) external returns (IBPool bPool);\n\n  /**\n   * @notice Sets the BDao address in the factory\n   * @param bDao The new BDao address\n   */\n  function setBDao(address bDao) external;\n\n  /**\n   * @notice Collects the fees of a pool and transfers it to BDao address\n   * @param bPool The address of the pool to collect fees from\n   */\n  function collect(IBPool bPool) external;\n\n  /**\n   * @notice Checks if an address is a BPool created from this factory\n   * @param bPool The address to check\n   * @return isBPool True if the address is a BPool, False otherwise\n   */\n  function isBPool(address bPool) external view returns (bool isBPool);\n\n  /**\n   * @notice Gets the BDao address\n   * @return bDao The address of the BDao\n   */\n  function getBDao() external view returns (address bDao);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1271.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "src/interfaces/IBPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.25;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ninterface IBPool is IERC20 {\n  /**\n   * @dev Struct for token records.\n   * @param bound If token is bound to pool.\n   * @param index Internal index of token array.\n   * @param denorm Denormalized weight of token.\n   */\n  struct Record {\n    bool bound;\n    uint256 index;\n    uint256 denorm;\n  }\n\n  /**\n   * @notice Emitted when a swap is executed\n   * @param caller The caller of the swap function\n   * @param tokenIn The address of the token being swapped in\n   * @param tokenOut The address of the token being swapped out\n   * @param tokenAmountIn The amount of tokenIn being swapped in\n   * @param tokenAmountOut The amount of tokenOut being swapped out\n   */\n  event LOG_SWAP(\n    address indexed caller,\n    address indexed tokenIn,\n    address indexed tokenOut,\n    uint256 tokenAmountIn,\n    uint256 tokenAmountOut\n  );\n\n  /**\n   * @notice Emitted when a join operation is executed\n   * @param caller The caller of the function\n   * @param tokenIn The address of the token being sent to the pool\n   * @param tokenAmountIn The balance of the token being sent to the pool\n   */\n  event LOG_JOIN(address indexed caller, address indexed tokenIn, uint256 tokenAmountIn);\n\n  /**\n   * @notice Emitted when a token amount is removed from the pool\n   * @param caller The caller of the function\n   * @param tokenOut The address of the token being removed from the pool\n   * @param tokenAmountOut The amount of the token being removed from the pool\n   */\n  event LOG_EXIT(address indexed caller, address indexed tokenOut, uint256 tokenAmountOut);\n\n  /**\n   * @notice Emitted when a call is executed on the pool\n   * @param sig The signature of the function selector being called\n   * @param caller The caller of the function\n   * @param data The complete data of the call\n   */\n  event LOG_CALL(bytes4 indexed sig, address indexed caller, bytes data) anonymous;\n\n  /**\n   * @notice Thrown when setting a variable to address zero\n   */\n  error BPool_AddressZero();\n\n  /**\n   * @notice Thrown when a reentrant call is made\n   */\n  error BPool_Reentrancy();\n\n  /**\n   * @notice Thrown when the pool is finalized\n   */\n  error BPool_PoolIsFinalized();\n\n  /**\n   * @notice Thrown when the caller is not the controller\n   */\n  error BPool_CallerIsNotController();\n\n  /**\n   * @notice Thrown when the pool is not finalized\n   */\n  error BPool_FeeBelowMinimum();\n\n  /**\n   * @notice Thrown when the fee to set is above the maximum\n   */\n  error BPool_FeeAboveMaximum();\n\n  /**\n   * @notice Thrown when the tokens array is below the minimum\n   */\n  error BPool_TokensBelowMinimum();\n\n  /**\n   * @notice Thrown when the token is already bound in the pool\n   */\n  error BPool_TokenAlreadyBound();\n\n  /**\n   * @notice Thrown when the tokens array is above the maximum\n   */\n  error BPool_TokensAboveMaximum();\n\n  /**\n   * @notice Thrown when the weight to set is below the minimum\n   */\n  error BPool_WeightBelowMinimum();\n\n  /**\n   * @notice Thrown when the weight to set is above the maximum\n   */\n  error BPool_WeightAboveMaximum();\n\n  /**\n   * @notice Thrown when the balance to add is below the minimum\n   */\n  error BPool_BalanceBelowMinimum();\n\n  /**\n   * @notice Thrown when the total weight is above the maximum\n   */\n  error BPool_TotalWeightAboveMaximum();\n\n  /**\n   * @notice Thrown when the ratio between the pool token amount and the total supply is zero\n   */\n  error BPool_InvalidPoolRatio();\n\n  /**\n   * @notice Thrown when the calculated token amount in is zero\n   */\n  error BPool_InvalidTokenAmountIn();\n\n  /**\n   * @notice Thrown when the token amount in is above maximum amount in allowed by the caller\n   */\n  error BPool_TokenAmountInAboveMaxAmountIn();\n\n  /**\n   * @notice Thrown when the calculated token amount out is zero\n   */\n  error BPool_InvalidTokenAmountOut();\n\n  /**\n   * @notice Thrown when the token amount out is below minimum amount out allowed by the caller\n   */\n  error BPool_TokenAmountOutBelowMinAmountOut();\n\n  /**\n   * @notice Thrown when the token is not bound in the pool\n   */\n  error BPool_TokenNotBound();\n\n  /**\n   * @notice Thrown when the pool is not finalized\n   */\n  error BPool_PoolNotFinalized();\n\n  /**\n   * @notice Thrown when the token amount in surpasses the maximum in ratio allowed by the pool\n   */\n  error BPool_TokenAmountInAboveMaxRatio();\n\n  /**\n   * @notice Thrown when the spot price before or after the swap is above the max allowed by the caller\n   */\n  error BPool_SpotPriceAboveMaxPrice();\n\n  /**\n   * @notice Thrown when the token amount out is below the minimum out allowed by the caller\n   */\n  error BPool_TokenAmountOutBelowMinOut();\n\n  /**\n   * @notice Thrown when the spot price after the swap is below the spot price before the swap\n   */\n  error BPool_SpotPriceAfterBelowSpotPriceBefore();\n\n  /**\n   * @notice Thrown when the spot price before the swap is above the ratio between the two tokens in the pool\n   */\n  error BPool_SpotPriceBeforeAboveTokenRatio();\n\n  /**\n   * @notice Thrown when the token amount out surpasses the maximum out allowed by the pool\n   */\n  error BPool_TokenAmountOutAboveMaxOut();\n\n  /**\n   * @notice Thrown when the pool token amount out is below the minimum pool token amount out allowed by the caller\n   */\n  error BPool_PoolAmountOutBelowMinPoolAmountOut();\n\n  /**\n   * @notice Thrown when the calculated pool token amount in is zero\n   */\n  error BPool_InvalidPoolAmountIn();\n\n  /**\n   * @notice Thrown when the pool token amount in is above the maximum amount in allowed by the caller\n   */\n  error BPool_PoolAmountInAboveMaxPoolAmountIn();\n\n  /**\n   * @notice Sets the new swap fee\n   * @param swapFee The new swap fee\n   */\n  function setSwapFee(uint256 swapFee) external;\n\n  /**\n   * @notice Sets the new controller\n   * @param manager The new controller\n   */\n  function setController(address manager) external;\n\n  /**\n   * @notice Finalize the pool, removing the restrictions on the pool\n   */\n  function finalize() external;\n\n  /**\n   * @notice Binds a token to the pool\n   * @param token The address of the token to bind\n   * @param balance The balance of the token to bind\n   * @param denorm The denormalized weight of the token to bind\n   */\n  function bind(address token, uint256 balance, uint256 denorm) external;\n\n  /**\n   * @notice Unbinds a token from the pool\n   * @param token The address of the token to unbind\n   */\n  function unbind(address token) external;\n\n  /**\n   * @notice Joins a pool, providing each token in the pool with a proportional amount\n   * @param poolAmountOut The amount of pool tokens to mint\n   * @param maxAmountsIn The maximum amount of tokens to send to the pool\n   */\n  function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external;\n\n  /**\n   * @notice Exits a pool, receiving each token in the pool with a proportional amount\n   * @param poolAmountIn The amount of pool tokens to burn\n   * @param minAmountsOut The minimum amount of tokens to receive from the pool\n   */\n  function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external;\n\n  /**\n   * @notice Swaps an exact amount of tokens in for an amount of tokens out\n   * @param tokenIn The address of the token to swap in\n   * @param tokenAmountIn The amount of token to swap in\n   * @param tokenOut The address of the token to swap out\n   * @param minAmountOut The minimum amount of token to receive from the swap\n   * @param maxPrice The maximum price to pay for the swap\n   * @return tokenAmountOut The amount of token swapped out\n   * @return spotPriceAfter The spot price after the swap\n   */\n  function swapExactAmountIn(\n    address tokenIn,\n    uint256 tokenAmountIn,\n    address tokenOut,\n    uint256 minAmountOut,\n    uint256 maxPrice\n  ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\n\n  /**\n   * @notice Swaps as many tokens in as needed for an exact amount of tokens out\n   * @param tokenIn The address of the token to swap in\n   * @param maxAmountIn The maximum amount of token to swap in\n   * @param tokenOut The address of the token to swap out\n   * @param tokenAmountOut The amount of token to swap out\n   * @param maxPrice The maximum price to pay for the swap\n   * @return tokenAmountIn The amount of token swapped in\n   * @return spotPriceAfter The spot price after the swap\n   */\n  function swapExactAmountOut(\n    address tokenIn,\n    uint256 maxAmountIn,\n    address tokenOut,\n    uint256 tokenAmountOut,\n    uint256 maxPrice\n  ) external returns (uint256 tokenAmountIn, uint256 spotPriceAfter);\n\n  /**\n   * @notice Gets the spot price of tokenIn in terms of tokenOut\n   * @param tokenIn The address of the token to swap in\n   * @param tokenOut The address of the token to swap out\n   * @return spotPrice The spot price of the swap\n   */\n  function getSpotPrice(address tokenIn, address tokenOut) external view returns (uint256 spotPrice);\n\n  /**\n   * @notice Gets the spot price of tokenIn in terms of tokenOut without the fee\n   * @param tokenIn The address of the token to swap in\n   * @param tokenOut The address of the token to swap out\n   * @return spotPrice The spot price of the swap without the fee\n   */\n  function getSpotPriceSansFee(address tokenIn, address tokenOut) external view returns (uint256 spotPrice);\n\n  /**\n   * @notice Gets the finalized status of the pool\n   * @return isFinalized True if the pool is finalized, False otherwise\n   */\n  function isFinalized() external view returns (bool isFinalized);\n\n  /**\n   * @notice Gets the bound status of a token\n   * @param t The address of the token to check\n   * @return isBound True if the token is bound, False otherwise\n   */\n  function isBound(address t) external view returns (bool isBound);\n\n  /**\n   * @notice Gets the number of tokens in the pool\n   * @return numTokens The number of tokens in the pool\n   */\n  function getNumTokens() external view returns (uint256 numTokens);\n\n  /**\n   * @notice Gets the current array of tokens in the pool, while the pool is not finalized\n   * @return tokens The array of tokens in the pool\n   */\n  function getCurrentTokens() external view returns (address[] memory tokens);\n\n  /**\n   * @notice Gets the final array of tokens in the pool, after finalization\n   * @return tokens The array of tokens in the pool\n   */\n  function getFinalTokens() external view returns (address[] memory tokens);\n\n  /**\n   * @notice Gets the denormalized weight of a token in the pool\n   * @param token The address of the token to check\n   * @return denormWeight The denormalized weight of the token in the pool\n   */\n  function getDenormalizedWeight(address token) external view returns (uint256 denormWeight);\n\n  /**\n   * @notice Gets the total denormalized weight of the pool\n   * @return totalDenormWeight The total denormalized weight of the pool\n   */\n  function getTotalDenormalizedWeight() external view returns (uint256 totalDenormWeight);\n\n  /**\n   * @notice Gets the normalized weight of a token in the pool\n   * @param token The address of the token to check\n   * @return normWeight The normalized weight of the token in the pool\n   */\n  function getNormalizedWeight(address token) external view returns (uint256 normWeight);\n\n  /**\n   * @notice Gets the Pool's ERC20 balance of a token\n   * @param token The address of the token to check\n   * @return balance The Pool's ERC20 balance of the token\n   */\n  function getBalance(address token) external view returns (uint256 balance);\n\n  /**\n   * @notice Gets the swap fee of the pool\n   * @return swapFee The swap fee of the pool\n   */\n  function getSwapFee() external view returns (uint256 swapFee);\n\n  /**\n   * @notice Gets the controller of the pool\n   * @return controller The controller of the pool\n   */\n  function getController() external view returns (address controller);\n\n  /**\n   * @notice Gets the BFactory address that deployed the pool\n   * @return factory The address of the factory\n   */\n  // solhint-disable-next-line style-guide-casing\n  function FACTORY() external view returns (address factory);\n}\n"
    },
    "src/interfaces/ISettlement.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.25;\n\nimport {IERC20} from '@cowprotocol/interfaces/IERC20.sol';\nimport {GPv2Interaction} from '@cowprotocol/libraries/GPv2Interaction.sol';\nimport {GPv2Trade} from '@cowprotocol/libraries/GPv2Trade.sol';\n\n/**\n * @title ISettlement\n * @notice External interface of CoW Protocol's SolutionSettler contract.\n */\ninterface ISettlement {\n  /**\n   * @notice Settles a batch of trades.\n   * @param tokens The tokens that are traded in the batch.\n   * @param clearingPrices The clearing prices of the trades.\n   * @param trades The trades to settle.\n   * @param interactions The interactions to execute.\n   */\n  function settle(\n    IERC20[] calldata tokens,\n    uint256[] calldata clearingPrices,\n    GPv2Trade.Data[] calldata trades,\n    GPv2Interaction.Data[][3] calldata interactions\n  ) external;\n\n  /**\n   * @return domainSeparator The domain separator for IERC1271 signature\n   * @dev Immutable value, would not change on chain forks\n   */\n  function domainSeparator() external view returns (bytes32 domainSeparator);\n\n  /**\n   * @return vaultRelayer The address that'll use the pool liquidity in CoWprotocol swaps\n   * @dev Address that will transfer and transferFrom the pool. Has an infinite allowance.\n   */\n  function vaultRelayer() external view returns (address vaultRelayer);\n}\n"
    },
    "src/contracts/BConst.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.25;\n\n/**\n * @title BConst\n * @notice Constants used in the scope of the BPool contract.\n */\ncontract BConst {\n  /// @notice The unit of precision used in the calculations.\n  uint256 public constant BONE = 10 ** 18;\n\n  /// @notice The minimum number of bound tokens in a pool.\n  uint256 public constant MIN_BOUND_TOKENS = 2;\n  /// @notice The maximum number of bound tokens in a pool.\n  uint256 public constant MAX_BOUND_TOKENS = 8;\n\n  /// @notice The minimum swap fee that can be set.\n  uint256 public constant MIN_FEE = BONE / 10 ** 6;\n  /// @notice The maximum swap fee that can be set.\n  uint256 public constant MAX_FEE = BONE - MIN_FEE;\n  /// @notice The immutable exit fee percentage\n  uint256 public constant EXIT_FEE = 0;\n\n  /// @notice The minimum weight that a token can have.\n  uint256 public constant MIN_WEIGHT = BONE;\n  /// @notice The maximum weight that a token can have.\n  uint256 public constant MAX_WEIGHT = BONE * 50;\n  /// @notice The maximum sum of weights of all tokens in a pool.\n  uint256 public constant MAX_TOTAL_WEIGHT = BONE * 50;\n  /// @notice The minimum balance that a token must have.\n  uint256 public constant MIN_BALANCE = BONE / 10 ** 12;\n\n  /// @notice The initial total supply of the pool tokens (minted to the pool creator).\n  uint256 public constant INIT_POOL_SUPPLY = BONE * 100;\n\n  /// @notice The minimum base value for the bpow calculation.\n  uint256 public constant MIN_BPOW_BASE = 1 wei;\n  /// @notice The maximum base value for the bpow calculation.\n  uint256 public constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\n  /// @notice The precision of the bpow calculation.\n  uint256 public constant BPOW_PRECISION = BONE / 10 ** 10;\n\n  /// @notice The maximum ratio of input tokens vs the current pool balance.\n  uint256 public constant MAX_IN_RATIO = BONE >> 1;\n  /// @notice The maximum ratio of output tokens vs the current pool balance.\n  uint256 public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\n\n  /**\n   * @notice The storage slot used to write transient data.\n   * @dev Using an arbitrary storage slot to prevent possible future\n   * transient variables defined by solidity from overriding it.\n   * @dev Value is: uint256(keccak256('BPool.transientStorageLock')) - 1;\n   */\n  uint256 internal constant _MUTEX_TRANSIENT_STORAGE_SLOT =\n    0x3f8f4c536ce1b925b469af1b09a44da237dab5bbc584585648c12be1ca25a8c4;\n  /// @notice The value representing an unlocked state of the mutex.\n  bytes32 internal constant _MUTEX_FREE = bytes32(uint256(0));\n  /// @notice The value representing a locked state of the mutex.\n  bytes32 internal constant _MUTEX_TAKEN = bytes32(uint256(1));\n}\n"
    },
    "src/contracts/BNum.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.25;\n\nimport {BConst} from './BConst.sol';\n\n/**\n * @title BNum\n * @notice Includes functions for arithmetic operations with fixed-point numbers.\n * @dev The arithmetic operations are implemented with a precision of BONE.\n */\n// solhint-disable private-vars-leading-underscore\n// solhint-disable named-return-values\ncontract BNum is BConst {\n  /**\n   * @notice Thrown when an overflow is encountered inside the add function\n   */\n  error BNum_AddOverflow();\n\n  /**\n   * @notice Thrown when an underflow is encountered inside the sub function\n   */\n  error BNum_SubUnderflow();\n\n  /**\n   * @notice Thrown when an overflow is encountered inside the mul function\n   */\n  error BNum_MulOverflow();\n\n  /**\n   * @notice Thrown when attempting to divide by zero\n   */\n  error BNum_DivZero();\n\n  /**\n   * @notice Thrown when an internal error occurs inside div function\n   */\n  error BNum_DivInternal();\n\n  /**\n   * @notice Thrown when the base is too low in the bpow function\n   */\n  error BNum_BPowBaseTooLow();\n\n  /**\n   * @notice Thrown when the base is too high in the bpow function\n   */\n  error BNum_BPowBaseTooHigh();\n\n  function btoi(uint256 a) internal pure returns (uint256) {\n    unchecked {\n      return a / BONE;\n    }\n  }\n\n  function bfloor(uint256 a) internal pure returns (uint256) {\n    unchecked {\n      return btoi(a) * BONE;\n    }\n  }\n\n  function badd(uint256 a, uint256 b) internal pure returns (uint256) {\n    unchecked {\n      uint256 c = a + b;\n      if (c < a) {\n        revert BNum_AddOverflow();\n      }\n      return c;\n    }\n  }\n\n  function bsub(uint256 a, uint256 b) internal pure returns (uint256) {\n    unchecked {\n      (uint256 c, bool flag) = bsubSign(a, b);\n      if (flag) {\n        revert BNum_SubUnderflow();\n      }\n      return c;\n    }\n  }\n\n  function bsubSign(uint256 a, uint256 b) internal pure returns (uint256, bool) {\n    unchecked {\n      if (a >= b) {\n        return (a - b, false);\n      } else {\n        return (b - a, true);\n      }\n    }\n  }\n\n  function bmul(uint256 a, uint256 b) internal pure returns (uint256) {\n    unchecked {\n      uint256 c0 = a * b;\n      if (a != 0 && c0 / a != b) {\n        revert BNum_MulOverflow();\n      }\n      // NOTE: using >> 1 instead of / 2\n      uint256 c1 = c0 + (BONE >> 1);\n      if (c1 < c0) {\n        revert BNum_MulOverflow();\n      }\n      uint256 c2 = c1 / BONE;\n      return c2;\n    }\n  }\n\n  function bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    unchecked {\n      if (b == 0) {\n        revert BNum_DivZero();\n      }\n      uint256 c0 = a * BONE;\n      if (a != 0 && c0 / a != BONE) {\n        revert BNum_DivInternal(); // bmul overflow\n      }\n      // NOTE: using >> 1 instead of / 2\n      uint256 c1 = c0 + (b >> 1);\n      if (c1 < c0) {\n        revert BNum_DivInternal(); //  badd require\n      }\n      uint256 c2 = c1 / b;\n      return c2;\n    }\n  }\n\n  // DSMath.wpow\n  function bpowi(uint256 a, uint256 n) internal pure returns (uint256) {\n    unchecked {\n      uint256 z = n % 2 != 0 ? a : BONE;\n\n      for (n /= 2; n != 0; n /= 2) {\n        a = bmul(a, a);\n\n        if (n % 2 != 0) {\n          z = bmul(z, a);\n        }\n      }\n      return z;\n    }\n  }\n\n  // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\n  // Use `bpowi` for `b^e` and `bpowK` for k iterations\n  // of approximation of b^0.w\n  function bpow(uint256 base, uint256 exp) internal pure returns (uint256) {\n    unchecked {\n      if (base < MIN_BPOW_BASE) {\n        revert BNum_BPowBaseTooLow();\n      }\n      if (base > MAX_BPOW_BASE) {\n        revert BNum_BPowBaseTooHigh();\n      }\n\n      uint256 whole = bfloor(exp);\n      uint256 remain = bsub(exp, whole);\n\n      uint256 wholePow = bpowi(base, btoi(whole));\n\n      if (remain == 0) {\n        return wholePow;\n      }\n\n      uint256 partialResult = bpowApprox(base, remain, BPOW_PRECISION);\n      return bmul(wholePow, partialResult);\n    }\n  }\n\n  function bpowApprox(uint256 base, uint256 exp, uint256 precision) internal pure returns (uint256) {\n    unchecked {\n      // term 0:\n      uint256 a = exp;\n      (uint256 x, bool xneg) = bsubSign(base, BONE);\n      uint256 term = BONE;\n      uint256 sum = term;\n      bool negative = false;\n\n      // term(k) = numer / denom\n      //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\n      // each iteration, multiply previous term by (a-(k-1)) * x / k\n      // continue until term is less than precision\n      for (uint256 i = 1; term >= precision; i++) {\n        uint256 bigK = i * BONE;\n        (uint256 c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\n        term = bmul(term, bmul(c, x));\n        term = bdiv(term, bigK);\n        if (term == 0) break;\n\n        if (xneg) negative = !negative;\n        if (cneg) negative = !negative;\n        if (negative) {\n          sum = bsub(sum, term);\n        } else {\n          sum = badd(sum, term);\n        }\n      }\n\n      return sum;\n    }\n  }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "node_modules/@cowprotocol/contracts/src/contracts/libraries/GPv2Trade.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity >=0.7.6 <0.9.0;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"../mixins/GPv2Signing.sol\";\nimport \"./GPv2Order.sol\";\n\n/// @title Gnosis Protocol v2 Trade Library.\n/// @author Gnosis Developers\nlibrary GPv2Trade {\n    using GPv2Order for GPv2Order.Data;\n    using GPv2Order for bytes;\n\n    /// @dev A struct representing a trade to be executed as part a batch\n    /// settlement.\n    struct Data {\n        uint256 sellTokenIndex;\n        uint256 buyTokenIndex;\n        address receiver;\n        uint256 sellAmount;\n        uint256 buyAmount;\n        uint32 validTo;\n        bytes32 appData;\n        uint256 feeAmount;\n        uint256 flags;\n        uint256 executedAmount;\n        bytes signature;\n    }\n\n    /// @dev Extracts the order data and signing scheme for the specified trade.\n    ///\n    /// @param trade The trade.\n    /// @param tokens The list of tokens included in the settlement. The token\n    /// indices in the trade parameters map to tokens in this array.\n    /// @param order The memory location to extract the order data to.\n    function extractOrder(\n        Data calldata trade,\n        IERC20[] calldata tokens,\n        GPv2Order.Data memory order\n    ) internal pure returns (GPv2Signing.Scheme signingScheme) {\n        order.sellToken = tokens[trade.sellTokenIndex];\n        order.buyToken = tokens[trade.buyTokenIndex];\n        order.receiver = trade.receiver;\n        order.sellAmount = trade.sellAmount;\n        order.buyAmount = trade.buyAmount;\n        order.validTo = trade.validTo;\n        order.appData = trade.appData;\n        order.feeAmount = trade.feeAmount;\n        (\n            order.kind,\n            order.partiallyFillable,\n            order.sellTokenBalance,\n            order.buyTokenBalance,\n            signingScheme\n        ) = extractFlags(trade.flags);\n    }\n\n    /// @dev Decodes trade flags.\n    ///\n    /// Trade flags are used to tightly encode information on how to decode\n    /// an order. Examples that directly affect the structure of an order are\n    /// the kind of order (either a sell or a buy order) as well as whether the\n    /// order is partially fillable or if it is a \"fill-or-kill\" order. It also\n    /// encodes the signature scheme used to validate the order. As the most\n    /// likely values are fill-or-kill sell orders by an externally owned\n    /// account, the flags are chosen such that `0x00` represents this kind of\n    /// order. The flags byte uses the following format:\n    ///\n    /// ```\n    /// bit | 31 ...   | 6 | 5 | 4 | 3 | 2 | 1 | 0 |\n    /// ----+----------+-------+---+-------+---+---+\n    ///     | reserved | *   * | * | *   * | * | * |\n    ///                  |   |   |   |   |   |   |\n    ///                  |   |   |   |   |   |   +---- order kind bit, 0 for a sell order\n    ///                  |   |   |   |   |   |         and 1 for a buy order\n    ///                  |   |   |   |   |   |\n    ///                  |   |   |   |   |   +-------- order fill bit, 0 for fill-or-kill\n    ///                  |   |   |   |   |             and 1 for a partially fillable order\n    ///                  |   |   |   |   |\n    ///                  |   |   |   +---+------------ use internal sell token balance bit:\n    ///                  |   |   |                     0x: ERC20 token balance\n    ///                  |   |   |                     10: external Balancer Vault balance\n    ///                  |   |   |                     11: internal Balancer Vault balance\n    ///                  |   |   |\n    ///                  |   |   +-------------------- use buy token balance bit\n    ///                  |   |                         0: ERC20 token balance\n    ///                  |   |                         1: internal Balancer Vault balance\n    ///                  |   |\n    ///                  +---+------------------------ signature scheme bits:\n    ///                                                00: EIP-712\n    ///                                                01: eth_sign\n    ///                                                10: EIP-1271\n    ///                                                11: pre_sign\n    /// ```\n    function extractFlags(\n        uint256 flags\n    )\n        internal\n        pure\n        returns (\n            bytes32 kind,\n            bool partiallyFillable,\n            bytes32 sellTokenBalance,\n            bytes32 buyTokenBalance,\n            GPv2Signing.Scheme signingScheme\n        )\n    {\n        if (flags & 0x01 == 0) {\n            kind = GPv2Order.KIND_SELL;\n        } else {\n            kind = GPv2Order.KIND_BUY;\n        }\n        partiallyFillable = flags & 0x02 != 0;\n        if (flags & 0x08 == 0) {\n            sellTokenBalance = GPv2Order.BALANCE_ERC20;\n        } else if (flags & 0x04 == 0) {\n            sellTokenBalance = GPv2Order.BALANCE_EXTERNAL;\n        } else {\n            sellTokenBalance = GPv2Order.BALANCE_INTERNAL;\n        }\n        if (flags & 0x10 == 0) {\n            buyTokenBalance = GPv2Order.BALANCE_ERC20;\n        } else {\n            buyTokenBalance = GPv2Order.BALANCE_INTERNAL;\n        }\n\n        // NOTE: Take advantage of the fact that Solidity will revert if the\n        // following expression does not produce a valid enum value. This means\n        // we check here that the leading reserved bits must be 0.\n        signingScheme = GPv2Signing.Scheme(flags >> 5);\n    }\n}\n"
    },
    "node_modules/@cowprotocol/contracts/src/contracts/mixins/GPv2Signing.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity >=0.7.6 <0.9.0;\n\nimport \"../interfaces/GPv2EIP1271.sol\";\nimport \"../libraries/GPv2Order.sol\";\nimport \"../libraries/GPv2Trade.sol\";\n\n/// @title Gnosis Protocol v2 Signing Library.\n/// @author Gnosis Developers\nabstract contract GPv2Signing {\n    using GPv2Order for GPv2Order.Data;\n    using GPv2Order for bytes;\n\n    /// @dev Recovered trade data containing the extracted order and the\n    /// recovered owner address.\n    struct RecoveredOrder {\n        GPv2Order.Data data;\n        bytes uid;\n        address owner;\n        address receiver;\n    }\n\n    /// @dev Signing scheme used for recovery.\n    enum Scheme {\n        Eip712,\n        EthSign,\n        Eip1271,\n        PreSign\n    }\n\n    /// @dev The EIP-712 domain type hash used for computing the domain\n    /// separator.\n    bytes32 private constant DOMAIN_TYPE_HASH =\n        keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n\n    /// @dev The EIP-712 domain name used for computing the domain separator.\n    bytes32 private constant DOMAIN_NAME = keccak256(\"Gnosis Protocol\");\n\n    /// @dev The EIP-712 domain version used for computing the domain separator.\n    bytes32 private constant DOMAIN_VERSION = keccak256(\"v2\");\n\n    /// @dev Marker value indicating an order is pre-signed.\n    uint256 private constant PRE_SIGNED =\n        uint256(keccak256(\"GPv2Signing.Scheme.PreSign\"));\n\n    /// @dev The domain separator used for signing orders that gets mixed in\n    /// making signatures for different domains incompatible. This domain\n    /// separator is computed following the EIP-712 standard and has replay\n    /// protection mixed in so that signed orders are only valid for specific\n    /// GPv2 contracts.\n    bytes32 public immutable domainSeparator;\n\n    /// @dev Storage indicating whether or not an order has been signed by a\n    /// particular address.\n    mapping(bytes => uint256) public preSignature;\n\n    /// @dev Event that is emitted when an account either pre-signs an order or\n    /// revokes an existing pre-signature.\n    event PreSignature(address indexed owner, bytes orderUid, bool signed);\n\n    constructor() {\n        // NOTE: Currently, the only way to get the chain ID in solidity is\n        // using assembly.\n        uint256 chainId;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            chainId := chainid()\n        }\n\n        domainSeparator = keccak256(\n            abi.encode(\n                DOMAIN_TYPE_HASH,\n                DOMAIN_NAME,\n                DOMAIN_VERSION,\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    /// @dev Sets a presignature for the specified order UID.\n    ///\n    /// @param orderUid The unique identifier of the order to pre-sign.\n    /// @param signed True to set the order as tradable with pre-sign, false to\n    /// false to unset it.\n    function setPreSignature(bytes calldata orderUid, bool signed) external {\n        (, address owner, ) = orderUid.extractOrderUidParams();\n        require(owner == msg.sender, \"GPv2: cannot presign order\");\n        if (signed) {\n            preSignature[orderUid] = PRE_SIGNED;\n        } else {\n            preSignature[orderUid] = 0;\n        }\n        emit PreSignature(owner, orderUid, signed);\n    }\n\n    /// @dev Returns an empty recovered order with a pre-allocated buffer for\n    /// packing the unique identifier.\n    ///\n    /// @return recoveredOrder The empty recovered order data.\n    function allocateRecoveredOrder()\n        internal\n        pure\n        returns (RecoveredOrder memory recoveredOrder)\n    {\n        recoveredOrder.uid = new bytes(GPv2Order.UID_LENGTH);\n    }\n\n    /// @dev Extracts order data and recovers the signer from the specified\n    /// trade.\n    ///\n    /// @param recoveredOrder Memory location used for writing the recovered order data.\n    /// @param tokens The list of tokens included in the settlement. The token\n    /// indices in the trade parameters map to tokens in this array.\n    /// @param trade The trade data to recover the order data from.\n    function recoverOrderFromTrade(\n        RecoveredOrder memory recoveredOrder,\n        IERC20[] calldata tokens,\n        GPv2Trade.Data calldata trade\n    ) internal view {\n        GPv2Order.Data memory order = recoveredOrder.data;\n\n        Scheme signingScheme = GPv2Trade.extractOrder(trade, tokens, order);\n        (bytes32 orderDigest, address owner) = recoverOrderSigner(\n            order,\n            signingScheme,\n            trade.signature\n        );\n\n        recoveredOrder.uid.packOrderUidParams(\n            orderDigest,\n            owner,\n            order.validTo\n        );\n        recoveredOrder.owner = owner;\n        recoveredOrder.receiver = order.actualReceiver(owner);\n    }\n\n    /// @dev The length of any signature from an externally owned account.\n    uint256 private constant ECDSA_SIGNATURE_LENGTH = 65;\n\n    /// @dev Recovers an order's signer from the specified order and signature.\n    ///\n    /// @param order The order to recover a signature for.\n    /// @param signingScheme The signing scheme.\n    /// @param signature The signature bytes.\n    /// @return orderDigest The computed order hash.\n    /// @return owner The recovered address from the specified signature.\n    function recoverOrderSigner(\n        GPv2Order.Data memory order,\n        Scheme signingScheme,\n        bytes calldata signature\n    ) internal view returns (bytes32 orderDigest, address owner) {\n        orderDigest = order.hash(domainSeparator);\n        if (signingScheme == Scheme.Eip712) {\n            owner = recoverEip712Signer(orderDigest, signature);\n        } else if (signingScheme == Scheme.EthSign) {\n            owner = recoverEthsignSigner(orderDigest, signature);\n        } else if (signingScheme == Scheme.Eip1271) {\n            owner = recoverEip1271Signer(orderDigest, signature);\n        } else {\n            // signingScheme == Scheme.PreSign\n            owner = recoverPreSigner(orderDigest, signature, order.validTo);\n        }\n    }\n\n    /// @dev Perform an ECDSA recover for the specified message and calldata\n    /// signature.\n    ///\n    /// The signature is encoded by tighyly packing the following struct:\n    /// ```\n    /// struct EncodedSignature {\n    ///     bytes32 r;\n    ///     bytes32 s;\n    ///     uint8 v;\n    /// }\n    /// ```\n    ///\n    /// @param message The signed message.\n    /// @param encodedSignature The encoded signature.\n    function ecdsaRecover(\n        bytes32 message,\n        bytes calldata encodedSignature\n    ) internal pure returns (address signer) {\n        require(\n            encodedSignature.length == ECDSA_SIGNATURE_LENGTH,\n            \"GPv2: malformed ecdsa signature\"\n        );\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // NOTE: Use assembly to efficiently decode signature data.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // r = uint256(encodedSignature[0:32])\n            r := calldataload(encodedSignature.offset)\n            // s = uint256(encodedSignature[32:64])\n            s := calldataload(add(encodedSignature.offset, 32))\n            // v = uint8(encodedSignature[64])\n            v := shr(248, calldataload(add(encodedSignature.offset, 64)))\n        }\n\n        signer = ecrecover(message, v, r, s);\n        require(signer != address(0), \"GPv2: invalid ecdsa signature\");\n    }\n\n    /// @dev Decodes signature bytes originating from an EIP-712-encoded\n    /// signature.\n    ///\n    /// EIP-712 signs typed data. The specifications are described in the\n    /// related EIP (<https://eips.ethereum.org/EIPS/eip-712>).\n    ///\n    /// EIP-712 signatures are encoded as standard ECDSA signatures as described\n    /// in the corresponding decoding function [`ecdsaRecover`].\n    ///\n    /// @param orderDigest The EIP-712 signing digest derived from the order\n    /// parameters.\n    /// @param encodedSignature Calldata pointing to tightly packed signature\n    /// bytes.\n    /// @return owner The address of the signer.\n    function recoverEip712Signer(\n        bytes32 orderDigest,\n        bytes calldata encodedSignature\n    ) internal pure returns (address owner) {\n        owner = ecdsaRecover(orderDigest, encodedSignature);\n    }\n\n    /// @dev Decodes signature bytes originating from the output of the eth_sign\n    /// RPC call.\n    ///\n    /// The specifications are described in the Ethereum documentation\n    /// (<https://eth.wiki/json-rpc/API#eth_sign>).\n    ///\n    /// eth_sign signatures are encoded as standard ECDSA signatures as\n    /// described in the corresponding decoding function\n    /// [`ecdsaRecover`].\n    ///\n    /// @param orderDigest The EIP-712 signing digest derived from the order\n    /// parameters.\n    /// @param encodedSignature Calldata pointing to tightly packed signature\n    /// bytes.\n    /// @return owner The address of the signer.\n    function recoverEthsignSigner(\n        bytes32 orderDigest,\n        bytes calldata encodedSignature\n    ) internal pure returns (address owner) {\n        // The signed message is encoded as:\n        // `\"\\x19Ethereum Signed Message:\\n\" || length || data`, where\n        // the length is a constant (32 bytes) and the data is defined as:\n        // `orderDigest`.\n        bytes32 ethsignDigest = keccak256(\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", orderDigest)\n        );\n\n        owner = ecdsaRecover(ethsignDigest, encodedSignature);\n    }\n\n    /// @dev Verifies the input calldata as an EIP-1271 contract signature and\n    /// returns the address of the signer.\n    ///\n    /// The encoded signature tightly packs the following struct:\n    ///\n    /// ```\n    /// struct EncodedEip1271Signature {\n    ///     address owner;\n    ///     bytes signature;\n    /// }\n    /// ```\n    ///\n    /// This function enforces that the encoded data stores enough bytes to\n    /// cover the full length of the decoded signature.\n    ///\n    /// @param encodedSignature The encoded EIP-1271 signature.\n    /// @param orderDigest The EIP-712 signing digest derived from the order\n    /// parameters.\n    /// @return owner The address of the signer.\n    function recoverEip1271Signer(\n        bytes32 orderDigest,\n        bytes calldata encodedSignature\n    ) internal view returns (address owner) {\n        // NOTE: Use assembly to read the verifier address from the encoded\n        // signature bytes.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // owner = address(encodedSignature[0:20])\n            owner := shr(96, calldataload(encodedSignature.offset))\n        }\n\n        // NOTE: Configure prettier to ignore the following line as it causes\n        // a panic in the Solidity plugin.\n        // prettier-ignore\n        bytes calldata signature = encodedSignature[20:];\n\n        require(\n            EIP1271Verifier(owner).isValidSignature(orderDigest, signature) ==\n                GPv2EIP1271.MAGICVALUE,\n            \"GPv2: invalid eip1271 signature\"\n        );\n    }\n\n    /// @dev Verifies the order has been pre-signed. The signature is the\n    /// address of the signer of the order.\n    ///\n    /// @param orderDigest The EIP-712 signing digest derived from the order\n    /// parameters.\n    /// @param encodedSignature The pre-sign signature reprenting the order UID.\n    /// @param validTo The order expiry timestamp.\n    /// @return owner The address of the signer.\n    function recoverPreSigner(\n        bytes32 orderDigest,\n        bytes calldata encodedSignature,\n        uint32 validTo\n    ) internal view returns (address owner) {\n        require(encodedSignature.length == 20, \"GPv2: malformed presignature\");\n        // NOTE: Use assembly to read the owner address from the encoded\n        // signature bytes.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // owner = address(encodedSignature[0:20])\n            owner := shr(96, calldataload(encodedSignature.offset))\n        }\n\n        bytes memory orderUid = new bytes(GPv2Order.UID_LENGTH);\n        orderUid.packOrderUidParams(orderDigest, owner, validTo);\n\n        require(\n            preSignature[orderUid] == PRE_SIGNED,\n            \"GPv2: order not presigned\"\n        );\n    }\n}\n"
    },
    "node_modules/@cowprotocol/contracts/src/contracts/interfaces/GPv2EIP1271.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity >=0.7.6 <0.9.0;\n\nlibrary GPv2EIP1271 {\n    /// @dev Value returned by a call to `isValidSignature` if the signature\n    /// was verified successfully. The value is defined in EIP-1271 as:\n    /// bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))\n    bytes4 internal constant MAGICVALUE = 0x1626ba7e;\n}\n\n/// @title EIP1271 Interface\n/// @dev Standardized interface for an implementation of smart contract\n/// signatures as described in EIP-1271. The code that follows is identical to\n/// the code in the standard with the exception of formatting and syntax\n/// changes to adapt the code to our Solidity version.\ninterface EIP1271Verifier {\n    /// @dev Should return whether the signature provided is valid for the\n    /// provided data\n    /// @param _hash      Hash of the data to be signed\n    /// @param _signature Signature byte array associated with _data\n    ///\n    /// MUST return the bytes4 magic value 0x1626ba7e when function passes.\n    /// MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for\n    /// solc > 0.5)\n    /// MUST allow external calls\n    ///\n    function isValidSignature(\n        bytes32 _hash,\n        bytes memory _signature\n    ) external view returns (bytes4 magicValue);\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "ds-test/=node_modules/ds-test/src/",
      "forge-std/=node_modules/forge-std/src/",
      "forge-gas-snapshot/=node_modules/forge-gas-snapshot/src/",
      "solmate/=node_modules/solmate/src/",
      "@cowprotocol/=node_modules/@cowprotocol/contracts/src/contracts/",
      "cowprotocol/=node_modules/@cowprotocol/contracts/src/",
      "@composable-cow/=node_modules/composable-cow/",
      "@cow-amm/=node_modules/cow-amm/src/",
      "lib/openzeppelin/=node_modules/@openzeppelin/",
      "halmos-cheatcodes/=node_modules/halmos-cheatcodes/",
      "@crytic/=node_modules/@crytic/",
      "contracts/=src/contracts/",
      "interfaces/=src/interfaces/",
      "libraries/=src/libraries/",
      "@openzeppelin/=node_modules/@openzeppelin/",
      "composable-cow/=node_modules/composable-cow/",
      "cow-amm/=node_modules/cow-amm/",
      "erc4626-tests/=node_modules/composable-cow/lib/@openzeppelin/lib/erc4626-tests/",
      "halmos-cheatcodes/=node_modules/halmos-cheatcodes/",
      "murky/=node_modules/composable-cow/lib/murky/src/",
      "openzeppelin-contracts/=node_modules/composable-cow/lib/murky/lib/openzeppelin-contracts/",
      "safe/=node_modules/composable-cow/lib/safe/contracts/",
      "lib/composable-cow:@openzeppelin/=node_modules/cow-amm/lib/openzeppelin/contracts/",
      "lib/composable-cow:@openzeppelin/contracts/=node_modules/cow-amm/lib/openzeppelin/contracts/",
      "lib/composable-cow:cowprotocol/=node_modules/cow-amm/lib/composable-cow/lib/cowprotocol/src/",
      "lib/composable-cow:safe/=node_modules/cow-amm/lib/composable-cow/lib/safe/contracts/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 500
    },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "evmVersion": "cancun",
    "viaIR": false,
    "libraries": {}
  }
}}