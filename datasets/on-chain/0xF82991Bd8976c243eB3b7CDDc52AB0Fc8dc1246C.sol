{{
  "language": "Solidity",
  "sources": {
    "contracts/interface/RocketStorageInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketStorageInterface {\n\n    // Deploy status\n    function getDeployedStatus() external view returns (bool);\n\n    // Guardian\n    function getGuardian() external view returns(address);\n    function setGuardian(address _newAddress) external;\n    function confirmGuardian() external;\n\n    // Getters\n    function getAddress(bytes32 _key) external view returns (address);\n    function getUint(bytes32 _key) external view returns (uint);\n    function getString(bytes32 _key) external view returns (string memory);\n    function getBytes(bytes32 _key) external view returns (bytes memory);\n    function getBool(bytes32 _key) external view returns (bool);\n    function getInt(bytes32 _key) external view returns (int);\n    function getBytes32(bytes32 _key) external view returns (bytes32);\n\n    // Setters\n    function setAddress(bytes32 _key, address _value) external;\n    function setUint(bytes32 _key, uint _value) external;\n    function setString(bytes32 _key, string calldata _value) external;\n    function setBytes(bytes32 _key, bytes calldata _value) external;\n    function setBool(bytes32 _key, bool _value) external;\n    function setInt(bytes32 _key, int _value) external;\n    function setBytes32(bytes32 _key, bytes32 _value) external;\n\n    // Deleters\n    function deleteAddress(bytes32 _key) external;\n    function deleteUint(bytes32 _key) external;\n    function deleteString(bytes32 _key) external;\n    function deleteBytes(bytes32 _key) external;\n    function deleteBool(bytes32 _key) external;\n    function deleteInt(bytes32 _key) external;\n    function deleteBytes32(bytes32 _key) external;\n\n    // Arithmetic\n    function addUint(bytes32 _key, uint256 _amount) external;\n    function subUint(bytes32 _key, uint256 _amount) external;\n\n    // Protected storage\n    function getNodeWithdrawalAddress(address _nodeAddress) external view returns (address);\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external view returns (address);\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external;\n    function confirmWithdrawalAddress(address _nodeAddress) external;\n}\n"
    },
    "contracts/contract/RocketBase.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"../interface/RocketStorageInterface.sol\";\n\n/// @title Base settings / modifiers for each contract in Rocket Pool\n/// @author David Rugendyke\n\nabstract contract RocketBase {\n\n    // Calculate using this as the base\n    uint256 constant calcBase = 1 ether;\n\n    // Version of the contract\n    uint8 public version;\n\n    // The main storage contract where primary persistant storage is maintained\n    RocketStorageInterface rocketStorage = RocketStorageInterface(address(0));\n\n\n    /*** Modifiers **********************************************************/\n\n    /**\n    * @dev Throws if called by any sender that doesn't match a Rocket Pool network contract\n    */\n    modifier onlyLatestNetworkContract() {\n        require(getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        _;\n    }\n\n    /**\n    * @dev Throws if called by any sender that doesn't match one of the supplied contract or is the latest version of that contract\n    */\n    modifier onlyLatestContract(string memory _contractName, address _contractAddress) {\n        require(_contractAddress == getAddress(keccak256(abi.encodePacked(\"contract.address\", _contractName))), \"Invalid or outdated contract\");\n        _;\n    }\n\n    /**\n    * @dev Throws if called by any sender that isn't a registered node\n    */\n    modifier onlyRegisteredNode(address _nodeAddress) {\n        require(getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress))), \"Invalid node\");\n        _;\n    }\n\n    /**\n    * @dev Throws if called by any sender that isn't a trusted node DAO member\n    */\n    modifier onlyTrustedNode(address _nodeAddress) {\n        require(getBool(keccak256(abi.encodePacked(\"dao.trustednodes.\", \"member\", _nodeAddress))), \"Invalid trusted node\");\n        _;\n    }\n\n    /**\n    * @dev Throws if called by any sender that isn't a registered minipool\n    */\n    modifier onlyRegisteredMinipool(address _minipoolAddress) {\n        require(getBool(keccak256(abi.encodePacked(\"minipool.exists\", _minipoolAddress))), \"Invalid minipool\");\n        _;\n    }\n    \n\n    /**\n    * @dev Throws if called by any account other than a guardian account (temporary account allowed access to settings before DAO is fully enabled)\n    */\n    modifier onlyGuardian() {\n        require(msg.sender == rocketStorage.getGuardian(), \"Account is not a temporary guardian\");\n        _;\n    }\n\n\n\n\n    /*** Methods **********************************************************/\n\n    /// @dev Set the main Rocket Storage address\n    constructor(RocketStorageInterface _rocketStorageAddress) {\n        // Update the contract address\n        rocketStorage = RocketStorageInterface(_rocketStorageAddress);\n    }\n\n\n    /// @dev Get the address of a network contract by name\n    function getContractAddress(string memory _contractName) internal view returns (address) {\n        // Get the current contract address\n        address contractAddress = getAddress(keccak256(abi.encodePacked(\"contract.address\", _contractName)));\n        // Check it\n        require(contractAddress != address(0x0), \"Contract not found\");\n        // Return\n        return contractAddress;\n    }\n\n\n    /// @dev Get the address of a network contract by name (returns address(0x0) instead of reverting if contract does not exist)\n    function getContractAddressUnsafe(string memory _contractName) internal view returns (address) {\n        // Get the current contract address\n        address contractAddress = getAddress(keccak256(abi.encodePacked(\"contract.address\", _contractName)));\n        // Return\n        return contractAddress;\n    }\n\n\n    /// @dev Get the name of a network contract by address\n    function getContractName(address _contractAddress) internal view returns (string memory) {\n        // Get the contract name\n        string memory contractName = getString(keccak256(abi.encodePacked(\"contract.name\", _contractAddress)));\n        // Check it\n        require(bytes(contractName).length > 0, \"Contract not found\");\n        // Return\n        return contractName;\n    }\n\n    /// @dev Get revert error message from a .call method\n    function getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return \"Transaction reverted silently\";\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n\n\n\n    /*** Rocket Storage Methods ****************************************/\n\n    // Note: Unused helpers have been removed to keep contract sizes down\n\n    /// @dev Storage get methods\n    function getAddress(bytes32 _key) internal view returns (address) { return rocketStorage.getAddress(_key); }\n    function getUint(bytes32 _key) internal view returns (uint) { return rocketStorage.getUint(_key); }\n    function getString(bytes32 _key) internal view returns (string memory) { return rocketStorage.getString(_key); }\n    function getBytes(bytes32 _key) internal view returns (bytes memory) { return rocketStorage.getBytes(_key); }\n    function getBool(bytes32 _key) internal view returns (bool) { return rocketStorage.getBool(_key); }\n    function getInt(bytes32 _key) internal view returns (int) { return rocketStorage.getInt(_key); }\n    function getBytes32(bytes32 _key) internal view returns (bytes32) { return rocketStorage.getBytes32(_key); }\n\n    /// @dev Storage set methods\n    function setAddress(bytes32 _key, address _value) internal { rocketStorage.setAddress(_key, _value); }\n    function setUint(bytes32 _key, uint _value) internal { rocketStorage.setUint(_key, _value); }\n    function setString(bytes32 _key, string memory _value) internal { rocketStorage.setString(_key, _value); }\n    function setBytes(bytes32 _key, bytes memory _value) internal { rocketStorage.setBytes(_key, _value); }\n    function setBool(bytes32 _key, bool _value) internal { rocketStorage.setBool(_key, _value); }\n    function setInt(bytes32 _key, int _value) internal { rocketStorage.setInt(_key, _value); }\n    function setBytes32(bytes32 _key, bytes32 _value) internal { rocketStorage.setBytes32(_key, _value); }\n\n    /// @dev Storage delete methods\n    function deleteAddress(bytes32 _key) internal { rocketStorage.deleteAddress(_key); }\n    function deleteUint(bytes32 _key) internal { rocketStorage.deleteUint(_key); }\n    function deleteString(bytes32 _key) internal { rocketStorage.deleteString(_key); }\n    function deleteBytes(bytes32 _key) internal { rocketStorage.deleteBytes(_key); }\n    function deleteBool(bytes32 _key) internal { rocketStorage.deleteBool(_key); }\n    function deleteInt(bytes32 _key) internal { rocketStorage.deleteInt(_key); }\n    function deleteBytes32(bytes32 _key) internal { rocketStorage.deleteBytes32(_key); }\n\n    /// @dev Storage arithmetic methods\n    function addUint(bytes32 _key, uint256 _amount) internal { rocketStorage.addUint(_key, _amount); }\n    function subUint(bytes32 _key, uint256 _amount) internal { rocketStorage.subUint(_key, _amount); }\n}\n"
    },
    "contracts/types/MinipoolStatus.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\n// Represents a minipool's status within the network\n\nenum MinipoolStatus {\n    Initialised,    // The minipool has been initialised and is awaiting a deposit of user ETH\n    Prelaunch,      // The minipool has enough ETH to begin staking and is awaiting launch by the node operator\n    Staking,        // The minipool is currently staking\n    Withdrawable,   // NO LONGER USED\n    Dissolved       // The minipool has been dissolved and its user deposited ETH has been returned to the deposit pool\n}\n"
    },
    "contracts/types/MinipoolDeposit.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\n// Represents the type of deposits required by a minipool\n\nenum MinipoolDeposit {\n    None,       // Marks an invalid deposit type\n    Full,       // The minipool requires 32 ETH from the node operator, 16 ETH of which will be refinanced from user deposits\n    Half,       // The minipool required 16 ETH from the node operator to be matched with 16 ETH from user deposits\n    Empty,      // The minipool requires 0 ETH from the node operator to be matched with 32 ETH from user deposits (trusted nodes only)\n    Variable    // Indicates this minipool is of the new generation that supports a variable deposit amount\n}\n"
    },
    "contracts/types/MinipoolDetails.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"./MinipoolDeposit.sol\";\nimport \"./MinipoolStatus.sol\";\n\n// A struct containing all the information on-chain about a specific minipool\n\nstruct MinipoolDetails {\n    bool exists;\n    address minipoolAddress;\n    bytes pubkey;\n    MinipoolStatus status;\n    uint256 statusBlock;\n    uint256 statusTime;\n    bool finalised;\n    MinipoolDeposit depositType;\n    uint256 nodeFee;\n    uint256 nodeDepositBalance;\n    bool nodeDepositAssigned;\n    uint256 userDepositBalance;\n    bool userDepositAssigned;\n    uint256 userDepositAssignedTime;\n    bool useLatestDelegate;\n    address delegate;\n    address previousDelegate;\n    address effectiveDelegate;\n    uint256 penaltyCount;\n    uint256 penaltyRate;\n    address nodeAddress;\n}\n"
    },
    "contracts/interface/dao/node/RocketDAONodeTrustedInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketDAONodeTrustedInterface {\n    function getBootstrapModeDisabled() external view returns (bool);\n    function getMemberQuorumVotesRequired() external view returns (uint256);\n    function getMemberAt(uint256 _index) external view returns (address);\n    function getMemberCount() external view returns (uint256);\n    function getMemberMinRequired() external view returns (uint256);\n    function getMemberIsValid(address _nodeAddress) external view returns (bool);\n    function getMemberLastProposalTime(address _nodeAddress) external view returns (uint256);\n    function getMemberID(address _nodeAddress) external view returns (string memory);\n    function getMemberUrl(address _nodeAddress) external view returns (string memory);\n    function getMemberJoinedTime(address _nodeAddress) external view returns (uint256);\n    function getMemberProposalExecutedTime(string memory _proposalType, address _nodeAddress) external view returns (uint256);\n    function getMemberRPLBondAmount(address _nodeAddress) external view returns (uint256);\n    function getMemberIsChallenged(address _nodeAddress) external view returns (bool);\n    function getMemberUnbondedValidatorCount(address _nodeAddress) external view returns (uint256);\n    function incrementMemberUnbondedValidatorCount(address _nodeAddress) external;\n    function decrementMemberUnbondedValidatorCount(address _nodeAddress) external;\n    function bootstrapMember(string memory _id, string memory _url, address _nodeAddress) external;\n    function bootstrapSettingUint(string memory _settingContractName, string memory _settingPath, uint256 _value) external;\n    function bootstrapSettingBool(string memory _settingContractName, string memory _settingPath, bool _value) external;\n    function bootstrapUpgrade(string memory _type, string memory _name, string memory _contractAbi, address _contractAddress) external;\n    function bootstrapDisable(bool _confirmDisableBootstrapMode) external;\n    function memberJoinRequired(string memory _id, string memory _url) external;\n}\n"
    },
    "contracts/interface/minipool/RocketMinipoolInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"../../types/MinipoolDeposit.sol\";\nimport \"../../types/MinipoolStatus.sol\";\nimport \"../RocketStorageInterface.sol\";\n\ninterface RocketMinipoolInterface {\n    function version() external view returns (uint8);\n    function initialise(address _nodeAddress) external;\n    function getStatus() external view returns (MinipoolStatus);\n    function getFinalised() external view returns (bool);\n    function getStatusBlock() external view returns (uint256);\n    function getStatusTime() external view returns (uint256);\n    function getScrubVoted(address _member) external view returns (bool);\n    function getDepositType() external view returns (MinipoolDeposit);\n    function getNodeAddress() external view returns (address);\n    function getNodeFee() external view returns (uint256);\n    function getNodeDepositBalance() external view returns (uint256);\n    function getNodeRefundBalance() external view returns (uint256);\n    function getNodeDepositAssigned() external view returns (bool);\n    function getPreLaunchValue() external view returns (uint256);\n    function getNodeTopUpValue() external view returns (uint256);\n    function getVacant() external view returns (bool);\n    function getPreMigrationBalance() external view returns (uint256);\n    function getUserDistributed() external view returns (bool);\n    function getUserDepositBalance() external view returns (uint256);\n    function getUserDepositAssigned() external view returns (bool);\n    function getUserDepositAssignedTime() external view returns (uint256);\n    function getTotalScrubVotes() external view returns (uint256);\n    function calculateNodeShare(uint256 _balance) external view returns (uint256);\n    function calculateUserShare(uint256 _balance) external view returns (uint256);\n    function preDeposit(uint256 _bondingValue, bytes calldata _validatorPubkey, bytes calldata _validatorSignature, bytes32 _depositDataRoot) external payable;\n    function deposit() external payable;\n    function userDeposit() external payable;\n    function distributeBalance(bool _rewardsOnly) external;\n    function beginUserDistribute() external;\n    function userDistributeAllowed() external view returns (bool);\n    function refund() external;\n    function slash() external;\n    function finalise() external;\n    function canStake() external view returns (bool);\n    function canPromote() external view returns (bool);\n    function stake(bytes calldata _validatorSignature, bytes32 _depositDataRoot) external;\n    function prepareVacancy(uint256 _bondAmount, uint256 _currentBalance) external;\n    function promote() external;\n    function dissolve() external;\n    function close() external;\n    function voteScrub() external;\n    function reduceBondAmount() external;\n}\n"
    },
    "contracts/interface/minipool/RocketMinipoolManagerInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"../../types/MinipoolDeposit.sol\";\nimport \"../../types/MinipoolDetails.sol\";\nimport \"./RocketMinipoolInterface.sol\";\n\ninterface RocketMinipoolManagerInterface {\n    function getMinipoolCount() external view returns (uint256);\n    function getStakingMinipoolCount() external view returns (uint256);\n    function getFinalisedMinipoolCount() external view returns (uint256);\n    function getActiveMinipoolCount() external view returns (uint256);\n    function getMinipoolRPLSlashed(address _minipoolAddress) external view returns (bool);\n    function getMinipoolCountPerStatus(uint256 offset, uint256 limit) external view returns (uint256, uint256, uint256, uint256, uint256);\n    function getPrelaunchMinipools(uint256 offset, uint256 limit) external view returns (address[] memory);\n    function getMinipoolAt(uint256 _index) external view returns (address);\n    function getNodeMinipoolCount(address _nodeAddress) external view returns (uint256);\n    function getNodeActiveMinipoolCount(address _nodeAddress) external view returns (uint256);\n    function getNodeFinalisedMinipoolCount(address _nodeAddress) external view returns (uint256);\n    function getNodeStakingMinipoolCount(address _nodeAddress) external view returns (uint256);\n    function getNodeStakingMinipoolCountBySize(address _nodeAddress, uint256 _depositSize) external view returns (uint256);\n    function getNodeMinipoolAt(address _nodeAddress, uint256 _index) external view returns (address);\n    function getNodeValidatingMinipoolCount(address _nodeAddress) external view returns (uint256);\n    function getNodeValidatingMinipoolAt(address _nodeAddress, uint256 _index) external view returns (address);\n    function getMinipoolByPubkey(bytes calldata _pubkey) external view returns (address);\n    function getMinipoolExists(address _minipoolAddress) external view returns (bool);\n    function getMinipoolDestroyed(address _minipoolAddress) external view returns (bool);\n    function getMinipoolPubkey(address _minipoolAddress) external view returns (bytes memory);\n    function updateNodeStakingMinipoolCount(uint256 _previousBond, uint256 _newBond, uint256 _previousFee, uint256 _newFee) external;\n    function getMinipoolWithdrawalCredentials(address _minipoolAddress) external pure returns (bytes memory);\n    function createMinipool(address _nodeAddress, uint256 _salt) external returns (RocketMinipoolInterface);\n    function createVacantMinipool(address _nodeAddress, uint256 _salt, bytes calldata _validatorPubkey, uint256 _bondAmount, uint256 _currentBalance) external returns (RocketMinipoolInterface);\n    function removeVacantMinipool() external;\n    function getVacantMinipoolCount() external view returns (uint256);\n    function getVacantMinipoolAt(uint256 _index) external view returns (address);\n    function destroyMinipool() external;\n    function incrementNodeStakingMinipoolCount(address _nodeAddress) external;\n    function decrementNodeStakingMinipoolCount(address _nodeAddress) external;\n    function tryDistribute(address _nodeAddress) external;\n    function incrementNodeFinalisedMinipoolCount(address _nodeAddress) external;\n    function setMinipoolPubkey(bytes calldata _pubkey) external;\n    function getMinipoolDepositType(address _minipoolAddress) external view returns (MinipoolDeposit);\n}\n"
    },
    "contracts/interface/node/RocketNodeStakingInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.5.0 <0.9.0;\n\ninterface RocketNodeStakingInterface {\n    function getTotalRPLStake() external view returns (uint256);\n    function getNodeRPLStake(address _nodeAddress) external view returns (uint256);\n    function getNodeETHMatched(address _nodeAddress) external view returns (uint256);\n    function getNodeETHProvided(address _nodeAddress) external view returns (uint256);\n    function getNodeETHCollateralisationRatio(address _nodeAddress) external view returns (uint256);\n    function getNodeRPLStakedTime(address _nodeAddress) external view returns (uint256);\n    function getNodeEffectiveRPLStake(address _nodeAddress) external view returns (uint256);\n    function getNodeMinimumRPLStake(address _nodeAddress) external view returns (uint256);\n    function getNodeMaximumRPLStake(address _nodeAddress) external view returns (uint256);\n    function getNodeETHMatchedLimit(address _nodeAddress) external view returns (uint256);\n    function getRPLLockingAllowed(address _nodeAddress) external view returns (bool);\n    function stakeRPL(uint256 _amount) external;\n    function stakeRPLFor(address _nodeAddress, uint256 _amount) external;\n    function setRPLLockingAllowed(address _nodeAddress, bool _allowed) external;\n    function setStakeRPLForAllowed(address _caller, bool _allowed) external;\n    function setStakeRPLForAllowed(address _nodeAddress, address _caller, bool _allowed) external;\n    function getNodeRPLLocked(address _nodeAddress) external view returns (uint256);\n    function lockRPL(address _nodeAddress, uint256 _amount) external;\n    function unlockRPL(address _nodeAddress, uint256 _amount) external;\n    function transferRPL(address _from, address _to, uint256 _amount) external;\n    function burnRPL(address _from, uint256 _amount) external;\n    function withdrawRPL(uint256 _amount) external;\n    function withdrawRPL(address _nodeAddress, uint256 _amount) external;\n    function slashRPL(address _nodeAddress, uint256 _ethSlashAmount) external;\n}\n"
    },
    "contracts/interface/util/AddressSetStorageInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface AddressSetStorageInterface {\n    function getCount(bytes32 _key) external view returns (uint);\n    function getItem(bytes32 _key, uint _index) external view returns (address);\n    function getIndexOf(bytes32 _key, address _value) external view returns (int);\n    function addItem(bytes32 _key, address _value) external;\n    function removeItem(bytes32 _key, address _value) external;\n}\n"
    },
    "contracts/types/NodeDetails.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\n// A struct containing all the information on-chain about a specific node\n\nstruct NodeDetails {\n    bool exists;\n    uint256 registrationTime;\n    string timezoneLocation;\n    bool feeDistributorInitialised;\n    address feeDistributorAddress;\n    uint256 rewardNetwork;\n    uint256 rplStake;\n    uint256 effectiveRPLStake;\n    uint256 minimumRPLStake;\n    uint256 maximumRPLStake;\n    uint256 ethMatched;\n    uint256 ethMatchedLimit;\n    uint256 minipoolCount;\n    uint256 balanceETH;\n    uint256 balanceRETH;\n    uint256 balanceRPL;\n    uint256 balanceOldRPL;\n    uint256 depositCreditBalance;\n    uint256 distributorBalanceUserETH;\n    uint256 distributorBalanceNodeETH;\n    address withdrawalAddress;\n    address pendingWithdrawalAddress;\n    bool smoothingPoolRegistrationState;\n    uint256 smoothingPoolRegistrationChanged;\n    address nodeAddress;\n}\n"
    },
    "contracts/interface/node/RocketNodeManagerInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.5.0 <0.9.0;\npragma abicoder v2;\n\nimport \"../../types/NodeDetails.sol\";\n\ninterface RocketNodeManagerInterface {\n\n    // Structs\n    struct TimezoneCount {\n        string timezone;\n        uint256 count;\n    }\n\n    function getNodeCount() external view returns (uint256);\n    function getNodeCountPerTimezone(uint256 offset, uint256 limit) external view returns (TimezoneCount[] memory);\n    function getNodeAt(uint256 _index) external view returns (address);\n    function getNodeExists(address _nodeAddress) external view returns (bool);\n    function getNodeWithdrawalAddress(address _nodeAddress) external view returns (address);\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external view returns (address);\n    function getNodeRPLWithdrawalAddress(address _nodeAddress) external view returns (address);\n    function getNodeRPLWithdrawalAddressIsSet(address _nodeAddress) external view returns (bool);\n    function unsetRPLWithdrawalAddress(address _nodeAddress) external;\n    function setRPLWithdrawalAddress(address _nodeAddress, address _newRPLWithdrawalAddress, bool _confirm) external;\n    function confirmRPLWithdrawalAddress(address _nodeAddress) external;\n    function getNodePendingRPLWithdrawalAddress(address _nodeAddress) external view returns (address);\n    function getNodeTimezoneLocation(address _nodeAddress) external view returns (string memory);\n    function registerNode(string calldata _timezoneLocation) external;\n    function getNodeRegistrationTime(address _nodeAddress) external view returns (uint256);\n    function setTimezoneLocation(string calldata _timezoneLocation) external;\n    function setRewardNetwork(address _nodeAddress, uint256 network) external;\n    function getRewardNetwork(address _nodeAddress) external view returns (uint256);\n    function getFeeDistributorInitialised(address _nodeAddress) external view returns (bool);\n    function initialiseFeeDistributor() external;\n    function getAverageNodeFee(address _nodeAddress) external view returns (uint256);\n    function setSmoothingPoolRegistrationState(bool _state) external;\n    function getSmoothingPoolRegistrationState(address _nodeAddress) external returns (bool);\n    function getSmoothingPoolRegistrationChanged(address _nodeAddress) external returns (uint256);\n    function getSmoothingPoolRegisteredNodeCount(uint256 _offset, uint256 _limit) external view returns (uint256);\n    function getNodeDetails(address _nodeAddress) external view returns (NodeDetails memory);\n    function getNodeAddresses(uint256 _offset, uint256 _limit) external view returns (address[] memory);\n}\n"
    },
    "contracts/interface/network/RocketNetworkPricesInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\ninterface RocketNetworkPricesInterface {\n    function getPricesBlock() external view returns (uint256);\n    function getRPLPrice() external view returns (uint256);\n    function submitPrices(uint256 _block, uint256 _slotTimestamp, uint256 _rplPrice) external;\n    function executeUpdatePrices(uint256 _block, uint256 _slotTimestamp, uint256 _rplPrice) external;\n}\n"
    },
    "contracts/interface/dao/protocol/settings/RocketDAOProtocolSettingsMinipoolInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"../../../../types/MinipoolDeposit.sol\";\n\ninterface RocketDAOProtocolSettingsMinipoolInterface {\n    function getLaunchBalance() external view returns (uint256);\n    function getPreLaunchValue() external pure returns (uint256);\n    function getDepositUserAmount(MinipoolDeposit _depositType) external view returns (uint256);\n    function getFullDepositUserAmount() external view returns (uint256);\n    function getHalfDepositUserAmount() external view returns (uint256);\n    function getVariableDepositAmount() external view returns (uint256);\n    function getSubmitWithdrawableEnabled() external view returns (bool);\n    function getBondReductionEnabled() external view returns (bool);\n    function getLaunchTimeout() external view returns (uint256);\n    function getMaximumCount() external view returns (uint256);\n    function isWithinUserDistributeWindow(uint256 _time) external view returns (bool);\n    function hasUserDistributeWindowPassed(uint256 _time) external view returns (bool);\n    function getUserDistributeWindowStart() external view returns (uint256);\n    function getUserDistributeWindowLength() external view returns (uint256);\n}\n"
    },
    "contracts/interface/dao/protocol/settings/RocketDAOProtocolSettingsNodeInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketDAOProtocolSettingsNodeInterface {\n    function getRegistrationEnabled() external view returns (bool);\n    function getSmoothingPoolRegistrationEnabled() external view returns (bool);\n    function getDepositEnabled() external view returns (bool);\n    function getVacantMinipoolsEnabled() external view returns (bool);\n    function getMinimumPerMinipoolStake() external view returns (uint256);\n    function getMaximumPerMinipoolStake() external view returns (uint256);\n    function getMaximumStakeForVotingPower() external view returns (uint256);\n}\n"
    },
    "contracts/interface/minipool/RocketMinipoolFactoryInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"../../types/MinipoolDeposit.sol\";\n\ninterface RocketMinipoolFactoryInterface {\n    function getExpectedAddress(address _nodeAddress, uint256 _salt) external view returns (address);\n    function deployContract(address _nodeAddress, uint256 _salt) external returns (address);\n}\n"
    },
    "contracts/interface/node/RocketNodeDistributorFactoryInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\r\n\r\ninterface RocketNodeDistributorFactoryInterface {\r\n    function getProxyBytecode() external pure returns (bytes memory);\r\n    function getProxyAddress(address _nodeAddress) external view returns(address);\r\n    function createProxy(address _nodeAddress) external;\r\n}\r\n"
    },
    "contracts/interface/node/RocketNodeDistributorInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\r\n\r\ninterface RocketNodeDistributorInterface {\r\n    function getNodeShare() external view returns (uint256);\r\n    function getUserShare() external view returns (uint256);\r\n    function distribute() external;\r\n}\r\n"
    },
    "contracts/interface/network/RocketNetworkPenaltiesInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketNetworkPenaltiesInterface {\n    function submitPenalty(address _minipoolAddress, uint256 _block) external;\n    function executeUpdatePenalty(address _minipoolAddress, uint256 _block) external;\n    function getPenaltyCount(address _minipoolAddress) external view returns (uint256);\n}\n"
    },
    "contracts/interface/minipool/RocketMinipoolPenaltyInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketMinipoolPenaltyInterface {\n    // Max penalty rate\n    function setMaxPenaltyRate(uint256 _rate) external;\n    function getMaxPenaltyRate() external view returns (uint256);\n\n    // Penalty rate\n    function setPenaltyRate(address _minipoolAddress, uint256 _rate) external;\n    function getPenaltyRate(address _minipoolAddress) external view returns(uint256);\n}\n"
    },
    "contracts/interface/node/RocketNodeDepositInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"../../types/MinipoolDeposit.sol\";\n\ninterface RocketNodeDepositInterface {\n    function getNodeDepositCredit(address _nodeAddress) external view returns (uint256);\n    function getNodeEthBalance(address _nodeAddress) external view returns (uint256);\n    function getNodeCreditAndBalance(address _nodeAddress) external view returns (uint256);\n    function getNodeUsableCreditAndBalance(address _nodeAddress) external view returns (uint256);\n    function getNodeUsableCredit(address _nodeAddress) external view returns (uint256);\n    function increaseDepositCreditBalance(address _nodeOperator, uint256 _amount) external;\n    function depositEthFor(address _nodeAddress) external payable;\n    function withdrawEth(address _nodeAddress, uint256 _amount) external;\n    function deposit(uint256 _depositAmount, uint256 _minimumNodeFee, bytes calldata _validatorPubkey, bytes calldata _validatorSignature, bytes32 _depositDataRoot, uint256 _salt, address _expectedMinipoolAddress) external payable;\n    function depositWithCredit(uint256 _depositAmount, uint256 _minimumNodeFee, bytes calldata _validatorPubkey, bytes calldata _validatorSignature, bytes32 _depositDataRoot, uint256 _salt, address _expectedMinipoolAddress) external payable;\n    function isValidDepositAmount(uint256 _amount) external pure returns (bool);\n    function getDepositAmounts() external pure returns (uint256[] memory);\n    function createVacantMinipool(uint256 _bondAmount, uint256 _minimumNodeFee, bytes calldata _validatorPubkey, uint256 _salt, address _expectedMinipoolAddress, uint256 _currentBalance) external;\n    function increaseEthMatched(address _nodeAddress, uint256 _amount) external;\n}\n"
    },
    "@openzeppelin4/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "contracts/interface/network/RocketNetworkSnapshotsInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.5.0 <0.9.0;\n\nstruct Checkpoint224 {\n    uint32 _block;\n    uint224 _value;\n}\n\n/// @notice Accounting for snapshotting of values based on block numbers\ninterface RocketNetworkSnapshotsInterface {\n    function push(bytes32 _key, uint224 _value) external;\n    function length(bytes32 _key) external view returns (uint256);\n    function latest(bytes32 _key) external view returns (bool, uint32, uint224);\n    function latestBlock(bytes32 _key) external view returns (uint32);\n    function latestValue(bytes32 _key) external view returns (uint224);\n    function lookup(bytes32 _key, uint32 _block) external view returns (uint224);\n    function lookupRecent(bytes32 _key, uint32 _block, uint256 _recency) external view returns (uint224);\n}\n"
    },
    "contracts/contract/network/RocketNetworkSnapshots.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\n// SPDX-License-Identifier: MIT\n// Copyright (c) 2016-2023 zOS Global Limited and contributors\n// Adapted from OpenZeppelin `Checkpoints` contract\npragma solidity 0.8.18;\n\nimport \"@openzeppelin4/contracts/utils/math/Math.sol\";\n\nimport \"../RocketBase.sol\";\nimport \"../../interface/network/RocketNetworkSnapshotsInterface.sol\";\n\n/// @notice Accounting for snapshotting of values based on block numbers\ncontract RocketNetworkSnapshots is RocketBase, RocketNetworkSnapshotsInterface {\n\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketBase(_rocketStorageAddress) {\n        // Set contract version\n        version = 1;\n\n        // Setup for if this contract is being deployed as part of a new instance deployment\n        if (!rocketStorage.getDeployedStatus()) {\n            _insert(keccak256(\"network.prices.rpl\"), 0.01 ether);\n            _insert(keccak256(\"node.voting.power.stake.maximum\"), 1.5 ether);\n        }\n    }\n\n    function push(bytes32 _key, uint224 _value) onlyLatestContract(\"rocketNetworkSnapshots\", address(this)) onlyLatestNetworkContract external {\n        _insert(_key, _value);\n    }\n\n    function length(bytes32 _key) public view returns (uint256) {\n        return rocketStorage.getUint(keccak256(abi.encodePacked(\"snapshot.length\", _key)));\n    }\n\n    function latest(bytes32 _key) external view returns (bool, uint32, uint224) {\n        uint256 len = length(_key);\n        if (len == 0) {\n            return (false, 0, 0);\n        }\n        Checkpoint224 memory checkpoint = _load(_key, len - 1);\n        return (true, checkpoint._block, checkpoint._value);\n    }\n\n    function latestBlock(bytes32 _key) external view returns (uint32) {\n        uint256 len = length(_key);\n        return len == 0 ? 0 : _blockAt(_key, len - 1);\n    }\n\n    function latestValue(bytes32 _key) external view returns (uint224) {\n        uint256 len = length(_key);\n        return len == 0 ? 0 : _valueAt(_key, len - 1);\n    }\n\n    function lookup(bytes32 _key, uint32 _block) external view returns (uint224) {\n        uint256 len = length(_key);\n        uint256 pos = _binaryLookup(_key, _block, 0, len);\n        return pos == 0 ? 0 : _valueAt(_key, pos - 1);\n    }\n\n    function lookupRecent(bytes32 _key, uint32 _block, uint256 _recency) external view returns (uint224) {\n        uint256 len = length(_key);\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5 && len > _recency) {\n            uint256 mid = len - _recency;\n            if (_block < _blockAt(_key, mid)) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _binaryLookup(_key, _block, low, high);\n\n        return pos == 0 ? 0 : _valueAt(_key, pos - 1);\n    }\n\n    function _insert(bytes32 _key, uint224 _value) private {\n        uint32 blockNumber = uint32(block.number);\n        uint256 pos = length(_key);\n\n        if (pos > 0) {\n            Checkpoint224 memory last = _load(_key, pos - 1);\n\n            // Checkpoint keys must be non-decreasing.\n            require (last._block <= blockNumber, \"Unordered snapshot insertion\");\n\n            // Update or push new checkpoint\n            if (last._block == blockNumber) {\n                last._value = _value;\n                _set(_key, pos - 1, last);\n            } else {\n                _push(_key, Checkpoint224({_block: blockNumber, _value: _value}));\n            }\n        } else {\n            _push(_key, Checkpoint224({_block: blockNumber, _value: _value}));\n        }\n    }\n\n    function _binaryLookup(\n        bytes32 _key,\n        uint32 _block,\n        uint256 _low,\n        uint256 _high\n    ) private view returns (uint256) {\n        while (_low < _high) {\n            uint256 mid = Math.average(_low, _high);\n            if (_blockAt(_key, mid) > _block) {\n                _high = mid;\n            } else {\n                _low = mid + 1;\n            }\n        }\n        return _high;\n    }\n\n    function _load(bytes32 _key, uint256 _pos) private view returns (Checkpoint224 memory) {\n        bytes32 key = bytes32(uint256(_key) + _pos);\n        bytes32 raw = rocketStorage.getBytes32(key);\n        Checkpoint224 memory result;\n        result._block = uint32(uint256(raw) >> 224);\n        result._value = uint224(uint256(raw));\n        return result;\n    }\n\n    function _blockAt(bytes32 _key, uint256 _pos) private view returns (uint32) {\n        bytes32 key = bytes32(uint256(_key) + _pos);\n        bytes32 raw = rocketStorage.getBytes32(key);\n        return uint32(uint256(raw) >> 224);\n    }\n\n    function _valueAt(bytes32 _key, uint256 _pos) private view returns (uint224) {\n        bytes32 key = bytes32(uint256(_key) + _pos);\n        bytes32 raw = rocketStorage.getBytes32(key);\n        return uint224(uint256(raw));\n    }\n\n    function _push(bytes32 _key, Checkpoint224 memory _item) private {\n        bytes32 lengthKey = keccak256(abi.encodePacked(\"snapshot.length\", _key));\n        uint256 snapshotLength = rocketStorage.getUint(lengthKey);\n        bytes32 key = bytes32(uint256(_key) + snapshotLength);\n        rocketStorage.setUint(lengthKey, snapshotLength + 1);\n        rocketStorage.setBytes32(key, _encode(_item));\n    }\n\n    function _set(bytes32 _key, uint256 _pos, Checkpoint224 memory _item) private {\n        bytes32 key = bytes32(uint256(_key) + _pos);\n        rocketStorage.setBytes32(key, _encode(_item));\n    }\n\n    function _encode(Checkpoint224 memory _item) private pure returns (bytes32) {\n        return bytes32(\n            uint256(_item._block) << 224 | uint256(_item._value)\n        );\n    }\n}\n"
    },
    "contracts/interface/util/IERC20.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\n// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity >0.5.0 <0.9.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "contracts/interface/dao/protocol/settings/RocketDAOProtocolSettingsRewardsInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.5.0 <0.9.0;\n\ninterface RocketDAOProtocolSettingsRewardsInterface {\n    function setSettingRewardsClaimers(uint256 _trustedNodePercent, uint256 _protocolPercent, uint256 _nodePercent) external;\n    function getRewardsClaimerPerc(string memory _contractName) external view returns (uint256);\n    function getRewardsClaimersPerc() external view returns (uint256 _trustedNodePercent, uint256 _protocolPercent, uint256 _nodePercent);\n    function getRewardsClaimersTrustedNodePerc() external view returns (uint256);\n    function getRewardsClaimersProtocolPerc() external view returns (uint256);\n    function getRewardsClaimersNodePerc() external view returns (uint256);\n    function getRewardsClaimersTimeUpdated() external view returns (uint256);\n    function getRewardsClaimIntervalPeriods() external view returns (uint256);\n    function getRewardsClaimIntervalTime() external view returns (uint256);\n}\n"
    },
    "contracts/interface/util/IERC20Burnable.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\n// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\nimport \"./IERC20.sol\";\n\npragma solidity >0.5.0 <0.9.0;\n\ninterface IERC20Burnable is IERC20 {\n    function burn(uint256 amount) external;\n    function burnFrom(address account, uint256 amount) external;\n}\n"
    },
    "contracts/interface/RocketVaultInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\nimport \"./util/IERC20Burnable.sol\";\n\ninterface RocketVaultInterface {\n    function balanceOf(string memory _networkContractName) external view returns (uint256);\n    function depositEther() external payable;\n    function withdrawEther(uint256 _amount) external;\n    function depositToken(string memory _networkContractName, IERC20 _tokenAddress, uint256 _amount) external;\n    function withdrawToken(address _withdrawalAddress, IERC20 _tokenAddress, uint256 _amount) external;\n    function balanceOfToken(string memory _networkContractName, IERC20 _tokenAddress) external view returns (uint256);\n    function transferToken(string memory _networkContractName, IERC20 _tokenAddress, uint256 _amount) external;\n    function burnToken(IERC20Burnable _tokenAddress, uint256 _amount) external;\n}\n"
    },
    "contracts/interface/network/RocketNetworkVotingInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.5.0 <0.9.0;\n\ninterface RocketNetworkVotingInterface {\n    function initialiseVotingFor(address _nodeAddress) external;\n    function initialiseVoting() external;\n    function initialiseVotingWithDelegate(address _delegate) external;\n    function getVotingInitialised(address _nodeAddress) external view returns (bool);\n    function getNodeCount(uint32 _block) external view returns (uint256);\n    function getVotingPower(address _nodeAddress, uint32 _block) external view returns (uint256);\n    function setDelegate(address _newDelegate) external;\n    function getDelegate(address _nodeAddress, uint32 _block) external view returns (address);\n    function getCurrentDelegate(address _nodeAddress) external view returns (address);\n}"
    },
    "contracts/contract/node/RocketNodeStaking.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.18;\n\nimport \"../../interface/util/IERC20.sol\";\n\nimport \"../RocketBase.sol\";\nimport \"../../interface/minipool/RocketMinipoolManagerInterface.sol\";\nimport \"../../interface/network/RocketNetworkPricesInterface.sol\";\nimport \"../../interface/node/RocketNodeStakingInterface.sol\";\nimport \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsRewardsInterface.sol\";\nimport \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsMinipoolInterface.sol\";\nimport \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsNodeInterface.sol\";\nimport \"../../interface/RocketVaultInterface.sol\";\nimport \"../../interface/util/AddressSetStorageInterface.sol\";\nimport \"../../interface/network/RocketNetworkSnapshotsInterface.sol\";\nimport \"../network/RocketNetworkSnapshots.sol\";\nimport \"../../interface/node/RocketNodeManagerInterface.sol\";\nimport \"../../interface/network/RocketNetworkVotingInterface.sol\";\n\n/// @notice Handles node deposits and minipool creation\ncontract RocketNodeStaking is RocketBase, RocketNodeStakingInterface {\n\n    // Constants\n    bytes32 immutable internal totalKey;\n\n    // Events\n    event RPLStaked(address indexed from, uint256 amount, uint256 time);\n    event RPLWithdrawn(address indexed to, uint256 amount, uint256 time);\n    event RPLSlashed(address indexed node, uint256 amount, uint256 ethValue, uint256 time);\n    event StakeRPLForAllowed(address indexed node, address indexed caller, bool allowed, uint256 time);\n    event RPLLockingAllowed(address indexed node, bool allowed, uint256 time);\n    event RPLLocked(address indexed from, uint256 amount, uint256 time);\n    event RPLUnlocked(address indexed from, uint256 amount, uint256 time);\n    event RPLTransferred(address indexed from, address indexed to, uint256 amount, uint256 time);\n    event RPLBurned(address indexed from, uint256 amount, uint256 time);\n\n    modifier onlyRPLWithdrawalAddressOrNode(address _nodeAddress) {\n        // Check that the call is coming from RPL withdrawal address (or node if unset)\n        RocketNodeManagerInterface rocketNodeManager = RocketNodeManagerInterface(getContractAddress(\"rocketNodeManager\"));\n        if (rocketNodeManager.getNodeRPLWithdrawalAddressIsSet(_nodeAddress)) {\n            address rplWithdrawalAddress = rocketNodeManager.getNodeRPLWithdrawalAddress(_nodeAddress);\n            require(msg.sender == rplWithdrawalAddress, \"Must be called from RPL withdrawal address\");\n        } else {\n            require(msg.sender == _nodeAddress, \"Must be called from node address\");\n        }\n        _;\n    }\n\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketBase(_rocketStorageAddress) {\n        version = 6;\n\n        // Precompute keys\n        totalKey = keccak256(abi.encodePacked(\"rpl.staked.total.amount\"));\n    }\n\n    /// @notice Returns the total quantity of RPL staked on the network\n    function getTotalRPLStake() override external view returns (uint256) {\n        return getUint(totalKey);\n    }\n\n    /// @dev Increases the total network RPL stake\n    /// @param _amount How much to increase by\n    function increaseTotalRPLStake(uint256 _amount) private {\n        addUint(totalKey, _amount);\n    }\n\n    /// @dev Decrease the total network RPL stake\n    /// @param _amount How much to decrease by\n    function decreaseTotalRPLStake(uint256 _amount) private {\n        subUint(totalKey, _amount);\n    }\n\n    /// @notice Returns the amount a given node operator has staked\n    /// @param _nodeAddress The address of the node operator to query\n    function getNodeRPLStake(address _nodeAddress) override public view returns (uint256) {\n        bytes32 key = keccak256(abi.encodePacked(\"rpl.staked.node.amount\", _nodeAddress));\n        RocketNetworkSnapshotsInterface rocketNetworkSnapshots = RocketNetworkSnapshotsInterface(getContractAddress(\"rocketNetworkSnapshots\"));\n        (bool exists,, uint224 value) = rocketNetworkSnapshots.latest(key);\n        uint256 stake = uint256(value);\n        if (!exists){\n            // Fallback to old value\n            stake = getUint(key);\n        }\n        return stake;\n    }\n\n    /// @dev Increases a node operator's RPL stake\n    /// @param _amount How much to increase by\n    function increaseNodeRPLStake(address _nodeAddress, uint256 _amount) private {\n        RocketNetworkSnapshotsInterface rocketNetworkSnapshots = RocketNetworkSnapshotsInterface(getContractAddress(\"rocketNetworkSnapshots\"));\n        bytes32 key = keccak256(abi.encodePacked(\"rpl.staked.node.amount\", _nodeAddress));\n        (bool exists,, uint224 value) = rocketNetworkSnapshots.latest(key);\n        if (!exists){\n            value = uint224(getUint(key));\n        }\n        rocketNetworkSnapshots.push(key, value + uint224(_amount));\n    }\n\n    /// @dev Decrease a node operator's RPL stake\n    /// @param _amount How much to decrease by\n    function decreaseNodeRPLStake(address _nodeAddress, uint256 _amount) private {\n        RocketNetworkSnapshotsInterface rocketNetworkSnapshots = RocketNetworkSnapshotsInterface(getContractAddress(\"rocketNetworkSnapshots\"));\n        bytes32 key = keccak256(abi.encodePacked(\"rpl.staked.node.amount\", _nodeAddress));\n        (bool exists,, uint224 value) = rocketNetworkSnapshots.latest(key);\n        if (!exists){\n            value = uint224(getUint(key));\n        }\n        rocketNetworkSnapshots.push(key, value - uint224(_amount));\n    }\n\n    /// @notice Returns a node's matched ETH amount (amount taken from protocol to stake)\n    /// @param _nodeAddress The address of the node operator to query\n    function getNodeETHMatched(address _nodeAddress) override public view returns (uint256) {\n        RocketNetworkSnapshotsInterface rocketNetworkSnapshots = RocketNetworkSnapshotsInterface(getContractAddress(\"rocketNetworkSnapshots\"));\n        bytes32 key = keccak256(abi.encodePacked(\"eth.matched.node.amount\", _nodeAddress));\n        (bool exists, , uint224 value) = rocketNetworkSnapshots.latest(key);\n        if (exists) {\n            // Value was previously set in a snapshot so return that\n            return value;\n        } else {\n            // Fallback to old method\n            uint256 ethMatched = getUint(key);\n            if (ethMatched > 0) {\n                // Value was previously calculated and stored so return that\n                return ethMatched;\n            } else {\n                // Fallback for backwards compatibility before ETH matched was recorded (all legacy minipools matched 16 ETH from protocol)\n                RocketMinipoolManagerInterface rocketMinipoolManager = RocketMinipoolManagerInterface(getContractAddress(\"rocketMinipoolManager\"));\n                return rocketMinipoolManager.getNodeActiveMinipoolCount(_nodeAddress) * 16 ether;\n            }\n        }\n    }\n\n    /// @notice Returns a node's provided ETH amount (amount supplied to create minipools)\n    /// @param _nodeAddress The address of the node operator to query\n    function getNodeETHProvided(address _nodeAddress) override public view returns (uint256) {\n        // Get contracts\n        RocketMinipoolManagerInterface rocketMinipoolManager = RocketMinipoolManagerInterface(getContractAddress(\"rocketMinipoolManager\"));\n        uint256 activeMinipoolCount = rocketMinipoolManager.getNodeActiveMinipoolCount(_nodeAddress);\n        // Retrieve stored ETH matched value\n        uint256 ethMatched = getNodeETHMatched(_nodeAddress);\n        if (ethMatched > 0) {\n            RocketDAOProtocolSettingsMinipoolInterface rocketDAOProtocolSettingsMinipool = RocketDAOProtocolSettingsMinipoolInterface(getContractAddress(\"rocketDAOProtocolSettingsMinipool\"));\n            uint256 launchAmount = rocketDAOProtocolSettingsMinipool.getLaunchBalance();\n            // ETH provided is number of staking minipools * 32 - eth matched\n            uint256 totalEthStaked = activeMinipoolCount * launchAmount;\n            return totalEthStaked - ethMatched;\n        } else {\n            // Fallback for legacy minipools is number of staking minipools * 16\n            return activeMinipoolCount * 16 ether;\n        }\n    }\n\n    /// @notice Returns the ratio between capital taken from users and provided by a node operator.\n    ///         The value is a 1e18 precision fixed point integer value of (node capital + user capital) / node capital.\n    /// @param _nodeAddress The address of the node operator to query\n    function getNodeETHCollateralisationRatio(address _nodeAddress) override public view returns (uint256) {\n        uint256 ethMatched = getNodeETHMatched(_nodeAddress);\n        if (ethMatched == 0) {\n            // Node operator only has legacy minipools and all legacy minipools had a 1:1 ratio\n            return calcBase * 2;\n        } else {\n            RocketDAOProtocolSettingsMinipoolInterface rocketDAOProtocolSettingsMinipool = RocketDAOProtocolSettingsMinipoolInterface(getContractAddress(\"rocketDAOProtocolSettingsMinipool\"));\n            uint256 launchAmount = rocketDAOProtocolSettingsMinipool.getLaunchBalance();\n            RocketMinipoolManagerInterface rocketMinipoolManager = RocketMinipoolManagerInterface(getContractAddress(\"rocketMinipoolManager\"));\n            uint256 totalEthStaked = rocketMinipoolManager.getNodeActiveMinipoolCount(_nodeAddress) * launchAmount;\n            return (totalEthStaked * calcBase) / (totalEthStaked - ethMatched);\n        }\n    }\n\n    /// @notice Returns the timestamp at which a node last staked RPL\n    function getNodeRPLStakedTime(address _nodeAddress) override public view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(\"rpl.staked.node.time\", _nodeAddress)));\n    }\n\n    /// @dev Sets the timestamp at which a node last staked RPL\n    /// @param _nodeAddress The address of the node operator to set the value for\n    /// @param _time The timestamp to set\n    function setNodeRPLStakedTime(address _nodeAddress, uint256 _time) private {\n        setUint(keccak256(abi.encodePacked(\"rpl.staked.node.time\", _nodeAddress)), _time);\n    }\n\n    /// @notice Calculate and return a node's effective RPL stake amount\n    /// @param _nodeAddress The address of the node operator to calculate for\n    function getNodeEffectiveRPLStake(address _nodeAddress) override public view returns (uint256) {\n        // Load contracts\n        RocketNetworkPricesInterface rocketNetworkPrices = RocketNetworkPricesInterface(getContractAddress(\"rocketNetworkPrices\"));\n        RocketDAOProtocolSettingsNodeInterface rocketDAOProtocolSettingsNode = RocketDAOProtocolSettingsNodeInterface(getContractAddress(\"rocketDAOProtocolSettingsNode\"));\n        // Get node's current RPL stake\n        uint256 rplStake = getNodeRPLStake(_nodeAddress);\n        // Retrieve variables for calculations\n        uint256 matchedETH = getNodeETHMatched(_nodeAddress);\n        uint256 providedETH = getNodeETHProvided(_nodeAddress);\n        uint256 rplPrice = rocketNetworkPrices.getRPLPrice();\n        // RPL stake cannot exceed maximum\n        uint256 maximumStakePercent = rocketDAOProtocolSettingsNode.getMaximumPerMinipoolStake();\n        uint256 maximumStake = providedETH * maximumStakePercent / rplPrice;\n        if (rplStake > maximumStake) {\n            return maximumStake;\n        }\n        // If RPL stake is lower than minimum, node has no effective stake\n        uint256 minimumStakePercent = rocketDAOProtocolSettingsNode.getMinimumPerMinipoolStake();\n        uint256 minimumStake = matchedETH * minimumStakePercent / rplPrice;\n        if (rplStake < minimumStake) {\n            return 0;\n        }\n        // Otherwise, return the actual stake\n        return rplStake;\n    }\n\n    /// @notice Calculate and return a node's minimum RPL stake to collateralize their minipools\n    /// @param _nodeAddress The address of the node operator to calculate for\n    function getNodeMinimumRPLStake(address _nodeAddress) override external view returns (uint256) {\n        // Load contracts\n        RocketNetworkPricesInterface rocketNetworkPrices = RocketNetworkPricesInterface(getContractAddress(\"rocketNetworkPrices\"));\n        RocketDAOProtocolSettingsNodeInterface rocketDAOProtocolSettingsNode = RocketDAOProtocolSettingsNodeInterface(getContractAddress(\"rocketDAOProtocolSettingsNode\"));\n        // Retrieve variables\n        uint256 minimumStakePercent = rocketDAOProtocolSettingsNode.getMinimumPerMinipoolStake();\n        uint256 matchedETH = getNodeETHMatched(_nodeAddress);\n        return matchedETH * minimumStakePercent / rocketNetworkPrices.getRPLPrice();\n    }\n\n    /// @notice Calculate and return a node's maximum RPL stake to fully collateralise their minipools\n    /// @param _nodeAddress The address of the node operator to calculate for\n    function getNodeMaximumRPLStake(address _nodeAddress) override public view returns (uint256) {\n        // Load contracts\n        RocketNetworkPricesInterface rocketNetworkPrices = RocketNetworkPricesInterface(getContractAddress(\"rocketNetworkPrices\"));\n        RocketDAOProtocolSettingsNodeInterface rocketDAOProtocolSettingsNode = RocketDAOProtocolSettingsNodeInterface(getContractAddress(\"rocketDAOProtocolSettingsNode\"));\n        // Retrieve variables\n        uint256 maximumStakePercent = rocketDAOProtocolSettingsNode.getMaximumPerMinipoolStake();\n        uint256 providedETH = getNodeETHProvided(_nodeAddress);\n        return providedETH * maximumStakePercent / rocketNetworkPrices.getRPLPrice();\n    }\n\n    /// @notice Calculate and return a node's limit of how much user ETH they can use based on RPL stake\n    /// @param _nodeAddress The address of the node operator to calculate for\n    function getNodeETHMatchedLimit(address _nodeAddress) override external view returns (uint256) {\n        // Load contracts\n        RocketDAOProtocolSettingsNodeInterface rocketDAOProtocolSettingsNode = RocketDAOProtocolSettingsNodeInterface(getContractAddress(\"rocketDAOProtocolSettingsNode\"));\n        // Retrieve minimum stake parameter\n        uint256 minimumStakePercent = rocketDAOProtocolSettingsNode.getMinimumPerMinipoolStake();\n        // When minimum stake is zero, allow unlimited amount of matched ETH\n        if (minimumStakePercent == 0) {\n            return type(uint256).max;\n        }\n        // Calculate and return limit\n        RocketNetworkPricesInterface rocketNetworkPrices = RocketNetworkPricesInterface(getContractAddress(\"rocketNetworkPrices\"));\n        return getNodeRPLStake(_nodeAddress) *rocketNetworkPrices.getRPLPrice() / minimumStakePercent;\n    }\n\n    /// @notice Returns whether this node allows RPL locking or not\n    /// @param _nodeAddress The address of the node operator to query for\n    function getRPLLockingAllowed(address _nodeAddress) external view returns (bool) {\n        return getBool(keccak256(abi.encodePacked(\"rpl.locking.allowed\", _nodeAddress)));\n    }\n\n    /// @notice Accept an RPL stake from the node operator's own address\n    ///         Requires the node's RPL withdrawal address to be unset\n    /// @param _amount The amount of RPL to stake\n    function stakeRPL(uint256 _amount) override external {\n        stakeRPLFor(msg.sender, _amount);\n    }\n\n    /// @notice Accept an RPL stake from any address for a specified node\n    ///         Requires caller to have approved this contract to spend RPL\n    ///         Requires caller to be on the node operator's allow list (see `setStakeForAllowed`)\n    /// @param _nodeAddress The address of the node operator to stake on behalf of\n    /// @param _amount The amount of RPL to stake\n    function stakeRPLFor(address _nodeAddress, uint256 _amount) override public onlyLatestContract(\"rocketNodeStaking\", address(this)) onlyRegisteredNode(_nodeAddress) {\n        // Must be node's RPL withdrawal address if set or the node's address or an allow listed address or rocketMerkleDistributorMainnet\n        if (msg.sender != getAddress(keccak256(abi.encodePacked(\"contract.address\", \"rocketMerkleDistributorMainnet\")))) {\n            RocketNodeManagerInterface rocketNodeManager = RocketNodeManagerInterface(getContractAddress(\"rocketNodeManager\"));\n            bool fromNode = false;\n            if (rocketNodeManager.getNodeRPLWithdrawalAddressIsSet(_nodeAddress)) {\n                address rplWithdrawalAddress = rocketNodeManager.getNodeRPLWithdrawalAddress(_nodeAddress);\n                fromNode = msg.sender == rplWithdrawalAddress;\n            } else {\n                address withdrawalAddress = rocketStorage.getNodeWithdrawalAddress(_nodeAddress);\n                fromNode = (msg.sender == _nodeAddress) || (msg.sender == withdrawalAddress);\n            }\n            if (!fromNode) {\n                require(getBool(keccak256(abi.encodePacked(\"node.stake.for.allowed\", _nodeAddress, msg.sender))), \"Not allowed to stake for\");\n            }\n        }\n        _stakeRPL(_nodeAddress, _amount);\n    }\n\n    /// @notice Sets the allow state for this node to perform functions that require locking RPL\n    /// @param _nodeAddress The address of the node operator to change the state for\n    /// @param _allowed Whether locking is allowed or not\n    function setRPLLockingAllowed(address _nodeAddress, bool _allowed) override external onlyLatestContract(\"rocketNodeStaking\", address(this)) onlyRPLWithdrawalAddressOrNode(_nodeAddress) {\n        // Set the value\n        setBool(keccak256(abi.encodePacked(\"rpl.locking.allowed\", _nodeAddress)), _allowed);\n        // Log it\n        emit RPLLockingAllowed(_nodeAddress, _allowed, block.timestamp);\n    }\n\n    /// @notice Explicitly allow or remove allowance of an address to be able to stake on behalf of a node\n    /// @dev The node operator is determined by the address calling this method, it is here for backwards compatibility\n    /// @param _caller The address you wish to allow\n    /// @param _allowed Whether the address is allowed or denied\n    function setStakeRPLForAllowed(address _caller, bool _allowed) override external {\n        setStakeRPLForAllowed(msg.sender, _caller, _allowed);\n    }\n\n    /// @notice Explicitly allow or remove allowance of an address to be able to stake on behalf of a node\n    /// @param _nodeAddress The address of the node operator allowing the caller\n    /// @param _caller The address you wish to allow\n    /// @param _allowed Whether the address is allowed or denied\n    function setStakeRPLForAllowed(address _nodeAddress, address _caller, bool _allowed) override public onlyLatestContract(\"rocketNodeStaking\", address(this)) onlyRPLWithdrawalAddressOrNode(_nodeAddress) {\n        // Set the value\n        setBool(keccak256(abi.encodePacked(\"node.stake.for.allowed\", _nodeAddress, _caller)), _allowed);\n        // Log it\n        emit StakeRPLForAllowed(_nodeAddress, _caller, _allowed, block.timestamp);\n    }\n\n    /// @dev Internal logic for staking RPL\n    /// @param _nodeAddress The address to increase the RPL stake of\n    /// @param _amount The amount of RPL to stake\n    function _stakeRPL(address _nodeAddress, uint256 _amount) internal {\n        // Ensure voting has been initialised for this node\n        RocketNetworkVotingInterface rocketNetworkVoting = RocketNetworkVotingInterface(getContractAddress(\"rocketNetworkVoting\"));\n        rocketNetworkVoting.initialiseVotingFor(_nodeAddress);\n        // Load contracts\n        address rplTokenAddress = getContractAddress(\"rocketTokenRPL\");\n        address rocketVaultAddress = getContractAddress(\"rocketVault\");\n        IERC20 rplToken = IERC20(rplTokenAddress);\n        RocketVaultInterface rocketVault = RocketVaultInterface(rocketVaultAddress);\n        // Transfer RPL tokens\n        require(rplToken.transferFrom(msg.sender, address(this), _amount), \"Could not transfer RPL to staking contract\");\n        // Deposit RPL tokens to vault\n        require(rplToken.approve(rocketVaultAddress, _amount), \"Could not approve vault RPL deposit\");\n        rocketVault.depositToken(\"rocketNodeStaking\", rplToken, _amount);\n        // Update RPL stake amounts & node RPL staked block\n        increaseTotalRPLStake(_amount);\n        increaseNodeRPLStake(_nodeAddress, _amount);\n        setNodeRPLStakedTime(_nodeAddress, block.timestamp);\n        // Emit RPL staked event\n        emit RPLStaked(_nodeAddress, _amount, block.timestamp);\n    }\n\n    /// @notice Returns the amount of RPL that is locked for a given node\n    /// @param _nodeAddress The address of the node operator to query for\n    function getNodeRPLLocked(address _nodeAddress) override public view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(\"rpl.locked.node.amount\", _nodeAddress)));\n    }\n\n    /// @notice Locks an amount of RPL from being withdrawn even if the node operator is over capitalised\n    /// @param _nodeAddress The address of the node operator\n    /// @param _amount The amount of RPL to lock\n    function lockRPL(address _nodeAddress, uint256 _amount) override external onlyLatestContract(\"rocketNodeStaking\", address(this)) onlyLatestNetworkContract() {\n        // Check status\n        require(getBool(keccak256(abi.encodePacked(\"rpl.locking.allowed\", _nodeAddress))), \"Node is not allowed to lock RPL\");\n        // The node must have unlocked stake equaling or greater than the amount\n        uint256 rplStake = getNodeRPLStake(_nodeAddress);\n        bytes32 lockedStakeKey = keccak256(abi.encodePacked(\"rpl.locked.node.amount\", _nodeAddress));\n        uint256 lockedStake = getUint(lockedStakeKey);\n        require(rplStake - lockedStake >= _amount, \"Not enough staked RPL\");\n        // Increase locked RPL\n        setUint(lockedStakeKey, lockedStake + _amount);\n        // Emit event\n        emit RPLLocked(_nodeAddress, _amount, block.timestamp);\n    }\n\n    /// @notice Unlocks an amount of RPL making it possible to withdraw if the nod is over capitalised\n    /// @param _nodeAddress The address of the node operator\n    /// @param _amount The amount of RPL to unlock\n    function unlockRPL(address _nodeAddress, uint256 _amount) override external onlyLatestContract(\"rocketNodeStaking\", address(this)) onlyLatestNetworkContract() {\n        // The node must have locked stake equaling or greater than the amount\n        bytes32 lockedStakeKey = keccak256(abi.encodePacked(\"rpl.locked.node.amount\", _nodeAddress));\n        uint256 lockedStake = getUint(lockedStakeKey);\n        require(_amount <= lockedStake, \"Not enough locked RPL\");\n        // Decrease locked RPL\n        setUint(lockedStakeKey, lockedStake - _amount);\n        // Emit event\n        emit RPLUnlocked(_nodeAddress, _amount, block.timestamp);\n    }\n\n    /// @notice Transfers RPL from one node to another\n    /// @param _from The node to transfer from\n    /// @param _to The node to transfer to\n    /// @param _amount The amount of RPL to transfer\n    function transferRPL(address _from, address _to, uint256 _amount) override external onlyLatestContract(\"rocketNodeStaking\", address(this)) onlyLatestNetworkContract() onlyRegisteredNode(_from) {\n        // Check sender has enough RPL\n        require(getNodeRPLStake(_from) >= _amount, \"Sender has insufficient RPL\");\n        // Transfer the stake\n        decreaseNodeRPLStake(_from, _amount);\n        increaseNodeRPLStake(_to, _amount);\n        // Emit event\n        emit RPLTransferred(_from, _to, _amount, block.timestamp);\n    }\n\n    /// @notice Burns an amount of RPL staked by a given node operator\n    /// @param _from The node to burn from\n    /// @param _amount The amount of RPL to burn\n    function burnRPL(address _from, uint256 _amount) override external onlyLatestContract(\"rocketNodeStaking\", address(this)) onlyLatestNetworkContract() onlyRegisteredNode(_from) {\n        // Check sender has enough RPL\n        require(getNodeRPLStake(_from) >= _amount, \"Node has insufficient RPL\");\n        // Decrease the stake amount\n        decreaseTotalRPLStake(_amount);\n        decreaseNodeRPLStake(_from, _amount);\n        // Withdraw the RPL to this contract\n        IERC20Burnable rplToken = IERC20Burnable(getContractAddress(\"rocketTokenRPL\"));\n        RocketVaultInterface rocketVault = RocketVaultInterface(getContractAddress(\"rocketVault\"));\n        rocketVault.withdrawToken(address(this), rplToken, _amount);\n        // Execute the token burn\n        rplToken.burn(_amount);\n        // Emit event\n        emit RPLBurned(_from, _amount, block.timestamp);\n    }\n\n    /// @notice Withdraw staked RPL back to the node account or withdraw RPL address\n    ///         Can only be called by a node if they have not set their RPL withdrawal address\n    /// @param _amount The amount of RPL to withdraw\n    function withdrawRPL(uint256 _amount) override external {\n        withdrawRPL(msg.sender, _amount);\n    }\n\n    /// @notice Withdraw staked RPL back to the node account or withdraw RPL address\n    ///         If RPL withdrawal address has been set, must be called from it. Otherwise, must be called from\n    ///         node's primary withdrawal address or their node address.\n    /// @param _nodeAddress The address of the node withdrawing\n    /// @param _amount The amount of RPL to withdraw\n    function withdrawRPL(address _nodeAddress, uint256 _amount) override public onlyLatestContract(\"rocketNodeStaking\", address(this)) {\n        // Check valid node\n        require(getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress))), \"Invalid node\");\n        // Check address is permitted to withdraw\n        RocketNodeManagerInterface rocketNodeManager = RocketNodeManagerInterface(getContractAddress(\"rocketNodeManager\"));\n        address rplWithdrawalAddress = rocketNodeManager.getNodeRPLWithdrawalAddress(_nodeAddress);\n        if (rocketNodeManager.getNodeRPLWithdrawalAddressIsSet(_nodeAddress)) {\n            // If RPL withdrawal address is set, must be called from it\n            require(msg.sender == rplWithdrawalAddress, \"Invalid caller\");\n        } else {\n            // Otherwise, must be called from node address or withdrawal address\n            address withdrawalAddress = rocketStorage.getNodeWithdrawalAddress(_nodeAddress);\n            require(msg.sender == _nodeAddress || msg.sender == withdrawalAddress, \"Invalid caller\");\n        }\n        // Load contracts\n        RocketDAOProtocolSettingsRewardsInterface rocketDAOProtocolSettingsRewards = RocketDAOProtocolSettingsRewardsInterface(getContractAddress(\"rocketDAOProtocolSettingsRewards\"));\n        RocketVaultInterface rocketVault = RocketVaultInterface(getContractAddress(\"rocketVault\"));\n        // Check cooldown period (one claim period) has passed since RPL last staked\n        require(block.timestamp - getNodeRPLStakedTime(_nodeAddress) >= rocketDAOProtocolSettingsRewards.getRewardsClaimIntervalTime(), \"The withdrawal cooldown period has not passed\");\n        // Get & check node's current RPL stake\n        uint256 rplStake = getNodeRPLStake(_nodeAddress);\n        uint256 lockedStake = getNodeRPLLocked(_nodeAddress);\n        require(rplStake - lockedStake >= _amount, \"Withdrawal amount exceeds node's staked RPL balance\");\n        // Check withdrawal would not under collateralise node\n        require(rplStake - _amount >= getNodeMaximumRPLStake(_nodeAddress) + lockedStake, \"Node's staked RPL balance after withdrawal is less than required balance\");\n        // Update RPL stake amounts\n        decreaseTotalRPLStake(_amount);\n        decreaseNodeRPLStake(_nodeAddress, _amount);\n        // Transfer RPL tokens to node's RPL withdrawal address (if unset, defaults to primary withdrawal address)\n        rocketVault.withdrawToken(rplWithdrawalAddress, IERC20(getContractAddress(\"rocketTokenRPL\")), _amount);\n        // Emit RPL withdrawn event\n        emit RPLWithdrawn(_nodeAddress, _amount, block.timestamp);\n    }\n\n    /// @notice Slash a node's RPL by an ETH amount\n    ///         Only accepts calls from registered minipools\n    /// @param _nodeAddress The address to slash RPL from\n    /// @param _ethSlashAmount The amount of RPL to slash denominated in ETH value\n    function slashRPL(address _nodeAddress, uint256 _ethSlashAmount) override external onlyLatestContract(\"rocketNodeStaking\", address(this)) onlyRegisteredMinipool(msg.sender) {\n        // Load contracts\n        RocketNetworkPricesInterface rocketNetworkPrices = RocketNetworkPricesInterface(getContractAddress(\"rocketNetworkPrices\"));\n        RocketVaultInterface rocketVault = RocketVaultInterface(getContractAddress(\"rocketVault\"));\n        // Calculate RPL amount to slash\n        uint256 rplSlashAmount = calcBase * _ethSlashAmount / rocketNetworkPrices.getRPLPrice();\n        // Cap slashed amount to node's RPL stake\n        uint256 rplStake = getNodeRPLStake(_nodeAddress);\n        if (rplSlashAmount > rplStake) { rplSlashAmount = rplStake; }\n        // Transfer slashed amount to auction contract\n        if(rplSlashAmount > 0) rocketVault.transferToken(\"rocketAuctionManager\", IERC20(getContractAddress(\"rocketTokenRPL\")), rplSlashAmount);\n        // Update RPL stake amounts\n        decreaseTotalRPLStake(rplSlashAmount);\n        decreaseNodeRPLStake(_nodeAddress, rplSlashAmount);\n        // Mark minipool as slashed\n        setBool(keccak256(abi.encodePacked(\"minipool.rpl.slashed\", msg.sender)), true);\n        // Emit RPL slashed event\n        emit RPLSlashed(_nodeAddress, rplSlashAmount, _ethSlashAmount, block.timestamp);\n    }\n\n}\n"
    },
    "contracts/contract/minipool/RocketMinipoolManager.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.18;\npragma abicoder v2;\n\nimport \"../RocketBase.sol\";\nimport \"../../types/MinipoolStatus.sol\";\nimport \"../../types/MinipoolDeposit.sol\";\nimport \"../../types/MinipoolDetails.sol\";\nimport \"../../interface/dao/node/RocketDAONodeTrustedInterface.sol\";\nimport \"../../interface/minipool/RocketMinipoolInterface.sol\";\nimport \"../../interface/minipool/RocketMinipoolManagerInterface.sol\";\nimport \"../../interface/node/RocketNodeStakingInterface.sol\";\nimport \"../../interface/util/AddressSetStorageInterface.sol\";\nimport \"../../interface/node/RocketNodeManagerInterface.sol\";\nimport \"../../interface/network/RocketNetworkPricesInterface.sol\";\nimport \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsMinipoolInterface.sol\";\nimport \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsNodeInterface.sol\";\nimport \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsNodeInterface.sol\";\nimport \"../../interface/minipool/RocketMinipoolFactoryInterface.sol\";\nimport \"../../interface/node/RocketNodeDistributorFactoryInterface.sol\";\nimport \"../../interface/node/RocketNodeDistributorInterface.sol\";\nimport \"../../interface/network/RocketNetworkPenaltiesInterface.sol\";\nimport \"../../interface/minipool/RocketMinipoolPenaltyInterface.sol\";\nimport \"../../interface/node/RocketNodeDepositInterface.sol\";\nimport \"../network/RocketNetworkSnapshots.sol\";\nimport \"../node/RocketNodeStaking.sol\";\n\n/// @notice Minipool creation, removal and management\ncontract RocketMinipoolManager is RocketBase, RocketMinipoolManagerInterface {\n\n    // Events\n    event MinipoolCreated(address indexed minipool, address indexed node, uint256 time);\n    event MinipoolDestroyed(address indexed minipool, address indexed node, uint256 time);\n    event BeginBondReduction(address indexed minipool, uint256 time);\n    event CancelReductionVoted(address indexed minipool, address indexed member, uint256 time);\n    event ReductionCancelled(address indexed minipool, uint256 time);\n\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketBase(_rocketStorageAddress) {\n        version = 5;\n    }\n\n    /// @notice Get the number of minipools in the network\n    function getMinipoolCount() override public view returns (uint256) {\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        return addressSetStorage.getCount(keccak256(bytes(\"minipools.index\")));\n    }\n\n    /// @notice Get the number of minipools in the network in the Staking state\n    function getStakingMinipoolCount() override public view returns (uint256) {\n        return getUint(keccak256(bytes(\"minipools.staking.count\")));\n    }\n\n    /// @notice Get the number of finalised minipools in the network\n    function getFinalisedMinipoolCount() override external view returns (uint256) {\n        return getUint(keccak256(bytes(\"minipools.finalised.count\")));\n    }\n\n    /// @notice Get the number of active minipools in the network\n    function getActiveMinipoolCount() override public view returns (uint256) {\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        uint256 total = addressSetStorage.getCount(keccak256(bytes(\"minipools.index\")));\n        uint256 finalised = getUint(keccak256(bytes(\"minipools.finalised.count\")));\n        return total - finalised;\n    }\n\n    /// @notice Returns true if a minipool has had an RPL slashing\n    function getMinipoolRPLSlashed(address _minipoolAddress) override external view returns (bool) {\n        return getBool(keccak256(abi.encodePacked(\"minipool.rpl.slashed\", _minipoolAddress)));\n    }\n\n    /// @notice Get the number of minipools in each status.\n    ///         Returns the counts for Initialised, Prelaunch, Staking, Withdrawable, and Dissolved in that order.\n    /// @param _offset The offset into the minipool set to start\n    /// @param _limit The maximum number of minipools to iterate\n    function getMinipoolCountPerStatus(uint256 _offset, uint256 _limit) override external view\n    returns (uint256 initialisedCount, uint256 prelaunchCount, uint256 stakingCount, uint256 withdrawableCount, uint256 dissolvedCount) {\n        // Get contracts\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        // Precompute minipool key\n        bytes32 minipoolKey = keccak256(abi.encodePacked(\"minipools.index\"));\n        // Iterate over the requested minipool range\n        uint256 totalMinipools = getMinipoolCount();\n        uint256 max = _offset + _limit;\n        if (max > totalMinipools || _limit == 0) { max = totalMinipools; }\n        for (uint256 i = _offset; i < max; ++i) {\n            // Get the minipool at index i\n            RocketMinipoolInterface minipool = RocketMinipoolInterface(addressSetStorage.getItem(minipoolKey, i));\n            // Get the minipool's status, and update the appropriate counter\n            MinipoolStatus status = minipool.getStatus();\n            if (status == MinipoolStatus.Initialised) {\n                initialisedCount++;\n            }\n            else if (status == MinipoolStatus.Prelaunch) {\n                prelaunchCount++;\n            }\n            else if (status == MinipoolStatus.Staking) {\n                stakingCount++;\n            }\n            else if (status == MinipoolStatus.Withdrawable) {\n                withdrawableCount++;\n            }\n            else if (status == MinipoolStatus.Dissolved) {\n                dissolvedCount++;\n            }\n        }\n    }\n\n    /// @notice Returns an array of all minipools in the prelaunch state\n    /// @param _offset The offset into the minipool set to start iterating\n    /// @param _limit The maximum number of minipools to iterate over\n    function getPrelaunchMinipools(uint256 _offset, uint256 _limit) override external view\n    returns (address[] memory) {\n        // Get contracts\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        // Precompute minipool key\n        bytes32 minipoolKey = keccak256(abi.encodePacked(\"minipools.index\"));\n        // Iterate over the requested minipool range\n        uint256 totalMinipools = getMinipoolCount();\n        uint256 max = _offset + _limit;\n        if (max > totalMinipools || _limit == 0) { max = totalMinipools; }\n        // Create array big enough for every minipool\n        address[] memory minipools = new address[](max - _offset);\n        uint256 total = 0;\n        for (uint256 i = _offset; i < max; ++i) {\n            // Get the minipool at index i\n            RocketMinipoolInterface minipool = RocketMinipoolInterface(addressSetStorage.getItem(minipoolKey, i));\n            // Get the minipool's status, and to array if it's in prelaunch\n            MinipoolStatus status = minipool.getStatus();\n            if (status == MinipoolStatus.Prelaunch) {\n                minipools[total] = address(minipool);\n                total++;\n            }\n        }\n        // Dirty hack to cut unused elements off end of return value\n        assembly {\n            mstore(minipools, total)\n        }\n        return minipools;\n    }\n\n    /// @notice Get a network minipool address by index\n    /// @param _index Index into the minipool set to return\n    function getMinipoolAt(uint256 _index) override external view returns (address) {\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        return addressSetStorage.getItem(keccak256(abi.encodePacked(\"minipools.index\")), _index);\n    }\n\n    /// @notice Get the number of minipools owned by a node\n    /// @param _nodeAddress The node operator to query the count of minipools of\n    function getNodeMinipoolCount(address _nodeAddress) override external view returns (uint256) {\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        return addressSetStorage.getCount(keccak256(abi.encodePacked(\"node.minipools.index\", _nodeAddress)));\n    }\n\n    /// @notice Get the number of minipools owned by a node that are not finalised\n    /// @param _nodeAddress The node operator to query the count of active minipools of\n    function getNodeActiveMinipoolCount(address _nodeAddress) override public view returns (uint256) {\n        bytes32 key = keccak256(abi.encodePacked(\"minipools.active.count\", _nodeAddress));\n        RocketNetworkSnapshotsInterface rocketNetworkSnapshots = RocketNetworkSnapshotsInterface(getContractAddress(\"rocketNetworkSnapshots\"));\n        (bool exists,, uint224 count) = rocketNetworkSnapshots.latest(key);\n        if (!exists){\n            // Fallback to old value\n            AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n            uint256 finalised = getUint(keccak256(abi.encodePacked(\"node.minipools.finalised.count\", _nodeAddress)));\n            uint256 total = addressSetStorage.getCount(keccak256(abi.encodePacked(\"node.minipools.index\", _nodeAddress)));\n            return total - finalised;\n        }\n        return uint256(count);\n    }\n\n    /// @notice Get the number of minipools owned by a node that are finalised\n    /// @param _nodeAddress The node operator to query the count of finalised minipools of\n    function getNodeFinalisedMinipoolCount(address _nodeAddress) override external view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(\"node.minipools.finalised.count\", _nodeAddress)));\n    }\n\n    /// @notice Get the number of minipools owned by a node that are in staking status\n    /// @param _nodeAddress The node operator to query the count of staking minipools of\n    function getNodeStakingMinipoolCount(address _nodeAddress) override public view returns (uint256) {\n        RocketNodeDepositInterface rocketNodeDeposit = RocketNodeDepositInterface(getContractAddress(\"rocketNodeDeposit\"));\n        // Get valid deposit amounts\n        uint256[] memory depositSizes = rocketNodeDeposit.getDepositAmounts();\n        uint256 total;\n        for (uint256 i = 0; i < depositSizes.length; ++i){\n            total = total + getNodeStakingMinipoolCountBySize(_nodeAddress, depositSizes[i]);\n        }\n        return total;\n    }\n\n    /// @notice Get the number of minipools owned by a node that are in staking status\n    /// @param _nodeAddress The node operator to query the count of minipools by desposit size of\n    /// @param _depositSize The deposit size to filter result by\n    function getNodeStakingMinipoolCountBySize(address _nodeAddress, uint256 _depositSize) override public view returns (uint256) {\n        bytes32 nodeKey;\n        if (_depositSize == 16 ether){\n            nodeKey = keccak256(abi.encodePacked(\"node.minipools.staking.count\", _nodeAddress));\n        } else {\n            nodeKey = keccak256(abi.encodePacked(\"node.minipools.staking.count\", _nodeAddress, _depositSize));\n        }\n        return getUint(nodeKey);\n    }\n\n    /// @notice Get a node minipool address by index\n    /// @param _nodeAddress The node operator to query the minipool of\n    /// @param _index Index into the node operator's set of minipools\n    function getNodeMinipoolAt(address _nodeAddress, uint256 _index) override external view returns (address) {\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        return addressSetStorage.getItem(keccak256(abi.encodePacked(\"node.minipools.index\", _nodeAddress)), _index);\n    }\n\n    /// @notice Get the number of validating minipools owned by a node\n    /// @param _nodeAddress The node operator to query the count of validating minipools of\n    function getNodeValidatingMinipoolCount(address _nodeAddress) override external view returns (uint256) {\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        return addressSetStorage.getCount(keccak256(abi.encodePacked(\"node.minipools.validating.index\", _nodeAddress)));\n    }\n\n    /// @notice Get a validating node minipool address by index\n    /// @param _nodeAddress The node operator to query the validating minipool of\n    /// @param _index Index into the node operator's set of validating minipools\n    function getNodeValidatingMinipoolAt(address _nodeAddress, uint256 _index) override external view returns (address) {\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        return addressSetStorage.getItem(keccak256(abi.encodePacked(\"node.minipools.validating.index\", _nodeAddress)), _index);\n    }\n\n    /// @notice Get a minipool address by validator pubkey\n    /// @param _pubkey The pubkey to query\n    function getMinipoolByPubkey(bytes memory _pubkey) override public view returns (address) {\n        return getAddress(keccak256(abi.encodePacked(\"validator.minipool\", _pubkey)));\n    }\n\n    /// @notice Returns true if a minipool exists\n    /// @param _minipoolAddress The address of the minipool to check the existence of\n    function getMinipoolExists(address _minipoolAddress) override public view returns (bool) {\n        return getBool(keccak256(abi.encodePacked(\"minipool.exists\", _minipoolAddress)));\n    }\n\n    /// @notice Returns true if a minipool previously existed at the given address\n    /// @param _minipoolAddress The address to check the previous existence of a minipool at\n    function getMinipoolDestroyed(address _minipoolAddress) override external view returns (bool) {\n        return getBool(keccak256(abi.encodePacked(\"minipool.destroyed\", _minipoolAddress)));\n    }\n\n    /// @notice Returns a minipool's validator pubkey\n    /// @param _minipoolAddress The minipool to query the pubkey of\n    function getMinipoolPubkey(address _minipoolAddress) override public view returns (bytes memory) {\n        return getBytes(keccak256(abi.encodePacked(\"minipool.pubkey\", _minipoolAddress)));\n    }\n\n    /// @notice Calculates what the withdrawal credentials of a minipool should be set to\n    /// @param _minipoolAddress The minipool to calculate the withdrawal credentials for\n    function getMinipoolWithdrawalCredentials(address _minipoolAddress) override public pure returns (bytes memory) {\n        return abi.encodePacked(bytes1(0x01), bytes11(0x0), address(_minipoolAddress));\n    }\n\n    /// @notice Decrements a node operator's number of staking minipools based on the minipools prior bond amount and\n    ///         increments it based on their new bond amount.\n    /// @param _previousBond The minipool's previous bond value\n    /// @param _newBond The minipool's new bond value\n    /// @param _previousFee The fee of the minipool prior to the bond change\n    /// @param _newFee The fee of the minipool after the bond change\n    function updateNodeStakingMinipoolCount(uint256 _previousBond, uint256 _newBond, uint256 _previousFee, uint256 _newFee) override external onlyLatestContract(\"rocketMinipoolManager\", address(this)) onlyRegisteredMinipool(msg.sender) {\n        bytes32 nodeKey;\n        bytes32 numeratorKey;\n        // Get contracts\n        RocketMinipoolInterface minipool = RocketMinipoolInterface(msg.sender);\n        address nodeAddress = minipool.getNodeAddress();\n        // Try to distribute current fees at previous average commission rate\n        _tryDistribute(nodeAddress);\n        // Decrement previous bond count\n        if (_previousBond == 16 ether){\n            nodeKey = keccak256(abi.encodePacked(\"node.minipools.staking.count\", nodeAddress));\n            numeratorKey = keccak256(abi.encodePacked(\"node.average.fee.numerator\", nodeAddress));\n        } else {\n            nodeKey = keccak256(abi.encodePacked(\"node.minipools.staking.count\", nodeAddress, _previousBond));\n            numeratorKey = keccak256(abi.encodePacked(\"node.average.fee.numerator\", nodeAddress, _previousBond));\n        }\n        subUint(nodeKey, 1);\n        subUint(numeratorKey, _previousFee);\n        // Increment new bond count\n        if (_newBond == 16 ether){\n            nodeKey = keccak256(abi.encodePacked(\"node.minipools.staking.count\", nodeAddress));\n            numeratorKey = keccak256(abi.encodePacked(\"node.average.fee.numerator\", nodeAddress));\n        } else {\n            nodeKey = keccak256(abi.encodePacked(\"node.minipools.staking.count\", nodeAddress, _newBond));\n            numeratorKey = keccak256(abi.encodePacked(\"node.average.fee.numerator\", nodeAddress, _newBond));\n        }\n        addUint(nodeKey, 1);\n        addUint(numeratorKey, _newFee);\n    }\n\n    /// @dev Increments a node operator's number of staking minipools and calculates updated average node fee.\n    ///      Must be called from the minipool itself as msg.sender is used to query the minipool's node fee\n    /// @param _nodeAddress The node address to increment the number of staking minipools of\n    function incrementNodeStakingMinipoolCount(address _nodeAddress) override external onlyLatestContract(\"rocketMinipoolManager\", address(this)) onlyRegisteredMinipool(msg.sender) {\n        // Get contracts\n        RocketMinipoolInterface minipool = RocketMinipoolInterface(msg.sender);\n        // Try to distribute current fees at previous average commission rate\n        _tryDistribute(_nodeAddress);\n        // Update the node specific count\n        uint256 depositSize = minipool.getNodeDepositBalance();\n        bytes32 nodeKey;\n        bytes32 numeratorKey;\n        if (depositSize == 16 ether){\n            nodeKey = keccak256(abi.encodePacked(\"node.minipools.staking.count\", _nodeAddress));\n            numeratorKey = keccak256(abi.encodePacked(\"node.average.fee.numerator\", _nodeAddress));\n        } else {\n            nodeKey = keccak256(abi.encodePacked(\"node.minipools.staking.count\", _nodeAddress, depositSize));\n            numeratorKey = keccak256(abi.encodePacked(\"node.average.fee.numerator\", _nodeAddress, depositSize));\n        }\n        uint256 nodeValue = getUint(nodeKey);\n        setUint(nodeKey, nodeValue + 1);\n        // Update the total count\n        bytes32 totalKey = keccak256(abi.encodePacked(\"minipools.staking.count\"));\n        uint256 totalValue = getUint(totalKey);\n        setUint(totalKey, totalValue + 1);\n        // Update node fee average\n        addUint(numeratorKey, minipool.getNodeFee());\n    }\n\n    /// @dev Decrements a node operator's number of minipools in staking status and calculates updated average node fee.\n    ///      Must be called from the minipool itself as msg.sender is used to query the minipool's node fee\n    /// @param _nodeAddress The node address to decrement the number of staking minipools of\n    function decrementNodeStakingMinipoolCount(address _nodeAddress) override external onlyLatestContract(\"rocketMinipoolManager\", address(this)) onlyRegisteredMinipool(msg.sender) {\n        // Get contracts\n        RocketMinipoolInterface minipool = RocketMinipoolInterface(msg.sender);\n        // Try to distribute current fees at previous average commission rate\n        _tryDistribute(_nodeAddress);\n        // Update the node specific count\n        uint256 depositSize = minipool.getNodeDepositBalance();\n        bytes32 nodeKey;\n        bytes32 numeratorKey;\n        if (depositSize == 16 ether){\n            nodeKey = keccak256(abi.encodePacked(\"node.minipools.staking.count\", _nodeAddress));\n            numeratorKey = keccak256(abi.encodePacked(\"node.average.fee.numerator\", _nodeAddress));\n        } else {\n            nodeKey = keccak256(abi.encodePacked(\"node.minipools.staking.count\", _nodeAddress, depositSize));\n            numeratorKey = keccak256(abi.encodePacked(\"node.average.fee.numerator\", _nodeAddress, depositSize));\n        }\n        uint256 nodeValue = getUint(nodeKey);\n        setUint(nodeKey, nodeValue - 1);\n        // Update the total count\n        bytes32 totalKey = keccak256(abi.encodePacked(\"minipools.staking.count\"));\n        uint256 totalValue = getUint(totalKey);\n        setUint(totalKey, totalValue - 1);\n        // Update node fee average\n        subUint(numeratorKey, minipool.getNodeFee());\n    }\n\n    /// @notice Calls distribute on the given node's distributor if it has a balance and has been initialised\n    /// @dev Reverts if node has not initialised their distributor\n    /// @param _nodeAddress The node operator to try distribute rewards for\n    function tryDistribute(address _nodeAddress) override external {\n        _tryDistribute(_nodeAddress);\n    }\n\n    /// @dev Calls distribute on the given node's distributor if it has a balance and has been initialised\n    /// @param _nodeAddress The node operator to try distribute rewards for\n    function _tryDistribute(address _nodeAddress) internal {\n        // Get contracts\n        RocketNodeDistributorFactoryInterface rocketNodeDistributorFactory = RocketNodeDistributorFactoryInterface(getContractAddress(\"rocketNodeDistributorFactory\"));\n        address distributorAddress = rocketNodeDistributorFactory.getProxyAddress(_nodeAddress);\n        // If there are funds to distribute than call distribute\n        if (distributorAddress.balance > 0) {\n            // Get contracts\n            RocketNodeManagerInterface rocketNodeManager = RocketNodeManagerInterface(getContractAddress(\"rocketNodeManager\"));\n            // Ensure distributor has been initialised\n            require(rocketNodeManager.getFeeDistributorInitialised(_nodeAddress), \"Distributor not initialised\");\n            RocketNodeDistributorInterface distributor = RocketNodeDistributorInterface(distributorAddress);\n            distributor.distribute();\n        }\n    }\n\n    /// @dev Increments a node operator's number of minipools that have been finalised\n    /// @param _nodeAddress The node operator to increment finalised minipool count for\n    function incrementNodeFinalisedMinipoolCount(address _nodeAddress) override external onlyLatestContract(\"rocketMinipoolManager\", address(this)) onlyRegisteredMinipool(msg.sender) {\n        // Get active minipool count (before increasing finalised count in case of fallback calculation)\n        uint256 activeMinipoolCount = getNodeActiveMinipoolCount(_nodeAddress);\n        // Can only finalise a minipool once\n        bytes32 finalisedKey = keccak256(abi.encodePacked(\"node.minipools.finalised\", msg.sender));\n        require(!getBool(finalisedKey), \"Minipool has already been finalised\");\n        setBool(finalisedKey, true);\n        // Get ETH matched (before adding to finalised count in case of fallback calculation)\n        RocketNodeStakingInterface rocketNodeStaking = RocketNodeStakingInterface(getContractAddress(\"rocketNodeStaking\"));\n        uint256 ethMatched = rocketNodeStaking.getNodeETHMatched(_nodeAddress);\n        // Update the node specific count\n        addUint(keccak256(abi.encodePacked(\"node.minipools.finalised.count\", _nodeAddress)), 1);\n        // Update the total count\n        addUint(keccak256(bytes(\"minipools.finalised.count\")), 1);\n        // Update ETH matched\n        RocketNetworkSnapshots rocketNetworkSnapshots = RocketNetworkSnapshots(getContractAddress(\"rocketNetworkSnapshots\"));\n        ethMatched -= RocketMinipoolInterface(msg.sender).getUserDepositBalance();\n        bytes32 key = keccak256(abi.encodePacked(\"eth.matched.node.amount\", _nodeAddress));\n        rocketNetworkSnapshots.push(key, uint224(ethMatched));\n        // Decrement active count\n        key = keccak256(abi.encodePacked(\"minipools.active.count\", _nodeAddress));\n        rocketNetworkSnapshots.push(key, uint224(activeMinipoolCount - 1));\n    }\n\n    /// @dev Create a minipool. Only accepts calls from the RocketNodeDeposit contract\n    /// @param _nodeAddress The owning node operator's address\n    /// @param _salt A salt used in determining the minipool's address\n    function createMinipool(address _nodeAddress, uint256 _salt) override public onlyLatestContract(\"rocketMinipoolManager\", address(this)) onlyLatestContract(\"rocketNodeDeposit\", msg.sender) returns (RocketMinipoolInterface) {\n        // Load contracts\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        // Check node minipool limit based on RPL stake\n        { // Local scope to prevent stack too deep error\n          RocketDAOProtocolSettingsMinipoolInterface rocketDAOProtocolSettingsMinipool = RocketDAOProtocolSettingsMinipoolInterface(getContractAddress(\"rocketDAOProtocolSettingsMinipool\"));\n          // Check global minipool limit\n          uint256 totalActiveMinipoolCount = getActiveMinipoolCount();\n          require(totalActiveMinipoolCount + 1 <= rocketDAOProtocolSettingsMinipool.getMaximumCount(), \"Global minipool limit reached\");\n        }\n        // Get current active minipool count for this node operator (before we insert into address set in case it uses fallback calc)\n        uint256 activeMinipoolCount = getNodeActiveMinipoolCount(_nodeAddress);\n        // Create minipool contract\n        address contractAddress = deployContract(_nodeAddress, _salt);\n        // Initialise minipool data\n        setBool(keccak256(abi.encodePacked(\"minipool.exists\", contractAddress)), true);\n        // Add minipool to indexes\n        addressSetStorage.addItem(keccak256(abi.encodePacked(\"minipools.index\")), contractAddress);\n        addressSetStorage.addItem(keccak256(abi.encodePacked(\"node.minipools.index\", _nodeAddress)), contractAddress);\n        // Increment active count\n        RocketNetworkSnapshots rocketNetworkSnapshots = RocketNetworkSnapshots(getContractAddress(\"rocketNetworkSnapshots\"));\n        bytes32 key = keccak256(abi.encodePacked(\"minipools.active.count\", _nodeAddress));\n        rocketNetworkSnapshots.push(key, uint224(activeMinipoolCount + 1));\n        // Emit minipool created event\n        emit MinipoolCreated(contractAddress, _nodeAddress, block.timestamp);\n        // Return created minipool address\n        return RocketMinipoolInterface(contractAddress);\n    }\n\n    /// @notice Creates a vacant minipool that can be promoted by changing the given validator's withdrawal credentials\n    /// @param _nodeAddress Address of the owning node operator\n    /// @param _salt A salt used in determining the minipool's address\n    /// @param _validatorPubkey A validator pubkey that the node operator intends to migrate the withdrawal credentials of\n    /// @param _bondAmount The bond amount selected by the node operator\n    /// @param _currentBalance The current balance of the validator on the beaconchain (will be checked by oDAO and scrubbed if not correct)\n    function createVacantMinipool(address _nodeAddress, uint256 _salt, bytes calldata _validatorPubkey, uint256 _bondAmount, uint256 _currentBalance) override external onlyLatestContract(\"rocketMinipoolManager\", address(this)) onlyLatestContract(\"rocketNodeDeposit\", msg.sender) returns (RocketMinipoolInterface) {\n        // Get contracts\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        // Create the minipool\n        RocketMinipoolInterface minipool = createMinipool(_nodeAddress, _salt);\n        // Prepare the minipool\n        minipool.prepareVacancy(_bondAmount, _currentBalance);\n        // Set the minipool's validator pubkey\n        _setMinipoolPubkey(address(minipool), _validatorPubkey);\n        // Add minipool to the vacant set\n        addressSetStorage.addItem(keccak256(abi.encodePacked(\"minipools.vacant.index\")), address(minipool));\n        // Return\n        return minipool;\n    }\n\n    /// @dev Called by minipool to remove from vacant set on promotion or dissolution\n    function removeVacantMinipool() override external onlyLatestContract(\"rocketMinipoolManager\", address(this)) onlyRegisteredMinipool(msg.sender) {\n        // Remove from vacant set\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        addressSetStorage.removeItem(keccak256(abi.encodePacked(\"minipools.vacant.index\")), msg.sender);\n        // If minipool was dissolved, remove mapping of pubkey to minipool to allow NO to try again in future\n        RocketMinipoolInterface minipool = RocketMinipoolInterface(msg.sender);\n        if (minipool.getStatus() == MinipoolStatus.Dissolved) {\n            bytes memory pubkey = getMinipoolPubkey(msg.sender);\n            deleteAddress(keccak256(abi.encodePacked(\"validator.minipool\", pubkey)));\n        }\n    }\n\n    /// @notice Returns the number of minipools in the vacant minipool set\n    function getVacantMinipoolCount() override external view returns (uint256) {\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        return addressSetStorage.getCount(keccak256(abi.encodePacked(\"minipools.vacant.index\")));\n    }\n\n    /// @notice Returns the vacant minipool at a given index\n    /// @param _index The index into the vacant minipool set to retrieve\n    function getVacantMinipoolAt(uint256 _index) override external view returns (address) {\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        return addressSetStorage.getItem(keccak256(abi.encodePacked(\"minipools.vacant.index\")), _index);\n    }\n\n    /// @dev Destroy a minipool cleaning up all relevant state. Only accepts calls from registered minipools\n    function destroyMinipool() override external onlyLatestContract(\"rocketMinipoolManager\", address(this)) onlyRegisteredMinipool(msg.sender) {\n        // Load contracts\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        // Initialize minipool & get properties\n        RocketMinipoolInterface minipool = RocketMinipoolInterface(msg.sender);\n        address nodeAddress = minipool.getNodeAddress();\n        // Update ETH matched\n        RocketNodeStakingInterface rocketNodeStaking = RocketNodeStakingInterface(getContractAddress(\"rocketNodeStaking\"));\n        uint256 ethMatched = rocketNodeStaking.getNodeETHMatched(nodeAddress);\n        ethMatched = ethMatched - minipool.getUserDepositBalance();\n        // Record in snapshot manager\n        RocketNetworkSnapshots rocketNetworkSnapshots = RocketNetworkSnapshots(getContractAddress(\"rocketNetworkSnapshots\"));\n        bytes32 key = keccak256(abi.encodePacked(\"eth.matched.node.amount\", nodeAddress));\n        rocketNetworkSnapshots.push(key, uint224(ethMatched));\n        // Update minipool data\n        setBool(keccak256(abi.encodePacked(\"minipool.exists\", msg.sender)), false);\n        // Record minipool as destroyed to prevent recreation at same address\n        setBool(keccak256(abi.encodePacked(\"minipool.destroyed\", msg.sender)), true);\n        // Get number of active minipools (before removing from address set in case of fallback calculation)\n        uint256 activeMinipoolCount = getNodeActiveMinipoolCount(nodeAddress);\n        // Remove minipool from indexes\n        addressSetStorage.removeItem(keccak256(abi.encodePacked(\"minipools.index\")), msg.sender);\n        addressSetStorage.removeItem(keccak256(abi.encodePacked(\"node.minipools.index\", nodeAddress)), msg.sender);\n        // Clean up pubkey state\n        bytes memory pubkey = getMinipoolPubkey(msg.sender);\n        deleteBytes(keccak256(abi.encodePacked(\"minipool.pubkey\", msg.sender)));\n        deleteAddress(keccak256(abi.encodePacked(\"validator.minipool\", pubkey)));\n        // Decrement active count\n        key = keccak256(abi.encodePacked(\"minipools.active.count\", nodeAddress));\n        rocketNetworkSnapshots.push(key, uint224(activeMinipoolCount - 1));\n        // Emit minipool destroyed event\n        emit MinipoolDestroyed(msg.sender, nodeAddress, block.timestamp);\n    }\n\n    /// @dev Set a minipool's validator pubkey. Only accepts calls from registered minipools\n    /// @param _pubkey The pubkey to set for the calling minipool\n    function setMinipoolPubkey(bytes calldata _pubkey) override public onlyLatestContract(\"rocketMinipoolManager\", address(this)) onlyRegisteredMinipool(msg.sender) {\n        _setMinipoolPubkey(msg.sender, _pubkey);\n    }\n\n    /// @dev Internal logic to set a minipool's pubkey, reverts if pubkey already set\n    /// @param _pubkey The pubkey to set for the calling minipool\n    function _setMinipoolPubkey(address _minipool, bytes calldata _pubkey) private {\n        // Check validator pubkey is not in use\n        require(getMinipoolByPubkey(_pubkey) == address(0x0), \"Validator pubkey is in use\");\n        // Load contracts\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        // Initialise minipool & get properties\n        RocketMinipoolInterface minipool = RocketMinipoolInterface(_minipool);\n        address nodeAddress = minipool.getNodeAddress();\n        // Set minipool validator pubkey & validator minipool address\n        setBytes(keccak256(abi.encodePacked(\"minipool.pubkey\", _minipool)), _pubkey);\n        setAddress(keccak256(abi.encodePacked(\"validator.minipool\", _pubkey)), _minipool);\n        // Add minipool to node validating minipools index\n        addressSetStorage.addItem(keccak256(abi.encodePacked(\"node.minipools.validating.index\", nodeAddress)), _minipool);\n    }\n\n    /// @dev Wrapper around minipool getDepositType which handles backwards compatibility with v1 and v2 delegates\n    /// @param _minipoolAddress Minipool address to get the deposit type of\n    function getMinipoolDepositType(address _minipoolAddress) external override view returns (MinipoolDeposit) {\n        RocketMinipoolInterface minipoolInterface = RocketMinipoolInterface(_minipoolAddress);\n        uint8 version = 1;\n\n        // Version 1 minipools did not have a version() function\n        try minipoolInterface.version() returns (uint8 tryVersion) {\n            version = tryVersion;\n        } catch (bytes memory /*lowLevelData*/) {}\n\n        if (version == 1 || version == 2) {\n            try minipoolInterface.getDepositType{gas: 30000}() returns (MinipoolDeposit depositType) {\n                return depositType;\n            } catch (bytes memory /*lowLevelData*/) {\n                return MinipoolDeposit.Variable;\n            }\n        }\n\n        return minipoolInterface.getDepositType();\n    }\n\n    /// @dev Performs a CREATE2 deployment of a minipool contract with given salt\n    /// @param _nodeAddress The owning node operator's address\n    /// @param _salt A salt used in determining the minipool's address\n    function deployContract(address _nodeAddress, uint256 _salt) private returns (address) {\n        RocketMinipoolFactoryInterface rocketMinipoolFactory = RocketMinipoolFactoryInterface(getContractAddress(\"rocketMinipoolFactory\"));\n        return rocketMinipoolFactory.deployContract(_nodeAddress, _salt);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 15000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}