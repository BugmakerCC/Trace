{{
  "language": "Solidity",
  "sources": {
    "contracts/interface/RocketStorageInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketStorageInterface {\n\n    // Deploy status\n    function getDeployedStatus() external view returns (bool);\n\n    // Guardian\n    function getGuardian() external view returns(address);\n    function setGuardian(address _newAddress) external;\n    function confirmGuardian() external;\n\n    // Getters\n    function getAddress(bytes32 _key) external view returns (address);\n    function getUint(bytes32 _key) external view returns (uint);\n    function getString(bytes32 _key) external view returns (string memory);\n    function getBytes(bytes32 _key) external view returns (bytes memory);\n    function getBool(bytes32 _key) external view returns (bool);\n    function getInt(bytes32 _key) external view returns (int);\n    function getBytes32(bytes32 _key) external view returns (bytes32);\n\n    // Setters\n    function setAddress(bytes32 _key, address _value) external;\n    function setUint(bytes32 _key, uint _value) external;\n    function setString(bytes32 _key, string calldata _value) external;\n    function setBytes(bytes32 _key, bytes calldata _value) external;\n    function setBool(bytes32 _key, bool _value) external;\n    function setInt(bytes32 _key, int _value) external;\n    function setBytes32(bytes32 _key, bytes32 _value) external;\n\n    // Deleters\n    function deleteAddress(bytes32 _key) external;\n    function deleteUint(bytes32 _key) external;\n    function deleteString(bytes32 _key) external;\n    function deleteBytes(bytes32 _key) external;\n    function deleteBool(bytes32 _key) external;\n    function deleteInt(bytes32 _key) external;\n    function deleteBytes32(bytes32 _key) external;\n\n    // Arithmetic\n    function addUint(bytes32 _key, uint256 _amount) external;\n    function subUint(bytes32 _key, uint256 _amount) external;\n\n    // Protected storage\n    function getNodeWithdrawalAddress(address _nodeAddress) external view returns (address);\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external view returns (address);\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external;\n    function confirmWithdrawalAddress(address _nodeAddress) external;\n}\n"
    },
    "contracts/contract/RocketBase.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"../interface/RocketStorageInterface.sol\";\n\n/// @title Base settings / modifiers for each contract in Rocket Pool\n/// @author David Rugendyke\n\nabstract contract RocketBase {\n\n    // Calculate using this as the base\n    uint256 constant calcBase = 1 ether;\n\n    // Version of the contract\n    uint8 public version;\n\n    // The main storage contract where primary persistant storage is maintained\n    RocketStorageInterface rocketStorage = RocketStorageInterface(address(0));\n\n\n    /*** Modifiers **********************************************************/\n\n    /**\n    * @dev Throws if called by any sender that doesn't match a Rocket Pool network contract\n    */\n    modifier onlyLatestNetworkContract() {\n        require(getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        _;\n    }\n\n    /**\n    * @dev Throws if called by any sender that doesn't match one of the supplied contract or is the latest version of that contract\n    */\n    modifier onlyLatestContract(string memory _contractName, address _contractAddress) {\n        require(_contractAddress == getAddress(keccak256(abi.encodePacked(\"contract.address\", _contractName))), \"Invalid or outdated contract\");\n        _;\n    }\n\n    /**\n    * @dev Throws if called by any sender that isn't a registered node\n    */\n    modifier onlyRegisteredNode(address _nodeAddress) {\n        require(getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress))), \"Invalid node\");\n        _;\n    }\n\n    /**\n    * @dev Throws if called by any sender that isn't a trusted node DAO member\n    */\n    modifier onlyTrustedNode(address _nodeAddress) {\n        require(getBool(keccak256(abi.encodePacked(\"dao.trustednodes.\", \"member\", _nodeAddress))), \"Invalid trusted node\");\n        _;\n    }\n\n    /**\n    * @dev Throws if called by any sender that isn't a registered minipool\n    */\n    modifier onlyRegisteredMinipool(address _minipoolAddress) {\n        require(getBool(keccak256(abi.encodePacked(\"minipool.exists\", _minipoolAddress))), \"Invalid minipool\");\n        _;\n    }\n    \n\n    /**\n    * @dev Throws if called by any account other than a guardian account (temporary account allowed access to settings before DAO is fully enabled)\n    */\n    modifier onlyGuardian() {\n        require(msg.sender == rocketStorage.getGuardian(), \"Account is not a temporary guardian\");\n        _;\n    }\n\n\n\n\n    /*** Methods **********************************************************/\n\n    /// @dev Set the main Rocket Storage address\n    constructor(RocketStorageInterface _rocketStorageAddress) {\n        // Update the contract address\n        rocketStorage = RocketStorageInterface(_rocketStorageAddress);\n    }\n\n\n    /// @dev Get the address of a network contract by name\n    function getContractAddress(string memory _contractName) internal view returns (address) {\n        // Get the current contract address\n        address contractAddress = getAddress(keccak256(abi.encodePacked(\"contract.address\", _contractName)));\n        // Check it\n        require(contractAddress != address(0x0), \"Contract not found\");\n        // Return\n        return contractAddress;\n    }\n\n\n    /// @dev Get the address of a network contract by name (returns address(0x0) instead of reverting if contract does not exist)\n    function getContractAddressUnsafe(string memory _contractName) internal view returns (address) {\n        // Get the current contract address\n        address contractAddress = getAddress(keccak256(abi.encodePacked(\"contract.address\", _contractName)));\n        // Return\n        return contractAddress;\n    }\n\n\n    /// @dev Get the name of a network contract by address\n    function getContractName(address _contractAddress) internal view returns (string memory) {\n        // Get the contract name\n        string memory contractName = getString(keccak256(abi.encodePacked(\"contract.name\", _contractAddress)));\n        // Check it\n        require(bytes(contractName).length > 0, \"Contract not found\");\n        // Return\n        return contractName;\n    }\n\n    /// @dev Get revert error message from a .call method\n    function getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return \"Transaction reverted silently\";\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n\n\n\n    /*** Rocket Storage Methods ****************************************/\n\n    // Note: Unused helpers have been removed to keep contract sizes down\n\n    /// @dev Storage get methods\n    function getAddress(bytes32 _key) internal view returns (address) { return rocketStorage.getAddress(_key); }\n    function getUint(bytes32 _key) internal view returns (uint) { return rocketStorage.getUint(_key); }\n    function getString(bytes32 _key) internal view returns (string memory) { return rocketStorage.getString(_key); }\n    function getBytes(bytes32 _key) internal view returns (bytes memory) { return rocketStorage.getBytes(_key); }\n    function getBool(bytes32 _key) internal view returns (bool) { return rocketStorage.getBool(_key); }\n    function getInt(bytes32 _key) internal view returns (int) { return rocketStorage.getInt(_key); }\n    function getBytes32(bytes32 _key) internal view returns (bytes32) { return rocketStorage.getBytes32(_key); }\n\n    /// @dev Storage set methods\n    function setAddress(bytes32 _key, address _value) internal { rocketStorage.setAddress(_key, _value); }\n    function setUint(bytes32 _key, uint _value) internal { rocketStorage.setUint(_key, _value); }\n    function setString(bytes32 _key, string memory _value) internal { rocketStorage.setString(_key, _value); }\n    function setBytes(bytes32 _key, bytes memory _value) internal { rocketStorage.setBytes(_key, _value); }\n    function setBool(bytes32 _key, bool _value) internal { rocketStorage.setBool(_key, _value); }\n    function setInt(bytes32 _key, int _value) internal { rocketStorage.setInt(_key, _value); }\n    function setBytes32(bytes32 _key, bytes32 _value) internal { rocketStorage.setBytes32(_key, _value); }\n\n    /// @dev Storage delete methods\n    function deleteAddress(bytes32 _key) internal { rocketStorage.deleteAddress(_key); }\n    function deleteUint(bytes32 _key) internal { rocketStorage.deleteUint(_key); }\n    function deleteString(bytes32 _key) internal { rocketStorage.deleteString(_key); }\n    function deleteBytes(bytes32 _key) internal { rocketStorage.deleteBytes(_key); }\n    function deleteBool(bytes32 _key) internal { rocketStorage.deleteBool(_key); }\n    function deleteInt(bytes32 _key) internal { rocketStorage.deleteInt(_key); }\n    function deleteBytes32(bytes32 _key) internal { rocketStorage.deleteBytes32(_key); }\n\n    /// @dev Storage arithmetic methods\n    function addUint(bytes32 _key, uint256 _amount) internal { rocketStorage.addUint(_key, _amount); }\n    function subUint(bytes32 _key, uint256 _amount) internal { rocketStorage.subUint(_key, _amount); }\n}\n"
    },
    "contracts/interface/deposit/RocketDepositPoolInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketDepositPoolInterface {\n    function getBalance() external view returns (uint256);\n    function getNodeBalance() external view returns (uint256);\n    function getUserBalance() external view returns (int256);\n    function getExcessBalance() external view returns (uint256);\n    function deposit() external payable;\n    function getMaximumDepositAmount() external view returns (uint256);\n    function nodeDeposit(uint256 _totalAmount) external payable;\n    function nodeCreditWithdrawal(uint256 _amount) external;\n    function recycleDissolvedDeposit() external payable;\n    function recycleExcessCollateral() external payable;\n    function recycleLiquidatedStake() external payable;\n    function assignDeposits() external;\n    function maybeAssignDeposits() external returns (bool);\n    function withdrawExcessBalance(uint256 _amount) external;\n}\n"
    },
    "contracts/types/MinipoolDeposit.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\n// Represents the type of deposits required by a minipool\n\nenum MinipoolDeposit {\n    None,       // Marks an invalid deposit type\n    Full,       // The minipool requires 32 ETH from the node operator, 16 ETH of which will be refinanced from user deposits\n    Half,       // The minipool required 16 ETH from the node operator to be matched with 16 ETH from user deposits\n    Empty,      // The minipool requires 0 ETH from the node operator to be matched with 32 ETH from user deposits (trusted nodes only)\n    Variable    // Indicates this minipool is of the new generation that supports a variable deposit amount\n}\n"
    },
    "contracts/types/MinipoolStatus.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\n// Represents a minipool's status within the network\n\nenum MinipoolStatus {\n    Initialised,    // The minipool has been initialised and is awaiting a deposit of user ETH\n    Prelaunch,      // The minipool has enough ETH to begin staking and is awaiting launch by the node operator\n    Staking,        // The minipool is currently staking\n    Withdrawable,   // NO LONGER USED\n    Dissolved       // The minipool has been dissolved and its user deposited ETH has been returned to the deposit pool\n}\n"
    },
    "contracts/interface/minipool/RocketMinipoolInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"../../types/MinipoolDeposit.sol\";\nimport \"../../types/MinipoolStatus.sol\";\nimport \"../RocketStorageInterface.sol\";\n\ninterface RocketMinipoolInterface {\n    function version() external view returns (uint8);\n    function initialise(address _nodeAddress) external;\n    function getStatus() external view returns (MinipoolStatus);\n    function getFinalised() external view returns (bool);\n    function getStatusBlock() external view returns (uint256);\n    function getStatusTime() external view returns (uint256);\n    function getScrubVoted(address _member) external view returns (bool);\n    function getDepositType() external view returns (MinipoolDeposit);\n    function getNodeAddress() external view returns (address);\n    function getNodeFee() external view returns (uint256);\n    function getNodeDepositBalance() external view returns (uint256);\n    function getNodeRefundBalance() external view returns (uint256);\n    function getNodeDepositAssigned() external view returns (bool);\n    function getPreLaunchValue() external view returns (uint256);\n    function getNodeTopUpValue() external view returns (uint256);\n    function getVacant() external view returns (bool);\n    function getPreMigrationBalance() external view returns (uint256);\n    function getUserDistributed() external view returns (bool);\n    function getUserDepositBalance() external view returns (uint256);\n    function getUserDepositAssigned() external view returns (bool);\n    function getUserDepositAssignedTime() external view returns (uint256);\n    function getTotalScrubVotes() external view returns (uint256);\n    function calculateNodeShare(uint256 _balance) external view returns (uint256);\n    function calculateUserShare(uint256 _balance) external view returns (uint256);\n    function preDeposit(uint256 _bondingValue, bytes calldata _validatorPubkey, bytes calldata _validatorSignature, bytes32 _depositDataRoot) external payable;\n    function deposit() external payable;\n    function userDeposit() external payable;\n    function distributeBalance(bool _rewardsOnly) external;\n    function beginUserDistribute() external;\n    function userDistributeAllowed() external view returns (bool);\n    function refund() external;\n    function slash() external;\n    function finalise() external;\n    function canStake() external view returns (bool);\n    function canPromote() external view returns (bool);\n    function stake(bytes calldata _validatorSignature, bytes32 _depositDataRoot) external;\n    function prepareVacancy(uint256 _bondAmount, uint256 _currentBalance) external;\n    function promote() external;\n    function dissolve() external;\n    function close() external;\n    function voteScrub() external;\n    function reduceBondAmount() external;\n}\n"
    },
    "contracts/types/MinipoolDetails.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"./MinipoolDeposit.sol\";\nimport \"./MinipoolStatus.sol\";\n\n// A struct containing all the information on-chain about a specific minipool\n\nstruct MinipoolDetails {\n    bool exists;\n    address minipoolAddress;\n    bytes pubkey;\n    MinipoolStatus status;\n    uint256 statusBlock;\n    uint256 statusTime;\n    bool finalised;\n    MinipoolDeposit depositType;\n    uint256 nodeFee;\n    uint256 nodeDepositBalance;\n    bool nodeDepositAssigned;\n    uint256 userDepositBalance;\n    bool userDepositAssigned;\n    uint256 userDepositAssignedTime;\n    bool useLatestDelegate;\n    address delegate;\n    address previousDelegate;\n    address effectiveDelegate;\n    uint256 penaltyCount;\n    uint256 penaltyRate;\n    address nodeAddress;\n}\n"
    },
    "contracts/interface/minipool/RocketMinipoolManagerInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"../../types/MinipoolDeposit.sol\";\nimport \"../../types/MinipoolDetails.sol\";\nimport \"./RocketMinipoolInterface.sol\";\n\ninterface RocketMinipoolManagerInterface {\n    function getMinipoolCount() external view returns (uint256);\n    function getStakingMinipoolCount() external view returns (uint256);\n    function getFinalisedMinipoolCount() external view returns (uint256);\n    function getActiveMinipoolCount() external view returns (uint256);\n    function getMinipoolRPLSlashed(address _minipoolAddress) external view returns (bool);\n    function getMinipoolCountPerStatus(uint256 offset, uint256 limit) external view returns (uint256, uint256, uint256, uint256, uint256);\n    function getPrelaunchMinipools(uint256 offset, uint256 limit) external view returns (address[] memory);\n    function getMinipoolAt(uint256 _index) external view returns (address);\n    function getNodeMinipoolCount(address _nodeAddress) external view returns (uint256);\n    function getNodeActiveMinipoolCount(address _nodeAddress) external view returns (uint256);\n    function getNodeFinalisedMinipoolCount(address _nodeAddress) external view returns (uint256);\n    function getNodeStakingMinipoolCount(address _nodeAddress) external view returns (uint256);\n    function getNodeStakingMinipoolCountBySize(address _nodeAddress, uint256 _depositSize) external view returns (uint256);\n    function getNodeMinipoolAt(address _nodeAddress, uint256 _index) external view returns (address);\n    function getNodeValidatingMinipoolCount(address _nodeAddress) external view returns (uint256);\n    function getNodeValidatingMinipoolAt(address _nodeAddress, uint256 _index) external view returns (address);\n    function getMinipoolByPubkey(bytes calldata _pubkey) external view returns (address);\n    function getMinipoolExists(address _minipoolAddress) external view returns (bool);\n    function getMinipoolDestroyed(address _minipoolAddress) external view returns (bool);\n    function getMinipoolPubkey(address _minipoolAddress) external view returns (bytes memory);\n    function updateNodeStakingMinipoolCount(uint256 _previousBond, uint256 _newBond, uint256 _previousFee, uint256 _newFee) external;\n    function getMinipoolWithdrawalCredentials(address _minipoolAddress) external pure returns (bytes memory);\n    function createMinipool(address _nodeAddress, uint256 _salt) external returns (RocketMinipoolInterface);\n    function createVacantMinipool(address _nodeAddress, uint256 _salt, bytes calldata _validatorPubkey, uint256 _bondAmount, uint256 _currentBalance) external returns (RocketMinipoolInterface);\n    function removeVacantMinipool() external;\n    function getVacantMinipoolCount() external view returns (uint256);\n    function getVacantMinipoolAt(uint256 _index) external view returns (address);\n    function destroyMinipool() external;\n    function incrementNodeStakingMinipoolCount(address _nodeAddress) external;\n    function decrementNodeStakingMinipoolCount(address _nodeAddress) external;\n    function tryDistribute(address _nodeAddress) external;\n    function incrementNodeFinalisedMinipoolCount(address _nodeAddress) external;\n    function setMinipoolPubkey(bytes calldata _pubkey) external;\n    function getMinipoolDepositType(address _minipoolAddress) external view returns (MinipoolDeposit);\n}\n"
    },
    "contracts/interface/minipool/RocketMinipoolQueueInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"../../types/MinipoolDeposit.sol\";\n\ninterface RocketMinipoolQueueInterface {\n    function getTotalLength() external view returns (uint256);\n    function getContainsLegacy() external view returns (bool);\n    function getLengthLegacy(MinipoolDeposit _depositType) external view returns (uint256);\n    function getLength() external view returns (uint256);\n    function getTotalCapacity() external view returns (uint256);\n    function getEffectiveCapacity() external view returns (uint256);\n    function getNextCapacityLegacy() external view returns (uint256);\n    function getNextDepositLegacy() external view returns (MinipoolDeposit, uint256);\n    function enqueueMinipool(address _minipool) external;\n    function dequeueMinipoolByDepositLegacy(MinipoolDeposit _depositType) external returns (address minipoolAddress);\n    function dequeueMinipools(uint256 _maxToDequeue) external returns (address[] memory minipoolAddress);\n    function removeMinipool(MinipoolDeposit _depositType) external;\n    function getMinipoolAt(uint256 _index) external view returns(address);\n    function getMinipoolPosition(address _minipool) external view returns (int256);\n}\n"
    },
    "contracts/interface/network/RocketNetworkFeesInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketNetworkFeesInterface {\n    function getNodeDemand() external view returns (int256);\n    function getNodeFee() external view returns (uint256);\n    function getNodeFeeByDemand(int256 _nodeDemand) external view returns (uint256);\n}\n"
    },
    "contracts/interface/node/RocketNodeDepositInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"../../types/MinipoolDeposit.sol\";\n\ninterface RocketNodeDepositInterface {\n    function getNodeDepositCredit(address _nodeAddress) external view returns (uint256);\n    function getNodeEthBalance(address _nodeAddress) external view returns (uint256);\n    function getNodeCreditAndBalance(address _nodeAddress) external view returns (uint256);\n    function getNodeUsableCreditAndBalance(address _nodeAddress) external view returns (uint256);\n    function getNodeUsableCredit(address _nodeAddress) external view returns (uint256);\n    function increaseDepositCreditBalance(address _nodeOperator, uint256 _amount) external;\n    function depositEthFor(address _nodeAddress) external payable;\n    function withdrawEth(address _nodeAddress, uint256 _amount) external;\n    function deposit(uint256 _depositAmount, uint256 _minimumNodeFee, bytes calldata _validatorPubkey, bytes calldata _validatorSignature, bytes32 _depositDataRoot, uint256 _salt, address _expectedMinipoolAddress) external payable;\n    function depositWithCredit(uint256 _depositAmount, uint256 _minimumNodeFee, bytes calldata _validatorPubkey, bytes calldata _validatorSignature, bytes32 _depositDataRoot, uint256 _salt, address _expectedMinipoolAddress) external payable;\n    function isValidDepositAmount(uint256 _amount) external pure returns (bool);\n    function getDepositAmounts() external pure returns (uint256[] memory);\n    function createVacantMinipool(uint256 _bondAmount, uint256 _minimumNodeFee, bytes calldata _validatorPubkey, uint256 _salt, address _expectedMinipoolAddress, uint256 _currentBalance) external;\n    function increaseEthMatched(address _nodeAddress, uint256 _amount) external;\n}\n"
    },
    "contracts/interface/dao/protocol/settings/RocketDAOProtocolSettingsDepositInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketDAOProtocolSettingsDepositInterface {\n    function getDepositEnabled() external view returns (bool);\n    function getAssignDepositsEnabled() external view returns (bool);\n    function getMinimumDeposit() external view returns (uint256);\n    function getMaximumDepositPoolSize() external view returns (uint256);\n    function getMaximumDepositAssignments() external view returns (uint256);\n    function getMaximumDepositSocialisedAssignments() external view returns (uint256);\n    function getDepositFee() external view returns (uint256);\n}\n"
    },
    "contracts/interface/dao/protocol/settings/RocketDAOProtocolSettingsMinipoolInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"../../../../types/MinipoolDeposit.sol\";\n\ninterface RocketDAOProtocolSettingsMinipoolInterface {\n    function getLaunchBalance() external view returns (uint256);\n    function getPreLaunchValue() external pure returns (uint256);\n    function getDepositUserAmount(MinipoolDeposit _depositType) external view returns (uint256);\n    function getFullDepositUserAmount() external view returns (uint256);\n    function getHalfDepositUserAmount() external view returns (uint256);\n    function getVariableDepositAmount() external view returns (uint256);\n    function getSubmitWithdrawableEnabled() external view returns (bool);\n    function getBondReductionEnabled() external view returns (bool);\n    function getLaunchTimeout() external view returns (uint256);\n    function getMaximumCount() external view returns (uint256);\n    function isWithinUserDistributeWindow(uint256 _time) external view returns (bool);\n    function hasUserDistributeWindowPassed(uint256 _time) external view returns (bool);\n    function getUserDistributeWindowStart() external view returns (uint256);\n    function getUserDistributeWindowLength() external view returns (uint256);\n}\n"
    },
    "contracts/interface/dao/protocol/settings/RocketDAOProtocolSettingsNodeInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketDAOProtocolSettingsNodeInterface {\n    function getRegistrationEnabled() external view returns (bool);\n    function getSmoothingPoolRegistrationEnabled() external view returns (bool);\n    function getDepositEnabled() external view returns (bool);\n    function getVacantMinipoolsEnabled() external view returns (bool);\n    function getMinimumPerMinipoolStake() external view returns (uint256);\n    function getMaximumPerMinipoolStake() external view returns (uint256);\n    function getMaximumStakeForVotingPower() external view returns (uint256);\n}\n"
    },
    "contracts/interface/dao/protocol/settings/RocketDAOProtocolSettingsNetworkInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketDAOProtocolSettingsNetworkInterface {\n    function getNodeConsensusThreshold() external view returns (uint256);\n    function getNodePenaltyThreshold() external view returns (uint256);\n    function getPerPenaltyRate() external view returns (uint256);\n    function getSubmitBalancesEnabled() external view returns (bool);\n    function getSubmitBalancesFrequency() external view returns (uint256);\n    function getSubmitPricesEnabled() external view returns (bool);\n    function getSubmitPricesFrequency() external view returns (uint256);\n    function getMinimumNodeFee() external view returns (uint256);\n    function getTargetNodeFee() external view returns (uint256);\n    function getMaximumNodeFee() external view returns (uint256);\n    function getNodeFeeDemandRange() external view returns (uint256);\n    function getTargetRethCollateralRate() external view returns (uint256);\n    function getRethDepositDelay() external view returns (uint256);\n    function getSubmitRewardsEnabled() external view returns (bool);\n}\n"
    },
    "contracts/interface/dao/node/RocketDAONodeTrustedInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketDAONodeTrustedInterface {\n    function getBootstrapModeDisabled() external view returns (bool);\n    function getMemberQuorumVotesRequired() external view returns (uint256);\n    function getMemberAt(uint256 _index) external view returns (address);\n    function getMemberCount() external view returns (uint256);\n    function getMemberMinRequired() external view returns (uint256);\n    function getMemberIsValid(address _nodeAddress) external view returns (bool);\n    function getMemberLastProposalTime(address _nodeAddress) external view returns (uint256);\n    function getMemberID(address _nodeAddress) external view returns (string memory);\n    function getMemberUrl(address _nodeAddress) external view returns (string memory);\n    function getMemberJoinedTime(address _nodeAddress) external view returns (uint256);\n    function getMemberProposalExecutedTime(string memory _proposalType, address _nodeAddress) external view returns (uint256);\n    function getMemberRPLBondAmount(address _nodeAddress) external view returns (uint256);\n    function getMemberIsChallenged(address _nodeAddress) external view returns (bool);\n    function getMemberUnbondedValidatorCount(address _nodeAddress) external view returns (uint256);\n    function incrementMemberUnbondedValidatorCount(address _nodeAddress) external;\n    function decrementMemberUnbondedValidatorCount(address _nodeAddress) external;\n    function bootstrapMember(string memory _id, string memory _url, address _nodeAddress) external;\n    function bootstrapSettingUint(string memory _settingContractName, string memory _settingPath, uint256 _value) external;\n    function bootstrapSettingBool(string memory _settingContractName, string memory _settingPath, bool _value) external;\n    function bootstrapUpgrade(string memory _type, string memory _name, string memory _contractAbi, address _contractAddress) external;\n    function bootstrapDisable(bool _confirmDisableBootstrapMode) external;\n    function memberJoinRequired(string memory _id, string memory _url) external;\n}\n"
    },
    "contracts/interface/dao/node/settings/RocketDAONodeTrustedSettingsMembersInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketDAONodeTrustedSettingsMembersInterface {\n    function getQuorum() external view returns (uint256);\n    function getRPLBond() external view returns(uint256);\n    function getMinipoolUnbondedMax() external view returns(uint256);\n    function getMinipoolUnbondedMinFee() external view returns(uint256);\n    function getChallengeCooldown() external view returns(uint256);\n    function getChallengeWindow() external view returns(uint256);\n    function getChallengeCost() external view returns(uint256);\n}\n"
    },
    "contracts/types/NodeDetails.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\n// A struct containing all the information on-chain about a specific node\n\nstruct NodeDetails {\n    bool exists;\n    uint256 registrationTime;\n    string timezoneLocation;\n    bool feeDistributorInitialised;\n    address feeDistributorAddress;\n    uint256 rewardNetwork;\n    uint256 rplStake;\n    uint256 effectiveRPLStake;\n    uint256 minimumRPLStake;\n    uint256 maximumRPLStake;\n    uint256 ethMatched;\n    uint256 ethMatchedLimit;\n    uint256 minipoolCount;\n    uint256 balanceETH;\n    uint256 balanceRETH;\n    uint256 balanceRPL;\n    uint256 balanceOldRPL;\n    uint256 depositCreditBalance;\n    uint256 distributorBalanceUserETH;\n    uint256 distributorBalanceNodeETH;\n    address withdrawalAddress;\n    address pendingWithdrawalAddress;\n    bool smoothingPoolRegistrationState;\n    uint256 smoothingPoolRegistrationChanged;\n    address nodeAddress;\n}\n"
    },
    "contracts/interface/node/RocketNodeManagerInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.5.0 <0.9.0;\npragma abicoder v2;\n\nimport \"../../types/NodeDetails.sol\";\n\ninterface RocketNodeManagerInterface {\n\n    // Structs\n    struct TimezoneCount {\n        string timezone;\n        uint256 count;\n    }\n\n    function getNodeCount() external view returns (uint256);\n    function getNodeCountPerTimezone(uint256 offset, uint256 limit) external view returns (TimezoneCount[] memory);\n    function getNodeAt(uint256 _index) external view returns (address);\n    function getNodeExists(address _nodeAddress) external view returns (bool);\n    function getNodeWithdrawalAddress(address _nodeAddress) external view returns (address);\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external view returns (address);\n    function getNodeRPLWithdrawalAddress(address _nodeAddress) external view returns (address);\n    function getNodeRPLWithdrawalAddressIsSet(address _nodeAddress) external view returns (bool);\n    function unsetRPLWithdrawalAddress(address _nodeAddress) external;\n    function setRPLWithdrawalAddress(address _nodeAddress, address _newRPLWithdrawalAddress, bool _confirm) external;\n    function confirmRPLWithdrawalAddress(address _nodeAddress) external;\n    function getNodePendingRPLWithdrawalAddress(address _nodeAddress) external view returns (address);\n    function getNodeTimezoneLocation(address _nodeAddress) external view returns (string memory);\n    function registerNode(string calldata _timezoneLocation) external;\n    function getNodeRegistrationTime(address _nodeAddress) external view returns (uint256);\n    function setTimezoneLocation(string calldata _timezoneLocation) external;\n    function setRewardNetwork(address _nodeAddress, uint256 network) external;\n    function getRewardNetwork(address _nodeAddress) external view returns (uint256);\n    function getFeeDistributorInitialised(address _nodeAddress) external view returns (bool);\n    function initialiseFeeDistributor() external;\n    function getAverageNodeFee(address _nodeAddress) external view returns (uint256);\n    function setSmoothingPoolRegistrationState(bool _state) external;\n    function getSmoothingPoolRegistrationState(address _nodeAddress) external returns (bool);\n    function getSmoothingPoolRegistrationChanged(address _nodeAddress) external returns (uint256);\n    function getSmoothingPoolRegisteredNodeCount(uint256 _offset, uint256 _limit) external view returns (uint256);\n    function getNodeDetails(address _nodeAddress) external view returns (NodeDetails memory);\n    function getNodeAddresses(uint256 _offset, uint256 _limit) external view returns (address[] memory);\n}\n"
    },
    "contracts/interface/util/IERC20.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\n// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity >0.5.0 <0.9.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "contracts/interface/util/IERC20Burnable.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\n// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\nimport \"./IERC20.sol\";\n\npragma solidity >0.5.0 <0.9.0;\n\ninterface IERC20Burnable is IERC20 {\n    function burn(uint256 amount) external;\n    function burnFrom(address account, uint256 amount) external;\n}\n"
    },
    "contracts/interface/RocketVaultInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\nimport \"./util/IERC20Burnable.sol\";\n\ninterface RocketVaultInterface {\n    function balanceOf(string memory _networkContractName) external view returns (uint256);\n    function depositEther() external payable;\n    function withdrawEther(uint256 _amount) external;\n    function depositToken(string memory _networkContractName, IERC20 _tokenAddress, uint256 _amount) external;\n    function withdrawToken(address _withdrawalAddress, IERC20 _tokenAddress, uint256 _amount) external;\n    function balanceOfToken(string memory _networkContractName, IERC20 _tokenAddress) external view returns (uint256);\n    function transferToken(string memory _networkContractName, IERC20 _tokenAddress, uint256 _amount) external;\n    function burnToken(IERC20Burnable _tokenAddress, uint256 _amount) external;\n}\n"
    },
    "contracts/interface/node/RocketNodeStakingInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.5.0 <0.9.0;\n\ninterface RocketNodeStakingInterface {\n    function getTotalRPLStake() external view returns (uint256);\n    function getNodeRPLStake(address _nodeAddress) external view returns (uint256);\n    function getNodeETHMatched(address _nodeAddress) external view returns (uint256);\n    function getNodeETHProvided(address _nodeAddress) external view returns (uint256);\n    function getNodeETHCollateralisationRatio(address _nodeAddress) external view returns (uint256);\n    function getNodeRPLStakedTime(address _nodeAddress) external view returns (uint256);\n    function getNodeEffectiveRPLStake(address _nodeAddress) external view returns (uint256);\n    function getNodeMinimumRPLStake(address _nodeAddress) external view returns (uint256);\n    function getNodeMaximumRPLStake(address _nodeAddress) external view returns (uint256);\n    function getNodeETHMatchedLimit(address _nodeAddress) external view returns (uint256);\n    function getRPLLockingAllowed(address _nodeAddress) external view returns (bool);\n    function stakeRPL(uint256 _amount) external;\n    function stakeRPLFor(address _nodeAddress, uint256 _amount) external;\n    function setRPLLockingAllowed(address _nodeAddress, bool _allowed) external;\n    function setStakeRPLForAllowed(address _caller, bool _allowed) external;\n    function setStakeRPLForAllowed(address _nodeAddress, address _caller, bool _allowed) external;\n    function getNodeRPLLocked(address _nodeAddress) external view returns (uint256);\n    function lockRPL(address _nodeAddress, uint256 _amount) external;\n    function unlockRPL(address _nodeAddress, uint256 _amount) external;\n    function transferRPL(address _from, address _to, uint256 _amount) external;\n    function burnRPL(address _from, uint256 _amount) external;\n    function withdrawRPL(uint256 _amount) external;\n    function withdrawRPL(address _nodeAddress, uint256 _amount) external;\n    function slashRPL(address _nodeAddress, uint256 _ethSlashAmount) external;\n}\n"
    },
    "@openzeppelin4/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "contracts/interface/network/RocketNetworkSnapshotsInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.5.0 <0.9.0;\n\nstruct Checkpoint224 {\n    uint32 _block;\n    uint224 _value;\n}\n\n/// @notice Accounting for snapshotting of values based on block numbers\ninterface RocketNetworkSnapshotsInterface {\n    function push(bytes32 _key, uint224 _value) external;\n    function length(bytes32 _key) external view returns (uint256);\n    function latest(bytes32 _key) external view returns (bool, uint32, uint224);\n    function latestBlock(bytes32 _key) external view returns (uint32);\n    function latestValue(bytes32 _key) external view returns (uint224);\n    function lookup(bytes32 _key, uint32 _block) external view returns (uint224);\n    function lookupRecent(bytes32 _key, uint32 _block, uint256 _recency) external view returns (uint224);\n}\n"
    },
    "contracts/contract/network/RocketNetworkSnapshots.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\n// SPDX-License-Identifier: MIT\n// Copyright (c) 2016-2023 zOS Global Limited and contributors\n// Adapted from OpenZeppelin `Checkpoints` contract\npragma solidity 0.8.18;\n\nimport \"@openzeppelin4/contracts/utils/math/Math.sol\";\n\nimport \"../RocketBase.sol\";\nimport \"../../interface/network/RocketNetworkSnapshotsInterface.sol\";\n\n/// @notice Accounting for snapshotting of values based on block numbers\ncontract RocketNetworkSnapshots is RocketBase, RocketNetworkSnapshotsInterface {\n\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketBase(_rocketStorageAddress) {\n        // Set contract version\n        version = 1;\n\n        // Setup for if this contract is being deployed as part of a new instance deployment\n        if (!rocketStorage.getDeployedStatus()) {\n            _insert(keccak256(\"network.prices.rpl\"), 0.01 ether);\n            _insert(keccak256(\"node.voting.power.stake.maximum\"), 1.5 ether);\n        }\n    }\n\n    function push(bytes32 _key, uint224 _value) onlyLatestContract(\"rocketNetworkSnapshots\", address(this)) onlyLatestNetworkContract external {\n        _insert(_key, _value);\n    }\n\n    function length(bytes32 _key) public view returns (uint256) {\n        return rocketStorage.getUint(keccak256(abi.encodePacked(\"snapshot.length\", _key)));\n    }\n\n    function latest(bytes32 _key) external view returns (bool, uint32, uint224) {\n        uint256 len = length(_key);\n        if (len == 0) {\n            return (false, 0, 0);\n        }\n        Checkpoint224 memory checkpoint = _load(_key, len - 1);\n        return (true, checkpoint._block, checkpoint._value);\n    }\n\n    function latestBlock(bytes32 _key) external view returns (uint32) {\n        uint256 len = length(_key);\n        return len == 0 ? 0 : _blockAt(_key, len - 1);\n    }\n\n    function latestValue(bytes32 _key) external view returns (uint224) {\n        uint256 len = length(_key);\n        return len == 0 ? 0 : _valueAt(_key, len - 1);\n    }\n\n    function lookup(bytes32 _key, uint32 _block) external view returns (uint224) {\n        uint256 len = length(_key);\n        uint256 pos = _binaryLookup(_key, _block, 0, len);\n        return pos == 0 ? 0 : _valueAt(_key, pos - 1);\n    }\n\n    function lookupRecent(bytes32 _key, uint32 _block, uint256 _recency) external view returns (uint224) {\n        uint256 len = length(_key);\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5 && len > _recency) {\n            uint256 mid = len - _recency;\n            if (_block < _blockAt(_key, mid)) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _binaryLookup(_key, _block, low, high);\n\n        return pos == 0 ? 0 : _valueAt(_key, pos - 1);\n    }\n\n    function _insert(bytes32 _key, uint224 _value) private {\n        uint32 blockNumber = uint32(block.number);\n        uint256 pos = length(_key);\n\n        if (pos > 0) {\n            Checkpoint224 memory last = _load(_key, pos - 1);\n\n            // Checkpoint keys must be non-decreasing.\n            require (last._block <= blockNumber, \"Unordered snapshot insertion\");\n\n            // Update or push new checkpoint\n            if (last._block == blockNumber) {\n                last._value = _value;\n                _set(_key, pos - 1, last);\n            } else {\n                _push(_key, Checkpoint224({_block: blockNumber, _value: _value}));\n            }\n        } else {\n            _push(_key, Checkpoint224({_block: blockNumber, _value: _value}));\n        }\n    }\n\n    function _binaryLookup(\n        bytes32 _key,\n        uint32 _block,\n        uint256 _low,\n        uint256 _high\n    ) private view returns (uint256) {\n        while (_low < _high) {\n            uint256 mid = Math.average(_low, _high);\n            if (_blockAt(_key, mid) > _block) {\n                _high = mid;\n            } else {\n                _low = mid + 1;\n            }\n        }\n        return _high;\n    }\n\n    function _load(bytes32 _key, uint256 _pos) private view returns (Checkpoint224 memory) {\n        bytes32 key = bytes32(uint256(_key) + _pos);\n        bytes32 raw = rocketStorage.getBytes32(key);\n        Checkpoint224 memory result;\n        result._block = uint32(uint256(raw) >> 224);\n        result._value = uint224(uint256(raw));\n        return result;\n    }\n\n    function _blockAt(bytes32 _key, uint256 _pos) private view returns (uint32) {\n        bytes32 key = bytes32(uint256(_key) + _pos);\n        bytes32 raw = rocketStorage.getBytes32(key);\n        return uint32(uint256(raw) >> 224);\n    }\n\n    function _valueAt(bytes32 _key, uint256 _pos) private view returns (uint224) {\n        bytes32 key = bytes32(uint256(_key) + _pos);\n        bytes32 raw = rocketStorage.getBytes32(key);\n        return uint224(uint256(raw));\n    }\n\n    function _push(bytes32 _key, Checkpoint224 memory _item) private {\n        bytes32 lengthKey = keccak256(abi.encodePacked(\"snapshot.length\", _key));\n        uint256 snapshotLength = rocketStorage.getUint(lengthKey);\n        bytes32 key = bytes32(uint256(_key) + snapshotLength);\n        rocketStorage.setUint(lengthKey, snapshotLength + 1);\n        rocketStorage.setBytes32(key, _encode(_item));\n    }\n\n    function _set(bytes32 _key, uint256 _pos, Checkpoint224 memory _item) private {\n        bytes32 key = bytes32(uint256(_key) + _pos);\n        rocketStorage.setBytes32(key, _encode(_item));\n    }\n\n    function _encode(Checkpoint224 memory _item) private pure returns (bytes32) {\n        return bytes32(\n            uint256(_item._block) << 224 | uint256(_item._value)\n        );\n    }\n}\n"
    },
    "contracts/interface/RocketVaultWithdrawerInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketVaultWithdrawerInterface {\n    function receiveVaultWithdrawalETH() external payable; \n}\n"
    },
    "contracts/interface/network/RocketNetworkVotingInterface.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.5.0 <0.9.0;\n\ninterface RocketNetworkVotingInterface {\n    function initialiseVotingFor(address _nodeAddress) external;\n    function initialiseVoting() external;\n    function initialiseVotingWithDelegate(address _delegate) external;\n    function getVotingInitialised(address _nodeAddress) external view returns (bool);\n    function getNodeCount(uint32 _block) external view returns (uint256);\n    function getVotingPower(address _nodeAddress, uint32 _block) external view returns (uint256);\n    function setDelegate(address _newDelegate) external;\n    function getDelegate(address _nodeAddress, uint32 _block) external view returns (address);\n    function getCurrentDelegate(address _nodeAddress) external view returns (address);\n}"
    },
    "contracts/contract/node/RocketNodeDeposit.sol": {
      "content": "/**\r\n   *       .\r\n   *      / \\\r\n   *     |.'.|\r\n   *     |'.'|\r\n   *   ,'|   |'.\r\n   *  |,-'-|-'-.|\r\n   *   __|_| |         _        _      _____           _\r\n   *  | ___ \\|        | |      | |    | ___ \\         | |\r\n   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n   * +---------------------------------------------------+\r\n   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |\r\n   * +---------------------------------------------------+\r\n   *\r\n   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to\r\n   *  be community-owned, decentralised, permissionless, & trustless.\r\n   *\r\n   *  For more information about Rocket Pool, visit https://rocketpool.net\r\n   *\r\n   *  Authored by the Rocket Pool Core Team\r\n   *  Contributors: https://github.com/rocket-pool/rocketpool/graphs/contributors\r\n   *  A special thanks to the Rocket Pool community for all their contributions.\r\n   *\r\n   */\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.8.18;\n\nimport \"../RocketBase.sol\";\nimport \"../../interface/deposit/RocketDepositPoolInterface.sol\";\nimport \"../../interface/minipool/RocketMinipoolInterface.sol\";\nimport \"../../interface/minipool/RocketMinipoolManagerInterface.sol\";\nimport \"../../interface/minipool/RocketMinipoolQueueInterface.sol\";\nimport \"../../interface/network/RocketNetworkFeesInterface.sol\";\nimport \"../../interface/node/RocketNodeDepositInterface.sol\";\nimport \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsDepositInterface.sol\";\nimport \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsMinipoolInterface.sol\";\nimport \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsNodeInterface.sol\";\nimport \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsNetworkInterface.sol\";\nimport \"../../interface/dao/node/RocketDAONodeTrustedInterface.sol\";\nimport \"../../interface/dao/node/settings/RocketDAONodeTrustedSettingsMembersInterface.sol\";\nimport \"../../types/MinipoolDeposit.sol\";\nimport \"../../interface/node/RocketNodeManagerInterface.sol\";\nimport \"../../interface/RocketVaultInterface.sol\";\nimport \"../../interface/node/RocketNodeStakingInterface.sol\";\nimport \"../network/RocketNetworkSnapshots.sol\";\nimport \"../../interface/RocketVaultWithdrawerInterface.sol\";\nimport \"../../interface/network/RocketNetworkVotingInterface.sol\";\n\n/// @notice Handles node deposits and minipool creation\ncontract RocketNodeDeposit is RocketBase, RocketNodeDepositInterface, RocketVaultWithdrawerInterface {\n\n    // Events\n    event DepositReceived(address indexed from, uint256 amount, uint256 time);\n    event DepositFor(address indexed nodeAddress, address indexed from, uint256 amount, uint256 time);\n    event Withdrawal(address indexed nodeAddress, address indexed to, uint256 amount, uint256 time);\n\n    function receiveVaultWithdrawalETH() external payable {}\n\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketBase(_rocketStorageAddress) {\n        version = 4;\n    }\n\n    /// @dev Accept incoming ETH from the deposit pool\n    receive() external payable onlyLatestContract(\"rocketDepositPool\", msg.sender) {}\n\n    /// @notice Returns a node operator's credit balance in wei\n    function getNodeDepositCredit(address _nodeOperator) override public view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(\"node.deposit.credit.balance\", _nodeOperator)));\n    }\n\n    /// @notice Returns the current ETH balance for the given node operator\n    function getNodeEthBalance(address _nodeAddress) override public view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(\"node.eth.balance\", _nodeAddress)));\n    }\n\n    /// @notice Returns the sum of the credit balance of a given node operator and their balance\n    function getNodeCreditAndBalance(address _nodeAddress) override external view returns (uint256) {\n        return getNodeDepositCredit(_nodeAddress) + getNodeEthBalance(_nodeAddress);\n    }\n\n    /// @notice Returns the sum of the amount of ETH credit currently usable by a given node operator and their balance\n    function getNodeUsableCreditAndBalance(address _nodeAddress) override external view returns (uint256) {\n        return getNodeUsableCredit(_nodeAddress) + getNodeEthBalance(_nodeAddress);\n    }\n\n    /// @notice Returns the amount of ETH credit currently usable by a given node operator\n    function getNodeUsableCredit(address _nodeAddress) override public view returns (uint256) {\n        RocketDepositPoolInterface rocketDepositPool = RocketDepositPoolInterface(getContractAddress(\"rocketDepositPool\"));\n        uint256 depositPoolBalance = rocketDepositPool.getBalance();\n        uint256 usableCredit = getNodeDepositCredit(_nodeAddress);\n        if (usableCredit > depositPoolBalance) {\n            usableCredit = depositPoolBalance;\n        }\n        return usableCredit;\n    }\n\n    /// @dev Increases a node operators deposit credit balance\n    function increaseDepositCreditBalance(address _nodeAddress, uint256 _amount) override external onlyLatestContract(\"rocketNodeDeposit\", address(this)) onlyRegisteredNode(_nodeAddress) {\n        // Accept calls from network contracts or registered minipools\n        require(getBool(keccak256(abi.encodePacked(\"minipool.exists\", msg.sender))) ||\n            getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))),\n            \"Invalid or outdated network contract\");\n        // Increase credit balance\n        addUint(keccak256(abi.encodePacked(\"node.deposit.credit.balance\", _nodeAddress)), _amount);\n    }\n\n    /// @notice Deposits ETH for the given node operator\n    /// @param _nodeAddress The address of the node operator to deposit ETH for\n    function depositEthFor(address _nodeAddress) override external payable onlyLatestContract(\"rocketNodeDeposit\", address(this)) onlyRegisteredNode(_nodeAddress) {\n        // Sanity check caller is not node itself\n        require(msg.sender != _nodeAddress, \"Cannot deposit ETH for self\");\n        // Send the ETH to vault\n        uint256 amount = msg.value;\n        RocketVaultInterface rocketVault = RocketVaultInterface(getContractAddress(\"rocketVault\"));\n        rocketVault.depositEther{value: amount}();\n        // Increment balance\n        addUint(keccak256(abi.encodePacked(\"node.eth.balance\", _nodeAddress)), amount);\n        // Log it\n        emit DepositFor(_nodeAddress, msg.sender, amount, block.timestamp);\n    }\n\n    /// @notice Withdraws ETH from a node operator's balance. Must be called from withdrawal address.\n    /// @param _nodeAddress Address of the node operator to withdraw from\n    /// @param _amount Amount of ETH to withdraw\n    function withdrawEth(address _nodeAddress, uint256 _amount) external onlyLatestContract(\"rocketNodeDeposit\", address(this)) onlyRegisteredNode(_nodeAddress) {\n        // Check valid caller\n        address withdrawalAddress = rocketStorage.getNodeWithdrawalAddress(_nodeAddress);\n        require(msg.sender == withdrawalAddress, \"Only withdrawal address can withdraw ETH\");\n        // Check balance and update\n        uint256 balance = getNodeEthBalance(_nodeAddress);\n        require(balance >= _amount, \"Insufficient balance\");\n        setUint(keccak256(abi.encodePacked(\"node.eth.balance\", _nodeAddress)), balance - _amount);\n        // Withdraw the funds\n        RocketVaultInterface rocketVault = RocketVaultInterface(getContractAddress(\"rocketVault\"));\n        rocketVault.withdrawEther(_amount);\n        // Send funds to withdrawalAddress\n        (bool success, ) = withdrawalAddress.call{value: _amount}(\"\");\n        require(success, \"Failed to withdraw ETH\");\n        // Log it\n        emit Withdrawal(_nodeAddress, withdrawalAddress, _amount, block.timestamp);\n    }\n\n    /// @notice Accept a node deposit and create a new minipool under the node. Only accepts calls from registered nodes\n    /// @param _bondAmount The amount of capital the node operator wants to put up as his bond\n    /// @param _minimumNodeFee Transaction will revert if network commission rate drops below this amount\n    /// @param _validatorPubkey Pubkey of the validator the node operator wishes to migrate\n    /// @param _validatorSignature Signature from the validator over the deposit data\n    /// @param _depositDataRoot The hash tree root of the deposit data (passed onto the deposit contract on pre stake)\n    /// @param _salt Salt used to deterministically construct the minipool's address\n    /// @param _expectedMinipoolAddress The expected deterministic minipool address. Will revert if it doesn't match\n    function deposit(uint256 _bondAmount, uint256 _minimumNodeFee, bytes calldata _validatorPubkey, bytes calldata _validatorSignature, bytes32 _depositDataRoot, uint256 _salt, address _expectedMinipoolAddress) override external payable onlyLatestContract(\"rocketNodeDeposit\", address(this)) onlyRegisteredNode(msg.sender) {\n        // Check amount\n        require(msg.value == _bondAmount, \"Invalid value\");\n        // Process the deposit\n        _deposit(_bondAmount, _minimumNodeFee, _validatorPubkey, _validatorSignature, _depositDataRoot, _salt, _expectedMinipoolAddress);\n    }\n\n    /// @notice Accept a node deposit and create a new minipool under the node. Uses node's credit balance to cover\n    ///         shortfall in value provided to cover bond. Only accepts calls from registered nodes\n    /// @param _bondAmount The amount of capital the node operator wants to put up as his bond\n    /// @param _minimumNodeFee Transaction will revert if network commission rate drops below this amount\n    /// @param _validatorPubkey Pubkey of the validator the node operator wishes to migrate\n    /// @param _validatorSignature Signature from the validator over the deposit data\n    /// @param _depositDataRoot The hash tree root of the deposit data (passed onto the deposit contract on pre stake)\n    /// @param _salt Salt used to deterministically construct the minipool's address\n    /// @param _expectedMinipoolAddress The expected deterministic minipool address. Will revert if it doesn't match\n    function depositWithCredit(uint256 _bondAmount, uint256 _minimumNodeFee, bytes calldata _validatorPubkey, bytes calldata _validatorSignature, bytes32 _depositDataRoot, uint256 _salt, address _expectedMinipoolAddress) override external payable onlyLatestContract(\"rocketNodeDeposit\", address(this)) onlyRegisteredNode(msg.sender) {\n        // Sanity check\n        require(msg.value <= _bondAmount, \"Excessive value for requested bond\");\n        {\n            uint256 balanceToUse = 0;\n            uint256 creditToUse = 0;\n            uint256 shortFall = _bondAmount - msg.value;\n            uint256 credit = getNodeUsableCredit(msg.sender);\n            uint256 balance = getNodeEthBalance(msg.sender);\n            // Check credit\n            require (credit + balance >= shortFall, \"Insufficient credit\");\n            // Calculate amounts to use\n            creditToUse = shortFall;\n            if (credit < shortFall) {\n                balanceToUse = shortFall - credit;\n                creditToUse = credit;\n            }\n            // Update balances\n            if (balanceToUse > 0) {\n                subUint(keccak256(abi.encodePacked(\"node.eth.balance\", msg.sender)), balanceToUse);\n                // Withdraw the funds\n                RocketVaultInterface rocketVault = RocketVaultInterface(getContractAddress(\"rocketVault\"));\n                rocketVault.withdrawEther(balanceToUse);\n            }\n            if (creditToUse > 0) {\n                subUint(keccak256(abi.encodePacked(\"node.deposit.credit.balance\", msg.sender)), creditToUse);\n            }\n        }\n        // Process the deposit\n        _deposit(_bondAmount, _minimumNodeFee, _validatorPubkey, _validatorSignature, _depositDataRoot, _salt, _expectedMinipoolAddress);\n    }\n\n    /// @notice Returns true if the given amount is a valid deposit amount\n    function isValidDepositAmount(uint256 _amount) override public pure returns (bool) {\n        return _amount == 16 ether || _amount == 8 ether;\n    }\n\n    /// @notice Returns an array of valid deposit amounts\n    function getDepositAmounts() override external pure returns (uint256[] memory) {\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = 16 ether;\n        amounts[1] = 8 ether;\n        return amounts;\n    }\n\n    /// @dev Internal logic to process a deposit\n    function _deposit(uint256 _bondAmount, uint256 _minimumNodeFee, bytes calldata _validatorPubkey, bytes calldata _validatorSignature, bytes32 _depositDataRoot, uint256 _salt, address _expectedMinipoolAddress) private {\n        // Check pre-conditions\n        checkVotingInitialised();\n        checkDepositsEnabled();\n        checkDistributorInitialised();\n        checkNodeFee(_minimumNodeFee);\n        require(isValidDepositAmount(_bondAmount), \"Invalid deposit amount\");\n        // Get launch constants\n        uint256 launchAmount;\n        uint256 preLaunchValue;\n        {\n            RocketDAOProtocolSettingsMinipoolInterface rocketDAOProtocolSettingsMinipool = RocketDAOProtocolSettingsMinipoolInterface(getContractAddress(\"rocketDAOProtocolSettingsMinipool\"));\n            launchAmount = rocketDAOProtocolSettingsMinipool.getLaunchBalance();\n            preLaunchValue = rocketDAOProtocolSettingsMinipool.getPreLaunchValue();\n        }\n        // Emit deposit received event\n        emit DepositReceived(msg.sender, msg.value, block.timestamp);\n        // Increase ETH matched (used to calculate RPL collateral requirements)\n        _increaseEthMatched(msg.sender, launchAmount - _bondAmount);\n        // Create the minipool\n        RocketMinipoolInterface minipool = createMinipool(_salt, _expectedMinipoolAddress);\n        // Process node deposit\n        _processNodeDeposit(preLaunchValue, _bondAmount);\n        // Perform the pre deposit\n        minipool.preDeposit{value: preLaunchValue}(_bondAmount, _validatorPubkey, _validatorSignature, _depositDataRoot);\n        // Enqueue the minipool\n        enqueueMinipool(address(minipool));\n        // Assign deposits if enabled\n        assignDeposits();\n    }\n\n    /// @dev Processes a node deposit with the deposit pool. If user has not supplied full bond amount with the transaction\n    ///      the shortfall will be taken from their credit. Any excess ETH after prelaunch value is sent to minipool is\n    //       then deposited into the deposit pool\n    /// @param _preLaunchValue The prelaunch value (result of call to `RocketDAOProtocolSettingsMinipool.getPreLaunchValue()`\n    /// @param _bondAmount The bond amount for this deposit\n    function _processNodeDeposit(uint256 _preLaunchValue, uint256 _bondAmount) private {\n        // Get contracts\n        RocketDepositPoolInterface rocketDepositPool = RocketDepositPoolInterface(getContractAddress(\"rocketDepositPool\"));\n        // Retrieve ETH from deposit pool if required\n        uint256 shortFall = 0;\n        if (address(this).balance < _preLaunchValue) {\n            shortFall = _preLaunchValue - address(this).balance;\n            rocketDepositPool.nodeCreditWithdrawal(shortFall);\n        }\n        uint256 remaining = address(this).balance - _preLaunchValue;\n        // Deposit the left over value into the deposit pool\n        rocketDepositPool.nodeDeposit{value: remaining}(_bondAmount - _preLaunchValue);\n    }\n\n    /// @notice Creates a \"vacant\" minipool which a node operator can use to migrate a validator with a BLS withdrawal credential\n    /// @param _bondAmount The amount of capital the node operator wants to put up as his bond\n    /// @param _minimumNodeFee Transaction will revert if network commission rate drops below this amount\n    /// @param _validatorPubkey Pubkey of the validator the node operator wishes to migrate\n    /// @param _salt Salt used to deterministically construct the minipool's address\n    /// @param _expectedMinipoolAddress The expected deterministic minipool address. Will revert if it doesn't match\n    /// @param _currentBalance The current balance of the validator on the beaconchain (will be checked by oDAO and scrubbed if not correct)\n    function createVacantMinipool(uint256 _bondAmount, uint256 _minimumNodeFee, bytes calldata _validatorPubkey, uint256 _salt, address _expectedMinipoolAddress, uint256 _currentBalance) override external onlyLatestContract(\"rocketNodeDeposit\", address(this)) onlyRegisteredNode(msg.sender) {\n        // Check pre-conditions\n        checkVacantMinipoolsEnabled();\n        checkDistributorInitialised();\n        checkNodeFee(_minimumNodeFee);\n        require(isValidDepositAmount(_bondAmount), \"Invalid deposit amount\");\n        // Increase ETH matched (used to calculate RPL collateral requirements)\n        RocketDAOProtocolSettingsMinipoolInterface rocketDAOProtocolSettingsMinipool = RocketDAOProtocolSettingsMinipoolInterface(getContractAddress(\"rocketDAOProtocolSettingsMinipool\"));\n        uint256 launchAmount = rocketDAOProtocolSettingsMinipool.getLaunchBalance();\n        _increaseEthMatched(msg.sender, launchAmount - _bondAmount);\n        // Create the minipool\n        _createVacantMinipool(_salt, _validatorPubkey, _bondAmount, _expectedMinipoolAddress, _currentBalance);\n    }\n\n    /// @notice Called by minipools during bond reduction to increase the amount of ETH the node operator has\n    /// @param _nodeAddress The node operator's address to increase the ETH matched for\n    /// @param _amount The amount to increase the ETH matched\n    /// @dev Will revert if the new ETH matched amount exceeds the node operators limit\n    function increaseEthMatched(address _nodeAddress, uint256 _amount) override external onlyLatestContract(\"rocketNodeDeposit\", address(this)) onlyLatestNetworkContract() {\n        // Try to distribute any existing rewards at the previous collateral rate\n        RocketMinipoolManagerInterface rocketMinipoolManager = RocketMinipoolManagerInterface(getContractAddress(\"rocketMinipoolManager\"));\n        rocketMinipoolManager.tryDistribute(_nodeAddress);\n        // Increase ETH matched\n        _increaseEthMatched(_nodeAddress, _amount);\n    }\n\n    /// @dev Increases the amount of ETH that has been matched against a node operators bond. Reverts if it exceeds the\n    ///      collateralisation requirements of the network\n    function _increaseEthMatched(address _nodeAddress, uint256 _amount) private {\n        // Check amount doesn't exceed limits\n        RocketNodeStakingInterface rocketNodeStaking = RocketNodeStakingInterface(getContractAddress(\"rocketNodeStaking\"));\n        RocketNetworkSnapshots rocketNetworkSnapshots = RocketNetworkSnapshots(getContractAddress(\"rocketNetworkSnapshots\"));\n        uint256 ethMatched = rocketNodeStaking.getNodeETHMatched(_nodeAddress) + _amount;\n        require(\n            ethMatched <= rocketNodeStaking.getNodeETHMatchedLimit(_nodeAddress),\n            \"ETH matched after deposit exceeds limit based on node RPL stake\"\n        );\n        // Push the change to snapshot manager\n        bytes32 key = keccak256(abi.encodePacked(\"eth.matched.node.amount\", _nodeAddress));\n        rocketNetworkSnapshots.push(key, uint224(ethMatched));\n    }\n\n    /// @dev Adds a minipool to the queue\n    function enqueueMinipool(address _minipoolAddress) private {\n        // Add minipool to queue\n        RocketMinipoolQueueInterface(getContractAddress(\"rocketMinipoolQueue\")).enqueueMinipool(_minipoolAddress);\n    }\n\n    /// @dev Initialises node's voting power if not already done\n    function checkVotingInitialised() private {\n        // Ensure voting has been initialised for this node\n        RocketNetworkVotingInterface rocketNetworkVoting = RocketNetworkVotingInterface(getContractAddress(\"rocketNetworkVoting\"));\n        rocketNetworkVoting.initialiseVotingFor(msg.sender);\n    }\n\n    /// @dev Reverts if node operator has not initialised their fee distributor\n    function checkDistributorInitialised() private view {\n        // Check node has initialised their fee distributor\n        RocketNodeManagerInterface rocketNodeManager = RocketNodeManagerInterface(getContractAddress(\"rocketNodeManager\"));\n        require(rocketNodeManager.getFeeDistributorInitialised(msg.sender), \"Fee distributor not initialised\");\n    }\n\n    /// @dev Creates a minipool and returns an instance of it\n    /// @param _salt The salt used to determine the minipools address\n    /// @param _expectedMinipoolAddress The expected minipool address. Reverts if not correct\n    function createMinipool(uint256 _salt, address _expectedMinipoolAddress) private returns (RocketMinipoolInterface) {\n        // Load contracts\n        RocketMinipoolManagerInterface rocketMinipoolManager = RocketMinipoolManagerInterface(getContractAddress(\"rocketMinipoolManager\"));\n        // Check minipool doesn't exist or previously exist\n        require(!rocketMinipoolManager.getMinipoolExists(_expectedMinipoolAddress) && !rocketMinipoolManager.getMinipoolDestroyed(_expectedMinipoolAddress), \"Minipool already exists or was previously destroyed\");\n        // Create minipool\n        RocketMinipoolInterface minipool = rocketMinipoolManager.createMinipool(msg.sender, _salt);\n        // Ensure minipool address matches expected\n        require(address(minipool) == _expectedMinipoolAddress, \"Unexpected minipool address\");\n        // Return\n        return minipool;\n    }\n\n    /// @dev Creates a vacant minipool and returns an instance of it\n    /// @param _salt The salt used to determine the minipools address\n    /// @param _validatorPubkey Pubkey of the validator owning this minipool\n    /// @param _bondAmount ETH value the node operator is putting up as capital for this minipool\n    /// @param _expectedMinipoolAddress The expected minipool address. Reverts if not correct\n    /// @param _currentBalance The current balance of the validator on the beaconchain (will be checked by oDAO and scrubbed if not correct)\n    function _createVacantMinipool(uint256 _salt, bytes calldata _validatorPubkey, uint256 _bondAmount, address _expectedMinipoolAddress, uint256 _currentBalance) private returns (RocketMinipoolInterface) {\n        // Load contracts\n        RocketMinipoolManagerInterface rocketMinipoolManager = RocketMinipoolManagerInterface(getContractAddress(\"rocketMinipoolManager\"));\n        // Check minipool doesn't exist or previously exist\n        require(!rocketMinipoolManager.getMinipoolExists(_expectedMinipoolAddress) && !rocketMinipoolManager.getMinipoolDestroyed(_expectedMinipoolAddress), \"Minipool already exists or was previously destroyed\");\n        // Create minipool\n        RocketMinipoolInterface minipool = rocketMinipoolManager.createVacantMinipool(msg.sender, _salt, _validatorPubkey, _bondAmount, _currentBalance);\n        // Ensure minipool address matches expected\n        require(address(minipool) == _expectedMinipoolAddress, \"Unexpected minipool address\");\n        // Return\n        return minipool;\n    }\n\n    /// @dev Reverts if network node fee is below a minimum\n    /// @param _minimumNodeFee The minimum node fee required to not revert\n    function checkNodeFee(uint256 _minimumNodeFee) private view {\n        // Load contracts\n        RocketNetworkFeesInterface rocketNetworkFees = RocketNetworkFeesInterface(getContractAddress(\"rocketNetworkFees\"));\n        // Check current node fee\n        uint256 nodeFee = rocketNetworkFees.getNodeFee();\n        require(nodeFee >= _minimumNodeFee, \"Minimum node fee exceeds current network node fee\");\n    }\n\n    /// @dev Reverts if deposits are not enabled\n    function checkDepositsEnabled() private view {\n        // Get contracts\n        RocketDAOProtocolSettingsNodeInterface rocketDAOProtocolSettingsNode = RocketDAOProtocolSettingsNodeInterface(getContractAddress(\"rocketDAOProtocolSettingsNode\"));\n        // Check node settings\n        require(rocketDAOProtocolSettingsNode.getDepositEnabled(), \"Node deposits are currently disabled\");\n    }\n\n    /// @dev Reverts if vacant minipools are not enabled\n    function checkVacantMinipoolsEnabled() private view {\n        // Get contracts\n        RocketDAOProtocolSettingsNodeInterface rocketDAOProtocolSettingsNode = RocketDAOProtocolSettingsNodeInterface(getContractAddress(\"rocketDAOProtocolSettingsNode\"));\n        // Check node settings\n        require(rocketDAOProtocolSettingsNode.getVacantMinipoolsEnabled(), \"Vacant minipools are currently disabled\");\n    }\n\n    /// @dev Executes an assignDeposits call on the deposit pool\n    function assignDeposits() private {\n        RocketDepositPoolInterface rocketDepositPool = RocketDepositPoolInterface(getContractAddress(\"rocketDepositPool\"));\n        rocketDepositPool.maybeAssignDeposits();\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 15000
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}